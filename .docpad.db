{
  "generateStarted": "2014-12-21T22:35:22.073Z",
  "generateEnded": null,
  "models": [
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/documents/index.html",
      "relativePath": "index.html",
      "basename": "index",
      "outBasename": "index",
      "extension": "html",
      "outExtension": "html",
      "extensions": [
        "html"
      ],
      "filename": "index.html",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/documents",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/index.html",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out",
      "outFilename": "index.html",
      "relativeOutPath": "index.html",
      "relativeDirPath": ".",
      "relativeOutDirPath": ".",
      "relativeBase": "index",
      "relativeOutBase": "index",
      "contentType": "text/html",
      "outContentType": "text/html",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T22:35:22.157Z",
      "rtime": "2014-12-21T22:35:25.174Z",
      "wtime": "2014-12-21T22:35:28.457Z",
      "exists": true,
      "encoding": "utf8",
      "source": "---\ntitle: \"PumPatterns\"\nlayout: \"default\"\nisPage: true\n---\n\n<ol id=\"items\">\n    <li class=\"item\">\n        <div class=\"inner\">\n            <iframe width=\"100%\" height=\"100%\" src=\"//www.mixcloud.com/widget/iframe/?feed=http%3A%2F%2Fwww.mixcloud.com%2Fwolleb%2Fpumpatterns-1%2F&amp;embed_type=widget_standard&amp;embed_uuid=e4f50ce2-789c-46ea-a19f-a02ffda38b95\" frameborder=\"0\"></iframe>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\">\n\n\n            <iframe width=\"100%\" height=\"100%\" src=\"//www.mixcloud.com/widget/iframe/?feed=http%3A%2F%2Fwww.mixcloud.com%2Fwolleb%2Fpumpatterns-2%2F&amp;embed_type=widget_standard&amp;embed_uuid=cc9d9612-a6d5-4313-a9f4-fc7e072558b5\" frameborder=\"0\"></iframe>\n\n\n        </div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\">\n\n            <iframe width=\"100%\" height=\"100%\" src=\"//www.mixcloud.com/widget/iframe/?feed=http%3A%2F%2Fwww.mixcloud.com%2Fwolleb%2Fpumpatterns-3%2F&amp;embed_type=widget_standard&amp;embed_uuid=98ebf600-0025-4f57-abcc-3149d1c6f7a2\" frameborder=\"0\"></iframe>\n\n        </div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n</ol>\n\n\n\n\n",
      "content": "<ol id=\"items\">\n    <li class=\"item\">\n        <div class=\"inner\">\n            <iframe width=\"100%\" height=\"100%\" src=\"//www.mixcloud.com/widget/iframe/?feed=http%3A%2F%2Fwww.mixcloud.com%2Fwolleb%2Fpumpatterns-1%2F&amp;embed_type=widget_standard&amp;embed_uuid=e4f50ce2-789c-46ea-a19f-a02ffda38b95\" frameborder=\"0\"></iframe>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\">\n\n\n            <iframe width=\"100%\" height=\"100%\" src=\"//www.mixcloud.com/widget/iframe/?feed=http%3A%2F%2Fwww.mixcloud.com%2Fwolleb%2Fpumpatterns-2%2F&amp;embed_type=widget_standard&amp;embed_uuid=cc9d9612-a6d5-4313-a9f4-fc7e072558b5\" frameborder=\"0\"></iframe>\n\n\n        </div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\">\n\n            <iframe width=\"100%\" height=\"100%\" src=\"//www.mixcloud.com/widget/iframe/?feed=http%3A%2F%2Fwww.mixcloud.com%2Fwolleb%2Fpumpatterns-3%2F&amp;embed_type=widget_standard&amp;embed_uuid=98ebf600-0025-4f57-abcc-3149d1c6f7a2\" frameborder=\"0\"></iframe>\n\n        </div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n</ol>",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": "PumPatterns",
      "name": "index.html",
      "date": "2014-12-21T22:35:22.157Z",
      "slug": "index",
      "url": "/index.html",
      "urls": [
        "/index.html"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": "title: \"PumPatterns\"\nlayout: \"default\"\nisPage: true",
      "parser": "yaml",
      "body": "<ol id=\"items\">\n    <li class=\"item\">\n        <div class=\"inner\">\n            <iframe width=\"100%\" height=\"100%\" src=\"//www.mixcloud.com/widget/iframe/?feed=http%3A%2F%2Fwww.mixcloud.com%2Fwolleb%2Fpumpatterns-1%2F&amp;embed_type=widget_standard&amp;embed_uuid=e4f50ce2-789c-46ea-a19f-a02ffda38b95\" frameborder=\"0\"></iframe>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\">\n\n\n            <iframe width=\"100%\" height=\"100%\" src=\"//www.mixcloud.com/widget/iframe/?feed=http%3A%2F%2Fwww.mixcloud.com%2Fwolleb%2Fpumpatterns-2%2F&amp;embed_type=widget_standard&amp;embed_uuid=cc9d9612-a6d5-4313-a9f4-fc7e072558b5\" frameborder=\"0\"></iframe>\n\n\n        </div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\">\n\n            <iframe width=\"100%\" height=\"100%\" src=\"//www.mixcloud.com/widget/iframe/?feed=http%3A%2F%2Fwww.mixcloud.com%2Fwolleb%2Fpumpatterns-3%2F&amp;embed_type=widget_standard&amp;embed_uuid=98ebf600-0025-4f57-abcc-3149d1c6f7a2\" frameborder=\"0\"></iframe>\n\n        </div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n</ol>",
      "rendered": true,
      "contentRendered": "<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>PumPatterns</title>\n    <meta name=\"generator\" content=\"DocPad v6.60.3\" />\n    <link href='http://fonts.googleapis.com/css?family=Marcellus+SC' rel='stylesheet' type='text/css'>\n    <style >html.wait {\n\tcursor: wait !important;\n\topacity: 0;\n\ttransition: opacity 0.5s ease;\n}</style><link  rel=\"stylesheet\" href=\"/screen.css\" />\n\n    <meta property=\"og:image\" content=\"http://www.mixcloud.com/wolleb/pumpatterns-3/\">\n\n\n</head>\n<body onload=\"App.Main()\">\n    <header>\n        <h1 class=\"logo\">PumPatterns</h1>\n    </header>\n\n    <section id=\"grid\" class=\"content\">\n\t\t\t<ol id=\"items\">\n    <li class=\"item\">\n        <div class=\"inner\">\n            <iframe width=\"100%\" height=\"100%\" src=\"//www.mixcloud.com/widget/iframe/?feed=http%3A%2F%2Fwww.mixcloud.com%2Fwolleb%2Fpumpatterns-1%2F&amp;embed_type=widget_standard&amp;embed_uuid=e4f50ce2-789c-46ea-a19f-a02ffda38b95\" frameborder=\"0\"></iframe>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\">\n\n\n            <iframe width=\"100%\" height=\"100%\" src=\"//www.mixcloud.com/widget/iframe/?feed=http%3A%2F%2Fwww.mixcloud.com%2Fwolleb%2Fpumpatterns-2%2F&amp;embed_type=widget_standard&amp;embed_uuid=cc9d9612-a6d5-4313-a9f4-fc7e072558b5\" frameborder=\"0\"></iframe>\n\n\n        </div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\">\n\n            <iframe width=\"100%\" height=\"100%\" src=\"//www.mixcloud.com/widget/iframe/?feed=http%3A%2F%2Fwww.mixcloud.com%2Fwolleb%2Fpumpatterns-3%2F&amp;embed_type=widget_standard&amp;embed_uuid=98ebf600-0025-4f57-abcc-3149d1c6f7a2\" frameborder=\"0\"></iframe>\n\n        </div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n</ol>\n    </section>\n    \n    <!--<div id=\"canvas-css\"></div>-->\n    <section id=\"canvas-three\"></section>\n\n\n\n    <script >(function(){\n\t/* Did we just livereload? */\nvar log = !!(localStorage && console && console.log && true);\nif ( log && localStorage.getItem('/docpad-livereload/reloaded') === 'yes' ) {\n\tlocalStorage.removeItem('/docpad-livereload/reloaded');\n\tconsole.log('LiveReload completed at', new Date())\n}\n\n/* Listen for the regenerated event and perform a reload of the page when the event occurs */\nvar listen = function(){\n\tvar primus = new Primus('/docpad-livereload');\n\tprimus.on('data', function(data){\n\t\tif ( data && data.message ) {\n\t\t\tif ( data.message === 'generateBefore' ) {\n\t\t\t\tif ( log ) {\n\t\t\t\t\tconsole.log('LiveReload started at', new Date());\n\t\t\t\t}\n\t\t\t\tif ( typeof document.getElementsByTagName !== 'undefined' ) {\n\tdocument.getElementsByTagName('html')[0].className += ' wait';\n}\n\t\t\t}\n\t\t\telse if ( data.message === 'generateAfter' ) {\n\t\t\t\tif ( log ) {\n\t\t\t\t\tlocalStorage.setItem('/docpad-livereload/reloaded', 'yes');\n\t\t\t\t}\n\t\t\t\tdocument.location.reload();\n\t\t\t}\n\t\t}\n\t});\n};\n\t/* Inject socket into our page */\nvar inject = function(){\n\tvar t = document.createElement('script');\n\tt.type = 'text/javascript';\n\tt.async = 'async';\n\tt.src = '/primus/primus.js';\n\tt.onload = listen;\n\tvar s = document.getElementsByTagName('script')[0];\n\ts.parentNode.insertBefore(t, s);\n};\n\tif ( typeof Primus !== 'undefined' ) {\n\t\tlisten();\n\t} else {\n\t\tinject();\n\t}\n})();</script><script defer=\"defer\"  src=\"/js/three.min.js\"></script><script defer=\"defer\"  src=\"/js/shaders/VignetteShader.js\"></script><script defer=\"defer\"  src=\"/js/shaders/CopyShader.js\"></script><script defer=\"defer\"  src=\"/js/shaders/DotScreenShader.js\"></script><script defer=\"defer\"  src=\"/js/shaders/RGBShiftShader.js\"></script><script defer=\"defer\"  src=\"/js/post/EffectComposer.js\"></script><script defer=\"defer\"  src=\"/js/post/RenderPass.js\"></script><script defer=\"defer\"  src=\"/js/post/MaskPass.js\"></script><script defer=\"defer\"  src=\"/js/post/ShaderPass.js\"></script><script defer=\"defer\"  src=\"/js/lib.js\"></script><script defer=\"defer\"  src=\"/js/processing-1.4.1.js\"></script><script defer=\"defer\"  src=\"/js/TrackballControls.js\"></script>\n\n    <script>\n        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\n\n        ga('create', 'UA-48062185-1', 'pumpatterns.co.uk');\n        ga('send', 'pageview');\n\n    </script>\n\n    <!-- AddThis Smart Layers BEGIN -->\n    <!-- Go to http://www.addthis.com/get/smart-layers to customize -->\n    <script type=\"text/javascript\" src=\"//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-52fd0fa531ffef7f\"></script>\n    <script type=\"text/javascript\">\n        addthis.layers({\n            'theme' : 'light',\n            'share' : {\n                'position' : 'right',\n                'numPreferredServices' : 1\n            }\n        });\n    </script>\n    <!-- AddThis Smart Layers END -->\n\n\n\n\n</body>\n</html>",
      "contentRenderedWithoutLayouts": "<ol id=\"items\">\n    <li class=\"item\">\n        <div class=\"inner\">\n            <iframe width=\"100%\" height=\"100%\" src=\"//www.mixcloud.com/widget/iframe/?feed=http%3A%2F%2Fwww.mixcloud.com%2Fwolleb%2Fpumpatterns-1%2F&amp;embed_type=widget_standard&amp;embed_uuid=e4f50ce2-789c-46ea-a19f-a02ffda38b95\" frameborder=\"0\"></iframe>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\">\n\n\n            <iframe width=\"100%\" height=\"100%\" src=\"//www.mixcloud.com/widget/iframe/?feed=http%3A%2F%2Fwww.mixcloud.com%2Fwolleb%2Fpumpatterns-2%2F&amp;embed_type=widget_standard&amp;embed_uuid=cc9d9612-a6d5-4313-a9f4-fc7e072558b5\" frameborder=\"0\"></iframe>\n\n\n        </div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\">\n\n            <iframe width=\"100%\" height=\"100%\" src=\"//www.mixcloud.com/widget/iframe/?feed=http%3A%2F%2Fwww.mixcloud.com%2Fwolleb%2Fpumpatterns-3%2F&amp;embed_type=widget_standard&amp;embed_uuid=98ebf600-0025-4f57-abcc-3149d1c6f7a2\" frameborder=\"0\"></iframe>\n\n        </div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n    <li class=\"item\">\n        <div class=\"inner\"></div>\n    </li>\n</ol>",
      "renderSingleExtensions": false,
      "layout": "default",
      "isPage": true,
      "layoutRelativePath": "default.html.eco",
      "meta": {
        "title": "PumPatterns",
        "layout": "default",
        "isPage": true
      }
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/documents/screen.css.scss",
      "relativePath": "screen.css.scss",
      "basename": "screen",
      "outBasename": "screen",
      "extension": "scss",
      "outExtension": "css",
      "extensions": [
        "css",
        "scss"
      ],
      "filename": "screen.css.scss",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/documents",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/screen.css",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out",
      "outFilename": "screen.css",
      "relativeOutPath": "screen.css",
      "relativeDirPath": ".",
      "relativeOutDirPath": ".",
      "relativeBase": "screen",
      "relativeOutBase": "screen",
      "contentType": "application/octet-stream",
      "outContentType": "text/css",
      "ctime": "2014-12-21T21:42:58.000Z",
      "mtime": "2014-12-21T22:35:22.285Z",
      "rtime": "2014-12-21T22:35:28.392Z",
      "wtime": "2014-12-21T22:35:28.448Z",
      "exists": true,
      "encoding": "utf8",
      "source": "@import \"compass/css3/box-sizing\";\n@import \"compass/utilities/general/clearfix\";\n@import \"compass/css3/box-shadow\";\n@import \"compass/css3/transition\";\n@import \"compass/css3/transform\";\n@import \"compass/reset\";\n@import \"susyone\";\n\n* {\n\t@include box-sizing(border-box);\n}\nhtml,body{ \n\tmargin: 0px;\n\tpadding: 0px;\n\n\twidth: 100%;\n\tmin-width:100%;\n    height: 100%;\n\n\tbackground : #fff;\n\tcolor:#555;\n\n    overflow: hidden;\n   \n    \n\n}\n\n$total-columns  : 12;             // a 12-column grid\n$column-width   : 4em;            // each column is 4em wide\n$gutter-width   : 0em;            // 1em gutters between columns\n$grid-padding   : $gutter-width;  // grid-padding equal to gutters\n\n\n.content {\n    @include clearfix;\n    position: relative;\n    z-index: 100;\n    margin: 0 auto;\n    height: 100%;\n    @include transition(transform 10s ease-out);\n    //@include transform(rotateX(45deg) rotateY(45deg)  scale(.8));\n    //background: blue;\n}\n\n\nol {\n    height: 680px;\n}\n\n.item {\n\n        @include span-columns(1,3);\n\n\t\t//background :red;\n       // opacity: 0;\n    opacity: 0;\n    @include transition(opacity 1s linear);\n\n        .inner {\n\n           // background: #888;\n            border : 2px solid #333;\n            width: 100%;\n            height: 100%;\n        }\n\n    @for $i from 1 through 9 {\n        .item:nth-child(#{$i}) {\n            background-image: url('/assets/pumpatterns' + #{$i} + '.jpg');\n            //opacity: 1;\n        }\n    }\n\n\n\t\tiframe {\n           //opacity: 0;\n            //@include transition(opacity 1s linear);\n\n\t\t\t//display: none;\n\t\t}\n\t}\n\n.item:last-child, .item:nth-child(3), .item:nth-child(6) {\n    margin-right: 0px;\n}\n\n.item:last-child, .item:nth-child(8), .item:nth-child(7) {\n    margin-bottom: 0px;\n}\n#canvas-three {\n\n    position: absolute;\n    top:0px;\n    left: 0px;\n    width:100%;\n    height: auto;\n    //height: 100%;\n    z-index: 1;\n}\nheader {\n    h1 {\n        padding: 20px 0px;\n    }\n    display: none;\n\n}\n#canvas-css {\n\n\t@include clearfix;\n\tposition:absolute;\n\tz-index: 100;\n\twidth: 1600px;\n\theight: 1200px;\n\ttop: 0px;\n\tleft:0px;\n\t//background: rgba(black, 0.1);\n}\n\n.logo {\n\tfont-family: 'Marcellus SC', serif;\n\tfont-size: 24px;\n}\n\n.seed {\n\tdisplay: block;\n\tposition: absolute;\n\n}\n\n.circle {\n\tposition: absolute;\n\twidth: 108px;\n\theight: 108px;\n\tborder-radius: 54px;\n\tborder: solid 1px #000;\n}\n\n.circle2 {\n    position: absolute;\n    width: 187px;\n    //@include box-shadow(rgba(yellow, 0.7) 0 0 25px);\n    height:187px;\n    border-radius: 94px;\n    border: solid 1px #000;\n}\n",
      "content": "@import \"compass/css3/box-sizing\";\n@import \"compass/utilities/general/clearfix\";\n@import \"compass/css3/box-shadow\";\n@import \"compass/css3/transition\";\n@import \"compass/css3/transform\";\n@import \"compass/reset\";\n@import \"susyone\";\n\n* {\n\t@include box-sizing(border-box);\n}\nhtml,body{ \n\tmargin: 0px;\n\tpadding: 0px;\n\n\twidth: 100%;\n\tmin-width:100%;\n    height: 100%;\n\n\tbackground : #fff;\n\tcolor:#555;\n\n    overflow: hidden;\n   \n    \n\n}\n\n$total-columns  : 12;             // a 12-column grid\n$column-width   : 4em;            // each column is 4em wide\n$gutter-width   : 0em;            // 1em gutters between columns\n$grid-padding   : $gutter-width;  // grid-padding equal to gutters\n\n\n.content {\n    @include clearfix;\n    position: relative;\n    z-index: 100;\n    margin: 0 auto;\n    height: 100%;\n    @include transition(transform 10s ease-out);\n    //@include transform(rotateX(45deg) rotateY(45deg)  scale(.8));\n    //background: blue;\n}\n\n\nol {\n    height: 680px;\n}\n\n.item {\n\n        @include span-columns(1,3);\n\n\t\t//background :red;\n       // opacity: 0;\n    opacity: 0;\n    @include transition(opacity 1s linear);\n\n        .inner {\n\n           // background: #888;\n            border : 2px solid #333;\n            width: 100%;\n            height: 100%;\n        }\n\n    @for $i from 1 through 9 {\n        .item:nth-child(#{$i}) {\n            background-image: url('/assets/pumpatterns' + #{$i} + '.jpg');\n            //opacity: 1;\n        }\n    }\n\n\n\t\tiframe {\n           //opacity: 0;\n            //@include transition(opacity 1s linear);\n\n\t\t\t//display: none;\n\t\t}\n\t}\n\n.item:last-child, .item:nth-child(3), .item:nth-child(6) {\n    margin-right: 0px;\n}\n\n.item:last-child, .item:nth-child(8), .item:nth-child(7) {\n    margin-bottom: 0px;\n}\n#canvas-three {\n\n    position: absolute;\n    top:0px;\n    left: 0px;\n    width:100%;\n    height: auto;\n    //height: 100%;\n    z-index: 1;\n}\nheader {\n    h1 {\n        padding: 20px 0px;\n    }\n    display: none;\n\n}\n#canvas-css {\n\n\t@include clearfix;\n\tposition:absolute;\n\tz-index: 100;\n\twidth: 1600px;\n\theight: 1200px;\n\ttop: 0px;\n\tleft:0px;\n\t//background: rgba(black, 0.1);\n}\n\n.logo {\n\tfont-family: 'Marcellus SC', serif;\n\tfont-size: 24px;\n}\n\n.seed {\n\tdisplay: block;\n\tposition: absolute;\n\n}\n\n.circle {\n\tposition: absolute;\n\twidth: 108px;\n\theight: 108px;\n\tborder-radius: 54px;\n\tborder: solid 1px #000;\n}\n\n.circle2 {\n    position: absolute;\n    width: 187px;\n    //@include box-shadow(rgba(yellow, 0.7) 0 0 25px);\n    height:187px;\n    border-radius: 94px;\n    border: solid 1px #000;\n}\n",
      "tags": null,
      "render": true,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "screen.css",
      "date": "2014-12-21T22:35:22.285Z",
      "slug": "screen",
      "url": "/screen.css",
      "urls": [
        "/screen.css"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": true,
      "header": null,
      "parser": null,
      "body": "@import \"compass/css3/box-sizing\";\n@import \"compass/utilities/general/clearfix\";\n@import \"compass/css3/box-shadow\";\n@import \"compass/css3/transition\";\n@import \"compass/css3/transform\";\n@import \"compass/reset\";\n@import \"susyone\";\n\n* {\n\t@include box-sizing(border-box);\n}\nhtml,body{ \n\tmargin: 0px;\n\tpadding: 0px;\n\n\twidth: 100%;\n\tmin-width:100%;\n    height: 100%;\n\n\tbackground : #fff;\n\tcolor:#555;\n\n    overflow: hidden;\n   \n    \n\n}\n\n$total-columns  : 12;             // a 12-column grid\n$column-width   : 4em;            // each column is 4em wide\n$gutter-width   : 0em;            // 1em gutters between columns\n$grid-padding   : $gutter-width;  // grid-padding equal to gutters\n\n\n.content {\n    @include clearfix;\n    position: relative;\n    z-index: 100;\n    margin: 0 auto;\n    height: 100%;\n    @include transition(transform 10s ease-out);\n    //@include transform(rotateX(45deg) rotateY(45deg)  scale(.8));\n    //background: blue;\n}\n\n\nol {\n    height: 680px;\n}\n\n.item {\n\n        @include span-columns(1,3);\n\n\t\t//background :red;\n       // opacity: 0;\n    opacity: 0;\n    @include transition(opacity 1s linear);\n\n        .inner {\n\n           // background: #888;\n            border : 2px solid #333;\n            width: 100%;\n            height: 100%;\n        }\n\n    @for $i from 1 through 9 {\n        .item:nth-child(#{$i}) {\n            background-image: url('/assets/pumpatterns' + #{$i} + '.jpg');\n            //opacity: 1;\n        }\n    }\n\n\n\t\tiframe {\n           //opacity: 0;\n            //@include transition(opacity 1s linear);\n\n\t\t\t//display: none;\n\t\t}\n\t}\n\n.item:last-child, .item:nth-child(3), .item:nth-child(6) {\n    margin-right: 0px;\n}\n\n.item:last-child, .item:nth-child(8), .item:nth-child(7) {\n    margin-bottom: 0px;\n}\n#canvas-three {\n\n    position: absolute;\n    top:0px;\n    left: 0px;\n    width:100%;\n    height: auto;\n    //height: 100%;\n    z-index: 1;\n}\nheader {\n    h1 {\n        padding: 20px 0px;\n    }\n    display: none;\n\n}\n#canvas-css {\n\n\t@include clearfix;\n\tposition:absolute;\n\tz-index: 100;\n\twidth: 1600px;\n\theight: 1200px;\n\ttop: 0px;\n\tleft:0px;\n\t//background: rgba(black, 0.1);\n}\n\n.logo {\n\tfont-family: 'Marcellus SC', serif;\n\tfont-size: 24px;\n}\n\n.seed {\n\tdisplay: block;\n\tposition: absolute;\n\n}\n\n.circle {\n\tposition: absolute;\n\twidth: 108px;\n\theight: 108px;\n\tborder-radius: 54px;\n\tborder: solid 1px #000;\n}\n\n.circle2 {\n    position: absolute;\n    width: 187px;\n    //@include box-shadow(rgba(yellow, 0.7) 0 0 25px);\n    height:187px;\n    border-radius: 94px;\n    border: solid 1px #000;\n}\n",
      "rendered": true,
      "contentRendered": "html, body, div, span, applet, object, iframe,\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\na, abbr, acronym, address, big, cite, code,\ndel, dfn, em, img, ins, kbd, q, s, samp,\nsmall, strike, strong, sub, sup, tt, var,\nb, u, i, center,\ndl, dt, dd, ol, ul, li,\nfieldset, form, label, legend,\ntable, caption, tbody, tfoot, thead, tr, th, td,\narticle, aside, canvas, details, embed,\nfigure, figcaption, footer, header, hgroup,\nmenu, nav, output, ruby, section, summary,\ntime, mark, audio, video {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font: inherit;\n  font-size: 100%;\n  vertical-align: baseline;\n}\n\nhtml {\n  line-height: 1;\n}\n\nol, ul {\n  list-style: none;\n}\n\ntable {\n  border-collapse: collapse;\n  border-spacing: 0;\n}\n\ncaption, th, td {\n  text-align: left;\n  font-weight: normal;\n  vertical-align: middle;\n}\n\nq, blockquote {\n  quotes: none;\n}\nq:before, q:after, blockquote:before, blockquote:after {\n  content: \"\";\n  content: none;\n}\n\na img {\n  border: none;\n}\n\narticle, aside, details, figcaption, figure, footer, header, hgroup, main, menu, nav, section, summary {\n  display: block;\n}\n\n* {\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\nhtml, body {\n  margin: 0px;\n  padding: 0px;\n  width: 100%;\n  min-width: 100%;\n  height: 100%;\n  background: #fff;\n  color: #555;\n  overflow: hidden;\n}\n\n.content {\n  overflow: hidden;\n  *zoom: 1;\n  position: relative;\n  z-index: 100;\n  margin: 0 auto;\n  height: 100%;\n  -moz-transition: -moz-transform 10s ease-out;\n  -o-transition: -o-transform 10s ease-out;\n  -webkit-transition: -webkit-transform 10s ease-out;\n  transition: transform 10s ease-out;\n}\n\nol {\n  height: 680px;\n}\n\n.item {\n  width: 33.33333%;\n  float: left;\n  margin-right: 0%;\n  display: inline;\n  opacity: 0;\n  -moz-transition: opacity 1s linear;\n  -o-transition: opacity 1s linear;\n  -webkit-transition: opacity 1s linear;\n  transition: opacity 1s linear;\n}\n.item .inner {\n  border: 2px solid #333;\n  width: 100%;\n  height: 100%;\n}\n.item .item:nth-child(1) {\n  background-image: url(\"/assets/pumpatterns\" + 1 + \".jpg\");\n}\n.item .item:nth-child(2) {\n  background-image: url(\"/assets/pumpatterns\" + 2 + \".jpg\");\n}\n.item .item:nth-child(3) {\n  background-image: url(\"/assets/pumpatterns\" + 3 + \".jpg\");\n}\n.item .item:nth-child(4) {\n  background-image: url(\"/assets/pumpatterns\" + 4 + \".jpg\");\n}\n.item .item:nth-child(5) {\n  background-image: url(\"/assets/pumpatterns\" + 5 + \".jpg\");\n}\n.item .item:nth-child(6) {\n  background-image: url(\"/assets/pumpatterns\" + 6 + \".jpg\");\n}\n.item .item:nth-child(7) {\n  background-image: url(\"/assets/pumpatterns\" + 7 + \".jpg\");\n}\n.item .item:nth-child(8) {\n  background-image: url(\"/assets/pumpatterns\" + 8 + \".jpg\");\n}\n.item .item:nth-child(9) {\n  background-image: url(\"/assets/pumpatterns\" + 9 + \".jpg\");\n}\n\n.item:last-child, .item:nth-child(3), .item:nth-child(6) {\n  margin-right: 0px;\n}\n\n.item:last-child, .item:nth-child(8), .item:nth-child(7) {\n  margin-bottom: 0px;\n}\n\n#canvas-three {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 100%;\n  height: auto;\n  z-index: 1;\n}\n\nheader {\n  display: none;\n}\nheader h1 {\n  padding: 20px 0px;\n}\n\n#canvas-css {\n  overflow: hidden;\n  *zoom: 1;\n  position: absolute;\n  z-index: 100;\n  width: 1600px;\n  height: 1200px;\n  top: 0px;\n  left: 0px;\n}\n\n.logo {\n  font-family: 'Marcellus SC', serif;\n  font-size: 24px;\n}\n\n.seed {\n  display: block;\n  position: absolute;\n}\n\n.circle {\n  position: absolute;\n  width: 108px;\n  height: 108px;\n  border-radius: 54px;\n  border: solid 1px #000;\n}\n\n.circle2 {\n  position: absolute;\n  width: 187px;\n  height: 187px;\n  border-radius: 94px;\n  border: solid 1px #000;\n}\n",
      "contentRenderedWithoutLayouts": "html, body, div, span, applet, object, iframe,\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\na, abbr, acronym, address, big, cite, code,\ndel, dfn, em, img, ins, kbd, q, s, samp,\nsmall, strike, strong, sub, sup, tt, var,\nb, u, i, center,\ndl, dt, dd, ol, ul, li,\nfieldset, form, label, legend,\ntable, caption, tbody, tfoot, thead, tr, th, td,\narticle, aside, canvas, details, embed,\nfigure, figcaption, footer, header, hgroup,\nmenu, nav, output, ruby, section, summary,\ntime, mark, audio, video {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  font: inherit;\n  font-size: 100%;\n  vertical-align: baseline;\n}\n\nhtml {\n  line-height: 1;\n}\n\nol, ul {\n  list-style: none;\n}\n\ntable {\n  border-collapse: collapse;\n  border-spacing: 0;\n}\n\ncaption, th, td {\n  text-align: left;\n  font-weight: normal;\n  vertical-align: middle;\n}\n\nq, blockquote {\n  quotes: none;\n}\nq:before, q:after, blockquote:before, blockquote:after {\n  content: \"\";\n  content: none;\n}\n\na img {\n  border: none;\n}\n\narticle, aside, details, figcaption, figure, footer, header, hgroup, main, menu, nav, section, summary {\n  display: block;\n}\n\n* {\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\nhtml, body {\n  margin: 0px;\n  padding: 0px;\n  width: 100%;\n  min-width: 100%;\n  height: 100%;\n  background: #fff;\n  color: #555;\n  overflow: hidden;\n}\n\n.content {\n  overflow: hidden;\n  *zoom: 1;\n  position: relative;\n  z-index: 100;\n  margin: 0 auto;\n  height: 100%;\n  -moz-transition: -moz-transform 10s ease-out;\n  -o-transition: -o-transform 10s ease-out;\n  -webkit-transition: -webkit-transform 10s ease-out;\n  transition: transform 10s ease-out;\n}\n\nol {\n  height: 680px;\n}\n\n.item {\n  width: 33.33333%;\n  float: left;\n  margin-right: 0%;\n  display: inline;\n  opacity: 0;\n  -moz-transition: opacity 1s linear;\n  -o-transition: opacity 1s linear;\n  -webkit-transition: opacity 1s linear;\n  transition: opacity 1s linear;\n}\n.item .inner {\n  border: 2px solid #333;\n  width: 100%;\n  height: 100%;\n}\n.item .item:nth-child(1) {\n  background-image: url(\"/assets/pumpatterns\" + 1 + \".jpg\");\n}\n.item .item:nth-child(2) {\n  background-image: url(\"/assets/pumpatterns\" + 2 + \".jpg\");\n}\n.item .item:nth-child(3) {\n  background-image: url(\"/assets/pumpatterns\" + 3 + \".jpg\");\n}\n.item .item:nth-child(4) {\n  background-image: url(\"/assets/pumpatterns\" + 4 + \".jpg\");\n}\n.item .item:nth-child(5) {\n  background-image: url(\"/assets/pumpatterns\" + 5 + \".jpg\");\n}\n.item .item:nth-child(6) {\n  background-image: url(\"/assets/pumpatterns\" + 6 + \".jpg\");\n}\n.item .item:nth-child(7) {\n  background-image: url(\"/assets/pumpatterns\" + 7 + \".jpg\");\n}\n.item .item:nth-child(8) {\n  background-image: url(\"/assets/pumpatterns\" + 8 + \".jpg\");\n}\n.item .item:nth-child(9) {\n  background-image: url(\"/assets/pumpatterns\" + 9 + \".jpg\");\n}\n\n.item:last-child, .item:nth-child(3), .item:nth-child(6) {\n  margin-right: 0px;\n}\n\n.item:last-child, .item:nth-child(8), .item:nth-child(7) {\n  margin-bottom: 0px;\n}\n\n#canvas-three {\n  position: absolute;\n  top: 0px;\n  left: 0px;\n  width: 100%;\n  height: auto;\n  z-index: 1;\n}\n\nheader {\n  display: none;\n}\nheader h1 {\n  padding: 20px 0px;\n}\n\n#canvas-css {\n  overflow: hidden;\n  *zoom: 1;\n  position: absolute;\n  z-index: 100;\n  width: 1600px;\n  height: 1200px;\n  top: 0px;\n  left: 0px;\n}\n\n.logo {\n  font-family: 'Marcellus SC', serif;\n  font-size: 24px;\n}\n\n.seed {\n  display: block;\n  position: absolute;\n}\n\n.circle {\n  position: absolute;\n  width: 108px;\n  height: 108px;\n  border-radius: 54px;\n  border: solid 1px #000;\n}\n\n.circle2 {\n  position: absolute;\n  width: 187px;\n  height: 187px;\n  border-radius: 94px;\n  border: solid 1px #000;\n}\n",
      "renderSingleExtensions": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/assets/Logo.png",
      "relativePath": "assets/Logo.png",
      "basename": "Logo",
      "outBasename": "Logo",
      "extension": "png",
      "outExtension": "png",
      "extensions": [
        "png"
      ],
      "filename": "Logo.png",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/assets",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/assets/Logo.png",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/assets",
      "outFilename": "Logo.png",
      "relativeOutPath": "assets/Logo.png",
      "relativeDirPath": "assets",
      "relativeOutDirPath": "assets",
      "relativeBase": "assets/Logo",
      "relativeOutBase": "assets/Logo",
      "contentType": "image/png",
      "outContentType": "image/png",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.452Z",
      "exists": true,
      "encoding": "binary",
      "source": "",
      "content": "",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "Logo.png",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "assets-Logo",
      "url": "/assets/Logo.png",
      "urls": [
        "/assets/Logo.png"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/assets/Screen-Shot-2014-02-13-at-11.31.17.jpg",
      "relativePath": "assets/Screen-Shot-2014-02-13-at-11.31.17.jpg",
      "basename": "Screen-Shot-2014-02-13-at-11",
      "outBasename": "Screen-Shot-2014-02-13-at-11",
      "extension": "jpg",
      "outExtension": "jpg",
      "extensions": [
        "31",
        "17",
        "jpg"
      ],
      "filename": "Screen-Shot-2014-02-13-at-11.31.17.jpg",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/assets",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/assets/Screen-Shot-2014-02-13-at-11.31.17.jpg",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/assets",
      "outFilename": "Screen-Shot-2014-02-13-at-11.31.17.jpg",
      "relativeOutPath": "assets/Screen-Shot-2014-02-13-at-11.31.17.jpg",
      "relativeDirPath": "assets",
      "relativeOutDirPath": "assets",
      "relativeBase": "assets/Screen-Shot-2014-02-13-at-11",
      "relativeOutBase": "assets/Screen-Shot-2014-02-13-at-11",
      "contentType": "image/jpeg",
      "outContentType": "image/jpeg",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.465Z",
      "exists": true,
      "encoding": "binary",
      "source": "",
      "content": "",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "Screen-Shot-2014-02-13-at-11.31.17.jpg",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "assets-Screen-Shot-2014-02-13-at-11",
      "url": "/assets/Screen-Shot-2014-02-13-at-11.31.17.jpg",
      "urls": [
        "/assets/Screen-Shot-2014-02-13-at-11.31.17.jpg"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/assets/logo.jpg",
      "relativePath": "assets/logo.jpg",
      "basename": "logo",
      "outBasename": "logo",
      "extension": "jpg",
      "outExtension": "jpg",
      "extensions": [
        "jpg"
      ],
      "filename": "logo.jpg",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/assets",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/assets/logo.jpg",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/assets",
      "outFilename": "logo.jpg",
      "relativeOutPath": "assets/logo.jpg",
      "relativeDirPath": "assets",
      "relativeOutDirPath": "assets",
      "relativeBase": "assets/logo",
      "relativeOutBase": "assets/logo",
      "contentType": "image/jpeg",
      "outContentType": "image/jpeg",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.475Z",
      "exists": true,
      "encoding": "binary",
      "source": "",
      "content": "",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "logo.jpg",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "assets-logo",
      "url": "/assets/logo.jpg",
      "urls": [
        "/assets/logo.jpg"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/assets/pumpatterns1.jpg",
      "relativePath": "assets/pumpatterns1.jpg",
      "basename": "pumpatterns1",
      "outBasename": "pumpatterns1",
      "extension": "jpg",
      "outExtension": "jpg",
      "extensions": [
        "jpg"
      ],
      "filename": "pumpatterns1.jpg",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/assets",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/assets/pumpatterns1.jpg",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/assets",
      "outFilename": "pumpatterns1.jpg",
      "relativeOutPath": "assets/pumpatterns1.jpg",
      "relativeDirPath": "assets",
      "relativeOutDirPath": "assets",
      "relativeBase": "assets/pumpatterns1",
      "relativeOutBase": "assets/pumpatterns1",
      "contentType": "image/jpeg",
      "outContentType": "image/jpeg",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.473Z",
      "exists": true,
      "encoding": "binary",
      "source": "",
      "content": "",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "pumpatterns1.jpg",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "assets-pumpatterns1",
      "url": "/assets/pumpatterns1.jpg",
      "urls": [
        "/assets/pumpatterns1.jpg"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/assets/pumpatterns1.png",
      "relativePath": "assets/pumpatterns1.png",
      "basename": "pumpatterns1",
      "outBasename": "pumpatterns1",
      "extension": "png",
      "outExtension": "png",
      "extensions": [
        "png"
      ],
      "filename": "pumpatterns1.png",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/assets",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/assets/pumpatterns1.png",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/assets",
      "outFilename": "pumpatterns1.png",
      "relativeOutPath": "assets/pumpatterns1.png",
      "relativeDirPath": "assets",
      "relativeOutDirPath": "assets",
      "relativeBase": "assets/pumpatterns1",
      "relativeOutBase": "assets/pumpatterns1",
      "contentType": "image/png",
      "outContentType": "image/png",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.484Z",
      "exists": true,
      "encoding": "binary",
      "source": "",
      "content": "",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "pumpatterns1.png",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "assets-pumpatterns1",
      "url": "/assets/pumpatterns1.png",
      "urls": [
        "/assets/pumpatterns1.png"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/assets/pumpatterns2.png",
      "relativePath": "assets/pumpatterns2.png",
      "basename": "pumpatterns2",
      "outBasename": "pumpatterns2",
      "extension": "png",
      "outExtension": "png",
      "extensions": [
        "png"
      ],
      "filename": "pumpatterns2.png",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/assets",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/assets/pumpatterns2.png",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/assets",
      "outFilename": "pumpatterns2.png",
      "relativeOutPath": "assets/pumpatterns2.png",
      "relativeDirPath": "assets",
      "relativeOutDirPath": "assets",
      "relativeBase": "assets/pumpatterns2",
      "relativeOutBase": "assets/pumpatterns2",
      "contentType": "image/png",
      "outContentType": "image/png",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.492Z",
      "exists": true,
      "encoding": "binary",
      "source": "",
      "content": "",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "pumpatterns2.png",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "assets-pumpatterns2",
      "url": "/assets/pumpatterns2.png",
      "urls": [
        "/assets/pumpatterns2.png"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/assets/pumpatterns3.png",
      "relativePath": "assets/pumpatterns3.png",
      "basename": "pumpatterns3",
      "outBasename": "pumpatterns3",
      "extension": "png",
      "outExtension": "png",
      "extensions": [
        "png"
      ],
      "filename": "pumpatterns3.png",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/assets",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/assets/pumpatterns3.png",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/assets",
      "outFilename": "pumpatterns3.png",
      "relativeOutPath": "assets/pumpatterns3.png",
      "relativeDirPath": "assets",
      "relativeOutDirPath": "assets",
      "relativeBase": "assets/pumpatterns3",
      "relativeOutBase": "assets/pumpatterns3",
      "contentType": "image/png",
      "outContentType": "image/png",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.498Z",
      "exists": true,
      "encoding": "binary",
      "source": "",
      "content": "",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "pumpatterns3.png",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "assets-pumpatterns3",
      "url": "/assets/pumpatterns3.png",
      "urls": [
        "/assets/pumpatterns3.png"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/assets/seed.jpg",
      "relativePath": "assets/seed.jpg",
      "basename": "seed",
      "outBasename": "seed",
      "extension": "jpg",
      "outExtension": "jpg",
      "extensions": [
        "jpg"
      ],
      "filename": "seed.jpg",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/assets",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/assets/seed.jpg",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/assets",
      "outFilename": "seed.jpg",
      "relativeOutPath": "assets/seed.jpg",
      "relativeDirPath": "assets",
      "relativeOutDirPath": "assets",
      "relativeBase": "assets/seed",
      "relativeOutBase": "assets/seed",
      "contentType": "image/jpeg",
      "outContentType": "image/jpeg",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.505Z",
      "exists": true,
      "encoding": "binary",
      "source": "",
      "content": "",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "seed.jpg",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "assets-seed",
      "url": "/assets/seed.jpg",
      "urls": [
        "/assets/seed.jpg"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/TrackballControls.js",
      "relativePath": "js/TrackballControls.js",
      "basename": "TrackballControls",
      "outBasename": "TrackballControls",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "TrackballControls.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/TrackballControls.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js",
      "outFilename": "TrackballControls.js",
      "relativeOutPath": "js/TrackballControls.js",
      "relativeDirPath": "js",
      "relativeOutDirPath": "js",
      "relativeBase": "js/TrackballControls",
      "relativeOutBase": "js/TrackballControls",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.513Z",
      "exists": true,
      "encoding": "utf8",
      "source": "                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /**\n * @author Eberhard Graether / http://egraether.com/\n * @author Mark Lundin \t/ http://mark-lundin.com\n */\n\nTHREE.TrackballControls = function ( object, domElement ) {\n\n\tvar _this = this;\n\tvar STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM: 4, TOUCH_PAN: 5 };\n\n\tthis.object = object;\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t// API\n\n\tthis.enabled = true;\n\n\tthis.screen = { left: 0, top: 0, width: 0, height: 0 };\n\n\tthis.rotateSpeed = 1.0;\n\tthis.zoomSpeed = 1.2;\n\tthis.panSpeed = 0.3;\n\n\tthis.noRotate = false;\n\tthis.noZoom = false;\n\tthis.noPan = false;\n\tthis.noRoll = false;\n\n\tthis.staticMoving = false;\n\tthis.dynamicDampingFactor = 0.2;\n\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\tthis.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];\n\n\t// internals\n\n\tthis.target = new THREE.Vector3();\n\n\tvar lastPosition = new THREE.Vector3();\n\n\tvar _state = STATE.NONE,\n\t_prevState = STATE.NONE,\n\n\t_eye = new THREE.Vector3(),\n\n\t_rotateStart = new THREE.Vector3(),\n\t_rotateEnd = new THREE.Vector3(),\n\n\t_zoomStart = new THREE.Vector2(),\n\t_zoomEnd = new THREE.Vector2(),\n\n\t_touchZoomDistanceStart = 0,\n\t_touchZoomDistanceEnd = 0,\n\n\t_panStart = new THREE.Vector2(),\n\t_panEnd = new THREE.Vector2();\n\n\t// for reset\n\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\tthis.up0 = this.object.up.clone();\n\n\t// events\n\n\tvar changeEvent = { type: 'change' };\n\tvar startEvent = { type: 'start'};\n\tvar endEvent = { type: 'end'};\n\n\n\t// methods\n\n\tthis.handleResize = function () {\n\n\t\tif ( this.domElement === document ) {\n\n\t\t\tthis.screen.left = 0;\n\t\t\tthis.screen.top = 0;\n\t\t\tthis.screen.width = window.innerWidth;\n\t\t\tthis.screen.height = window.innerHeight;\n\n\t\t} else {\n\n\t\t\tthis.screen = this.domElement.getBoundingClientRect();\n\t\t\t// adjustments come from similar code in the jquery offset() function\n\t\t\tvar d = this.domElement.ownerDocument.documentElement\n\t\t\tthis.screen.left += window.pageXOffset - d.clientLeft\n\t\t\tthis.screen.top += window.pageYOffset - d.clientTop\n\n\t\t}\n\n\t};\n\n\tthis.handleEvent = function ( event ) {\n\n\t\tif ( typeof this[ event.type ] == 'function' ) {\n\n\t\t\tthis[ event.type ]( event );\n\n\t\t}\n\n\t};\n\n\tthis.getMouseOnScreen = function ( pageX, pageY, vector ) {\n\n\t\treturn vector.set(\n\t\t\t( pageX - _this.screen.left ) / _this.screen.width,\n\t\t\t( pageY - _this.screen.top ) / _this.screen.height\n\t\t);\n\n\t};\n\n\tthis.getMouseProjectionOnBall = (function(){\n\n\t\tvar objectUp = new THREE.Vector3(),\n\t\t    mouseOnBall = new THREE.Vector3();\n\n\n\t\treturn function ( pageX, pageY, projection ) {\n\n\t\t\tmouseOnBall.set(\n\t\t\t\t( pageX - _this.screen.width * 0.5 - _this.screen.left ) / (_this.screen.width*.5),\n\t\t\t\t( _this.screen.height * 0.5 + _this.screen.top - pageY ) / (_this.screen.height*.5),\n\t\t\t\t0.0\n\t\t\t);\n\n\t\t\tvar length = mouseOnBall.length();\n\n\t\t\tif ( _this.noRoll ) {\n\n\t\t\t\tif ( length < Math.SQRT1_2 ) {\n\n\t\t\t\t\tmouseOnBall.z = Math.sqrt( 1.0 - length*length );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmouseOnBall.z = .5 / length;\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t} else if ( length > 1.0 ) {\n\n\t\t\t\tmouseOnBall.normalize();\n\n\t\t\t} else {\n\n\t\t\t\tmouseOnBall.z = Math.sqrt( 1.0 - length * length );\n\n\t\t\t}\n\n\t\t\t_eye.copy( _this.object.position ).sub( _this.target );\n\n\t\t\tprojection.copy( _this.object.up ).setLength( mouseOnBall.y )\n\t\t\tprojection.add( objectUp.copy( _this.object.up ).cross( _eye ).setLength( mouseOnBall.x ) );\n\t\t\tprojection.add( _eye.setLength( mouseOnBall.z ) );\n\n\t\t\treturn projection;\n\t\t}\n\n\t}());\n\n\tthis.rotateCamera = (function(){\n\n\t\tvar axis = new THREE.Vector3(),\n\t\t\tquaternion = new THREE.Quaternion();\n\n\n\t\treturn function () {\n\n\t\t\tvar angle = Math.acos( _rotateStart.dot( _rotateEnd ) / _rotateStart.length() / _rotateEnd.length() );\n\n\t\t\tif ( angle ) {\n\n\t\t\t\taxis.crossVectors( _rotateStart, _rotateEnd ).normalize();\n\n\t\t\t\tangle *= _this.rotateSpeed;\n\n\t\t\t\tquaternion.setFromAxisAngle( axis, -angle );\n\n\t\t\t\t_eye.applyQuaternion( quaternion );\n\t\t\t\t_this.object.up.applyQuaternion( quaternion );\n\n\t\t\t\t_rotateEnd.applyQuaternion( quaternion );\n\n\t\t\t\tif ( _this.staticMoving ) {\n\n\t\t\t\t\t_rotateStart.copy( _rotateEnd );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tquaternion.setFromAxisAngle( axis, angle * ( _this.dynamicDampingFactor - 1.0 ) );\n\t\t\t\t\t_rotateStart.applyQuaternion( quaternion );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t}());\n\n\tthis.zoomCamera = function () {\n\n\t\tif ( _state === STATE.TOUCH_ZOOM ) {\n\n\t\t\tvar factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;\n\t\t\t_touchZoomDistanceStart = _touchZoomDistanceEnd;\n\t\t\t_eye.multiplyScalar( factor );\n\n\t\t} else {\n\n\t\t\tvar factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;\n\n\t\t\tif ( factor !== 1.0 && factor > 0.0 ) {\n\n\t\t\t\t_eye.multiplyScalar( factor );\n\n\t\t\t\tif ( _this.staticMoving ) {\n\n\t\t\t\t\t_zoomStart.copy( _zoomEnd );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.panCamera = (function(){\n\n\t\tvar mouseChange = new THREE.Vector2(),\n\t\t\tobjectUp = new THREE.Vector3(),\n\t\t\tpan = new THREE.Vector3();\n\n\t\treturn function () {\n\n\t\t\tmouseChange.copy( _panEnd ).sub( _panStart );\n\n\t\t\tif ( mouseChange.lengthSq() ) {\n\n\t\t\t\tmouseChange.multiplyScalar( _eye.length() * _this.panSpeed );\n\n\t\t\t\tpan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );\n\t\t\t\tpan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );\n\n\t\t\t\t_this.object.position.add( pan );\n\t\t\t\t_this.target.add( pan );\n\n\t\t\t\tif ( _this.staticMoving ) {\n\n\t\t\t\t\t_panStart.copy( _panEnd );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t}());\n\n\tthis.checkDistances = function () {\n\n\t\tif ( !_this.noZoom || !_this.noPan ) {\n\n\t\t\tif ( _eye.lengthSq() > _this.maxDistance * _this.maxDistance ) {\n\n\t\t\t\t_this.object.position.addVectors( _this.target, _eye.setLength( _this.maxDistance ) );\n\n\t\t\t}\n\n\t\t\tif ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {\n\n\t\t\t\t_this.object.position.addVectors( _this.target, _eye.setLength( _this.minDistance ) );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.update = function () {\n\n\t\t_eye.subVectors( _this.object.position, _this.target );\n\n\t\tif ( !_this.noRotate ) {\n\n\t\t\t_this.rotateCamera();\n\n\t\t}\n\n\t\tif ( !_this.noZoom ) {\n\n\t\t\t_this.zoomCamera();\n\n\t\t}\n\n\t\tif ( !_this.noPan ) {\n\n\t\t\t_this.panCamera();\n\n\t\t}\n\n\t\t_this.object.position.addVectors( _this.target, _eye );\n\n\t\t_this.checkDistances();\n\n\t\t_this.object.lookAt( _this.target );\n\n\t\tif ( lastPosition.distanceToSquared( _this.object.position ) > 0 ) {\n\n\t\t\t_this.dispatchEvent( changeEvent );\n\n\t\t\tlastPosition.copy( _this.object.position );\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\t_state = STATE.NONE;\n\t\t_prevState = STATE.NONE;\n\n\t\t_this.target.copy( _this.target0 );\n\t\t_this.object.position.copy( _this.position0 );\n\t\t_this.object.up.copy( _this.up0 );\n\n\t\t_eye.subVectors( _this.object.position, _this.target );\n\n\t\t_this.object.lookAt( _this.target );\n\n\t\t_this.dispatchEvent( changeEvent );\n\n\t\tlastPosition.copy( _this.object.position );\n\n\t};\n\n\t// listeners\n\n\tfunction keydown( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\twindow.removeEventListener( 'keydown', keydown );\n\n\t\t_prevState = _state;\n\n\t\tif ( _state !== STATE.NONE ) {\n\n\t\t\treturn;\n\n\t\t} else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && !_this.noRotate ) {\n\n\t\t\t_state = STATE.ROTATE;\n\n\t\t} else if ( event.keyCode === _this.keys[ STATE.ZOOM ] && !_this.noZoom ) {\n\n\t\t\t_state = STATE.ZOOM;\n\n\t\t} else if ( event.keyCode === _this.keys[ STATE.PAN ] && !_this.noPan ) {\n\n\t\t\t_state = STATE.PAN;\n\n\t\t}\n\n\t}\n\n\tfunction keyup( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\t_state = _prevState;\n\n\t\twindow.addEventListener( 'keydown', keydown, false );\n\n\t}\n\n\tfunction mousedown( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif ( _state === STATE.NONE ) {\n\n\t\t\t_state = event.button;\n\n\t\t}\n\n\t\tif ( _state === STATE.ROTATE && !_this.noRotate ) {\n\n\t\t\t_this.getMouseProjectionOnBall( event.pageX, event.pageY, _rotateStart );\n\t\t\t_rotateEnd.copy(_rotateStart)\n\n\t\t} else if ( _state === STATE.ZOOM && !_this.noZoom ) {\n\n\t\t\t_this.getMouseOnScreen( event.pageX, event.pageY, _zoomStart );\n\t\t\t_zoomEnd.copy(_zoomStart);\n\n\t\t} else if ( _state === STATE.PAN && !_this.noPan ) {\n\n\t\t\t_this.getMouseOnScreen( event.pageX, event.pageY, _panStart );\n\t\t\t_panEnd.copy(_panStart)\n\n\t\t}\n\n\t\tdocument.addEventListener( 'mousemove', mousemove, false );\n\t\tdocument.addEventListener( 'mouseup', mouseup, false );\n\t\t_this.dispatchEvent( startEvent );\n\n\n\t}\n\n\tfunction mousemove( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif ( _state === STATE.ROTATE && !_this.noRotate ) {\n\n\t\t\t_this.getMouseProjectionOnBall( event.pageX, event.pageY, _rotateEnd );\n\n\t\t} else if ( _state === STATE.ZOOM && !_this.noZoom ) {\n\n\t\t\t_this.getMouseOnScreen( event.pageX, event.pageY, _zoomEnd );\n\n\t\t} else if ( _state === STATE.PAN && !_this.noPan ) {\n\n\t\t\t_this.getMouseOnScreen( event.pageX, event.pageY, _panEnd );\n\n\t\t}\n\n\t}\n\n\tfunction mouseup( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\t_state = STATE.NONE;\n\n\t\tdocument.removeEventListener( 'mousemove', mousemove );\n\t\tdocument.removeEventListener( 'mouseup', mouseup );\n\t\t_this.dispatchEvent( endEvent );\n\n\t}\n\n\tfunction mousewheel( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tvar delta = 0;\n\n\t\tif ( event.wheelDelta ) { // WebKit / Opera / Explorer 9\n\n\t\t\tdelta = event.wheelDelta / 40;\n\n\t\t} else if ( event.detail ) { // Firefox\n\n\t\t\tdelta = - event.detail / 3;\n\n\t\t}\n\n\t\t_zoomStart.y += delta * 0.01;\n\t\t_this.dispatchEvent( startEvent );\n\t\t_this.dispatchEvent( endEvent );\n\n\t}\n\n\tfunction touchstart( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1:\n\t\t\t\t_state = STATE.TOUCH_ROTATE;\n\t\t\t\t_rotateEnd.copy( _this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _rotateStart ));\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t_state = STATE.TOUCH_ZOOM;\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\t_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\t_state = STATE.TOUCH_PAN;\n\t\t\t\t_panEnd.copy( _this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _panStart ));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t_state = STATE.NONE;\n\n\t\t}\n\t\t_this.dispatchEvent( startEvent );\n\n\n\t}\n\n\tfunction touchmove( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1:\n\t\t\t\t_this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _rotateEnd );\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\t_touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy )\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\t_this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _panEnd );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t_state = STATE.NONE;\n\n\t\t}\n\n\t}\n\n\tfunction touchend( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1:\n\t\t\t\t_rotateStart.copy( _this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _rotateEnd ));\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t_touchZoomDistanceStart = _touchZoomDistanceEnd = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\t_panStart.copy( _this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _panEnd ));\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t_state = STATE.NONE;\n\t\t_this.dispatchEvent( endEvent );\n\n\t}\n\n\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\n\n\tthis.domElement.addEventListener( 'mousedown', mousedown, false );\n\n\tthis.domElement.addEventListener( 'mousewheel', mousewheel, false );\n\tthis.domElement.addEventListener( 'DOMMouseScroll', mousewheel, false ); // firefox\n\n\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\n\tthis.domElement.addEventListener( 'touchend', touchend, false );\n\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\n\n\twindow.addEventListener( 'keydown', keydown, false );\n\twindow.addEventListener( 'keyup', keyup, false );\n\n\tthis.handleResize();\n\n};\n\nTHREE.TrackballControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n",
      "content": "                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /**\n * @author Eberhard Graether / http://egraether.com/\n * @author Mark Lundin \t/ http://mark-lundin.com\n */\n\nTHREE.TrackballControls = function ( object, domElement ) {\n\n\tvar _this = this;\n\tvar STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM: 4, TOUCH_PAN: 5 };\n\n\tthis.object = object;\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\t// API\n\n\tthis.enabled = true;\n\n\tthis.screen = { left: 0, top: 0, width: 0, height: 0 };\n\n\tthis.rotateSpeed = 1.0;\n\tthis.zoomSpeed = 1.2;\n\tthis.panSpeed = 0.3;\n\n\tthis.noRotate = false;\n\tthis.noZoom = false;\n\tthis.noPan = false;\n\tthis.noRoll = false;\n\n\tthis.staticMoving = false;\n\tthis.dynamicDampingFactor = 0.2;\n\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\tthis.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];\n\n\t// internals\n\n\tthis.target = new THREE.Vector3();\n\n\tvar lastPosition = new THREE.Vector3();\n\n\tvar _state = STATE.NONE,\n\t_prevState = STATE.NONE,\n\n\t_eye = new THREE.Vector3(),\n\n\t_rotateStart = new THREE.Vector3(),\n\t_rotateEnd = new THREE.Vector3(),\n\n\t_zoomStart = new THREE.Vector2(),\n\t_zoomEnd = new THREE.Vector2(),\n\n\t_touchZoomDistanceStart = 0,\n\t_touchZoomDistanceEnd = 0,\n\n\t_panStart = new THREE.Vector2(),\n\t_panEnd = new THREE.Vector2();\n\n\t// for reset\n\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\tthis.up0 = this.object.up.clone();\n\n\t// events\n\n\tvar changeEvent = { type: 'change' };\n\tvar startEvent = { type: 'start'};\n\tvar endEvent = { type: 'end'};\n\n\n\t// methods\n\n\tthis.handleResize = function () {\n\n\t\tif ( this.domElement === document ) {\n\n\t\t\tthis.screen.left = 0;\n\t\t\tthis.screen.top = 0;\n\t\t\tthis.screen.width = window.innerWidth;\n\t\t\tthis.screen.height = window.innerHeight;\n\n\t\t} else {\n\n\t\t\tthis.screen = this.domElement.getBoundingClientRect();\n\t\t\t// adjustments come from similar code in the jquery offset() function\n\t\t\tvar d = this.domElement.ownerDocument.documentElement\n\t\t\tthis.screen.left += window.pageXOffset - d.clientLeft\n\t\t\tthis.screen.top += window.pageYOffset - d.clientTop\n\n\t\t}\n\n\t};\n\n\tthis.handleEvent = function ( event ) {\n\n\t\tif ( typeof this[ event.type ] == 'function' ) {\n\n\t\t\tthis[ event.type ]( event );\n\n\t\t}\n\n\t};\n\n\tthis.getMouseOnScreen = function ( pageX, pageY, vector ) {\n\n\t\treturn vector.set(\n\t\t\t( pageX - _this.screen.left ) / _this.screen.width,\n\t\t\t( pageY - _this.screen.top ) / _this.screen.height\n\t\t);\n\n\t};\n\n\tthis.getMouseProjectionOnBall = (function(){\n\n\t\tvar objectUp = new THREE.Vector3(),\n\t\t    mouseOnBall = new THREE.Vector3();\n\n\n\t\treturn function ( pageX, pageY, projection ) {\n\n\t\t\tmouseOnBall.set(\n\t\t\t\t( pageX - _this.screen.width * 0.5 - _this.screen.left ) / (_this.screen.width*.5),\n\t\t\t\t( _this.screen.height * 0.5 + _this.screen.top - pageY ) / (_this.screen.height*.5),\n\t\t\t\t0.0\n\t\t\t);\n\n\t\t\tvar length = mouseOnBall.length();\n\n\t\t\tif ( _this.noRoll ) {\n\n\t\t\t\tif ( length < Math.SQRT1_2 ) {\n\n\t\t\t\t\tmouseOnBall.z = Math.sqrt( 1.0 - length*length );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmouseOnBall.z = .5 / length;\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t} else if ( length > 1.0 ) {\n\n\t\t\t\tmouseOnBall.normalize();\n\n\t\t\t} else {\n\n\t\t\t\tmouseOnBall.z = Math.sqrt( 1.0 - length * length );\n\n\t\t\t}\n\n\t\t\t_eye.copy( _this.object.position ).sub( _this.target );\n\n\t\t\tprojection.copy( _this.object.up ).setLength( mouseOnBall.y )\n\t\t\tprojection.add( objectUp.copy( _this.object.up ).cross( _eye ).setLength( mouseOnBall.x ) );\n\t\t\tprojection.add( _eye.setLength( mouseOnBall.z ) );\n\n\t\t\treturn projection;\n\t\t}\n\n\t}());\n\n\tthis.rotateCamera = (function(){\n\n\t\tvar axis = new THREE.Vector3(),\n\t\t\tquaternion = new THREE.Quaternion();\n\n\n\t\treturn function () {\n\n\t\t\tvar angle = Math.acos( _rotateStart.dot( _rotateEnd ) / _rotateStart.length() / _rotateEnd.length() );\n\n\t\t\tif ( angle ) {\n\n\t\t\t\taxis.crossVectors( _rotateStart, _rotateEnd ).normalize();\n\n\t\t\t\tangle *= _this.rotateSpeed;\n\n\t\t\t\tquaternion.setFromAxisAngle( axis, -angle );\n\n\t\t\t\t_eye.applyQuaternion( quaternion );\n\t\t\t\t_this.object.up.applyQuaternion( quaternion );\n\n\t\t\t\t_rotateEnd.applyQuaternion( quaternion );\n\n\t\t\t\tif ( _this.staticMoving ) {\n\n\t\t\t\t\t_rotateStart.copy( _rotateEnd );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tquaternion.setFromAxisAngle( axis, angle * ( _this.dynamicDampingFactor - 1.0 ) );\n\t\t\t\t\t_rotateStart.applyQuaternion( quaternion );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t}());\n\n\tthis.zoomCamera = function () {\n\n\t\tif ( _state === STATE.TOUCH_ZOOM ) {\n\n\t\t\tvar factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;\n\t\t\t_touchZoomDistanceStart = _touchZoomDistanceEnd;\n\t\t\t_eye.multiplyScalar( factor );\n\n\t\t} else {\n\n\t\t\tvar factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;\n\n\t\t\tif ( factor !== 1.0 && factor > 0.0 ) {\n\n\t\t\t\t_eye.multiplyScalar( factor );\n\n\t\t\t\tif ( _this.staticMoving ) {\n\n\t\t\t\t\t_zoomStart.copy( _zoomEnd );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.panCamera = (function(){\n\n\t\tvar mouseChange = new THREE.Vector2(),\n\t\t\tobjectUp = new THREE.Vector3(),\n\t\t\tpan = new THREE.Vector3();\n\n\t\treturn function () {\n\n\t\t\tmouseChange.copy( _panEnd ).sub( _panStart );\n\n\t\t\tif ( mouseChange.lengthSq() ) {\n\n\t\t\t\tmouseChange.multiplyScalar( _eye.length() * _this.panSpeed );\n\n\t\t\t\tpan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );\n\t\t\t\tpan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );\n\n\t\t\t\t_this.object.position.add( pan );\n\t\t\t\t_this.target.add( pan );\n\n\t\t\t\tif ( _this.staticMoving ) {\n\n\t\t\t\t\t_panStart.copy( _panEnd );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t}());\n\n\tthis.checkDistances = function () {\n\n\t\tif ( !_this.noZoom || !_this.noPan ) {\n\n\t\t\tif ( _eye.lengthSq() > _this.maxDistance * _this.maxDistance ) {\n\n\t\t\t\t_this.object.position.addVectors( _this.target, _eye.setLength( _this.maxDistance ) );\n\n\t\t\t}\n\n\t\t\tif ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {\n\n\t\t\t\t_this.object.position.addVectors( _this.target, _eye.setLength( _this.minDistance ) );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.update = function () {\n\n\t\t_eye.subVectors( _this.object.position, _this.target );\n\n\t\tif ( !_this.noRotate ) {\n\n\t\t\t_this.rotateCamera();\n\n\t\t}\n\n\t\tif ( !_this.noZoom ) {\n\n\t\t\t_this.zoomCamera();\n\n\t\t}\n\n\t\tif ( !_this.noPan ) {\n\n\t\t\t_this.panCamera();\n\n\t\t}\n\n\t\t_this.object.position.addVectors( _this.target, _eye );\n\n\t\t_this.checkDistances();\n\n\t\t_this.object.lookAt( _this.target );\n\n\t\tif ( lastPosition.distanceToSquared( _this.object.position ) > 0 ) {\n\n\t\t\t_this.dispatchEvent( changeEvent );\n\n\t\t\tlastPosition.copy( _this.object.position );\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\t_state = STATE.NONE;\n\t\t_prevState = STATE.NONE;\n\n\t\t_this.target.copy( _this.target0 );\n\t\t_this.object.position.copy( _this.position0 );\n\t\t_this.object.up.copy( _this.up0 );\n\n\t\t_eye.subVectors( _this.object.position, _this.target );\n\n\t\t_this.object.lookAt( _this.target );\n\n\t\t_this.dispatchEvent( changeEvent );\n\n\t\tlastPosition.copy( _this.object.position );\n\n\t};\n\n\t// listeners\n\n\tfunction keydown( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\twindow.removeEventListener( 'keydown', keydown );\n\n\t\t_prevState = _state;\n\n\t\tif ( _state !== STATE.NONE ) {\n\n\t\t\treturn;\n\n\t\t} else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && !_this.noRotate ) {\n\n\t\t\t_state = STATE.ROTATE;\n\n\t\t} else if ( event.keyCode === _this.keys[ STATE.ZOOM ] && !_this.noZoom ) {\n\n\t\t\t_state = STATE.ZOOM;\n\n\t\t} else if ( event.keyCode === _this.keys[ STATE.PAN ] && !_this.noPan ) {\n\n\t\t\t_state = STATE.PAN;\n\n\t\t}\n\n\t}\n\n\tfunction keyup( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\t_state = _prevState;\n\n\t\twindow.addEventListener( 'keydown', keydown, false );\n\n\t}\n\n\tfunction mousedown( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif ( _state === STATE.NONE ) {\n\n\t\t\t_state = event.button;\n\n\t\t}\n\n\t\tif ( _state === STATE.ROTATE && !_this.noRotate ) {\n\n\t\t\t_this.getMouseProjectionOnBall( event.pageX, event.pageY, _rotateStart );\n\t\t\t_rotateEnd.copy(_rotateStart)\n\n\t\t} else if ( _state === STATE.ZOOM && !_this.noZoom ) {\n\n\t\t\t_this.getMouseOnScreen( event.pageX, event.pageY, _zoomStart );\n\t\t\t_zoomEnd.copy(_zoomStart);\n\n\t\t} else if ( _state === STATE.PAN && !_this.noPan ) {\n\n\t\t\t_this.getMouseOnScreen( event.pageX, event.pageY, _panStart );\n\t\t\t_panEnd.copy(_panStart)\n\n\t\t}\n\n\t\tdocument.addEventListener( 'mousemove', mousemove, false );\n\t\tdocument.addEventListener( 'mouseup', mouseup, false );\n\t\t_this.dispatchEvent( startEvent );\n\n\n\t}\n\n\tfunction mousemove( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif ( _state === STATE.ROTATE && !_this.noRotate ) {\n\n\t\t\t_this.getMouseProjectionOnBall( event.pageX, event.pageY, _rotateEnd );\n\n\t\t} else if ( _state === STATE.ZOOM && !_this.noZoom ) {\n\n\t\t\t_this.getMouseOnScreen( event.pageX, event.pageY, _zoomEnd );\n\n\t\t} else if ( _state === STATE.PAN && !_this.noPan ) {\n\n\t\t\t_this.getMouseOnScreen( event.pageX, event.pageY, _panEnd );\n\n\t\t}\n\n\t}\n\n\tfunction mouseup( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\t_state = STATE.NONE;\n\n\t\tdocument.removeEventListener( 'mousemove', mousemove );\n\t\tdocument.removeEventListener( 'mouseup', mouseup );\n\t\t_this.dispatchEvent( endEvent );\n\n\t}\n\n\tfunction mousewheel( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tvar delta = 0;\n\n\t\tif ( event.wheelDelta ) { // WebKit / Opera / Explorer 9\n\n\t\t\tdelta = event.wheelDelta / 40;\n\n\t\t} else if ( event.detail ) { // Firefox\n\n\t\t\tdelta = - event.detail / 3;\n\n\t\t}\n\n\t\t_zoomStart.y += delta * 0.01;\n\t\t_this.dispatchEvent( startEvent );\n\t\t_this.dispatchEvent( endEvent );\n\n\t}\n\n\tfunction touchstart( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1:\n\t\t\t\t_state = STATE.TOUCH_ROTATE;\n\t\t\t\t_rotateEnd.copy( _this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _rotateStart ));\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t_state = STATE.TOUCH_ZOOM;\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\t_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\t_state = STATE.TOUCH_PAN;\n\t\t\t\t_panEnd.copy( _this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _panStart ));\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t_state = STATE.NONE;\n\n\t\t}\n\t\t_this.dispatchEvent( startEvent );\n\n\n\t}\n\n\tfunction touchmove( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1:\n\t\t\t\t_this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _rotateEnd );\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\t_touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy )\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\t_this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _panEnd );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t_state = STATE.NONE;\n\n\t\t}\n\n\t}\n\n\tfunction touchend( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1:\n\t\t\t\t_rotateStart.copy( _this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _rotateEnd ));\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\t_touchZoomDistanceStart = _touchZoomDistanceEnd = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase 3:\n\t\t\t\t_panStart.copy( _this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY, _panEnd ));\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t_state = STATE.NONE;\n\t\t_this.dispatchEvent( endEvent );\n\n\t}\n\n\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\n\n\tthis.domElement.addEventListener( 'mousedown', mousedown, false );\n\n\tthis.domElement.addEventListener( 'mousewheel', mousewheel, false );\n\tthis.domElement.addEventListener( 'DOMMouseScroll', mousewheel, false ); // firefox\n\n\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\n\tthis.domElement.addEventListener( 'touchend', touchend, false );\n\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\n\n\twindow.addEventListener( 'keydown', keydown, false );\n\twindow.addEventListener( 'keyup', keyup, false );\n\n\tthis.handleResize();\n\n};\n\nTHREE.TrackballControls.prototype = Object.create( THREE.EventDispatcher.prototype );\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "TrackballControls.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-TrackballControls",
      "url": "/js/TrackballControls.js",
      "urls": [
        "/js/TrackballControls.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/dancer.js",
      "relativePath": "js/dancer.js",
      "basename": "dancer",
      "outBasename": "dancer",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "dancer.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/dancer.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js",
      "outFilename": "dancer.js",
      "relativeOutPath": "js/dancer.js",
      "relativeDirPath": "js",
      "relativeOutDirPath": "js",
      "relativeBase": "js/dancer",
      "relativeOutBase": "js/dancer",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.510Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/* dancer.js - v0.3.2 - 2012-09-29\n* https://github.com/jsantell/dancer.js\n* Copyright (c) 2012 Jordan Santell; Licensed MIT */\n\n(function() {\n\n  var Dancer = function () {\n    this.audioAdapter = Dancer._getAdapter( this );\n    this.events = {};\n    this.sections = [];\n    this.bind( 'update', update );\n  };\n\n  Dancer.version = '0.3.2';\n  Dancer.adapters = {};\n\n  Dancer.prototype = {\n\n    load : function ( source ) {\n      var path;\n\n      // Loading an Audio element\n      if ( source instanceof HTMLElement ) {\n        this.source = source;\n        if ( Dancer.isSupported() === 'flash' ) {\n          this.source = { src: Dancer._getMP3SrcFromAudio( source ) };\n        }\n\n      // Loading an object with src, [codecs]\n      } else {\n        this.source = window.Audio ? new Audio() : {};\n        this.source.src = Dancer._makeSupportedPath( source.src, source.codecs );\n      }\n\n      this.audio = this.audioAdapter.load( this.source );\n      return this;\n    },\n\n    /* Controls */\n\n    play : function () {\n      this.audioAdapter.play();\n      return this;\n    },\n\n    pause : function () {\n      this.audioAdapter.pause();\n      return this;\n    },\n\n    setVolume : function ( volume ) {\n      this.audioAdapter.setVolume( volume );\n      return this;\n    },\n\n\n    /* Actions */\n\n    createKick : function ( options ) {\n      return new Dancer.Kick( this, options );\n    },\n\n    bind : function ( name, callback ) {\n      if ( !this.events[ name ] ) {\n        this.events[ name ] = [];\n      }\n      this.events[ name ].push( callback );\n      return this;\n    },\n\n    unbind : function ( name ) {\n      if ( this.events[ name ] ) {\n        delete this.events[ name ];\n      }\n      return this;\n    },\n\n    trigger : function ( name ) {\n      var _this = this;\n      if ( this.events[ name ] ) {\n        this.events[ name ].forEach(function( callback ) {\n          callback.call( _this );\n        });\n      }\n      return this;\n    },\n\n\n    /* Getters */\n\n    getVolume : function () {\n      return this.audioAdapter.getVolume();\n    },\n\n    getProgress : function () {\n      return this.audioAdapter.getProgress();\n    },\n\n    getTime : function () {\n      return this.audioAdapter.getTime();\n    },\n\n    // Returns the magnitude of a frequency or average over a range of frequencies\n    getFrequency : function ( freq, endFreq ) {\n      var sum = 0;\n      if ( endFreq !== undefined ) {\n        for ( var i = freq; i <= endFreq; i++ ) {\n          sum += this.getSpectrum()[ i ];\n        }\n        return sum / ( endFreq - freq + 1 );\n      } else {\n        return this.getSpectrum()[ freq ];\n      }\n    },\n\n    getWaveform : function () {\n      return this.audioAdapter.getWaveform();\n    },\n\n    getSpectrum : function () {\n      return this.audioAdapter.getSpectrum();\n    },\n\n    isLoaded : function () {\n      return this.audioAdapter.isLoaded;\n    },\n\n    isPlaying : function () {\n      return this.audioAdapter.isPlaying;\n    },\n\n\n    /* Sections */\n\n    after : function ( time, callback ) {\n      var _this = this;\n      this.sections.push({\n        condition : function () {\n          return _this.getTime() > time;\n        },\n        callback : callback\n      });\n      return this;\n    },\n\n    before : function ( time, callback ) {\n      var _this = this;\n      this.sections.push({\n        condition : function () {\n          return _this.getTime() < time;\n        },\n        callback : callback\n      });\n      return this;\n    },\n\n    between : function ( startTime, endTime, callback ) {\n      var _this = this;\n      this.sections.push({\n        condition : function () {\n          return _this.getTime() > startTime && _this.getTime() < endTime;\n        },\n        callback : callback\n      });\n      return this;\n    },\n\n    onceAt : function ( time, callback ) {\n      var\n        _this = this,\n        thisSection = null;\n      this.sections.push({\n        condition : function () {\n          return _this.getTime() > time && !this.called;\n        },\n        callback : function () {\n          callback.call( this );\n          thisSection.called = true;\n        },\n        called : false\n      });\n      // Baking the section in the closure due to callback's this being the dancer instance\n      thisSection = this.sections[ this.sections.length - 1 ];\n      return this;\n    }\n  };\n\n  function update () {\n    for ( var i in this.sections ) {\n      if ( this.sections[ i ].condition() )\n        this.sections[ i ].callback.call( this );\n    }\n  }\n\n  window.Dancer = Dancer;\n})();\n\n(function ( Dancer ) {\n\n  var CODECS = {\n    'mp3' : 'audio/mpeg;',\n    'ogg' : 'audio/ogg; codecs=\"vorbis\"',\n    'wav' : 'audio/wav; codecs=\"1\"',\n    'aac' : 'audio/mp4; codecs=\"mp4a.40.2\"'\n  },\n  audioEl = document.createElement( 'audio' );\n\n  Dancer.options = {};\n\n  Dancer.setOptions = function ( o ) {\n    for ( var option in o ) {\n      if ( o.hasOwnProperty( option ) ) {\n        Dancer.options[ option ] = o[ option ];\n      }\n    }\n  };\n\n  Dancer.isSupported = function () {\n    if ( !window.Float32Array || !window.Uint32Array ) {\n      return null;\n    } else if ( !isUnsupportedSafari() && ( window.AudioContext || window.webkitAudioContext )) {\n      return 'webaudio';\n    } else if ( audioEl && audioEl.mozSetup ) {\n      return 'audiodata';\n    } else if ( FlashDetect.versionAtLeast( 9 ) ) {\n      return 'flash';\n    } else {\n      return '';\n    }\n  };\n\n  Dancer.canPlay = function ( type ) {\n    var canPlay = audioEl.canPlayType;\n    return !!(\n      Dancer.isSupported() === 'flash' ?\n        type.toLowerCase() === 'mp3' :\n        audioEl.canPlayType &&\n        audioEl.canPlayType( CODECS[ type.toLowerCase() ] ).replace( /no/, ''));\n  };\n\n  Dancer.addPlugin = function ( name, fn ) {\n    if ( Dancer.prototype[ name ] === undefined ) {\n      Dancer.prototype[ name ] = fn;\n    }\n  };\n\n  Dancer._makeSupportedPath = function ( source, codecs ) {\n    if ( !codecs ) { return source; }\n\n    for ( var i = 0; i < codecs.length; i++ ) {\n      if ( Dancer.canPlay( codecs[ i ] ) ) {\n        return source + '.' + codecs[ i ];\n      }\n    }\n    return source;\n  };\n\n  Dancer._getAdapter = function ( instance ) {\n    switch ( Dancer.isSupported() ) {\n      case 'webaudio':\n        return new Dancer.adapters.webkit( instance );\n      case 'audiodata':\n        return new Dancer.adapters.moz( instance );\n      case 'flash':\n        return new Dancer.adapters.flash( instance );\n      default:\n        return null;\n    }\n  };\n\n  Dancer._getMP3SrcFromAudio = function ( audioEl ) {\n    var sources = audioEl.children;\n    if ( audioEl.src ) { return audioEl.src; }\n    for ( var i = sources.length; i--; ) {\n      if (( sources[ i ].type || '' ).match( /audio\\/mpeg/ )) return sources[ i ].src;\n    }\n    return null;\n  };\n\n  // Browser detection is lame, but Safari 6 has Web Audio API,\n  // but does not support processing audio from a Media Element Source\n  // https://gist.github.com/3265344\n  function isUnsupportedSafari () {\n    var\n      isApple = !!( navigator.vendor || '' ).match( /Apple/ ),\n      version = navigator.userAgent.match( /Version\\/([^ ]*)/ );\n    version = version ? parseFloat( version[ 1 ] ) : 0;\n    return isApple && version <= 6;\n  }\n\n})( window.Dancer );\n\n(function ( undefined ) {\n  var Kick = function ( dancer, o ) {\n    o = o || {};\n    this.dancer    = dancer;\n    this.frequency = o.frequency !== undefined ? o.frequency : [ 0, 10 ];\n    this.threshold = o.threshold !== undefined ? o.threshold :  0.3;\n    this.decay     = o.decay     !== undefined ? o.decay     :  0.02;\n    this.onKick    = o.onKick;\n    this.offKick   = o.offKick;\n    this.isOn      = false;\n    this.currentThreshold = this.threshold;\n\n    var _this = this;\n    this.dancer.bind( 'update', function () {\n      _this.onUpdate();\n    });\n  };\n\n  Kick.prototype = {\n    on  : function () { \n      this.isOn = true;\n      return this;\n    },\n    off : function () {\n      this.isOn = false;\n      return this;\n    },\n\n    set : function ( o ) {\n      o = o || {};\n      this.frequency = o.frequency !== undefined ? o.frequency : this.frequency;\n      this.threshold = o.threshold !== undefined ? o.threshold : this.threshold;\n      this.decay     = o.decay     !== undefined ? o.decay : this.decay;\n      this.onKick    = o.onKick    || this.onKick;\n      this.offKick   = o.offKick   || this.offKick;\n    },\n\n    onUpdate : function () {\n      if ( !this.isOn ) { return; }\n      var magnitude = this.maxAmplitude( this.frequency );\n      if ( magnitude >= this.currentThreshold &&\n          magnitude >= this.threshold ) {\n        this.currentThreshold = magnitude;\n        this.onKick && this.onKick.call( this.dancer, magnitude );\n      } else {\n        this.offKick && this.offKick.call( this.dancer, magnitude );\n        this.currentThreshold -= this.decay;\n      }\n    },\n    maxAmplitude : function ( frequency ) {\n      var\n        max = 0,\n        fft = this.dancer.getSpectrum();\n\n      // Sloppy array check\n      if ( !frequency.length ) {\n        return frequency < fft.length ?\n          fft[ ~~frequency ] :\n          null;\n      }\n\n      for ( var i = frequency[ 0 ], l = frequency[ 1 ]; i <= l; i++ ) {\n        if ( fft[ i ] > max ) { max = fft[ i ]; }\n      }\n      return max;\n    }\n  };\n\n  window.Dancer.Kick = Kick;\n})();\n\n(function() {\n  var\n    SAMPLE_SIZE = 2048,\n    SAMPLE_RATE = 44100;\n\n  var adapter = function ( dancer ) {\n    this.dancer = dancer;\n    this.audio = new Audio();\n    this.context = window.AudioContext ?\n      new window.AudioContext() :\n      new window.webkitAudioContext();\n  };\n\n  adapter.prototype = {\n\n    load : function ( _source ) {\n      var _this = this;\n      this.audio = _source;\n\n      this.isLoaded = false;\n      this.progress = 0;\n\n      this.proc = this.context.createJavaScriptNode( SAMPLE_SIZE / 2, 1, 1 );\n      this.proc.onaudioprocess = function ( e ) {\n        _this.update.call( _this, e );\n      };\n      this.gain = this.context.createGainNode();\n\n      this.fft = new FFT( SAMPLE_SIZE / 2, SAMPLE_RATE );\n      this.signal = new Float32Array( SAMPLE_SIZE / 2 );\n\n      if ( this.audio.readyState < 3 ) {\n        this.audio.addEventListener( 'canplay', function () {\n          connectContext.call( _this );\n        });\n      } else {\n        connectContext.call( _this );\n      }\n\n      this.audio.addEventListener( 'progress', function ( e ) {\n        if ( e.currentTarget.duration ) {\n          //_this.progress = e.currentTarget.seekable.end( 0 ) / e.currentTarget.duration;\n        }\n      });\n\n      return this.audio;\n    },\n\n    play : function () {\n      this.audio.play();\n      this.isPlaying = true;\n    },\n\n    pause : function () {\n      this.audio.pause();\n      this.isPlaying = false;\n    },\n\n    setVolume : function ( volume ) {\n      this.gain.gain.value = volume;\n    },\n\n    getVolume : function () {\n      return this.gain.gain.value;\n    },\n\n    getProgress : function() {\n      return this.progress;\n    },\n\n    getWaveform : function () {\n      return this.signal;\n    },\n\n    getSpectrum : function () {\n      return this.fft.spectrum;\n    },\n\n    getTime : function () {\n      return this.audio.currentTime;\n    },\n\n    update : function ( e ) {\n      if ( !this.isPlaying || !this.isLoaded ) return;\n\n      var\n        buffers = [],\n        channels = e.inputBuffer.numberOfChannels,\n        resolution = SAMPLE_SIZE / channels,\n        sum = function ( prev, curr ) {\n          return prev[ i ] + curr[ i ];\n        }, i;\n\n      for ( i = channels; i--; ) {\n        buffers.push( e.inputBuffer.getChannelData( i ) );\n      }\n\n      for ( i = 0; i < resolution; i++ ) {\n        this.signal[ i ] = channels > 1 ?\n          buffers.reduce( sum ) / channels :\n          buffers[ 0 ][ i ];\n      }\n\n      this.fft.forward( this.signal );\n      this.dancer.trigger( 'update' );\n    }\n  };\n\n  function connectContext () {\n    this.source = this.context.createMediaElementSource( this.audio );\n    this.source.connect( this.proc );\n    this.source.connect( this.gain );\n    this.gain.connect( this.context.destination );\n    this.proc.connect( this.context.destination );\n\n    this.isLoaded = true;\n    this.progress = 1;\n    this.dancer.trigger( 'loaded' );\n  }\n\n  Dancer.adapters.webkit = adapter;\n\n})();\n\n(function() {\n\n  var adapter = function ( dancer ) {\n    this.dancer = dancer;\n    this.audio = new Audio();\n  };\n\n  adapter.prototype = {\n\n    load : function ( _source ) {\n      var _this = this;\n      this.audio = _source;\n\n      this.isLoaded = false;\n      this.progress = 0;\n\n      if ( this.audio.readyState < 3 ) {\n        this.audio.addEventListener( 'loadedmetadata', function () {\n          getMetadata.call( _this );\n        }, false);\n      } else {\n        getMetadata.call( _this );\n      }\n\n      this.audio.addEventListener( 'MozAudioAvailable', function ( e ) {\n        _this.update( e );\n      }, false);\n\n      this.audio.addEventListener( 'progress', function ( e ) {\n        if ( e.currentTarget.duration ) {\n          _this.progress = e.currentTarget.seekable.end( 0 ) / e.currentTarget.duration;\n        }\n      }, false);\n\n      return this.audio;\n    },\n\n    play : function () {\n      this.audio.play();\n      this.isPlaying = true;\n    },\n\n    pause : function () {\n      this.audio.pause();\n      this.isPlaying = false;\n    },\n\n    setVolume : function ( volume ) {\n      this.audio.volume = volume;\n    },\n\n    getVolume : function () {\n      return this.audio.volume;\n    },\n\n    getProgress : function () {\n      return this.progress;\n    },\n\n    getWaveform : function () {\n      return this.signal;\n    },\n\n    getSpectrum : function () {\n      return this.fft.spectrum;\n    },\n\n    getTime : function () {\n      return this.audio.currentTime;\n    },\n\n    update : function ( e ) {\n      if ( !this.isPlaying || !this.isLoaded ) return;\n\n      for ( var i = 0, j = this.fbLength / 2; i < j; i++ ) {\n        this.signal[ i ] = ( e.frameBuffer[ 2 * i ] + e.frameBuffer[ 2 * i + 1 ] ) / 2;\n      }\n\n      this.fft.forward( this.signal );\n      this.dancer.trigger( 'update' );\n    }\n  };\n\n  function getMetadata () {\n    this.fbLength = this.audio.mozFrameBufferLength;\n    this.channels = this.audio.mozChannels;\n    this.rate     = this.audio.mozSampleRate;\n    this.fft      = new FFT( this.fbLength / this.channels, this.rate );\n    this.signal   = new Float32Array( this.fbLength / this.channels );\n    this.isLoaded = true;\n    this.progress = 1;\n    this.dancer.trigger( 'loaded' );\n  }\n\n  Dancer.adapters.moz = adapter;\n\n})();\n\n(function() {\n  var\n    SAMPLE_SIZE  = 1024,\n    SAMPLE_RATE  = 44100,\n    smLoaded     = false,\n    smLoading    = false,\n    CONVERSION_COEFFICIENT = 0.93;\n\n  var adapter = function ( dancer ) {\n    this.dancer = dancer;\n    this.wave_L = [];\n    this.wave_R = [];\n    this.spectrum = [];\n    window.SM2_DEFER = true;\n  };\n\n  adapter.prototype = {\n    // `source` can be either an Audio element, if supported, or an object\n    // either way, the path is stored in the `src` property\n    load : function ( source ) {\n      var _this = this;\n      this.path = source ? source.src : this.path;\n\n      this.isLoaded = false;\n      this.progress = 0;\n\n      !window.soundManager && !smLoading && loadSM.call( this );\n\n      if ( window.soundManager ) {\n        this.audio = soundManager.createSound({\n          id       : 'dancer' + Math.random() + '',\n          url      : this.path,\n          stream   : true,\n          autoPlay : false,\n          autoLoad : true,\n          whileplaying : function () {\n            _this.update();\n          },\n          whileloading : function () {\n            _this.progress = this.bytesLoaded / this.bytesTotal;\n          },\n          onload   : function () {\n            _this.fft = new FFT( SAMPLE_SIZE, SAMPLE_RATE );\n            _this.signal = new Float32Array( SAMPLE_SIZE );\n            _this.waveform = new Float32Array( SAMPLE_SIZE );\n            _this.isLoaded = true;\n            _this.progress = 1;\n            _this.dancer.trigger( 'loaded' );\n          }\n        });\n        this.dancer.audio = this.audio;\n      }\n\n      // Returns audio if SM already loaded -- otherwise,\n      // sets dancer instance's audio property after load\n      return this.audio;\n    },\n\n    play : function () {\n      this.audio.play();\n      this.isPlaying = true;\n    },\n\n    pause : function () {\n      this.audio.pause();\n      this.isPlaying = false;\n    },\n\n    setVolume : function ( volume ) {\n      this.audio.setVolume( volume * 100 );\n    },\n\n    getVolume : function () {\n      return this.audio.volume / 100;\n    },\n\n    getProgress : function () {\n      return this.progress;\n    },\n\n    getWaveform : function () {\n      return this.waveform;\n    },\n\n    getSpectrum : function () {\n      return this.fft.spectrum;\n    },\n\n    getTime : function () {\n      return this.audio.position / 1000;\n    },\n\n    update : function () {\n      if ( !this.isPlaying && !this.isLoaded ) return;\n      this.wave_L = this.audio.waveformData.left;\n      this.wave_R = this.audio.waveformData.right;\n      var avg;\n      for ( var i = 0, j = this.wave_L.length; i < j; i++ ) {\n        avg = parseFloat(this.wave_L[ i ]) + parseFloat(this.wave_R[ i ]);\n        this.waveform[ 2 * i ]     = avg / 2;\n        this.waveform[ i * 2 + 1 ] = avg / 2;\n        this.signal[ 2 * i ]       = avg * CONVERSION_COEFFICIENT;\n        this.signal[ i * 2 + 1 ]   = avg * CONVERSION_COEFFICIENT;\n      }\n\n      this.fft.forward( this.signal );\n      this.dancer.trigger( 'update' );\n    }\n  };\n\n  function loadSM () {\n    var adapter = this;\n    smLoading = true;\n    loadScript( Dancer.options.flashJS, function () {\n      soundManager = new SoundManager();\n      soundManager.flashVersion = 9;\n      soundManager.flash9Options.useWaveformData = true;\n      soundManager.useWaveformData = true;\n      soundManager.useHighPerformance = true;\n      soundManager.useFastPolling = true;\n      soundManager.multiShot = false;\n      soundManager.debugMode = false;\n      soundManager.debugFlash = false;\n      soundManager.url = Dancer.options.flashSWF;\n      soundManager.onready(function () {\n        smLoaded = true;\n        adapter.load();\n      });\n      soundManager.ontimeout(function(){\n        console.error( 'Error loading SoundManager2.swf' );\n      });\n      soundManager.beginDelayedInit();\n    });\n  }\n\n  function loadScript ( url, callback ) {\n    var\n      script   = document.createElement( 'script' ),\n      appender = document.getElementsByTagName( 'script' )[0];\n    script.type = 'text/javascript';\n    script.src = url;\n    script.onload = callback;\n    appender.parentNode.insertBefore( script, appender );\n  }\n\n  Dancer.adapters.flash = adapter;\n\n})();\n\n/* \n *  DSP.js - a comprehensive digital signal processing  library for javascript\n * \n *  Created by Corban Brook <corbanbrook@gmail.com> on 2010-01-01.\n *  Copyright 2010 Corban Brook. All rights reserved.\n *\n */\n\n// Fourier Transform Module used by DFT, FFT, RFFT\nfunction FourierTransform(bufferSize, sampleRate) {\n  this.bufferSize = bufferSize;\n  this.sampleRate = sampleRate;\n  this.bandwidth  = 2 / bufferSize * sampleRate / 2;\n\n  this.spectrum   = new Float32Array(bufferSize/2);\n  this.real       = new Float32Array(bufferSize);\n  this.imag       = new Float32Array(bufferSize);\n\n  this.peakBand   = 0;\n  this.peak       = 0;\n\n  /**\n   * Calculates the *middle* frequency of an FFT band.\n   *\n   * @param {Number} index The index of the FFT band.\n   *\n   * @returns The middle frequency in Hz.\n   */\n  this.getBandFrequency = function(index) {\n    return this.bandwidth * index + this.bandwidth / 2;\n  };\n\n  this.calculateSpectrum = function() {\n    var spectrum  = this.spectrum,\n        real      = this.real,\n        imag      = this.imag,\n        bSi       = 2 / this.bufferSize,\n        sqrt      = Math.sqrt,\n        rval, \n        ival,\n        mag;\n\n    for (var i = 0, N = bufferSize/2; i < N; i++) {\n      rval = real[i];\n      ival = imag[i];\n      mag = bSi * sqrt(rval * rval + ival * ival);\n\n      if (mag > this.peak) {\n        this.peakBand = i;\n        this.peak = mag;\n      }\n\n      spectrum[i] = mag;\n    }\n  };\n}\n\n/**\n * FFT is a class for calculating the Discrete Fourier Transform of a signal\n * with the Fast Fourier Transform algorithm.\n *\n * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2\n * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)\n *\n * @constructor\n */\nfunction FFT(bufferSize, sampleRate) {\n  FourierTransform.call(this, bufferSize, sampleRate);\n   \n  this.reverseTable = new Uint32Array(bufferSize);\n\n  var limit = 1;\n  var bit = bufferSize >> 1;\n\n  var i;\n\n  while (limit < bufferSize) {\n    for (i = 0; i < limit; i++) {\n      this.reverseTable[i + limit] = this.reverseTable[i] + bit;\n    }\n\n    limit = limit << 1;\n    bit = bit >> 1;\n  }\n\n  this.sinTable = new Float32Array(bufferSize);\n  this.cosTable = new Float32Array(bufferSize);\n\n  for (i = 0; i < bufferSize; i++) {\n    this.sinTable[i] = Math.sin(-Math.PI/i);\n    this.cosTable[i] = Math.cos(-Math.PI/i);\n  }\n}\n\n/**\n * Performs a forward transform on the sample buffer.\n * Converts a time domain signal to frequency domain spectra.\n *\n * @param {Array} buffer The sample buffer. Buffer Length must be power of 2\n *\n * @returns The frequency spectrum array\n */\nFFT.prototype.forward = function(buffer) {\n  // Locally scope variables for speed up\n  var bufferSize      = this.bufferSize,\n      cosTable        = this.cosTable,\n      sinTable        = this.sinTable,\n      reverseTable    = this.reverseTable,\n      real            = this.real,\n      imag            = this.imag,\n      spectrum        = this.spectrum;\n\n  var k = Math.floor(Math.log(bufferSize) / Math.LN2);\n\n  if (Math.pow(2, k) !== bufferSize) { throw \"Invalid buffer size, must be a power of 2.\"; }\n  if (bufferSize !== buffer.length)  { throw \"Supplied buffer is not the same size as defined FFT. FFT Size: \" + bufferSize + \" Buffer Size: \" + buffer.length; }\n\n  var halfSize = 1,\n      phaseShiftStepReal,\n      phaseShiftStepImag,\n      currentPhaseShiftReal,\n      currentPhaseShiftImag,\n      off,\n      tr,\n      ti,\n      tmpReal,\n      i;\n\n  for (i = 0; i < bufferSize; i++) {\n    real[i] = buffer[reverseTable[i]];\n    imag[i] = 0;\n  }\n\n  while (halfSize < bufferSize) {\n    //phaseShiftStepReal = Math.cos(-Math.PI/halfSize);\n    //phaseShiftStepImag = Math.sin(-Math.PI/halfSize);\n    phaseShiftStepReal = cosTable[halfSize];\n    phaseShiftStepImag = sinTable[halfSize];\n    \n    currentPhaseShiftReal = 1;\n    currentPhaseShiftImag = 0;\n\n    for (var fftStep = 0; fftStep < halfSize; fftStep++) {\n      i = fftStep;\n\n      while (i < bufferSize) {\n        off = i + halfSize;\n        tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);\n        ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);\n\n        real[off] = real[i] - tr;\n        imag[off] = imag[i] - ti;\n        real[i] += tr;\n        imag[i] += ti;\n\n        i += halfSize << 1;\n      }\n\n      tmpReal = currentPhaseShiftReal;\n      currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);\n      currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);\n    }\n\n    halfSize = halfSize << 1;\n  }\n\n  return this.calculateSpectrum();\n};\n\n/*\nCopyright (c) Copyright (c) 2007, Carl S. Yestrau All rights reserved.\nCode licensed under the BSD License: http://www.featureblend.com/license.txt\nVersion: 1.0.4\n*/\nvar FlashDetect = new function(){\n    var self = this;\n    self.installed = false;\n    self.raw = \"\";\n    self.major = -1;\n    self.minor = -1;\n    self.revision = -1;\n    self.revisionStr = \"\";\n    var activeXDetectRules = [\n        {\n            \"name\":\"ShockwaveFlash.ShockwaveFlash.7\",\n            \"version\":function(obj){\n                return getActiveXVersion(obj);\n            }\n        },\n        {\n            \"name\":\"ShockwaveFlash.ShockwaveFlash.6\",\n            \"version\":function(obj){\n                var version = \"6,0,21\";\n                try{\n                    obj.AllowScriptAccess = \"always\";\n                    version = getActiveXVersion(obj);\n                }catch(err){}\n                return version;\n            }\n        },\n        {\n            \"name\":\"ShockwaveFlash.ShockwaveFlash\",\n            \"version\":function(obj){\n                return getActiveXVersion(obj);\n            }\n        }\n    ];\n    /**\n     * Extract the ActiveX version of the plugin.\n     * \n     * @param {Object} The flash ActiveX object.\n     * @type String\n     */\n    var getActiveXVersion = function(activeXObj){\n        var version = -1;\n        try{\n            version = activeXObj.GetVariable(\"$version\");\n        }catch(err){}\n        return version;\n    };\n    /**\n     * Try and retrieve an ActiveX object having a specified name.\n     * \n     * @param {String} name The ActiveX object name lookup.\n     * @return One of ActiveX object or a simple object having an attribute of activeXError with a value of true.\n     * @type Object\n     */\n    var getActiveXObject = function(name){\n        var obj = -1;\n        try{\n            obj = new ActiveXObject(name);\n        }catch(err){\n            obj = {activeXError:true};\n        }\n        return obj;\n    };\n    /**\n     * Parse an ActiveX $version string into an object.\n     * \n     * @param {String} str The ActiveX Object GetVariable($version) return value. \n     * @return An object having raw, major, minor, revision and revisionStr attributes.\n     * @type Object\n     */\n    var parseActiveXVersion = function(str){\n        var versionArray = str.split(\",\");//replace with regex\n        return {\n            \"raw\":str,\n            \"major\":parseInt(versionArray[0].split(\" \")[1], 10),\n            \"minor\":parseInt(versionArray[1], 10),\n            \"revision\":parseInt(versionArray[2], 10),\n            \"revisionStr\":versionArray[2]\n        };\n    };\n    /**\n     * Parse a standard enabledPlugin.description into an object.\n     * \n     * @param {String} str The enabledPlugin.description value.\n     * @return An object having raw, major, minor, revision and revisionStr attributes.\n     * @type Object\n     */\n    var parseStandardVersion = function(str){\n        var descParts = str.split(/ +/);\n        var majorMinor = descParts[2].split(/\\./);\n        var revisionStr = descParts[3];\n        return {\n            \"raw\":str,\n            \"major\":parseInt(majorMinor[0], 10),\n            \"minor\":parseInt(majorMinor[1], 10), \n            \"revisionStr\":revisionStr,\n            \"revision\":parseRevisionStrToInt(revisionStr)\n        };\n    };\n    /**\n     * Parse the plugin revision string into an integer.\n     * \n     * @param {String} The revision in string format.\n     * @type Number\n     */\n    var parseRevisionStrToInt = function(str){\n        return parseInt(str.replace(/[a-zA-Z]/g, \"\"), 10) || self.revision;\n    };\n    /**\n     * Is the major version greater than or equal to a specified version.\n     * \n     * @param {Number} version The minimum required major version.\n     * @type Boolean\n     */\n    self.majorAtLeast = function(version){\n        return self.major >= version;\n    };\n    /**\n     * Is the minor version greater than or equal to a specified version.\n     * \n     * @param {Number} version The minimum required minor version.\n     * @type Boolean\n     */\n    self.minorAtLeast = function(version){\n        return self.minor >= version;\n    };\n    /**\n     * Is the revision version greater than or equal to a specified version.\n     * \n     * @param {Number} version The minimum required revision version.\n     * @type Boolean\n     */\n    self.revisionAtLeast = function(version){\n        return self.revision >= version;\n    };\n    /**\n     * Is the version greater than or equal to a specified major, minor and revision.\n     * \n     * @param {Number} major The minimum required major version.\n     * @param {Number} (Optional) minor The minimum required minor version.\n     * @param {Number} (Optional) revision The minimum required revision version.\n     * @type Boolean\n     */\n    self.versionAtLeast = function(major){\n        var properties = [self.major, self.minor, self.revision];\n        var len = Math.min(properties.length, arguments.length);\n        for(i=0; i<len; i++){\n            if(properties[i]>=arguments[i]){\n                if(i+1<len && properties[i]==arguments[i]){\n                    continue;\n                }else{\n                    return true;\n                }\n            }else{\n                return false;\n            }\n        }\n    };\n    /**\n     * Constructor, sets raw, major, minor, revisionStr, revision and installed public properties.\n     */\n    self.FlashDetect = function(){\n        if(navigator.plugins && navigator.plugins.length>0){\n            var type = 'application/x-shockwave-flash';\n            var mimeTypes = navigator.mimeTypes;\n            if(mimeTypes && mimeTypes[type] && mimeTypes[type].enabledPlugin && mimeTypes[type].enabledPlugin.description){\n                var version = mimeTypes[type].enabledPlugin.description;\n                var versionObj = parseStandardVersion(version);\n                self.raw = versionObj.raw;\n                self.major = versionObj.major;\n                self.minor = versionObj.minor; \n                self.revisionStr = versionObj.revisionStr;\n                self.revision = versionObj.revision;\n                self.installed = true;\n            }\n        }else if(navigator.appVersion.indexOf(\"Mac\")==-1 && window.execScript){\n            var version = -1;\n            for(var i=0; i<activeXDetectRules.length && version==-1; i++){\n                var obj = getActiveXObject(activeXDetectRules[i].name);\n                if(!obj.activeXError){\n                    self.installed = true;\n                    version = activeXDetectRules[i].version(obj);\n                    if(version!=-1){\n                        var versionObj = parseActiveXVersion(version);\n                        self.raw = versionObj.raw;\n                        self.major = versionObj.major;\n                        self.minor = versionObj.minor; \n                        self.revision = versionObj.revision;\n                        self.revisionStr = versionObj.revisionStr;\n                    }\n                }\n            }\n        }\n    }();\n};\nFlashDetect.JS_RELEASE = \"1.0.4\";",
      "content": "/* dancer.js - v0.3.2 - 2012-09-29\n* https://github.com/jsantell/dancer.js\n* Copyright (c) 2012 Jordan Santell; Licensed MIT */\n\n(function() {\n\n  var Dancer = function () {\n    this.audioAdapter = Dancer._getAdapter( this );\n    this.events = {};\n    this.sections = [];\n    this.bind( 'update', update );\n  };\n\n  Dancer.version = '0.3.2';\n  Dancer.adapters = {};\n\n  Dancer.prototype = {\n\n    load : function ( source ) {\n      var path;\n\n      // Loading an Audio element\n      if ( source instanceof HTMLElement ) {\n        this.source = source;\n        if ( Dancer.isSupported() === 'flash' ) {\n          this.source = { src: Dancer._getMP3SrcFromAudio( source ) };\n        }\n\n      // Loading an object with src, [codecs]\n      } else {\n        this.source = window.Audio ? new Audio() : {};\n        this.source.src = Dancer._makeSupportedPath( source.src, source.codecs );\n      }\n\n      this.audio = this.audioAdapter.load( this.source );\n      return this;\n    },\n\n    /* Controls */\n\n    play : function () {\n      this.audioAdapter.play();\n      return this;\n    },\n\n    pause : function () {\n      this.audioAdapter.pause();\n      return this;\n    },\n\n    setVolume : function ( volume ) {\n      this.audioAdapter.setVolume( volume );\n      return this;\n    },\n\n\n    /* Actions */\n\n    createKick : function ( options ) {\n      return new Dancer.Kick( this, options );\n    },\n\n    bind : function ( name, callback ) {\n      if ( !this.events[ name ] ) {\n        this.events[ name ] = [];\n      }\n      this.events[ name ].push( callback );\n      return this;\n    },\n\n    unbind : function ( name ) {\n      if ( this.events[ name ] ) {\n        delete this.events[ name ];\n      }\n      return this;\n    },\n\n    trigger : function ( name ) {\n      var _this = this;\n      if ( this.events[ name ] ) {\n        this.events[ name ].forEach(function( callback ) {\n          callback.call( _this );\n        });\n      }\n      return this;\n    },\n\n\n    /* Getters */\n\n    getVolume : function () {\n      return this.audioAdapter.getVolume();\n    },\n\n    getProgress : function () {\n      return this.audioAdapter.getProgress();\n    },\n\n    getTime : function () {\n      return this.audioAdapter.getTime();\n    },\n\n    // Returns the magnitude of a frequency or average over a range of frequencies\n    getFrequency : function ( freq, endFreq ) {\n      var sum = 0;\n      if ( endFreq !== undefined ) {\n        for ( var i = freq; i <= endFreq; i++ ) {\n          sum += this.getSpectrum()[ i ];\n        }\n        return sum / ( endFreq - freq + 1 );\n      } else {\n        return this.getSpectrum()[ freq ];\n      }\n    },\n\n    getWaveform : function () {\n      return this.audioAdapter.getWaveform();\n    },\n\n    getSpectrum : function () {\n      return this.audioAdapter.getSpectrum();\n    },\n\n    isLoaded : function () {\n      return this.audioAdapter.isLoaded;\n    },\n\n    isPlaying : function () {\n      return this.audioAdapter.isPlaying;\n    },\n\n\n    /* Sections */\n\n    after : function ( time, callback ) {\n      var _this = this;\n      this.sections.push({\n        condition : function () {\n          return _this.getTime() > time;\n        },\n        callback : callback\n      });\n      return this;\n    },\n\n    before : function ( time, callback ) {\n      var _this = this;\n      this.sections.push({\n        condition : function () {\n          return _this.getTime() < time;\n        },\n        callback : callback\n      });\n      return this;\n    },\n\n    between : function ( startTime, endTime, callback ) {\n      var _this = this;\n      this.sections.push({\n        condition : function () {\n          return _this.getTime() > startTime && _this.getTime() < endTime;\n        },\n        callback : callback\n      });\n      return this;\n    },\n\n    onceAt : function ( time, callback ) {\n      var\n        _this = this,\n        thisSection = null;\n      this.sections.push({\n        condition : function () {\n          return _this.getTime() > time && !this.called;\n        },\n        callback : function () {\n          callback.call( this );\n          thisSection.called = true;\n        },\n        called : false\n      });\n      // Baking the section in the closure due to callback's this being the dancer instance\n      thisSection = this.sections[ this.sections.length - 1 ];\n      return this;\n    }\n  };\n\n  function update () {\n    for ( var i in this.sections ) {\n      if ( this.sections[ i ].condition() )\n        this.sections[ i ].callback.call( this );\n    }\n  }\n\n  window.Dancer = Dancer;\n})();\n\n(function ( Dancer ) {\n\n  var CODECS = {\n    'mp3' : 'audio/mpeg;',\n    'ogg' : 'audio/ogg; codecs=\"vorbis\"',\n    'wav' : 'audio/wav; codecs=\"1\"',\n    'aac' : 'audio/mp4; codecs=\"mp4a.40.2\"'\n  },\n  audioEl = document.createElement( 'audio' );\n\n  Dancer.options = {};\n\n  Dancer.setOptions = function ( o ) {\n    for ( var option in o ) {\n      if ( o.hasOwnProperty( option ) ) {\n        Dancer.options[ option ] = o[ option ];\n      }\n    }\n  };\n\n  Dancer.isSupported = function () {\n    if ( !window.Float32Array || !window.Uint32Array ) {\n      return null;\n    } else if ( !isUnsupportedSafari() && ( window.AudioContext || window.webkitAudioContext )) {\n      return 'webaudio';\n    } else if ( audioEl && audioEl.mozSetup ) {\n      return 'audiodata';\n    } else if ( FlashDetect.versionAtLeast( 9 ) ) {\n      return 'flash';\n    } else {\n      return '';\n    }\n  };\n\n  Dancer.canPlay = function ( type ) {\n    var canPlay = audioEl.canPlayType;\n    return !!(\n      Dancer.isSupported() === 'flash' ?\n        type.toLowerCase() === 'mp3' :\n        audioEl.canPlayType &&\n        audioEl.canPlayType( CODECS[ type.toLowerCase() ] ).replace( /no/, ''));\n  };\n\n  Dancer.addPlugin = function ( name, fn ) {\n    if ( Dancer.prototype[ name ] === undefined ) {\n      Dancer.prototype[ name ] = fn;\n    }\n  };\n\n  Dancer._makeSupportedPath = function ( source, codecs ) {\n    if ( !codecs ) { return source; }\n\n    for ( var i = 0; i < codecs.length; i++ ) {\n      if ( Dancer.canPlay( codecs[ i ] ) ) {\n        return source + '.' + codecs[ i ];\n      }\n    }\n    return source;\n  };\n\n  Dancer._getAdapter = function ( instance ) {\n    switch ( Dancer.isSupported() ) {\n      case 'webaudio':\n        return new Dancer.adapters.webkit( instance );\n      case 'audiodata':\n        return new Dancer.adapters.moz( instance );\n      case 'flash':\n        return new Dancer.adapters.flash( instance );\n      default:\n        return null;\n    }\n  };\n\n  Dancer._getMP3SrcFromAudio = function ( audioEl ) {\n    var sources = audioEl.children;\n    if ( audioEl.src ) { return audioEl.src; }\n    for ( var i = sources.length; i--; ) {\n      if (( sources[ i ].type || '' ).match( /audio\\/mpeg/ )) return sources[ i ].src;\n    }\n    return null;\n  };\n\n  // Browser detection is lame, but Safari 6 has Web Audio API,\n  // but does not support processing audio from a Media Element Source\n  // https://gist.github.com/3265344\n  function isUnsupportedSafari () {\n    var\n      isApple = !!( navigator.vendor || '' ).match( /Apple/ ),\n      version = navigator.userAgent.match( /Version\\/([^ ]*)/ );\n    version = version ? parseFloat( version[ 1 ] ) : 0;\n    return isApple && version <= 6;\n  }\n\n})( window.Dancer );\n\n(function ( undefined ) {\n  var Kick = function ( dancer, o ) {\n    o = o || {};\n    this.dancer    = dancer;\n    this.frequency = o.frequency !== undefined ? o.frequency : [ 0, 10 ];\n    this.threshold = o.threshold !== undefined ? o.threshold :  0.3;\n    this.decay     = o.decay     !== undefined ? o.decay     :  0.02;\n    this.onKick    = o.onKick;\n    this.offKick   = o.offKick;\n    this.isOn      = false;\n    this.currentThreshold = this.threshold;\n\n    var _this = this;\n    this.dancer.bind( 'update', function () {\n      _this.onUpdate();\n    });\n  };\n\n  Kick.prototype = {\n    on  : function () { \n      this.isOn = true;\n      return this;\n    },\n    off : function () {\n      this.isOn = false;\n      return this;\n    },\n\n    set : function ( o ) {\n      o = o || {};\n      this.frequency = o.frequency !== undefined ? o.frequency : this.frequency;\n      this.threshold = o.threshold !== undefined ? o.threshold : this.threshold;\n      this.decay     = o.decay     !== undefined ? o.decay : this.decay;\n      this.onKick    = o.onKick    || this.onKick;\n      this.offKick   = o.offKick   || this.offKick;\n    },\n\n    onUpdate : function () {\n      if ( !this.isOn ) { return; }\n      var magnitude = this.maxAmplitude( this.frequency );\n      if ( magnitude >= this.currentThreshold &&\n          magnitude >= this.threshold ) {\n        this.currentThreshold = magnitude;\n        this.onKick && this.onKick.call( this.dancer, magnitude );\n      } else {\n        this.offKick && this.offKick.call( this.dancer, magnitude );\n        this.currentThreshold -= this.decay;\n      }\n    },\n    maxAmplitude : function ( frequency ) {\n      var\n        max = 0,\n        fft = this.dancer.getSpectrum();\n\n      // Sloppy array check\n      if ( !frequency.length ) {\n        return frequency < fft.length ?\n          fft[ ~~frequency ] :\n          null;\n      }\n\n      for ( var i = frequency[ 0 ], l = frequency[ 1 ]; i <= l; i++ ) {\n        if ( fft[ i ] > max ) { max = fft[ i ]; }\n      }\n      return max;\n    }\n  };\n\n  window.Dancer.Kick = Kick;\n})();\n\n(function() {\n  var\n    SAMPLE_SIZE = 2048,\n    SAMPLE_RATE = 44100;\n\n  var adapter = function ( dancer ) {\n    this.dancer = dancer;\n    this.audio = new Audio();\n    this.context = window.AudioContext ?\n      new window.AudioContext() :\n      new window.webkitAudioContext();\n  };\n\n  adapter.prototype = {\n\n    load : function ( _source ) {\n      var _this = this;\n      this.audio = _source;\n\n      this.isLoaded = false;\n      this.progress = 0;\n\n      this.proc = this.context.createJavaScriptNode( SAMPLE_SIZE / 2, 1, 1 );\n      this.proc.onaudioprocess = function ( e ) {\n        _this.update.call( _this, e );\n      };\n      this.gain = this.context.createGainNode();\n\n      this.fft = new FFT( SAMPLE_SIZE / 2, SAMPLE_RATE );\n      this.signal = new Float32Array( SAMPLE_SIZE / 2 );\n\n      if ( this.audio.readyState < 3 ) {\n        this.audio.addEventListener( 'canplay', function () {\n          connectContext.call( _this );\n        });\n      } else {\n        connectContext.call( _this );\n      }\n\n      this.audio.addEventListener( 'progress', function ( e ) {\n        if ( e.currentTarget.duration ) {\n          //_this.progress = e.currentTarget.seekable.end( 0 ) / e.currentTarget.duration;\n        }\n      });\n\n      return this.audio;\n    },\n\n    play : function () {\n      this.audio.play();\n      this.isPlaying = true;\n    },\n\n    pause : function () {\n      this.audio.pause();\n      this.isPlaying = false;\n    },\n\n    setVolume : function ( volume ) {\n      this.gain.gain.value = volume;\n    },\n\n    getVolume : function () {\n      return this.gain.gain.value;\n    },\n\n    getProgress : function() {\n      return this.progress;\n    },\n\n    getWaveform : function () {\n      return this.signal;\n    },\n\n    getSpectrum : function () {\n      return this.fft.spectrum;\n    },\n\n    getTime : function () {\n      return this.audio.currentTime;\n    },\n\n    update : function ( e ) {\n      if ( !this.isPlaying || !this.isLoaded ) return;\n\n      var\n        buffers = [],\n        channels = e.inputBuffer.numberOfChannels,\n        resolution = SAMPLE_SIZE / channels,\n        sum = function ( prev, curr ) {\n          return prev[ i ] + curr[ i ];\n        }, i;\n\n      for ( i = channels; i--; ) {\n        buffers.push( e.inputBuffer.getChannelData( i ) );\n      }\n\n      for ( i = 0; i < resolution; i++ ) {\n        this.signal[ i ] = channels > 1 ?\n          buffers.reduce( sum ) / channels :\n          buffers[ 0 ][ i ];\n      }\n\n      this.fft.forward( this.signal );\n      this.dancer.trigger( 'update' );\n    }\n  };\n\n  function connectContext () {\n    this.source = this.context.createMediaElementSource( this.audio );\n    this.source.connect( this.proc );\n    this.source.connect( this.gain );\n    this.gain.connect( this.context.destination );\n    this.proc.connect( this.context.destination );\n\n    this.isLoaded = true;\n    this.progress = 1;\n    this.dancer.trigger( 'loaded' );\n  }\n\n  Dancer.adapters.webkit = adapter;\n\n})();\n\n(function() {\n\n  var adapter = function ( dancer ) {\n    this.dancer = dancer;\n    this.audio = new Audio();\n  };\n\n  adapter.prototype = {\n\n    load : function ( _source ) {\n      var _this = this;\n      this.audio = _source;\n\n      this.isLoaded = false;\n      this.progress = 0;\n\n      if ( this.audio.readyState < 3 ) {\n        this.audio.addEventListener( 'loadedmetadata', function () {\n          getMetadata.call( _this );\n        }, false);\n      } else {\n        getMetadata.call( _this );\n      }\n\n      this.audio.addEventListener( 'MozAudioAvailable', function ( e ) {\n        _this.update( e );\n      }, false);\n\n      this.audio.addEventListener( 'progress', function ( e ) {\n        if ( e.currentTarget.duration ) {\n          _this.progress = e.currentTarget.seekable.end( 0 ) / e.currentTarget.duration;\n        }\n      }, false);\n\n      return this.audio;\n    },\n\n    play : function () {\n      this.audio.play();\n      this.isPlaying = true;\n    },\n\n    pause : function () {\n      this.audio.pause();\n      this.isPlaying = false;\n    },\n\n    setVolume : function ( volume ) {\n      this.audio.volume = volume;\n    },\n\n    getVolume : function () {\n      return this.audio.volume;\n    },\n\n    getProgress : function () {\n      return this.progress;\n    },\n\n    getWaveform : function () {\n      return this.signal;\n    },\n\n    getSpectrum : function () {\n      return this.fft.spectrum;\n    },\n\n    getTime : function () {\n      return this.audio.currentTime;\n    },\n\n    update : function ( e ) {\n      if ( !this.isPlaying || !this.isLoaded ) return;\n\n      for ( var i = 0, j = this.fbLength / 2; i < j; i++ ) {\n        this.signal[ i ] = ( e.frameBuffer[ 2 * i ] + e.frameBuffer[ 2 * i + 1 ] ) / 2;\n      }\n\n      this.fft.forward( this.signal );\n      this.dancer.trigger( 'update' );\n    }\n  };\n\n  function getMetadata () {\n    this.fbLength = this.audio.mozFrameBufferLength;\n    this.channels = this.audio.mozChannels;\n    this.rate     = this.audio.mozSampleRate;\n    this.fft      = new FFT( this.fbLength / this.channels, this.rate );\n    this.signal   = new Float32Array( this.fbLength / this.channels );\n    this.isLoaded = true;\n    this.progress = 1;\n    this.dancer.trigger( 'loaded' );\n  }\n\n  Dancer.adapters.moz = adapter;\n\n})();\n\n(function() {\n  var\n    SAMPLE_SIZE  = 1024,\n    SAMPLE_RATE  = 44100,\n    smLoaded     = false,\n    smLoading    = false,\n    CONVERSION_COEFFICIENT = 0.93;\n\n  var adapter = function ( dancer ) {\n    this.dancer = dancer;\n    this.wave_L = [];\n    this.wave_R = [];\n    this.spectrum = [];\n    window.SM2_DEFER = true;\n  };\n\n  adapter.prototype = {\n    // `source` can be either an Audio element, if supported, or an object\n    // either way, the path is stored in the `src` property\n    load : function ( source ) {\n      var _this = this;\n      this.path = source ? source.src : this.path;\n\n      this.isLoaded = false;\n      this.progress = 0;\n\n      !window.soundManager && !smLoading && loadSM.call( this );\n\n      if ( window.soundManager ) {\n        this.audio = soundManager.createSound({\n          id       : 'dancer' + Math.random() + '',\n          url      : this.path,\n          stream   : true,\n          autoPlay : false,\n          autoLoad : true,\n          whileplaying : function () {\n            _this.update();\n          },\n          whileloading : function () {\n            _this.progress = this.bytesLoaded / this.bytesTotal;\n          },\n          onload   : function () {\n            _this.fft = new FFT( SAMPLE_SIZE, SAMPLE_RATE );\n            _this.signal = new Float32Array( SAMPLE_SIZE );\n            _this.waveform = new Float32Array( SAMPLE_SIZE );\n            _this.isLoaded = true;\n            _this.progress = 1;\n            _this.dancer.trigger( 'loaded' );\n          }\n        });\n        this.dancer.audio = this.audio;\n      }\n\n      // Returns audio if SM already loaded -- otherwise,\n      // sets dancer instance's audio property after load\n      return this.audio;\n    },\n\n    play : function () {\n      this.audio.play();\n      this.isPlaying = true;\n    },\n\n    pause : function () {\n      this.audio.pause();\n      this.isPlaying = false;\n    },\n\n    setVolume : function ( volume ) {\n      this.audio.setVolume( volume * 100 );\n    },\n\n    getVolume : function () {\n      return this.audio.volume / 100;\n    },\n\n    getProgress : function () {\n      return this.progress;\n    },\n\n    getWaveform : function () {\n      return this.waveform;\n    },\n\n    getSpectrum : function () {\n      return this.fft.spectrum;\n    },\n\n    getTime : function () {\n      return this.audio.position / 1000;\n    },\n\n    update : function () {\n      if ( !this.isPlaying && !this.isLoaded ) return;\n      this.wave_L = this.audio.waveformData.left;\n      this.wave_R = this.audio.waveformData.right;\n      var avg;\n      for ( var i = 0, j = this.wave_L.length; i < j; i++ ) {\n        avg = parseFloat(this.wave_L[ i ]) + parseFloat(this.wave_R[ i ]);\n        this.waveform[ 2 * i ]     = avg / 2;\n        this.waveform[ i * 2 + 1 ] = avg / 2;\n        this.signal[ 2 * i ]       = avg * CONVERSION_COEFFICIENT;\n        this.signal[ i * 2 + 1 ]   = avg * CONVERSION_COEFFICIENT;\n      }\n\n      this.fft.forward( this.signal );\n      this.dancer.trigger( 'update' );\n    }\n  };\n\n  function loadSM () {\n    var adapter = this;\n    smLoading = true;\n    loadScript( Dancer.options.flashJS, function () {\n      soundManager = new SoundManager();\n      soundManager.flashVersion = 9;\n      soundManager.flash9Options.useWaveformData = true;\n      soundManager.useWaveformData = true;\n      soundManager.useHighPerformance = true;\n      soundManager.useFastPolling = true;\n      soundManager.multiShot = false;\n      soundManager.debugMode = false;\n      soundManager.debugFlash = false;\n      soundManager.url = Dancer.options.flashSWF;\n      soundManager.onready(function () {\n        smLoaded = true;\n        adapter.load();\n      });\n      soundManager.ontimeout(function(){\n        console.error( 'Error loading SoundManager2.swf' );\n      });\n      soundManager.beginDelayedInit();\n    });\n  }\n\n  function loadScript ( url, callback ) {\n    var\n      script   = document.createElement( 'script' ),\n      appender = document.getElementsByTagName( 'script' )[0];\n    script.type = 'text/javascript';\n    script.src = url;\n    script.onload = callback;\n    appender.parentNode.insertBefore( script, appender );\n  }\n\n  Dancer.adapters.flash = adapter;\n\n})();\n\n/* \n *  DSP.js - a comprehensive digital signal processing  library for javascript\n * \n *  Created by Corban Brook <corbanbrook@gmail.com> on 2010-01-01.\n *  Copyright 2010 Corban Brook. All rights reserved.\n *\n */\n\n// Fourier Transform Module used by DFT, FFT, RFFT\nfunction FourierTransform(bufferSize, sampleRate) {\n  this.bufferSize = bufferSize;\n  this.sampleRate = sampleRate;\n  this.bandwidth  = 2 / bufferSize * sampleRate / 2;\n\n  this.spectrum   = new Float32Array(bufferSize/2);\n  this.real       = new Float32Array(bufferSize);\n  this.imag       = new Float32Array(bufferSize);\n\n  this.peakBand   = 0;\n  this.peak       = 0;\n\n  /**\n   * Calculates the *middle* frequency of an FFT band.\n   *\n   * @param {Number} index The index of the FFT band.\n   *\n   * @returns The middle frequency in Hz.\n   */\n  this.getBandFrequency = function(index) {\n    return this.bandwidth * index + this.bandwidth / 2;\n  };\n\n  this.calculateSpectrum = function() {\n    var spectrum  = this.spectrum,\n        real      = this.real,\n        imag      = this.imag,\n        bSi       = 2 / this.bufferSize,\n        sqrt      = Math.sqrt,\n        rval, \n        ival,\n        mag;\n\n    for (var i = 0, N = bufferSize/2; i < N; i++) {\n      rval = real[i];\n      ival = imag[i];\n      mag = bSi * sqrt(rval * rval + ival * ival);\n\n      if (mag > this.peak) {\n        this.peakBand = i;\n        this.peak = mag;\n      }\n\n      spectrum[i] = mag;\n    }\n  };\n}\n\n/**\n * FFT is a class for calculating the Discrete Fourier Transform of a signal\n * with the Fast Fourier Transform algorithm.\n *\n * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2\n * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)\n *\n * @constructor\n */\nfunction FFT(bufferSize, sampleRate) {\n  FourierTransform.call(this, bufferSize, sampleRate);\n   \n  this.reverseTable = new Uint32Array(bufferSize);\n\n  var limit = 1;\n  var bit = bufferSize >> 1;\n\n  var i;\n\n  while (limit < bufferSize) {\n    for (i = 0; i < limit; i++) {\n      this.reverseTable[i + limit] = this.reverseTable[i] + bit;\n    }\n\n    limit = limit << 1;\n    bit = bit >> 1;\n  }\n\n  this.sinTable = new Float32Array(bufferSize);\n  this.cosTable = new Float32Array(bufferSize);\n\n  for (i = 0; i < bufferSize; i++) {\n    this.sinTable[i] = Math.sin(-Math.PI/i);\n    this.cosTable[i] = Math.cos(-Math.PI/i);\n  }\n}\n\n/**\n * Performs a forward transform on the sample buffer.\n * Converts a time domain signal to frequency domain spectra.\n *\n * @param {Array} buffer The sample buffer. Buffer Length must be power of 2\n *\n * @returns The frequency spectrum array\n */\nFFT.prototype.forward = function(buffer) {\n  // Locally scope variables for speed up\n  var bufferSize      = this.bufferSize,\n      cosTable        = this.cosTable,\n      sinTable        = this.sinTable,\n      reverseTable    = this.reverseTable,\n      real            = this.real,\n      imag            = this.imag,\n      spectrum        = this.spectrum;\n\n  var k = Math.floor(Math.log(bufferSize) / Math.LN2);\n\n  if (Math.pow(2, k) !== bufferSize) { throw \"Invalid buffer size, must be a power of 2.\"; }\n  if (bufferSize !== buffer.length)  { throw \"Supplied buffer is not the same size as defined FFT. FFT Size: \" + bufferSize + \" Buffer Size: \" + buffer.length; }\n\n  var halfSize = 1,\n      phaseShiftStepReal,\n      phaseShiftStepImag,\n      currentPhaseShiftReal,\n      currentPhaseShiftImag,\n      off,\n      tr,\n      ti,\n      tmpReal,\n      i;\n\n  for (i = 0; i < bufferSize; i++) {\n    real[i] = buffer[reverseTable[i]];\n    imag[i] = 0;\n  }\n\n  while (halfSize < bufferSize) {\n    //phaseShiftStepReal = Math.cos(-Math.PI/halfSize);\n    //phaseShiftStepImag = Math.sin(-Math.PI/halfSize);\n    phaseShiftStepReal = cosTable[halfSize];\n    phaseShiftStepImag = sinTable[halfSize];\n    \n    currentPhaseShiftReal = 1;\n    currentPhaseShiftImag = 0;\n\n    for (var fftStep = 0; fftStep < halfSize; fftStep++) {\n      i = fftStep;\n\n      while (i < bufferSize) {\n        off = i + halfSize;\n        tr = (currentPhaseShiftReal * real[off]) - (currentPhaseShiftImag * imag[off]);\n        ti = (currentPhaseShiftReal * imag[off]) + (currentPhaseShiftImag * real[off]);\n\n        real[off] = real[i] - tr;\n        imag[off] = imag[i] - ti;\n        real[i] += tr;\n        imag[i] += ti;\n\n        i += halfSize << 1;\n      }\n\n      tmpReal = currentPhaseShiftReal;\n      currentPhaseShiftReal = (tmpReal * phaseShiftStepReal) - (currentPhaseShiftImag * phaseShiftStepImag);\n      currentPhaseShiftImag = (tmpReal * phaseShiftStepImag) + (currentPhaseShiftImag * phaseShiftStepReal);\n    }\n\n    halfSize = halfSize << 1;\n  }\n\n  return this.calculateSpectrum();\n};\n\n/*\nCopyright (c) Copyright (c) 2007, Carl S. Yestrau All rights reserved.\nCode licensed under the BSD License: http://www.featureblend.com/license.txt\nVersion: 1.0.4\n*/\nvar FlashDetect = new function(){\n    var self = this;\n    self.installed = false;\n    self.raw = \"\";\n    self.major = -1;\n    self.minor = -1;\n    self.revision = -1;\n    self.revisionStr = \"\";\n    var activeXDetectRules = [\n        {\n            \"name\":\"ShockwaveFlash.ShockwaveFlash.7\",\n            \"version\":function(obj){\n                return getActiveXVersion(obj);\n            }\n        },\n        {\n            \"name\":\"ShockwaveFlash.ShockwaveFlash.6\",\n            \"version\":function(obj){\n                var version = \"6,0,21\";\n                try{\n                    obj.AllowScriptAccess = \"always\";\n                    version = getActiveXVersion(obj);\n                }catch(err){}\n                return version;\n            }\n        },\n        {\n            \"name\":\"ShockwaveFlash.ShockwaveFlash\",\n            \"version\":function(obj){\n                return getActiveXVersion(obj);\n            }\n        }\n    ];\n    /**\n     * Extract the ActiveX version of the plugin.\n     * \n     * @param {Object} The flash ActiveX object.\n     * @type String\n     */\n    var getActiveXVersion = function(activeXObj){\n        var version = -1;\n        try{\n            version = activeXObj.GetVariable(\"$version\");\n        }catch(err){}\n        return version;\n    };\n    /**\n     * Try and retrieve an ActiveX object having a specified name.\n     * \n     * @param {String} name The ActiveX object name lookup.\n     * @return One of ActiveX object or a simple object having an attribute of activeXError with a value of true.\n     * @type Object\n     */\n    var getActiveXObject = function(name){\n        var obj = -1;\n        try{\n            obj = new ActiveXObject(name);\n        }catch(err){\n            obj = {activeXError:true};\n        }\n        return obj;\n    };\n    /**\n     * Parse an ActiveX $version string into an object.\n     * \n     * @param {String} str The ActiveX Object GetVariable($version) return value. \n     * @return An object having raw, major, minor, revision and revisionStr attributes.\n     * @type Object\n     */\n    var parseActiveXVersion = function(str){\n        var versionArray = str.split(\",\");//replace with regex\n        return {\n            \"raw\":str,\n            \"major\":parseInt(versionArray[0].split(\" \")[1], 10),\n            \"minor\":parseInt(versionArray[1], 10),\n            \"revision\":parseInt(versionArray[2], 10),\n            \"revisionStr\":versionArray[2]\n        };\n    };\n    /**\n     * Parse a standard enabledPlugin.description into an object.\n     * \n     * @param {String} str The enabledPlugin.description value.\n     * @return An object having raw, major, minor, revision and revisionStr attributes.\n     * @type Object\n     */\n    var parseStandardVersion = function(str){\n        var descParts = str.split(/ +/);\n        var majorMinor = descParts[2].split(/\\./);\n        var revisionStr = descParts[3];\n        return {\n            \"raw\":str,\n            \"major\":parseInt(majorMinor[0], 10),\n            \"minor\":parseInt(majorMinor[1], 10), \n            \"revisionStr\":revisionStr,\n            \"revision\":parseRevisionStrToInt(revisionStr)\n        };\n    };\n    /**\n     * Parse the plugin revision string into an integer.\n     * \n     * @param {String} The revision in string format.\n     * @type Number\n     */\n    var parseRevisionStrToInt = function(str){\n        return parseInt(str.replace(/[a-zA-Z]/g, \"\"), 10) || self.revision;\n    };\n    /**\n     * Is the major version greater than or equal to a specified version.\n     * \n     * @param {Number} version The minimum required major version.\n     * @type Boolean\n     */\n    self.majorAtLeast = function(version){\n        return self.major >= version;\n    };\n    /**\n     * Is the minor version greater than or equal to a specified version.\n     * \n     * @param {Number} version The minimum required minor version.\n     * @type Boolean\n     */\n    self.minorAtLeast = function(version){\n        return self.minor >= version;\n    };\n    /**\n     * Is the revision version greater than or equal to a specified version.\n     * \n     * @param {Number} version The minimum required revision version.\n     * @type Boolean\n     */\n    self.revisionAtLeast = function(version){\n        return self.revision >= version;\n    };\n    /**\n     * Is the version greater than or equal to a specified major, minor and revision.\n     * \n     * @param {Number} major The minimum required major version.\n     * @param {Number} (Optional) minor The minimum required minor version.\n     * @param {Number} (Optional) revision The minimum required revision version.\n     * @type Boolean\n     */\n    self.versionAtLeast = function(major){\n        var properties = [self.major, self.minor, self.revision];\n        var len = Math.min(properties.length, arguments.length);\n        for(i=0; i<len; i++){\n            if(properties[i]>=arguments[i]){\n                if(i+1<len && properties[i]==arguments[i]){\n                    continue;\n                }else{\n                    return true;\n                }\n            }else{\n                return false;\n            }\n        }\n    };\n    /**\n     * Constructor, sets raw, major, minor, revisionStr, revision and installed public properties.\n     */\n    self.FlashDetect = function(){\n        if(navigator.plugins && navigator.plugins.length>0){\n            var type = 'application/x-shockwave-flash';\n            var mimeTypes = navigator.mimeTypes;\n            if(mimeTypes && mimeTypes[type] && mimeTypes[type].enabledPlugin && mimeTypes[type].enabledPlugin.description){\n                var version = mimeTypes[type].enabledPlugin.description;\n                var versionObj = parseStandardVersion(version);\n                self.raw = versionObj.raw;\n                self.major = versionObj.major;\n                self.minor = versionObj.minor; \n                self.revisionStr = versionObj.revisionStr;\n                self.revision = versionObj.revision;\n                self.installed = true;\n            }\n        }else if(navigator.appVersion.indexOf(\"Mac\")==-1 && window.execScript){\n            var version = -1;\n            for(var i=0; i<activeXDetectRules.length && version==-1; i++){\n                var obj = getActiveXObject(activeXDetectRules[i].name);\n                if(!obj.activeXError){\n                    self.installed = true;\n                    version = activeXDetectRules[i].version(obj);\n                    if(version!=-1){\n                        var versionObj = parseActiveXVersion(version);\n                        self.raw = versionObj.raw;\n                        self.major = versionObj.major;\n                        self.minor = versionObj.minor; \n                        self.revision = versionObj.revision;\n                        self.revisionStr = versionObj.revisionStr;\n                    }\n                }\n            }\n        }\n    }();\n};\nFlashDetect.JS_RELEASE = \"1.0.4\";",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "dancer.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-dancer",
      "url": "/js/dancer.js",
      "urls": [
        "/js/dancer.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/dancer.min.js",
      "relativePath": "js/dancer.min.js",
      "basename": "dancer",
      "outBasename": "dancer",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "min",
        "js"
      ],
      "filename": "dancer.min.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/dancer.min.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js",
      "outFilename": "dancer.min.js",
      "relativeOutPath": "js/dancer.min.js",
      "relativeDirPath": "js",
      "relativeOutDirPath": "js",
      "relativeBase": "js/dancer",
      "relativeOutBase": "js/dancer",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.519Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/* dancer.js - v0.3.2 - 2012-09-29\n* https://github.com/jsantell/dancer.js\n* Copyright (c) 2012 Jordan Santell; Licensed MIT */\nfunction FourierTransform(e,t){this.bufferSize=e,this.sampleRate=t,this.bandwidth=2/e*t/2,this.spectrum=new Float32Array(e/2),this.real=new Float32Array(e),this.imag=new Float32Array(e),this.peakBand=0,this.peak=0,this.getBandFrequency=function(e){return this.bandwidth*e+this.bandwidth/2},this.calculateSpectrum=function(){var t=this.spectrum,n=this.real,r=this.imag,i=2/this.bufferSize,s=Math.sqrt,o,u,a;for(var f=0,l=e/2;f<l;f++)o=n[f],u=r[f],a=i*s(o*o+u*u),a>this.peak&&(this.peakBand=f,this.peak=a),t[f]=a}}function FFT(e,t){FourierTransform.call(this,e,t),this.reverseTable=new Uint32Array(e);var n=1,r=e>>1,i;while(n<e){for(i=0;i<n;i++)this.reverseTable[i+n]=this.reverseTable[i]+r;n<<=1,r>>=1}this.sinTable=new Float32Array(e),this.cosTable=new Float32Array(e);for(i=0;i<e;i++)this.sinTable[i]=Math.sin(-Math.PI/i),this.cosTable[i]=Math.cos(-Math.PI/i)}(function(){function t(){for(var e in this.sections)this.sections[e].condition()&&this.sections[e].callback.call(this)}var e=function(){this.audioAdapter=e._getAdapter(this),this.events={},this.sections=[],this.bind(\"update\",t)};e.version=\"0.3.2\",e.adapters={},e.prototype={load:function(t){var n;return t instanceof HTMLElement?(this.source=t,e.isSupported()===\"flash\"&&(this.source={src:e._getMP3SrcFromAudio(t)})):(this.source=window.Audio?new Audio:{},this.source.src=e._makeSupportedPath(t.src,t.codecs)),this.audio=this.audioAdapter.load(this.source),this},play:function(){return this.audioAdapter.play(),this},pause:function(){return this.audioAdapter.pause(),this},setVolume:function(e){return this.audioAdapter.setVolume(e),this},createKick:function(t){return new e.Kick(this,t)},bind:function(e,t){return this.events[e]||(this.events[e]=[]),this.events[e].push(t),this},unbind:function(e){return this.events[e]&&delete this.events[e],this},trigger:function(e){var t=this;return this.events[e]&&this.events[e].forEach(function(e){e.call(t)}),this},getVolume:function(){return this.audioAdapter.getVolume()},getProgress:function(){return this.audioAdapter.getProgress()},getTime:function(){return this.audioAdapter.getTime()},getFrequency:function(e,t){var n=0;if(t!==undefined){for(var r=e;r<=t;r++)n+=this.getSpectrum()[r];return n/(t-e+1)}return this.getSpectrum()[e]},getWaveform:function(){return this.audioAdapter.getWaveform()},getSpectrum:function(){return this.audioAdapter.getSpectrum()},isLoaded:function(){return this.audioAdapter.isLoaded},isPlaying:function(){return this.audioAdapter.isPlaying},after:function(e,t){var n=this;return this.sections.push({condition:function(){return n.getTime()>e},callback:t}),this},before:function(e,t){var n=this;return this.sections.push({condition:function(){return n.getTime()<e},callback:t}),this},between:function(e,t,n){var r=this;return this.sections.push({condition:function(){return r.getTime()>e&&r.getTime()<t},callback:n}),this},onceAt:function(e,t){var n=this,r=null;return this.sections.push({condition:function(){return n.getTime()>e&&!this.called},callback:function(){t.call(this),r.called=!0},called:!1}),r=this.sections[this.sections.length-1],this}},window.Dancer=e})(),function(e){function r(){var e=!!(navigator.vendor||\"\").match(/Apple/),t=navigator.userAgent.match(/Version\\/([^ ]*)/);return t=t?parseFloat(t[1]):0,e&&t<=6}var t={mp3:\"audio/mpeg;\",ogg:'audio/ogg; codecs=\"vorbis\"',wav:'audio/wav; codecs=\"1\"',aac:'audio/mp4; codecs=\"mp4a.40.2\"'},n=document.createElement(\"audio\");e.options={},e.setOptions=function(t){for(var n in t)t.hasOwnProperty(n)&&(e.options[n]=t[n])},e.isSupported=function(){return!window.Float32Array||!window.Uint32Array?null:!r()&&(window.AudioContext||window.webkitAudioContext)?\"webaudio\":n&&n.mozSetup?\"audiodata\":FlashDetect.versionAtLeast(9)?\"flash\":\"\"},e.canPlay=function(r){var i=n.canPlayType;return e.isSupported()===\"flash\"?r.toLowerCase()===\"mp3\":!!n.canPlayType&&!!n.canPlayType(t[r.toLowerCase()]).replace(/no/,\"\")},e.addPlugin=function(t,n){e.prototype[t]===undefined&&(e.prototype[t]=n)},e._makeSupportedPath=function(t,n){if(!n)return t;for(var r=0;r<n.length;r++)if(e.canPlay(n[r]))return t+\".\"+n[r];return t},e._getAdapter=function(t){switch(e.isSupported()){case\"webaudio\":return new e.adapters.webkit(t);case\"audiodata\":return new e.adapters.moz(t);case\"flash\":return new e.adapters.flash(t);default:return null}},e._getMP3SrcFromAudio=function(e){var t=e.children;if(e.src)return e.src;for(var n=t.length;n--;)if((t[n].type||\"\").match(/audio\\/mpeg/))return t[n].src;return null}}(window.Dancer),function(e){var t=function(t,n){n=n||{},this.dancer=t,this.frequency=n.frequency!==e?n.frequency:[0,10],this.threshold=n.threshold!==e?n.threshold:.3,this.decay=n.decay!==e?n.decay:.02,this.onKick=n.onKick,this.offKick=n.offKick,this.isOn=!1,this.currentThreshold=this.threshold;var r=this;this.dancer.bind(\"update\",function(){r.onUpdate()})};t.prototype={on:function(){return this.isOn=!0,this},off:function(){return this.isOn=!1,this},set:function(t){t=t||{},this.frequency=t.frequency!==e?t.frequency:this.frequency,this.threshold=t.threshold!==e?t.threshold:this.threshold,this.decay=t.decay!==e?t.decay:this.decay,this.onKick=t.onKick||this.onKick,this.offKick=t.offKick||this.offKick},onUpdate:function(){if(!this.isOn)return;var e=this.maxAmplitude(this.frequency);e>=this.currentThreshold&&e>=this.threshold?(this.currentThreshold=e,this.onKick&&this.onKick.call(this.dancer,e)):(this.offKick&&this.offKick.call(this.dancer,e),this.currentThreshold-=this.decay)},maxAmplitude:function(e){var t=0,n=this.dancer.getSpectrum();if(!e.length)return e<n.length?n[~~e]:null;for(var r=e[0],i=e[1];r<=i;r++)n[r]>t&&(t=n[r]);return t}},window.Dancer.Kick=t}(),function(){function r(){this.source=this.context.createMediaElementSource(this.audio),this.source.connect(this.proc),this.source.connect(this.gain),this.gain.connect(this.context.destination),this.proc.connect(this.context.destination),this.isLoaded=!0,this.progress=1,this.dancer.trigger(\"loaded\")}var e=2048,t=44100,n=function(e){this.dancer=e,this.audio=new Audio,this.context=window.AudioContext?new window.AudioContext:new window.webkitAudioContext};n.prototype={load:function(n){var i=this;return this.audio=n,this.isLoaded=!1,this.progress=0,this.proc=this.context.createJavaScriptNode(e/2,1,1),this.proc.onaudioprocess=function(e){i.update.call(i,e)},this.gain=this.context.createGainNode(),this.fft=new FFT(e/2,t),this.signal=new Float32Array(e/2),this.audio.readyState<3?this.audio.addEventListener(\"canplay\",function(){r.call(i)}):r.call(i),this.audio.addEventListener(\"progress\",function(e){e.currentTarget.duration&&(i.progress=e.currentTarget.seekable.end(0)/e.currentTarget.duration)}),this.audio},play:function(){this.audio.play(),this.isPlaying=!0},pause:function(){this.audio.pause(),this.isPlaying=!1},setVolume:function(e){this.gain.gain.value=e},getVolume:function(){return this.gain.gain.value},getProgress:function(){return this.progress},getWaveform:function(){return this.signal},getSpectrum:function(){return this.fft.spectrum},getTime:function(){return this.audio.currentTime},update:function(t){if(!this.isPlaying||!this.isLoaded)return;var n=[],r=t.inputBuffer.numberOfChannels,i=e/r,s=function(e,t){return e[o]+t[o]},o;for(o=r;o--;)n.push(t.inputBuffer.getChannelData(o));for(o=0;o<i;o++)this.signal[o]=r>1?n.reduce(s)/r:n[0][o];this.fft.forward(this.signal),this.dancer.trigger(\"update\")}},Dancer.adapters.webkit=n}(),function(){function t(){this.fbLength=this.audio.mozFrameBufferLength,this.channels=this.audio.mozChannels,this.rate=this.audio.mozSampleRate,this.fft=new FFT(this.fbLength/this.channels,this.rate),this.signal=new Float32Array(this.fbLength/this.channels),this.isLoaded=!0,this.progress=1,this.dancer.trigger(\"loaded\")}var e=function(e){this.dancer=e,this.audio=new Audio};e.prototype={load:function(e){var n=this;return this.audio=e,this.isLoaded=!1,this.progress=0,this.audio.readyState<3?this.audio.addEventListener(\"loadedmetadata\",function(){t.call(n)},!1):t.call(n),this.audio.addEventListener(\"MozAudioAvailable\",function(e){n.update(e)},!1),this.audio.addEventListener(\"progress\",function(e){e.currentTarget.duration&&(n.progress=e.currentTarget.seekable.end(0)/e.currentTarget.duration)},!1),this.audio},play:function(){this.audio.play(),this.isPlaying=!0},pause:function(){this.audio.pause(),this.isPlaying=!1},setVolume:function(e){this.audio.volume=e},getVolume:function(){return this.audio.volume},getProgress:function(){return this.progress},getWaveform:function(){return this.signal},getSpectrum:function(){return this.fft.spectrum},getTime:function(){return this.audio.currentTime},update:function(e){if(!this.isPlaying||!this.isLoaded)return;for(var t=0,n=this.fbLength/2;t<n;t++)this.signal[t]=(e.frameBuffer[2*t]+e.frameBuffer[2*t+1])/2;this.fft.forward(this.signal),this.dancer.trigger(\"update\")}},Dancer.adapters.moz=e}(),function(){function o(){var e=this;r=!0,u(Dancer.options.flashJS,function(){soundManager=new SoundManager,soundManager.flashVersion=9,soundManager.flash9Options.useWaveformData=!0,soundManager.useWaveformData=!0,soundManager.useHighPerformance=!0,soundManager.useFastPolling=!0,soundManager.multiShot=!1,soundManager.debugMode=!1,soundManager.debugFlash=!1,soundManager.url=Dancer.options.flashSWF,soundManager.onready(function(){n=!0,e.load()}),soundManager.ontimeout(function(){console.error(\"Error loading SoundManager2.swf\")}),soundManager.beginDelayedInit()})}function u(e,t){var n=document.createElement(\"script\"),r=document.getElementsByTagName(\"script\")[0];n.type=\"text/javascript\",n.src=e,n.onload=t,r.parentNode.insertBefore(n,r)}var e=1024,t=44100,n=!1,r=!1,i=.93,s=function(e){this.dancer=e,this.wave_L=[],this.wave_R=[],this.spectrum=[],window.SM2_DEFER=!0};s.prototype={load:function(n){var i=this;return this.path=n?n.src:this.path,this.isLoaded=!1,this.progress=0,!window.soundManager&&!r&&o.call(this),window.soundManager&&(this.audio=soundManager.createSound({id:\"dancer\"+Math.random()+\"\",url:this.path,stream:!0,autoPlay:!1,autoLoad:!0,whileplaying:function(){i.update()},whileloading:function(){i.progress=this.bytesLoaded/this.bytesTotal},onload:function(){i.fft=new FFT(e,t),i.signal=new Float32Array(e),i.waveform=new Float32Array(e),i.isLoaded=!0,i.progress=1,i.dancer.trigger(\"loaded\")}}),this.dancer.audio=this.audio),this.audio},play:function(){this.audio.play(),this.isPlaying=!0},pause:function(){this.audio.pause(),this.isPlaying=!1},setVolume:function(e){this.audio.setVolume(e*100)},getVolume:function(){return this.audio.volume/100},getProgress:function(){return this.progress},getWaveform:function(){return this.waveform},getSpectrum:function(){return this.fft.spectrum},getTime:function(){return this.audio.position/1e3},update:function(){if(!this.isPlaying&&!this.isLoaded)return;this.wave_L=this.audio.waveformData.left,this.wave_R=this.audio.waveformData.right;var e;for(var t=0,n=this.wave_L.length;t<n;t++)e=parseFloat(this.wave_L[t])+parseFloat(this.wave_R[t]),this.waveform[2*t]=e/2,this.waveform[t*2+1]=e/2,this.signal[2*t]=e*i,this.signal[t*2+1]=e*i;this.fft.forward(this.signal),this.dancer.trigger(\"update\")}},Dancer.adapters.flash=s}(),FFT.prototype.forward=function(e){var t=this.bufferSize,n=this.cosTable,r=this.sinTable,i=this.reverseTable,s=this.real,o=this.imag,u=this.spectrum,a=Math.floor(Math.log(t)/Math.LN2);if(Math.pow(2,a)!==t)throw\"Invalid buffer size, must be a power of 2.\";if(t!==e.length)throw\"Supplied buffer is not the same size as defined FFT. FFT Size: \"+t+\" Buffer Size: \"+e.length;var f=1,l,c,h,p,d,v,m,g,y;for(y=0;y<t;y++)s[y]=e[i[y]],o[y]=0;while(f<t){l=n[f],c=r[f],h=1,p=0;for(var b=0;b<f;b++){y=b;while(y<t)d=y+f,v=h*s[d]-p*o[d],m=h*o[d]+p*s[d],s[d]=s[y]-v,o[d]=o[y]-m,s[y]+=v,o[y]+=m,y+=f<<1;g=h,h=g*l-p*c,p=g*c+p*l}f<<=1}return this.calculateSpectrum()};var FlashDetect=new function(){var e=this;e.installed=!1,e.raw=\"\",e.major=-1,e.minor=-1,e.revision=-1,e.revisionStr=\"\";var t=[{name:\"ShockwaveFlash.ShockwaveFlash.7\",version:function(e){return n(e)}},{name:\"ShockwaveFlash.ShockwaveFlash.6\",version:function(e){var t=\"6,0,21\";try{e.AllowScriptAccess=\"always\",t=n(e)}catch(r){}return t}},{name:\"ShockwaveFlash.ShockwaveFlash\",version:function(e){return n(e)}}],n=function(e){var t=-1;try{t=e.GetVariable(\"$version\")}catch(n){}return t},r=function(e){var t=-1;try{t=new ActiveXObject(e)}catch(n){t={activeXError:!0}}return t},s=function(e){var t=e.split(\",\");return{raw:e,major:parseInt(t[0].split(\" \")[1],10),minor:parseInt(t[1],10),revision:parseInt(t[2],10),revisionStr:t[2]}},o=function(e){var t=e.split(/ +/),n=t[2].split(/\\./),r=t[3];return{raw:e,major:parseInt(n[0],10),minor:parseInt(n[1],10),revisionStr:r,revision:u(r)}},u=function(t){return parseInt(t.replace(/[a-zA-Z]/g,\"\"),10)||e.revision};e.majorAtLeast=function(t){return e.major>=t},e.minorAtLeast=function(t){return e.minor>=t},e.revisionAtLeast=function(t){return e.revision>=t},e.versionAtLeast=function(t){var n=[e.major,e.minor,e.revision],r=Math.min(n.length,arguments.length);for(i=0;i<r;i++){if(n[i]>=arguments[i]){if(i+1<r&&n[i]==arguments[i])continue;return!0}return!1}},e.FlashDetect=function(){if(navigator.plugins&&navigator.plugins.length>0){var n=\"application/x-shockwave-flash\",i=navigator.mimeTypes;if(i&&i[n]&&i[n].enabledPlugin&&i[n].enabledPlugin.description){var u=i[n].enabledPlugin.description,a=o(u);e.raw=a.raw,e.major=a.major,e.minor=a.minor,e.revisionStr=a.revisionStr,e.revision=a.revision,e.installed=!0}}else if(navigator.appVersion.indexOf(\"Mac\")==-1&&window.execScript){var u=-1;for(var f=0;f<t.length&&u==-1;f++){var l=r(t[f].name);if(!l.activeXError){e.installed=!0,u=t[f].version(l);if(u!=-1){var a=s(u);e.raw=a.raw,e.major=a.major,e.minor=a.minor,e.revision=a.revision,e.revisionStr=a.revisionStr}}}}}()};FlashDetect.JS_RELEASE=\"1.0.4\";",
      "content": "/* dancer.js - v0.3.2 - 2012-09-29\n* https://github.com/jsantell/dancer.js\n* Copyright (c) 2012 Jordan Santell; Licensed MIT */\nfunction FourierTransform(e,t){this.bufferSize=e,this.sampleRate=t,this.bandwidth=2/e*t/2,this.spectrum=new Float32Array(e/2),this.real=new Float32Array(e),this.imag=new Float32Array(e),this.peakBand=0,this.peak=0,this.getBandFrequency=function(e){return this.bandwidth*e+this.bandwidth/2},this.calculateSpectrum=function(){var t=this.spectrum,n=this.real,r=this.imag,i=2/this.bufferSize,s=Math.sqrt,o,u,a;for(var f=0,l=e/2;f<l;f++)o=n[f],u=r[f],a=i*s(o*o+u*u),a>this.peak&&(this.peakBand=f,this.peak=a),t[f]=a}}function FFT(e,t){FourierTransform.call(this,e,t),this.reverseTable=new Uint32Array(e);var n=1,r=e>>1,i;while(n<e){for(i=0;i<n;i++)this.reverseTable[i+n]=this.reverseTable[i]+r;n<<=1,r>>=1}this.sinTable=new Float32Array(e),this.cosTable=new Float32Array(e);for(i=0;i<e;i++)this.sinTable[i]=Math.sin(-Math.PI/i),this.cosTable[i]=Math.cos(-Math.PI/i)}(function(){function t(){for(var e in this.sections)this.sections[e].condition()&&this.sections[e].callback.call(this)}var e=function(){this.audioAdapter=e._getAdapter(this),this.events={},this.sections=[],this.bind(\"update\",t)};e.version=\"0.3.2\",e.adapters={},e.prototype={load:function(t){var n;return t instanceof HTMLElement?(this.source=t,e.isSupported()===\"flash\"&&(this.source={src:e._getMP3SrcFromAudio(t)})):(this.source=window.Audio?new Audio:{},this.source.src=e._makeSupportedPath(t.src,t.codecs)),this.audio=this.audioAdapter.load(this.source),this},play:function(){return this.audioAdapter.play(),this},pause:function(){return this.audioAdapter.pause(),this},setVolume:function(e){return this.audioAdapter.setVolume(e),this},createKick:function(t){return new e.Kick(this,t)},bind:function(e,t){return this.events[e]||(this.events[e]=[]),this.events[e].push(t),this},unbind:function(e){return this.events[e]&&delete this.events[e],this},trigger:function(e){var t=this;return this.events[e]&&this.events[e].forEach(function(e){e.call(t)}),this},getVolume:function(){return this.audioAdapter.getVolume()},getProgress:function(){return this.audioAdapter.getProgress()},getTime:function(){return this.audioAdapter.getTime()},getFrequency:function(e,t){var n=0;if(t!==undefined){for(var r=e;r<=t;r++)n+=this.getSpectrum()[r];return n/(t-e+1)}return this.getSpectrum()[e]},getWaveform:function(){return this.audioAdapter.getWaveform()},getSpectrum:function(){return this.audioAdapter.getSpectrum()},isLoaded:function(){return this.audioAdapter.isLoaded},isPlaying:function(){return this.audioAdapter.isPlaying},after:function(e,t){var n=this;return this.sections.push({condition:function(){return n.getTime()>e},callback:t}),this},before:function(e,t){var n=this;return this.sections.push({condition:function(){return n.getTime()<e},callback:t}),this},between:function(e,t,n){var r=this;return this.sections.push({condition:function(){return r.getTime()>e&&r.getTime()<t},callback:n}),this},onceAt:function(e,t){var n=this,r=null;return this.sections.push({condition:function(){return n.getTime()>e&&!this.called},callback:function(){t.call(this),r.called=!0},called:!1}),r=this.sections[this.sections.length-1],this}},window.Dancer=e})(),function(e){function r(){var e=!!(navigator.vendor||\"\").match(/Apple/),t=navigator.userAgent.match(/Version\\/([^ ]*)/);return t=t?parseFloat(t[1]):0,e&&t<=6}var t={mp3:\"audio/mpeg;\",ogg:'audio/ogg; codecs=\"vorbis\"',wav:'audio/wav; codecs=\"1\"',aac:'audio/mp4; codecs=\"mp4a.40.2\"'},n=document.createElement(\"audio\");e.options={},e.setOptions=function(t){for(var n in t)t.hasOwnProperty(n)&&(e.options[n]=t[n])},e.isSupported=function(){return!window.Float32Array||!window.Uint32Array?null:!r()&&(window.AudioContext||window.webkitAudioContext)?\"webaudio\":n&&n.mozSetup?\"audiodata\":FlashDetect.versionAtLeast(9)?\"flash\":\"\"},e.canPlay=function(r){var i=n.canPlayType;return e.isSupported()===\"flash\"?r.toLowerCase()===\"mp3\":!!n.canPlayType&&!!n.canPlayType(t[r.toLowerCase()]).replace(/no/,\"\")},e.addPlugin=function(t,n){e.prototype[t]===undefined&&(e.prototype[t]=n)},e._makeSupportedPath=function(t,n){if(!n)return t;for(var r=0;r<n.length;r++)if(e.canPlay(n[r]))return t+\".\"+n[r];return t},e._getAdapter=function(t){switch(e.isSupported()){case\"webaudio\":return new e.adapters.webkit(t);case\"audiodata\":return new e.adapters.moz(t);case\"flash\":return new e.adapters.flash(t);default:return null}},e._getMP3SrcFromAudio=function(e){var t=e.children;if(e.src)return e.src;for(var n=t.length;n--;)if((t[n].type||\"\").match(/audio\\/mpeg/))return t[n].src;return null}}(window.Dancer),function(e){var t=function(t,n){n=n||{},this.dancer=t,this.frequency=n.frequency!==e?n.frequency:[0,10],this.threshold=n.threshold!==e?n.threshold:.3,this.decay=n.decay!==e?n.decay:.02,this.onKick=n.onKick,this.offKick=n.offKick,this.isOn=!1,this.currentThreshold=this.threshold;var r=this;this.dancer.bind(\"update\",function(){r.onUpdate()})};t.prototype={on:function(){return this.isOn=!0,this},off:function(){return this.isOn=!1,this},set:function(t){t=t||{},this.frequency=t.frequency!==e?t.frequency:this.frequency,this.threshold=t.threshold!==e?t.threshold:this.threshold,this.decay=t.decay!==e?t.decay:this.decay,this.onKick=t.onKick||this.onKick,this.offKick=t.offKick||this.offKick},onUpdate:function(){if(!this.isOn)return;var e=this.maxAmplitude(this.frequency);e>=this.currentThreshold&&e>=this.threshold?(this.currentThreshold=e,this.onKick&&this.onKick.call(this.dancer,e)):(this.offKick&&this.offKick.call(this.dancer,e),this.currentThreshold-=this.decay)},maxAmplitude:function(e){var t=0,n=this.dancer.getSpectrum();if(!e.length)return e<n.length?n[~~e]:null;for(var r=e[0],i=e[1];r<=i;r++)n[r]>t&&(t=n[r]);return t}},window.Dancer.Kick=t}(),function(){function r(){this.source=this.context.createMediaElementSource(this.audio),this.source.connect(this.proc),this.source.connect(this.gain),this.gain.connect(this.context.destination),this.proc.connect(this.context.destination),this.isLoaded=!0,this.progress=1,this.dancer.trigger(\"loaded\")}var e=2048,t=44100,n=function(e){this.dancer=e,this.audio=new Audio,this.context=window.AudioContext?new window.AudioContext:new window.webkitAudioContext};n.prototype={load:function(n){var i=this;return this.audio=n,this.isLoaded=!1,this.progress=0,this.proc=this.context.createJavaScriptNode(e/2,1,1),this.proc.onaudioprocess=function(e){i.update.call(i,e)},this.gain=this.context.createGainNode(),this.fft=new FFT(e/2,t),this.signal=new Float32Array(e/2),this.audio.readyState<3?this.audio.addEventListener(\"canplay\",function(){r.call(i)}):r.call(i),this.audio.addEventListener(\"progress\",function(e){e.currentTarget.duration&&(i.progress=e.currentTarget.seekable.end(0)/e.currentTarget.duration)}),this.audio},play:function(){this.audio.play(),this.isPlaying=!0},pause:function(){this.audio.pause(),this.isPlaying=!1},setVolume:function(e){this.gain.gain.value=e},getVolume:function(){return this.gain.gain.value},getProgress:function(){return this.progress},getWaveform:function(){return this.signal},getSpectrum:function(){return this.fft.spectrum},getTime:function(){return this.audio.currentTime},update:function(t){if(!this.isPlaying||!this.isLoaded)return;var n=[],r=t.inputBuffer.numberOfChannels,i=e/r,s=function(e,t){return e[o]+t[o]},o;for(o=r;o--;)n.push(t.inputBuffer.getChannelData(o));for(o=0;o<i;o++)this.signal[o]=r>1?n.reduce(s)/r:n[0][o];this.fft.forward(this.signal),this.dancer.trigger(\"update\")}},Dancer.adapters.webkit=n}(),function(){function t(){this.fbLength=this.audio.mozFrameBufferLength,this.channels=this.audio.mozChannels,this.rate=this.audio.mozSampleRate,this.fft=new FFT(this.fbLength/this.channels,this.rate),this.signal=new Float32Array(this.fbLength/this.channels),this.isLoaded=!0,this.progress=1,this.dancer.trigger(\"loaded\")}var e=function(e){this.dancer=e,this.audio=new Audio};e.prototype={load:function(e){var n=this;return this.audio=e,this.isLoaded=!1,this.progress=0,this.audio.readyState<3?this.audio.addEventListener(\"loadedmetadata\",function(){t.call(n)},!1):t.call(n),this.audio.addEventListener(\"MozAudioAvailable\",function(e){n.update(e)},!1),this.audio.addEventListener(\"progress\",function(e){e.currentTarget.duration&&(n.progress=e.currentTarget.seekable.end(0)/e.currentTarget.duration)},!1),this.audio},play:function(){this.audio.play(),this.isPlaying=!0},pause:function(){this.audio.pause(),this.isPlaying=!1},setVolume:function(e){this.audio.volume=e},getVolume:function(){return this.audio.volume},getProgress:function(){return this.progress},getWaveform:function(){return this.signal},getSpectrum:function(){return this.fft.spectrum},getTime:function(){return this.audio.currentTime},update:function(e){if(!this.isPlaying||!this.isLoaded)return;for(var t=0,n=this.fbLength/2;t<n;t++)this.signal[t]=(e.frameBuffer[2*t]+e.frameBuffer[2*t+1])/2;this.fft.forward(this.signal),this.dancer.trigger(\"update\")}},Dancer.adapters.moz=e}(),function(){function o(){var e=this;r=!0,u(Dancer.options.flashJS,function(){soundManager=new SoundManager,soundManager.flashVersion=9,soundManager.flash9Options.useWaveformData=!0,soundManager.useWaveformData=!0,soundManager.useHighPerformance=!0,soundManager.useFastPolling=!0,soundManager.multiShot=!1,soundManager.debugMode=!1,soundManager.debugFlash=!1,soundManager.url=Dancer.options.flashSWF,soundManager.onready(function(){n=!0,e.load()}),soundManager.ontimeout(function(){console.error(\"Error loading SoundManager2.swf\")}),soundManager.beginDelayedInit()})}function u(e,t){var n=document.createElement(\"script\"),r=document.getElementsByTagName(\"script\")[0];n.type=\"text/javascript\",n.src=e,n.onload=t,r.parentNode.insertBefore(n,r)}var e=1024,t=44100,n=!1,r=!1,i=.93,s=function(e){this.dancer=e,this.wave_L=[],this.wave_R=[],this.spectrum=[],window.SM2_DEFER=!0};s.prototype={load:function(n){var i=this;return this.path=n?n.src:this.path,this.isLoaded=!1,this.progress=0,!window.soundManager&&!r&&o.call(this),window.soundManager&&(this.audio=soundManager.createSound({id:\"dancer\"+Math.random()+\"\",url:this.path,stream:!0,autoPlay:!1,autoLoad:!0,whileplaying:function(){i.update()},whileloading:function(){i.progress=this.bytesLoaded/this.bytesTotal},onload:function(){i.fft=new FFT(e,t),i.signal=new Float32Array(e),i.waveform=new Float32Array(e),i.isLoaded=!0,i.progress=1,i.dancer.trigger(\"loaded\")}}),this.dancer.audio=this.audio),this.audio},play:function(){this.audio.play(),this.isPlaying=!0},pause:function(){this.audio.pause(),this.isPlaying=!1},setVolume:function(e){this.audio.setVolume(e*100)},getVolume:function(){return this.audio.volume/100},getProgress:function(){return this.progress},getWaveform:function(){return this.waveform},getSpectrum:function(){return this.fft.spectrum},getTime:function(){return this.audio.position/1e3},update:function(){if(!this.isPlaying&&!this.isLoaded)return;this.wave_L=this.audio.waveformData.left,this.wave_R=this.audio.waveformData.right;var e;for(var t=0,n=this.wave_L.length;t<n;t++)e=parseFloat(this.wave_L[t])+parseFloat(this.wave_R[t]),this.waveform[2*t]=e/2,this.waveform[t*2+1]=e/2,this.signal[2*t]=e*i,this.signal[t*2+1]=e*i;this.fft.forward(this.signal),this.dancer.trigger(\"update\")}},Dancer.adapters.flash=s}(),FFT.prototype.forward=function(e){var t=this.bufferSize,n=this.cosTable,r=this.sinTable,i=this.reverseTable,s=this.real,o=this.imag,u=this.spectrum,a=Math.floor(Math.log(t)/Math.LN2);if(Math.pow(2,a)!==t)throw\"Invalid buffer size, must be a power of 2.\";if(t!==e.length)throw\"Supplied buffer is not the same size as defined FFT. FFT Size: \"+t+\" Buffer Size: \"+e.length;var f=1,l,c,h,p,d,v,m,g,y;for(y=0;y<t;y++)s[y]=e[i[y]],o[y]=0;while(f<t){l=n[f],c=r[f],h=1,p=0;for(var b=0;b<f;b++){y=b;while(y<t)d=y+f,v=h*s[d]-p*o[d],m=h*o[d]+p*s[d],s[d]=s[y]-v,o[d]=o[y]-m,s[y]+=v,o[y]+=m,y+=f<<1;g=h,h=g*l-p*c,p=g*c+p*l}f<<=1}return this.calculateSpectrum()};var FlashDetect=new function(){var e=this;e.installed=!1,e.raw=\"\",e.major=-1,e.minor=-1,e.revision=-1,e.revisionStr=\"\";var t=[{name:\"ShockwaveFlash.ShockwaveFlash.7\",version:function(e){return n(e)}},{name:\"ShockwaveFlash.ShockwaveFlash.6\",version:function(e){var t=\"6,0,21\";try{e.AllowScriptAccess=\"always\",t=n(e)}catch(r){}return t}},{name:\"ShockwaveFlash.ShockwaveFlash\",version:function(e){return n(e)}}],n=function(e){var t=-1;try{t=e.GetVariable(\"$version\")}catch(n){}return t},r=function(e){var t=-1;try{t=new ActiveXObject(e)}catch(n){t={activeXError:!0}}return t},s=function(e){var t=e.split(\",\");return{raw:e,major:parseInt(t[0].split(\" \")[1],10),minor:parseInt(t[1],10),revision:parseInt(t[2],10),revisionStr:t[2]}},o=function(e){var t=e.split(/ +/),n=t[2].split(/\\./),r=t[3];return{raw:e,major:parseInt(n[0],10),minor:parseInt(n[1],10),revisionStr:r,revision:u(r)}},u=function(t){return parseInt(t.replace(/[a-zA-Z]/g,\"\"),10)||e.revision};e.majorAtLeast=function(t){return e.major>=t},e.minorAtLeast=function(t){return e.minor>=t},e.revisionAtLeast=function(t){return e.revision>=t},e.versionAtLeast=function(t){var n=[e.major,e.minor,e.revision],r=Math.min(n.length,arguments.length);for(i=0;i<r;i++){if(n[i]>=arguments[i]){if(i+1<r&&n[i]==arguments[i])continue;return!0}return!1}},e.FlashDetect=function(){if(navigator.plugins&&navigator.plugins.length>0){var n=\"application/x-shockwave-flash\",i=navigator.mimeTypes;if(i&&i[n]&&i[n].enabledPlugin&&i[n].enabledPlugin.description){var u=i[n].enabledPlugin.description,a=o(u);e.raw=a.raw,e.major=a.major,e.minor=a.minor,e.revisionStr=a.revisionStr,e.revision=a.revision,e.installed=!0}}else if(navigator.appVersion.indexOf(\"Mac\")==-1&&window.execScript){var u=-1;for(var f=0;f<t.length&&u==-1;f++){var l=r(t[f].name);if(!l.activeXError){e.installed=!0,u=t[f].version(l);if(u!=-1){var a=s(u);e.raw=a.raw,e.major=a.major,e.minor=a.minor,e.revision=a.revision,e.revisionStr=a.revisionStr}}}}}()};FlashDetect.JS_RELEASE=\"1.0.4\";",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "dancer.min.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-dancer",
      "url": "/js/dancer.min.js",
      "urls": [
        "/js/dancer.min.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/glt.js",
      "relativePath": "js/glt.js",
      "basename": "glt",
      "outBasename": "glt",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "glt.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/glt.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js",
      "outFilename": "glt.js",
      "relativeOutPath": "js/glt.js",
      "relativeDirPath": "js",
      "relativeOutDirPath": "js",
      "relativeBase": "js/glt",
      "relativeOutBase": "js/glt",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.525Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * Created with JetBrains WebStorm.\n * User: admin\n * Date: 27/08/2013\n * Time: 19:00\n * To change this template use File | Settings | File Templates.\n */\n\n(function(){\n\n    \"use strict\";\n\n    \n    function Mesh(gl, program, vertices, vComponents, indices, texCoordinates, drawMode) {\n        this.gl = gl;\n        this.program = program;\n        this.drawMode = drawMode || gl.TRIANGLES;\n\n        this.vertexBuffer = createArrayBuffer(gl, vertices, vComponents);\n        this.textureCoordBuffer = createArrayBuffer(gl, texCoordinates, 2);\n        this.indexBuffer = createElementArrayBuffer(gl, indices, 1)\n    }\n\n    Mesh.prototype = {\n\n        draw : function() {\n            var gl = this.gl;\n            var program = this.program;\n            \n            gl.useProgram(program);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n            gl.vertexAttribPointer(program.vertexPosAttrib, this.vertexBuffer.numComponents, gl.FLOAT, false, 0, 0);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.textureCoordBuffer);\n            gl.vertexAttribPointer(program.textureCoordAttrib, this.textureCoordBuffer.numComponents, gl.FLOAT, false, 0, 0);\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n            gl.drawElements(this.drawMode, this.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        }   \n\n    }\n\n    function getShader(gl, id) {\n        var shaderScript = document.getElementById(id);\n        if (!shaderScript) {\n            return null;\n        }\n\n        var str = \"\";\n        var k = shaderScript.firstChild;\n        while (k) {\n            if (k.nodeType == 3) {\n                str += k.textContent;\n            }\n            k = k.nextSibling;\n        }\n\n        var shader;\n        if (shaderScript.type == \"x-shader/x-fragment\") {\n            shader = gl.createShader(gl.FRAGMENT_SHADER);\n        } else if (shaderScript.type == \"x-shader/x-vertex\") {\n            shader = gl.createShader(gl.VERTEX_SHADER);\n        } else {\n            return null;\n        }\n\n        gl.shaderSource(shader, str);\n        gl.compileShader(shader);\n\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n            throw new Error('Shader Compilation Error: ' + gl.getShaderInfoLog(shader) );\n            return null;\n        }\n\n        return shader;\n    }\n\n    function createProgram(gl, shaders) {\n        var p = gl.createProgram();\n        gl.attachShader(p, shaders[0]);\n        gl.attachShader(p, shaders[1]);\n        gl.linkProgram(p);\n\n        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {\n            throw new Error('Shader Program Link Error: ' + gl.getProgramInfoLog(p));\n            return null;\n        }\n        return p;\n    }\n\n    function getGL(canvas, options) {\n        var gl;\n        try {\n            gl = canvas.getContext(\"experimental-webgl\", options);\n            gl.viewportWidth = canvas.width;\n            gl.viewportHeight = canvas.height;\n\n\n            return gl\n        } catch (e) {\n        }\n        if (!gl) {\n            throw new Error(\"Could not initialise WebGL\");\n        }\n\n    }\n\n    function screenQuad(gl) {\n        var vertexPosBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);\n        var vertices = [ -1.0,-1.0,\n                    1.0,-1.0,\n                    1.0,1.0,\n                    -1.0,1.0];\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n        vertexPosBuffer.numComponents = 2;\n        vertexPosBuffer.numItems = 4;\n        return vertexPosBuffer;\n    }\n\n    function createArrayBuffer(gl, vertices, components) {\n        var buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n        buffer.numComponents = components;\n        buffer.numItems = vertices.length / components;\n        return buffer;\n    }\n\n    function createElementArrayBuffer(gl, indices, components) {\n        var buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\n        buffer.numComponents = components;\n        buffer.numItems = indices.length / components;\n        return buffer;\n    }\n\n    function createTexture(gl, flipY) {\n        flipY = flipY || false; \n        var t = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, t);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return t;\n    }\n\n    function createStateTexture(gl) {\n        var t = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, t);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return t;\n    }\n\n\n    function raf() {\n\n        window.requestAnimFrame = (function(){\n            return  window.requestAnimationFrame       ||\n                window.webkitRequestAnimationFrame ||\n                window.mozRequestAnimationFrame    ||\n                function( callback ){\n                    window.setTimeout(callback, 1000 / 60);\n                };\n        })();\n    }\n\n    window.glt = {\n\n        Mesh : Mesh,\n\n        compileShader : function(gl, shader) {\n            return getShader(gl, shader);\n        },\n\n        createTexture : function(gl) {\n            return createTexture(gl);\n        },\n\n        createStateTexture : function(gl) {\n            return createStateTexture(gl);\n        },\n\n        createProgram : function(gl, shaders) {\n            return createProgram(gl, shaders);\n        },\n\n        getGL : function(canvas, options) {\n            return getGL(canvas);\n        },\n\n        screenQuad : function(gl) {\n            return screenQuad(gl);\n        },\n\n        createArrayBuffer : function(gl, vertices, components) {\n            return createArrayBuffer(gl, vertices, components);\n        },\n\n        raf : function() {\n            raf();\n        }\n\n\n    }\n\n})()",
      "content": "/**\n * Created with JetBrains WebStorm.\n * User: admin\n * Date: 27/08/2013\n * Time: 19:00\n * To change this template use File | Settings | File Templates.\n */\n\n(function(){\n\n    \"use strict\";\n\n    \n    function Mesh(gl, program, vertices, vComponents, indices, texCoordinates, drawMode) {\n        this.gl = gl;\n        this.program = program;\n        this.drawMode = drawMode || gl.TRIANGLES;\n\n        this.vertexBuffer = createArrayBuffer(gl, vertices, vComponents);\n        this.textureCoordBuffer = createArrayBuffer(gl, texCoordinates, 2);\n        this.indexBuffer = createElementArrayBuffer(gl, indices, 1)\n    }\n\n    Mesh.prototype = {\n\n        draw : function() {\n            var gl = this.gl;\n            var program = this.program;\n            \n            gl.useProgram(program);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n            gl.vertexAttribPointer(program.vertexPosAttrib, this.vertexBuffer.numComponents, gl.FLOAT, false, 0, 0);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.textureCoordBuffer);\n            gl.vertexAttribPointer(program.textureCoordAttrib, this.textureCoordBuffer.numComponents, gl.FLOAT, false, 0, 0);\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n            gl.drawElements(this.drawMode, this.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        }   \n\n    }\n\n    function getShader(gl, id) {\n        var shaderScript = document.getElementById(id);\n        if (!shaderScript) {\n            return null;\n        }\n\n        var str = \"\";\n        var k = shaderScript.firstChild;\n        while (k) {\n            if (k.nodeType == 3) {\n                str += k.textContent;\n            }\n            k = k.nextSibling;\n        }\n\n        var shader;\n        if (shaderScript.type == \"x-shader/x-fragment\") {\n            shader = gl.createShader(gl.FRAGMENT_SHADER);\n        } else if (shaderScript.type == \"x-shader/x-vertex\") {\n            shader = gl.createShader(gl.VERTEX_SHADER);\n        } else {\n            return null;\n        }\n\n        gl.shaderSource(shader, str);\n        gl.compileShader(shader);\n\n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n            throw new Error('Shader Compilation Error: ' + gl.getShaderInfoLog(shader) );\n            return null;\n        }\n\n        return shader;\n    }\n\n    function createProgram(gl, shaders) {\n        var p = gl.createProgram();\n        gl.attachShader(p, shaders[0]);\n        gl.attachShader(p, shaders[1]);\n        gl.linkProgram(p);\n\n        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {\n            throw new Error('Shader Program Link Error: ' + gl.getProgramInfoLog(p));\n            return null;\n        }\n        return p;\n    }\n\n    function getGL(canvas, options) {\n        var gl;\n        try {\n            gl = canvas.getContext(\"experimental-webgl\", options);\n            gl.viewportWidth = canvas.width;\n            gl.viewportHeight = canvas.height;\n\n\n            return gl\n        } catch (e) {\n        }\n        if (!gl) {\n            throw new Error(\"Could not initialise WebGL\");\n        }\n\n    }\n\n    function screenQuad(gl) {\n        var vertexPosBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);\n        var vertices = [ -1.0,-1.0,\n                    1.0,-1.0,\n                    1.0,1.0,\n                    -1.0,1.0];\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n        vertexPosBuffer.numComponents = 2;\n        vertexPosBuffer.numItems = 4;\n        return vertexPosBuffer;\n    }\n\n    function createArrayBuffer(gl, vertices, components) {\n        var buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\n        buffer.numComponents = components;\n        buffer.numItems = vertices.length / components;\n        return buffer;\n    }\n\n    function createElementArrayBuffer(gl, indices, components) {\n        var buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);\n        buffer.numComponents = components;\n        buffer.numItems = indices.length / components;\n        return buffer;\n    }\n\n    function createTexture(gl, flipY) {\n        flipY = flipY || false; \n        var t = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, t);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return t;\n    }\n\n    function createStateTexture(gl) {\n        var t = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, t);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return t;\n    }\n\n\n    function raf() {\n\n        window.requestAnimFrame = (function(){\n            return  window.requestAnimationFrame       ||\n                window.webkitRequestAnimationFrame ||\n                window.mozRequestAnimationFrame    ||\n                function( callback ){\n                    window.setTimeout(callback, 1000 / 60);\n                };\n        })();\n    }\n\n    window.glt = {\n\n        Mesh : Mesh,\n\n        compileShader : function(gl, shader) {\n            return getShader(gl, shader);\n        },\n\n        createTexture : function(gl) {\n            return createTexture(gl);\n        },\n\n        createStateTexture : function(gl) {\n            return createStateTexture(gl);\n        },\n\n        createProgram : function(gl, shaders) {\n            return createProgram(gl, shaders);\n        },\n\n        getGL : function(canvas, options) {\n            return getGL(canvas);\n        },\n\n        screenQuad : function(gl) {\n            return screenQuad(gl);\n        },\n\n        createArrayBuffer : function(gl, vertices, components) {\n            return createArrayBuffer(gl, vertices, components);\n        },\n\n        raf : function() {\n            raf();\n        }\n\n\n    }\n\n})()",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "glt.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-glt",
      "url": "/js/glt.js",
      "urls": [
        "/js/glt.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/lib.js",
      "relativePath": "js/lib.js",
      "basename": "lib",
      "outBasename": "lib",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "lib.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/lib.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js",
      "outFilename": "lib.js",
      "relativeOutPath": "js/lib.js",
      "relativeDirPath": "js",
      "relativeOutDirPath": "js",
      "relativeBase": "js/lib",
      "relativeOutBase": "js/lib",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T22:35:18.000Z",
      "mtime": "2014-12-21T22:35:18.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.531Z",
      "exists": true,
      "encoding": "utf8",
      "source": "var App = function() {\n\n\n\n\t///this.gl = glt.getGL(document.getElementById('canvas'), {alpha:false});\n    this.canvas = new App.CanvasThree();\n\n    this.el = document.getElementById('grid');\n\n    this.items = document.getElementsByClassName('item');\n\n\n    for(var i = 0, l = this.items.length; i < l; ++i ) {\n\n        var item = this.items[i];\n        //item.style.opacity = 1;\n        setTimeout((function(el){\n            el.style.opacity = 1;\n        }).bind(this), i * 300, item);\n    }\n\n\n\n    window.addEventListener('resize', this.resize.bind(this));\n\n\n\n        //document.getElementById('canvas-css').style.left = ((window.innerWidth -1600) * .5) + 'px';\n\n\n\n\n\n\n\n\n\n        this.resize();\n\n}\n\nApp.Main = function() {\n\t//glt.raf();\n\tApp.instance = new App();\n}\n\nApp.prototype = {\n\n    resize : function(e) {\n\n        var w = window.innerWidth;\n        var h = window.innerHeight;\n        var thirdHeight;\n        var padding;\n\n        if(w > h) {\n            padding = h / 100;\n            w = h;\n        } else {\n            padding = w / 100;\n            h = w;\n        }\n\n\n        thirdHeight = h / 3;\n\n        this.el.style.height = h + 'px';\n        this.el.style.width = w + 'px';\n\n        var i = 0, l = this.items.length;\n        var item;\n        for(; i < l; ++i) {\n            item = this.items[i];\n            item.style.height = thirdHeight + 'px'\n            item.style.padding = padding + 'px'\n        }\n\n\n        this.canvas.resize()\n    },\n\n\tcreateCircle : function(x,y,color, scale) {\n\n\t\tvar c = document.createElement('div');\n\t\tc.className = 'circle';\n        c.style.borderColor = color;\n\t\tc.x = x;\n\t\tc.y = y;\n        c.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';\n\t\tc.style.top = \ty+'px';\n\t\tc.style.left = \tx+'px';\n\t\tdocument.getElementById('canvas-css').appendChild(c);\n\t\treturn c;\n\t},\n\n    createDCircle : function(x,y,color, scale) {\n\n        var c = document.createElement('div');\n        c.className = 'circle2';\n        c.style.borderColor = color;\n        c.x = x;\n        c.y = y;\n        c.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';\n        c.style.top = \ty+'px';\n        c.style.left = \tx+'px';\n        document.getElementById('canvas-css').appendChild(c);\n        return c;\n    }\n\n}\n\nApp.CanvasThree = function() {\n\n    //this.dancer = dancer;\n\n    var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;\n    var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;\n\n    this.scene = new THREE.Scene();\n    this.camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);\n    //this.camera = new THREE.OrthographicCamera( SCREEN_WIDTH / - 2, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, SCREEN_HEIGHT / - 2, 1, 1000 );\n    this.controls = new THREE.TrackballControls( this.camera );\n\n    this.scene.add(this.camera);\n    this.camera.position.set(0,0,33.9);\n\n\n\n\n\n\n    this.renderer = new THREE.WebGLRenderer( {antialias:true, alpha:true} );\n\n    this.composer = new THREE.EffectComposer( this.renderer );\n    this.composer.addPass( new THREE.RenderPass( this.scene, this.camera ) );\n\n//    var effect = new THREE.ShaderPass( THREE.DotScreenShader );\n//    effect.uniforms[ 'scale' ].value = 4;\n//    this.composer.addPass( effect );\n//\n//    var effect = new THREE.ShaderPass( THREE.RGBShiftShader );\n//    effect.uniforms[ 'amount' ].value = 0.0015;\n//    effect.renderToScreen = true;\n//    this.composer.addPass( effect );\n\n\n    effect = new THREE.ShaderPass( THREE.DotScreenShader );\n    effect.renderToScreen = true;\n    //this.composer.addPass( effect );\n\n    effect = new THREE.ShaderPass( THREE.VignetteShader );\n    effect.uniforms[ \"darkness\" ].value = .5;\n    effect.renderToScreen = true;\n    this.composer.addPass( effect );\n\n    // create a custom render target with a stencil buffer\n//    // the stencil buffer allows for masking to take place\n//    this.renderTargetParameters = {\n//        minFilter: THREE.LinearFilter,\n//        magFilter: THREE.LinearFilter,\n//        format: THREE.RGBAFormat,\n//        //stencilBuffer: true\n//    };\n//\n//    this.renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, this.renderTargetParameters );\n//    this.composer = new THREE.EffectComposer( this.renderer, this.renderTarget );\n//\n\n\n\n\n    this.cube = new THREE.Mesh(new THREE.CubeGeometry(), new THREE.MeshBasicMaterial());\n    this.cube = new THREE.Mesh( new THREE.CubeGeometry(23, 23, 1), new THREE.MeshNormalMaterial() );\n    //this.cube.position.y = 150;\n\n\n    var r = 13.7;\n    var lineWidth = 3;\n    var lineColor = 0x333333;\n\n\n    this.circleGeometry = new THREE.CircleGeometry(r, 100);\n    this.circleGeometry.vertices.shift();\n\n    this.circle = new THREE.Line(this.circleGeometry, new THREE.LineBasicMaterial({color : lineColor, linewidth : 9}))\n    //this.scene.add(this.circle);\n\n    this.circle = new THREE.Line(this.circleGeometry, new THREE.LineBasicMaterial({color : lineColor, linewidth : lineWidth}))\n    //this.circle.geometry.vertices.shift();\n    this.scene.add(this.circle);\n\n//    this.circle = new THREE.Line(new THREE.CircleGeometry(r, 100), new THREE.LineBasicMaterial({color : 0x333333, linewidth : 3}))\n//    this.circle.position.x = -27.6\n//    this.scene.add(this.circle);\n//    this.circle = new THREE.Line(new THREE.CircleGeometry(r, 100), new THREE.LineBasicMaterial({color : 0x333333, linewidth : 3}))\n//    this.circle.position.x = -r\n//    this.scene.add(this.circle);\n//\n//    this.circle = new THREE.Line(new THREE.CircleGeometry(r, 100), new THREE.LineBasicMaterial({color : 0x333333, linewidth : 3}))\n//    this.circle.position.y = -27.6\n//    this.scene.add(this.circle);\n//\n//    this.circle = new THREE.Line(new THREE.CircleGeometry(r, 100), new THREE.LineBasicMaterial({color : 0x333333, linewidth : 3}))\n//    this.circle.position.y = -27.6\n//    this.circle.position.x = -27.6\n//    this.scene.add(this.circle);\n\n\n\n\n\n\n\n    ////       //////// /////\n\n\n    //var r = 161;\n    var d = Math.sqrt((2*r)*(2*r) - r*r);\n    var d2 = Math.sqrt( (r/2)*(r/2) + (d + d/2) * (d + d/2) );\n    var d3 = Math.sqrt((d/2)*(d/2) + (3*r+r/2) * (3*r+r/2));\n    var d4 = Math.sqrt((d/2)*(d/2) + (4*r+r/2) * (4*r+r/2));\n\n    var dRatio = d2 / d;\n    var rRatio = d / r\n    var r2Ratio = d2 / r\n    var r3Ratio = d3 / r\n    var r2 = 2 * Math.sqrt(r*r - (r/2*r/2));\n    var DEG_60 = 1.04719755;\n    var DEG_30 = 30 * (Math.PI/180) ;\n\n    var delta1 = 2*r/d;\n    var delta2 = 3*r/d2;\n    var delta3 = 4*r/d3;\n\n\n    var alpha1 =  Math.asin((d/2) / d);\n    console.log('ALPHA1', alpha1*180/Math.PI);\n\n    var alpha2 =  Math.asin((d/2) / d2);\n    console.log('ALPHA2', alpha2*180/Math.PI);\n\n    var alpha3 =  Math.asin((d/2) / d3);\n    console.log('ALPHA3', alpha3*180/Math.PI);\n\n    var alpha4 =  Math.asin((d/2) / d4);\n    console.log('ALPHA4', alpha4*180/Math.PI);\n\n\n    for(var j = 0; j < 6; j++) {\n\n\n        this.circle = new THREE.Line(this.circleGeometry, new THREE.LineBasicMaterial({color : lineColor, linewidth : lineWidth}))\n        this.circle.position.x  = + r * Math.cos(j*DEG_60)\n        this.circle.position.y = r * Math.sin(j*DEG_60)\n        //this.circle.geometry.vertices.shift();\n        this.scene.add(this.circle);\n\n        //c = \tthis.createCircle(800 + r * Math.cos(j*DEG_60), 535 + r * Math.sin(j*DEG_60));\n    }\n\n\n    for(var j = 0; j < 6; j++) {\n\n        this.circle = new THREE.Line(this.circleGeometry, new THREE.LineBasicMaterial({color : lineColor, linewidth : lineWidth}))\n        this.circle.position.x  = d * Math.cos(j*DEG_60 + DEG_30)\n        this.circle.position.y = d * Math.sin(j*DEG_60 + DEG_30)\n\n        this.scene.add(this.circle);\n\n    }\n\n\n\n    for(var j = 0; j < 6; j++) {\n        this.circle = new THREE.Line(this.circleGeometry, new THREE.LineBasicMaterial({color : lineColor, linewidth : lineWidth}))\n        this.circle.position.x  = r*2 * Math.cos(j*DEG_60)\n        this.circle.position.y = r*2 * Math.sin(j*DEG_60)\n        //this.circle.geometry.vertices.shift();\n        this.scene.add(this.circle);\n\n    }\n\n\n    //var wave = this.dancer.getWaveform();\n    var vertices = this.circleGeometry.vertices;\n    var  i = 0, l = vertices.length;\n\n    for(; i < l; ++i) {\n        vertices[i]._x = vertices[i].x;\n    }\n\n\n\n\n    this.renderer.render( this.scene, this.camera );\n\n    document.getElementById('canvas-three').appendChild(this.renderer.domElement);\n\n    this.startTime = 0.0;\n\n    this.animate();\n\n\n\n    var debugaxis = function(context, axisLength){\n\n        var self = context;\n        //Shorten the vertex function\n        function v(x,y,z){\n            return new THREE.Vertex(new THREE.Vector3(x,y,z));\n        }\n\n        //Create axis (point1, point2, colour)\n        function createAxis(p1, p2, color){\n            var line, lineGeometry = new THREE.Geometry(),\n                lineMat = new THREE.LineBasicMaterial({color: color, lineWidth: 1});\n            lineGeometry.vertices.push(p1, p2);\n            line = new THREE.Line(lineGeometry, lineMat);\n            self.scene.add(line);\n        }\n\n        createAxis(v(-axisLength, 0, 0), v(axisLength, 0, 0), 0xFF0000);\n        createAxis(v(0, -axisLength, 0), v(0, axisLength, 0), 0x00FF00);\n        createAxis(v(0, 0, -axisLength), v(0, 0, axisLength), 0x0000FF);\n    };\n\n   // debugaxis(this, 100)\n\n\n}\n\nApp.CanvasThree.prototype = {\n\n    resize : function() {\n\n\n\n        var width, height;\n        width = window.innerWidth; // for example\n        height = window.innerHeight; // for example\n\n        //First update the camera's aspect ratio: width / height\n        this.camera.aspect = width/height;\n\n        //Whenever you make a change to the camera,\n        //you must update for your changes to take effect\n        this.camera.updateProjectionMatrix();\n\n        //Here we reset the size of the window to the new height\n        this.renderer.setSize(width, height);\n\n        document.getElementById('items').style.width\n\n        this.renderer.render( this.scene, this.camera );\n    },\n\n    animate : function () {\n        // render the 3D scene\n\n        this.controls.update();\n        this.render();\n        // relaunch the 'timer'\n        requestAnimationFrame( this.animate.bind(this) );\n\n\n    },\n\n    render: function() {\n        this.cube.position.x = -24.5;\n        //this.cube.position.y = -25;\n        this.cube.position.z = 11.5;\n        // make the cube bounce\n        var dtime\t= Date.now() - this.startTime;\n\n        if(this.rotate) {\n           this.camera.rotateCamera\n        }\n\n\n        //var wave = this.dancer.getWaveform();\n        var vertices = this.circleGeometry.vertices;\n        var  i = 0, l = vertices.length;\n\n        for(; i < l; ++i) {\n            vertices[i].x = vertices[i]._x + wave[i];\n        }\n\n        this.circleGeometry.dynamic = true;\n        //this.circleGeometry.computeFaceNormals();\n        //this.circleGeometry.computeVertexNormals();\n        this.circleGeometry.verticesNeedUpdate = true;\n        //this.circleGeometry.normalsNeedUpdate = true;\n\n\n        //cube.scale.x\t= 1.0 + 0.3*Math.sin(dtime/300);\n        //cube.scale.y\t= 1.0 + 0.3*Math.sin(dtime/300);\n        //cube.scale.z\t= 1.0 + 0.3*Math.sin(dtime/300);\n        // actually display the scene in the Dom element\n        this.composer.render(1000);\n        //this.renderer.render( this.scene, this.camera );\n    }\n\n}\n\nApp.CanvasCSS = function() {\n    var r = 161;\n    var d = Math.sqrt((2*r)*(2*r) - r*r);\n    var d2 = Math.sqrt( (r/2)*(r/2) + (d + d/2) * (d + d/2) );\n    var d3 = Math.sqrt((d/2)*(d/2) + (3*r+r/2) * (3*r+r/2));\n    var d4 = Math.sqrt((d/2)*(d/2) + (4*r+r/2) * (4*r+r/2));\n\n    var dRatio = d2 / d;\n    var rRatio = d / r\n    var r2Ratio = d2 / r\n    var r3Ratio = d3 / r\n    var r2 = 2 * Math.sqrt(r*r - (r/2*r/2));\n    var DEG_60 = 1.04719755;\n    var DEG_30 = 30 * (Math.PI/180) ;\n\n    var delta1 = 2*r/d;\n    var delta2 = 3*r/d2;\n    var delta3 = 4*r/d3;\n\n\n    var alpha1 =  Math.asin((d/2) / d);\n    console.log('ALPHA1', alpha1*180/Math.PI);\n\n    var alpha2 =  Math.asin((d/2) / d2);\n    console.log('ALPHA2', alpha2*180/Math.PI);\n\n    var alpha3 =  Math.asin((d/2) / d3);\n    console.log('ALPHA3', alpha3*180/Math.PI);\n\n    var alpha4 =  Math.asin((d/2) / d4);\n    console.log('ALPHA4', alpha4*180/Math.PI);\n\n    console.log('DELTAS', delta1, delta2, delta3)\n\n    console.log('DELTA of DELTAS', delta1-delta2, delta2- delta3)\n\n    console.log('d', d);\n    console.log('d2', d2)\n    console.log('dRAT/iO', dRatio)\n    console.log('rRAT/iO', rRatio);\n    console.log('r2RAT/iO', r2Ratio)\n    console.log('r3RAT/iO', r3Ratio)\n    console.log('DELTA of RATIOS', r2Ratio-rRatio, r3Ratio-r2Ratio)\n    var circles = [];\n\n\n\n    c = this.createDCircle(800, 535, 'black', 2);\n\n    c = this.createDCircle(800, 535, 'green', rRatio);\n\n\n\n    c = this.createDCircle(800, 535, 'green', r2Ratio);\n    c = this.createDCircle(800, 535, 'black', 3);\n\n    c = this.createDCircle(800, 535, 'green', r3Ratio);\n    c = this.createDCircle(800, 535, 'blue', rRatio);\n    c = this.createDCircle(800, 535, 'black', 4);\n\n\n\n\n\n\n\n\n\n    for(var i=0; i < 6; i++) {\n\n        var c;\n\n        switch(i) {\n            case 0 :\n                c = this.createCircle(800, 535);\n                circles.push(c);\n                break;\n\n            case 1 :\n                for(var j = 0; j < 6; j++) {\n                    c = \tthis.createCircle(800 + r * Math.cos(j*DEG_60), 535 + r * Math.sin(j*DEG_60));\n                    circles.push(c);\n                }\n\n\n\n                break;\n//\n            case 2 :\n                for(var j = 0; j < 6; j++) {\n                    c = \tthis.createCircle(800 + d * Math.cos(j*DEG_60 + DEG_30), 535 + d * Math.sin(j*DEG_60 + DEG_30));\n                    circles.push(c);\n                }\n\n\n\n                break;\n            case 3 :\n                for(var j = 0; j < 6; j++) {\n                    c = this.createCircle(800 + r*2 * Math.cos(j*DEG_60), 535 + r*2 * Math.sin(j*DEG_60));\n                    circles.push(c);\n                }\n\n\n\n                break;\n////\n            case 4 :\n                var angle = alpha2\n                for(var j = 0; j < 6; j++) {\n                    //if(2 % j == 0) angle += DEG_60;\n\n                    c = this.createCircle(800 + d2  * Math.cos(angle), 535 + d2  * Math.sin(angle));\n                    angle += (DEG_60)\n                    circles.push(c);\n                }\n\n                angle = -alpha2;\n\n                for(var j = 0; j < 6; j++) {\n                    //if(2 % j == 0) angle += DEG_60;\n\n                    c = this.createCircle(800 + d2  * Math.cos(angle), 535 + d2  * Math.sin(angle));\n                    angle += (DEG_60)\n                    circles.push(c);\n                }\n\n                break;\n            case 5 :\n                for(var j = 0; j < 6; j++) {\n                    c = this.createCircle(800 + (r*3) * Math.cos(j*DEG_60), 535 + (r*3) * Math.sin(j*DEG_60));\n                    circles.push(c);\n                }\n\n            case 6 :\n                var angle = alpha3\n                for(var j = 0; j < 6; j++) {\n                    //if(2 % j == 0) angle += DEG_60;\n\n                    c = this.createCircle(800 + d3  * Math.cos(angle), 535 + d3  * Math.sin(angle), 'red');\n                    angle += (DEG_60)\n                    circles.push(c);\n                }\n\n                angle = -alpha3;\n\n                for(var j = 0; j < 6; j++) {\n                    //if(2 % j == 0) angle += DEG_60;\n\n                    c = this.createCircle(800 + d3  * Math.cos(angle), 535 + d3  * Math.sin(angle), 'red');\n                    angle += (DEG_60)\n                    circles.push(c);\n                }\n\n            case 5 :\n                for(var j = 0; j < 6; j++) {\n                    c = this.createCircle(800 + (r*4) * Math.cos(j*DEG_60), 535 + (r*4) * Math.sin(j*DEG_60));\n                    circles.push(c);\n                }\n//\n//\n//\n//\t\t\tbreak;\n        }\n\n\n\n    }\n\n}\n\n",
      "content": "var App = function() {\n\n\n\n\t///this.gl = glt.getGL(document.getElementById('canvas'), {alpha:false});\n    this.canvas = new App.CanvasThree();\n\n    this.el = document.getElementById('grid');\n\n    this.items = document.getElementsByClassName('item');\n\n\n    for(var i = 0, l = this.items.length; i < l; ++i ) {\n\n        var item = this.items[i];\n        //item.style.opacity = 1;\n        setTimeout((function(el){\n            el.style.opacity = 1;\n        }).bind(this), i * 300, item);\n    }\n\n\n\n    window.addEventListener('resize', this.resize.bind(this));\n\n\n\n        //document.getElementById('canvas-css').style.left = ((window.innerWidth -1600) * .5) + 'px';\n\n\n\n\n\n\n\n\n\n        this.resize();\n\n}\n\nApp.Main = function() {\n\t//glt.raf();\n\tApp.instance = new App();\n}\n\nApp.prototype = {\n\n    resize : function(e) {\n\n        var w = window.innerWidth;\n        var h = window.innerHeight;\n        var thirdHeight;\n        var padding;\n\n        if(w > h) {\n            padding = h / 100;\n            w = h;\n        } else {\n            padding = w / 100;\n            h = w;\n        }\n\n\n        thirdHeight = h / 3;\n\n        this.el.style.height = h + 'px';\n        this.el.style.width = w + 'px';\n\n        var i = 0, l = this.items.length;\n        var item;\n        for(; i < l; ++i) {\n            item = this.items[i];\n            item.style.height = thirdHeight + 'px'\n            item.style.padding = padding + 'px'\n        }\n\n\n        this.canvas.resize()\n    },\n\n\tcreateCircle : function(x,y,color, scale) {\n\n\t\tvar c = document.createElement('div');\n\t\tc.className = 'circle';\n        c.style.borderColor = color;\n\t\tc.x = x;\n\t\tc.y = y;\n        c.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';\n\t\tc.style.top = \ty+'px';\n\t\tc.style.left = \tx+'px';\n\t\tdocument.getElementById('canvas-css').appendChild(c);\n\t\treturn c;\n\t},\n\n    createDCircle : function(x,y,color, scale) {\n\n        var c = document.createElement('div');\n        c.className = 'circle2';\n        c.style.borderColor = color;\n        c.x = x;\n        c.y = y;\n        c.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';\n        c.style.top = \ty+'px';\n        c.style.left = \tx+'px';\n        document.getElementById('canvas-css').appendChild(c);\n        return c;\n    }\n\n}\n\nApp.CanvasThree = function() {\n\n    //this.dancer = dancer;\n\n    var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;\n    var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;\n\n    this.scene = new THREE.Scene();\n    this.camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);\n    //this.camera = new THREE.OrthographicCamera( SCREEN_WIDTH / - 2, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2, SCREEN_HEIGHT / - 2, 1, 1000 );\n    this.controls = new THREE.TrackballControls( this.camera );\n\n    this.scene.add(this.camera);\n    this.camera.position.set(0,0,33.9);\n\n\n\n\n\n\n    this.renderer = new THREE.WebGLRenderer( {antialias:true, alpha:true} );\n\n    this.composer = new THREE.EffectComposer( this.renderer );\n    this.composer.addPass( new THREE.RenderPass( this.scene, this.camera ) );\n\n//    var effect = new THREE.ShaderPass( THREE.DotScreenShader );\n//    effect.uniforms[ 'scale' ].value = 4;\n//    this.composer.addPass( effect );\n//\n//    var effect = new THREE.ShaderPass( THREE.RGBShiftShader );\n//    effect.uniforms[ 'amount' ].value = 0.0015;\n//    effect.renderToScreen = true;\n//    this.composer.addPass( effect );\n\n\n    effect = new THREE.ShaderPass( THREE.DotScreenShader );\n    effect.renderToScreen = true;\n    //this.composer.addPass( effect );\n\n    effect = new THREE.ShaderPass( THREE.VignetteShader );\n    effect.uniforms[ \"darkness\" ].value = .5;\n    effect.renderToScreen = true;\n    this.composer.addPass( effect );\n\n    // create a custom render target with a stencil buffer\n//    // the stencil buffer allows for masking to take place\n//    this.renderTargetParameters = {\n//        minFilter: THREE.LinearFilter,\n//        magFilter: THREE.LinearFilter,\n//        format: THREE.RGBAFormat,\n//        //stencilBuffer: true\n//    };\n//\n//    this.renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, this.renderTargetParameters );\n//    this.composer = new THREE.EffectComposer( this.renderer, this.renderTarget );\n//\n\n\n\n\n    this.cube = new THREE.Mesh(new THREE.CubeGeometry(), new THREE.MeshBasicMaterial());\n    this.cube = new THREE.Mesh( new THREE.CubeGeometry(23, 23, 1), new THREE.MeshNormalMaterial() );\n    //this.cube.position.y = 150;\n\n\n    var r = 13.7;\n    var lineWidth = 3;\n    var lineColor = 0x333333;\n\n\n    this.circleGeometry = new THREE.CircleGeometry(r, 100);\n    this.circleGeometry.vertices.shift();\n\n    this.circle = new THREE.Line(this.circleGeometry, new THREE.LineBasicMaterial({color : lineColor, linewidth : 9}))\n    //this.scene.add(this.circle);\n\n    this.circle = new THREE.Line(this.circleGeometry, new THREE.LineBasicMaterial({color : lineColor, linewidth : lineWidth}))\n    //this.circle.geometry.vertices.shift();\n    this.scene.add(this.circle);\n\n//    this.circle = new THREE.Line(new THREE.CircleGeometry(r, 100), new THREE.LineBasicMaterial({color : 0x333333, linewidth : 3}))\n//    this.circle.position.x = -27.6\n//    this.scene.add(this.circle);\n//    this.circle = new THREE.Line(new THREE.CircleGeometry(r, 100), new THREE.LineBasicMaterial({color : 0x333333, linewidth : 3}))\n//    this.circle.position.x = -r\n//    this.scene.add(this.circle);\n//\n//    this.circle = new THREE.Line(new THREE.CircleGeometry(r, 100), new THREE.LineBasicMaterial({color : 0x333333, linewidth : 3}))\n//    this.circle.position.y = -27.6\n//    this.scene.add(this.circle);\n//\n//    this.circle = new THREE.Line(new THREE.CircleGeometry(r, 100), new THREE.LineBasicMaterial({color : 0x333333, linewidth : 3}))\n//    this.circle.position.y = -27.6\n//    this.circle.position.x = -27.6\n//    this.scene.add(this.circle);\n\n\n\n\n\n\n\n    ////       //////// /////\n\n\n    //var r = 161;\n    var d = Math.sqrt((2*r)*(2*r) - r*r);\n    var d2 = Math.sqrt( (r/2)*(r/2) + (d + d/2) * (d + d/2) );\n    var d3 = Math.sqrt((d/2)*(d/2) + (3*r+r/2) * (3*r+r/2));\n    var d4 = Math.sqrt((d/2)*(d/2) + (4*r+r/2) * (4*r+r/2));\n\n    var dRatio = d2 / d;\n    var rRatio = d / r\n    var r2Ratio = d2 / r\n    var r3Ratio = d3 / r\n    var r2 = 2 * Math.sqrt(r*r - (r/2*r/2));\n    var DEG_60 = 1.04719755;\n    var DEG_30 = 30 * (Math.PI/180) ;\n\n    var delta1 = 2*r/d;\n    var delta2 = 3*r/d2;\n    var delta3 = 4*r/d3;\n\n\n    var alpha1 =  Math.asin((d/2) / d);\n    console.log('ALPHA1', alpha1*180/Math.PI);\n\n    var alpha2 =  Math.asin((d/2) / d2);\n    console.log('ALPHA2', alpha2*180/Math.PI);\n\n    var alpha3 =  Math.asin((d/2) / d3);\n    console.log('ALPHA3', alpha3*180/Math.PI);\n\n    var alpha4 =  Math.asin((d/2) / d4);\n    console.log('ALPHA4', alpha4*180/Math.PI);\n\n\n    for(var j = 0; j < 6; j++) {\n\n\n        this.circle = new THREE.Line(this.circleGeometry, new THREE.LineBasicMaterial({color : lineColor, linewidth : lineWidth}))\n        this.circle.position.x  = + r * Math.cos(j*DEG_60)\n        this.circle.position.y = r * Math.sin(j*DEG_60)\n        //this.circle.geometry.vertices.shift();\n        this.scene.add(this.circle);\n\n        //c = \tthis.createCircle(800 + r * Math.cos(j*DEG_60), 535 + r * Math.sin(j*DEG_60));\n    }\n\n\n    for(var j = 0; j < 6; j++) {\n\n        this.circle = new THREE.Line(this.circleGeometry, new THREE.LineBasicMaterial({color : lineColor, linewidth : lineWidth}))\n        this.circle.position.x  = d * Math.cos(j*DEG_60 + DEG_30)\n        this.circle.position.y = d * Math.sin(j*DEG_60 + DEG_30)\n\n        this.scene.add(this.circle);\n\n    }\n\n\n\n    for(var j = 0; j < 6; j++) {\n        this.circle = new THREE.Line(this.circleGeometry, new THREE.LineBasicMaterial({color : lineColor, linewidth : lineWidth}))\n        this.circle.position.x  = r*2 * Math.cos(j*DEG_60)\n        this.circle.position.y = r*2 * Math.sin(j*DEG_60)\n        //this.circle.geometry.vertices.shift();\n        this.scene.add(this.circle);\n\n    }\n\n\n    //var wave = this.dancer.getWaveform();\n    var vertices = this.circleGeometry.vertices;\n    var  i = 0, l = vertices.length;\n\n    for(; i < l; ++i) {\n        vertices[i]._x = vertices[i].x;\n    }\n\n\n\n\n    this.renderer.render( this.scene, this.camera );\n\n    document.getElementById('canvas-three').appendChild(this.renderer.domElement);\n\n    this.startTime = 0.0;\n\n    this.animate();\n\n\n\n    var debugaxis = function(context, axisLength){\n\n        var self = context;\n        //Shorten the vertex function\n        function v(x,y,z){\n            return new THREE.Vertex(new THREE.Vector3(x,y,z));\n        }\n\n        //Create axis (point1, point2, colour)\n        function createAxis(p1, p2, color){\n            var line, lineGeometry = new THREE.Geometry(),\n                lineMat = new THREE.LineBasicMaterial({color: color, lineWidth: 1});\n            lineGeometry.vertices.push(p1, p2);\n            line = new THREE.Line(lineGeometry, lineMat);\n            self.scene.add(line);\n        }\n\n        createAxis(v(-axisLength, 0, 0), v(axisLength, 0, 0), 0xFF0000);\n        createAxis(v(0, -axisLength, 0), v(0, axisLength, 0), 0x00FF00);\n        createAxis(v(0, 0, -axisLength), v(0, 0, axisLength), 0x0000FF);\n    };\n\n   // debugaxis(this, 100)\n\n\n}\n\nApp.CanvasThree.prototype = {\n\n    resize : function() {\n\n\n\n        var width, height;\n        width = window.innerWidth; // for example\n        height = window.innerHeight; // for example\n\n        //First update the camera's aspect ratio: width / height\n        this.camera.aspect = width/height;\n\n        //Whenever you make a change to the camera,\n        //you must update for your changes to take effect\n        this.camera.updateProjectionMatrix();\n\n        //Here we reset the size of the window to the new height\n        this.renderer.setSize(width, height);\n\n        document.getElementById('items').style.width\n\n        this.renderer.render( this.scene, this.camera );\n    },\n\n    animate : function () {\n        // render the 3D scene\n\n        this.controls.update();\n        this.render();\n        // relaunch the 'timer'\n        requestAnimationFrame( this.animate.bind(this) );\n\n\n    },\n\n    render: function() {\n        this.cube.position.x = -24.5;\n        //this.cube.position.y = -25;\n        this.cube.position.z = 11.5;\n        // make the cube bounce\n        var dtime\t= Date.now() - this.startTime;\n\n        if(this.rotate) {\n           this.camera.rotateCamera\n        }\n\n\n        //var wave = this.dancer.getWaveform();\n        var vertices = this.circleGeometry.vertices;\n        var  i = 0, l = vertices.length;\n\n        for(; i < l; ++i) {\n            vertices[i].x = vertices[i]._x + wave[i];\n        }\n\n        this.circleGeometry.dynamic = true;\n        //this.circleGeometry.computeFaceNormals();\n        //this.circleGeometry.computeVertexNormals();\n        this.circleGeometry.verticesNeedUpdate = true;\n        //this.circleGeometry.normalsNeedUpdate = true;\n\n\n        //cube.scale.x\t= 1.0 + 0.3*Math.sin(dtime/300);\n        //cube.scale.y\t= 1.0 + 0.3*Math.sin(dtime/300);\n        //cube.scale.z\t= 1.0 + 0.3*Math.sin(dtime/300);\n        // actually display the scene in the Dom element\n        this.composer.render(1000);\n        //this.renderer.render( this.scene, this.camera );\n    }\n\n}\n\nApp.CanvasCSS = function() {\n    var r = 161;\n    var d = Math.sqrt((2*r)*(2*r) - r*r);\n    var d2 = Math.sqrt( (r/2)*(r/2) + (d + d/2) * (d + d/2) );\n    var d3 = Math.sqrt((d/2)*(d/2) + (3*r+r/2) * (3*r+r/2));\n    var d4 = Math.sqrt((d/2)*(d/2) + (4*r+r/2) * (4*r+r/2));\n\n    var dRatio = d2 / d;\n    var rRatio = d / r\n    var r2Ratio = d2 / r\n    var r3Ratio = d3 / r\n    var r2 = 2 * Math.sqrt(r*r - (r/2*r/2));\n    var DEG_60 = 1.04719755;\n    var DEG_30 = 30 * (Math.PI/180) ;\n\n    var delta1 = 2*r/d;\n    var delta2 = 3*r/d2;\n    var delta3 = 4*r/d3;\n\n\n    var alpha1 =  Math.asin((d/2) / d);\n    console.log('ALPHA1', alpha1*180/Math.PI);\n\n    var alpha2 =  Math.asin((d/2) / d2);\n    console.log('ALPHA2', alpha2*180/Math.PI);\n\n    var alpha3 =  Math.asin((d/2) / d3);\n    console.log('ALPHA3', alpha3*180/Math.PI);\n\n    var alpha4 =  Math.asin((d/2) / d4);\n    console.log('ALPHA4', alpha4*180/Math.PI);\n\n    console.log('DELTAS', delta1, delta2, delta3)\n\n    console.log('DELTA of DELTAS', delta1-delta2, delta2- delta3)\n\n    console.log('d', d);\n    console.log('d2', d2)\n    console.log('dRAT/iO', dRatio)\n    console.log('rRAT/iO', rRatio);\n    console.log('r2RAT/iO', r2Ratio)\n    console.log('r3RAT/iO', r3Ratio)\n    console.log('DELTA of RATIOS', r2Ratio-rRatio, r3Ratio-r2Ratio)\n    var circles = [];\n\n\n\n    c = this.createDCircle(800, 535, 'black', 2);\n\n    c = this.createDCircle(800, 535, 'green', rRatio);\n\n\n\n    c = this.createDCircle(800, 535, 'green', r2Ratio);\n    c = this.createDCircle(800, 535, 'black', 3);\n\n    c = this.createDCircle(800, 535, 'green', r3Ratio);\n    c = this.createDCircle(800, 535, 'blue', rRatio);\n    c = this.createDCircle(800, 535, 'black', 4);\n\n\n\n\n\n\n\n\n\n    for(var i=0; i < 6; i++) {\n\n        var c;\n\n        switch(i) {\n            case 0 :\n                c = this.createCircle(800, 535);\n                circles.push(c);\n                break;\n\n            case 1 :\n                for(var j = 0; j < 6; j++) {\n                    c = \tthis.createCircle(800 + r * Math.cos(j*DEG_60), 535 + r * Math.sin(j*DEG_60));\n                    circles.push(c);\n                }\n\n\n\n                break;\n//\n            case 2 :\n                for(var j = 0; j < 6; j++) {\n                    c = \tthis.createCircle(800 + d * Math.cos(j*DEG_60 + DEG_30), 535 + d * Math.sin(j*DEG_60 + DEG_30));\n                    circles.push(c);\n                }\n\n\n\n                break;\n            case 3 :\n                for(var j = 0; j < 6; j++) {\n                    c = this.createCircle(800 + r*2 * Math.cos(j*DEG_60), 535 + r*2 * Math.sin(j*DEG_60));\n                    circles.push(c);\n                }\n\n\n\n                break;\n////\n            case 4 :\n                var angle = alpha2\n                for(var j = 0; j < 6; j++) {\n                    //if(2 % j == 0) angle += DEG_60;\n\n                    c = this.createCircle(800 + d2  * Math.cos(angle), 535 + d2  * Math.sin(angle));\n                    angle += (DEG_60)\n                    circles.push(c);\n                }\n\n                angle = -alpha2;\n\n                for(var j = 0; j < 6; j++) {\n                    //if(2 % j == 0) angle += DEG_60;\n\n                    c = this.createCircle(800 + d2  * Math.cos(angle), 535 + d2  * Math.sin(angle));\n                    angle += (DEG_60)\n                    circles.push(c);\n                }\n\n                break;\n            case 5 :\n                for(var j = 0; j < 6; j++) {\n                    c = this.createCircle(800 + (r*3) * Math.cos(j*DEG_60), 535 + (r*3) * Math.sin(j*DEG_60));\n                    circles.push(c);\n                }\n\n            case 6 :\n                var angle = alpha3\n                for(var j = 0; j < 6; j++) {\n                    //if(2 % j == 0) angle += DEG_60;\n\n                    c = this.createCircle(800 + d3  * Math.cos(angle), 535 + d3  * Math.sin(angle), 'red');\n                    angle += (DEG_60)\n                    circles.push(c);\n                }\n\n                angle = -alpha3;\n\n                for(var j = 0; j < 6; j++) {\n                    //if(2 % j == 0) angle += DEG_60;\n\n                    c = this.createCircle(800 + d3  * Math.cos(angle), 535 + d3  * Math.sin(angle), 'red');\n                    angle += (DEG_60)\n                    circles.push(c);\n                }\n\n            case 5 :\n                for(var j = 0; j < 6; j++) {\n                    c = this.createCircle(800 + (r*4) * Math.cos(j*DEG_60), 535 + (r*4) * Math.sin(j*DEG_60));\n                    circles.push(c);\n                }\n//\n//\n//\n//\t\t\tbreak;\n        }\n\n\n\n    }\n\n}\n\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "lib.js",
      "date": "2014-12-21T22:35:18.000Z",
      "slug": "js-lib",
      "url": "/js/lib.js",
      "urls": [
        "/js/lib.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/processing-1.4.1.js",
      "relativePath": "js/processing-1.4.1.js",
      "basename": "processing-1",
      "outBasename": "processing-1",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "4",
        "1",
        "js"
      ],
      "filename": "processing-1.4.1.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/processing-1.4.1.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js",
      "outFilename": "processing-1.4.1.js",
      "relativeOutPath": "js/processing-1.4.1.js",
      "relativeDirPath": "js",
      "relativeOutDirPath": "js",
      "relativeBase": "js/processing-1",
      "relativeOutBase": "js/processing-1",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.541Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/***\n\n    P R O C E S S I N G . J S - 1.4.1\n    a port of the Processing visualization language\n\n    Processing.js is licensed under the MIT License, see LICENSE.\n    For a list of copyright holders, please refer to AUTHORS.\n\n    http://processingjs.org\n\n***/\n\n(function(D,d,q,t){var G=function(){};var s=function(){if(\"console\" in D){return function(N){D.console.log(\"Processing.js: \"+N)}}return G}();var w=function(N){var O=new XMLHttpRequest;O.open(\"GET\",N,false);if(O.overrideMimeType){O.overrideMimeType(\"text/plain\")}O.setRequestHeader(\"If-Modified-Since\",\"Fri, 01 Jan 1960 00:00:00 GMT\");O.send(null);if(O.status!==200&&O.status!==0){throw\"XMLHttpRequest failed, status code \"+O.status}return O.responseText};var n=\"document\" in this&&!(\"fake\" in this.document);d.head=d.head||d.getElementsByTagName(\"head\")[0];function C(N,O){if(N in D){return D[N]}if(typeof D[O]===\"function\"){return D[O]}return function(Q){if(Q instanceof Array){return Q}if(typeof Q===\"number\"){var P=[];P.length=Q;return P}}}if(d.documentMode>=9&&!d.doctype){throw\"The doctype directive is missing. The recommended doctype in Internet Explorer is the HTML5 doctype: <!DOCTYPE html>\"}var e=C(\"Float32Array\",\"WebGLFloatArray\"),K=C(\"Int32Array\",\"WebGLIntArray\"),y=C(\"Uint16Array\",\"WebGLUnsignedShortArray\"),b=C(\"Uint8Array\",\"WebGLUnsignedByteArray\");var B={X:0,Y:1,Z:2,R:3,G:4,B:5,A:6,U:7,V:8,NX:9,NY:10,NZ:11,EDGE:12,SR:13,SG:14,SB:15,SA:16,SW:17,TX:18,TY:19,TZ:20,VX:21,VY:22,VZ:23,VW:24,AR:25,AG:26,AB:27,DR:3,DG:4,DB:5,DA:6,SPR:28,SPG:29,SPB:30,SHINE:31,ER:32,EG:33,EB:34,BEEN_LIT:35,VERTEX_FIELD_COUNT:36,P2D:1,JAVA2D:1,WEBGL:2,P3D:2,OPENGL:2,PDF:0,DXF:0,OTHER:0,WINDOWS:1,MAXOSX:2,LINUX:3,EPSILON:0.0001,MAX_FLOAT:3.4028235e+38,MIN_FLOAT:-3.4028235e+38,MAX_INT:2147483647,MIN_INT:-2147483648,PI:q.PI,TWO_PI:2*q.PI,HALF_PI:q.PI/2,THIRD_PI:q.PI/3,QUARTER_PI:q.PI/4,DEG_TO_RAD:q.PI/180,RAD_TO_DEG:180/q.PI,WHITESPACE:\" \\t\\n\\r\\u000c\\u00a0\",RGB:1,ARGB:2,HSB:3,ALPHA:4,CMYK:5,TIFF:0,TARGA:1,JPEG:2,GIF:3,BLUR:11,GRAY:12,INVERT:13,OPAQUE:14,POSTERIZE:15,THRESHOLD:16,ERODE:17,DILATE:18,REPLACE:0,BLEND:1<<0,ADD:1<<1,SUBTRACT:1<<2,LIGHTEST:1<<3,DARKEST:1<<4,DIFFERENCE:1<<5,EXCLUSION:1<<6,MULTIPLY:1<<7,SCREEN:1<<8,OVERLAY:1<<9,HARD_LIGHT:1<<10,SOFT_LIGHT:1<<11,DODGE:1<<12,BURN:1<<13,ALPHA_MASK:4278190080,RED_MASK:16711680,GREEN_MASK:65280,BLUE_MASK:255,CUSTOM:0,ORTHOGRAPHIC:2,PERSPECTIVE:3,POINT:2,POINTS:2,LINE:4,LINES:4,TRIANGLE:8,TRIANGLES:9,TRIANGLE_STRIP:10,TRIANGLE_FAN:11,QUAD:16,QUADS:16,QUAD_STRIP:17,POLYGON:20,PATH:21,RECT:30,ELLIPSE:31,ARC:32,SPHERE:40,BOX:41,GROUP:0,PRIMITIVE:1,GEOMETRY:3,VERTEX:0,BEZIER_VERTEX:1,CURVE_VERTEX:2,BREAK:3,CLOSESHAPE:4,OPEN:1,CLOSE:2,CORNER:0,CORNERS:1,RADIUS:2,CENTER_RADIUS:2,CENTER:3,DIAMETER:3,CENTER_DIAMETER:3,BASELINE:0,TOP:101,BOTTOM:102,NORMAL:1,NORMALIZED:1,IMAGE:2,MODEL:4,SHAPE:5,SQUARE:\"butt\",ROUND:\"round\",PROJECT:\"square\",MITER:\"miter\",BEVEL:\"bevel\",AMBIENT:0,DIRECTIONAL:1,SPOT:3,BACKSPACE:8,TAB:9,ENTER:10,RETURN:13,ESC:27,DELETE:127,CODED:65535,SHIFT:16,CONTROL:17,ALT:18,CAPSLK:20,PGUP:33,PGDN:34,END:35,HOME:36,LEFT:37,UP:38,RIGHT:39,DOWN:40,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,NUMLK:144,META:157,INSERT:155,ARROW:\"default\",CROSS:\"crosshair\",HAND:\"pointer\",MOVE:\"move\",TEXT:\"text\",WAIT:\"wait\",NOCURSOR:\"url('data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto\",DISABLE_OPENGL_2X_SMOOTH:1,ENABLE_OPENGL_2X_SMOOTH:-1,ENABLE_OPENGL_4X_SMOOTH:2,ENABLE_NATIVE_FONTS:3,DISABLE_DEPTH_TEST:4,ENABLE_DEPTH_TEST:-4,ENABLE_DEPTH_SORT:5,DISABLE_DEPTH_SORT:-5,DISABLE_OPENGL_ERROR_REPORT:6,ENABLE_OPENGL_ERROR_REPORT:-6,ENABLE_ACCURATE_TEXTURES:7,DISABLE_ACCURATE_TEXTURES:-7,HINT_COUNT:10,SINCOS_LENGTH:720,PRECISIONB:15,PRECISIONF:1<<15,PREC_MAXVAL:(1<<15)-1,PREC_ALPHA_SHIFT:24-15,PREC_RED_SHIFT:16-15,NORMAL_MODE_AUTO:0,NORMAL_MODE_SHAPE:1,NORMAL_MODE_VERTEX:2,MAX_LIGHTS:8};function h(P){if(typeof P===\"string\"){var O=0;for(var N=0;N<P.length;++N){O=O*31+P.charCodeAt(N)&4294967295}return O}if(typeof P!==\"object\"){return P&4294967295}if(P.hashCode instanceof Function){return P.hashCode()}if(P.$id===t){P.$id=q.floor(q.random()*65536)-32768<<16|q.floor(q.random()*65536)}return P.$id}function r(O,N){if(O===null||N===null){return O===null&&N===null}if(typeof O===\"string\"){return O===N}if(typeof O!==\"object\"){return O===N}if(O.equals instanceof Function){return O.equals(N)}return O===N}var o=function(O){if(O.iterator instanceof Function){return O.iterator()}if(O instanceof Array){var N=-1;this.hasNext=function(){return ++N<O.length};this.next=function(){return O[N]}}else{throw\"Unable to iterate: \"+O}};var f=function(){function O(Q){var P=0;this.hasNext=function(){return P<Q.length};this.next=function(){return Q[P++]};this.remove=function(){Q.splice(P,1)}}function N(P){var Q;if(P instanceof N){Q=P.toArray()}else{Q=[];if(typeof P===\"number\"){Q.length=P>0?P:0}}this.get=function(R){return Q[R]};this.contains=function(R){return this.indexOf(R)>-1};this.indexOf=function(T){for(var S=0,R=Q.length;S<R;++S){if(r(T,Q[S])){return S}}return -1};this.lastIndexOf=function(S){for(var R=Q.length-1;R>=0;--R){if(r(S,Q[R])){return R}}return -1};this.add=function(){if(arguments.length===1){Q.push(arguments[0])}else{if(arguments.length===2){var R=arguments[0];if(typeof R===\"number\"){if(R>=0&&R<=Q.length){Q.splice(R,0,arguments[1])}else{throw R+\" is not a valid index\"}}else{throw typeof R+\" is not a number\"}}else{throw\"Please use the proper number of parameters.\"}}};this.addAll=function(S,R){var T;if(typeof S===\"number\"){if(S<0||S>Q.length){throw\"Index out of bounds for addAll: \"+S+\" greater or equal than \"+Q.length}T=new o(R);while(T.hasNext()){Q.splice(S++,0,T.next())}}else{T=new o(S);while(T.hasNext()){Q.push(T.next())}}};this.set=function(){if(arguments.length===2){var R=arguments[0];if(typeof R===\"number\"){if(R>=0&&R<Q.length){Q.splice(R,1,arguments[1])}else{throw R+\" is not a valid index.\"}}else{throw typeof R+\" is not a number\"}}else{throw\"Please use the proper number of parameters.\"}};this.size=function(){return Q.length};this.clear=function(){Q.length=0};this.remove=function(R){if(typeof R===\"number\"){return Q.splice(R,1)[0]}R=this.indexOf(R);if(R>-1){Q.splice(R,1);return true}return false};this.removeAll=function(V){var S,R,U,T=new N;T.addAll(this);this.clear();for(S=0,R=0;S<T.size();S++){U=T.get(S);if(!V.contains(U)){this.add(R++,U)}}if(this.size()<T.size()){return true}return false};this.isEmpty=function(){return !Q.length};this.clone=function(){return new N(this)};this.toArray=function(){return Q.slice(0)};this.iterator=function(){return new O(Q)}}return N}();var x=function(){function N(){if(arguments.length===1&&arguments[0] instanceof N){return arguments[0].clone()}var W=arguments.length>0?arguments[0]:16;var X=arguments.length>1?arguments[1]:0.75;var Q=[];Q.length=W;var S=0;var O=this;function U(Z){var Y=h(Z)%Q.length;return Y<0?Q.length+Y:Y}function R(){if(S<=X*Q.length){return}var ab=[];for(var aa=0;aa<Q.length;++aa){if(Q[aa]!==t){ab=ab.concat(Q[aa])}}var ac=Q.length*2;Q=[];Q.length=ac;for(var Z=0;Z<ab.length;++Z){var Y=U(ab[Z].key);var ad=Q[Y];if(ad===t){Q[Y]=ad=[]}ad.push(ab[Z])}}function P(ad,ae){var Y=0;var ac=-1;var ab=false;var aa;function Z(){while(!ab){++ac;if(Y>=Q.length){ab=true}else{if(Q[Y]===t||ac>=Q[Y].length){ac=-1;++Y}else{return}}}}this.hasNext=function(){return !ab};this.next=function(){aa=ad(Q[Y][ac]);Z();return aa};this.remove=function(){if(aa!==t){ae(aa);--ac;Z()}};Z()}function V(Y,Z,aa){this.clear=function(){O.clear()};this.contains=function(ab){return Z(ab)};this.containsAll=function(ac){var ab=ac.iterator();while(ab.hasNext()){if(!this.contains(ab.next())){return false}}return true};this.isEmpty=function(){return O.isEmpty()};this.iterator=function(){return new P(Y,aa)};this.remove=function(ab){if(this.contains(ab)){aa(ab);return true}return false};this.removeAll=function(ae){var ab=ae.iterator();var ad=false;while(ab.hasNext()){var ac=ab.next();if(this.contains(ac)){aa(ac);ad=true}}return true};this.retainAll=function(af){var ad=this.iterator();var ac=[];while(ad.hasNext()){var ae=ad.next();if(!af.contains(ae)){ac.push(ae)}}for(var ab=0;ab<ac.length;++ab){aa(ac[ab])}return ac.length>0};this.size=function(){return O.size()};this.toArray=function(){var ab=[];var ac=this.iterator();while(ac.hasNext()){ab.push(ac.next())}return ab}}function T(Y){this._isIn=function(Z){return Z===O&&Y.removed===t};this.equals=function(Z){return r(Y.key,Z.getKey())};this.getKey=function(){return Y.key};this.getValue=function(){return Y.value};this.hashCode=function(Z){return h(Y.key)};this.setValue=function(aa){var Z=Y.value;Y.value=aa;return Z}}this.clear=function(){S=0;Q=[];Q.length=W};this.clone=function(){var Y=new N;Y.putAll(this);return Y};this.containsKey=function(aa){var Y=U(aa);var ab=Q[Y];if(ab===t){return false}for(var Z=0;Z<ab.length;++Z){if(r(ab[Z].key,aa)){return true}}return false};this.containsValue=function(aa){for(var Z=0;Z<Q.length;++Z){var ab=Q[Z];if(ab===t){continue}for(var Y=0;Y<ab.length;++Y){if(r(ab[Y].value,aa)){return true}}}return false};this.entrySet=function(){return new V(function(Y){return new T(Y)},function(Y){return Y instanceof T&&Y._isIn(O)},function(Y){return O.remove(Y.getKey())})};this.get=function(aa){var Y=U(aa);var ab=Q[Y];if(ab===t){return null}for(var Z=0;Z<ab.length;++Z){if(r(ab[Z].key,aa)){return ab[Z].value}}return null};this.isEmpty=function(){return S===0};this.keySet=function(){return new V(function(Y){return Y.key},function(Y){return O.containsKey(Y)},function(Y){return O.remove(Y)})};this.values=function(){return new V(function(Y){return Y.value},function(Y){return O.containsValue(Y)},function(Y){return O.removeByValue(Y)})};this.put=function(aa,ac){var Y=U(aa);var ad=Q[Y];if(ad===t){++S;Q[Y]=[{key:aa,value:ac}];R();return null}for(var Z=0;Z<ad.length;++Z){if(r(ad[Z].key,aa)){var ab=ad[Z].value;ad[Z].value=ac;return ab}}++S;ad.push({key:aa,value:ac});R();return null};this.putAll=function(Y){var Z=Y.entrySet().iterator();while(Z.hasNext()){var aa=Z.next();this.put(aa.getKey(),aa.getValue())}};this.remove=function(aa){var Y=U(aa);var ac=Q[Y];if(ac===t){return null}for(var Z=0;Z<ac.length;++Z){if(r(ac[Z].key,aa)){--S;var ab=ac[Z].value;ac[Z].removed=true;if(ac.length>1){ac.splice(Z,1)}else{Q[Y]=t}return ab}}return null};this.removeByValue=function(aa){var ac,Z,Y,ab;for(ac in Q){if(Q.hasOwnProperty(ac)){for(Z=0,Y=Q[ac].length;Z<Y;Z++){ab=Q[ac][Z];if(ab.value===aa){Q[ac].splice(Z,1);return true}}}}return false};this.size=function(){return S}}return N}();var A=function(){function N(Q,S,R){this.x=Q||0;this.y=S||0;this.z=R||0}N.dist=function(R,Q){return R.dist(Q)};N.dot=function(R,Q){return R.dot(Q)};N.cross=function(R,Q){return R.cross(Q)};N.angleBetween=function(R,Q){return q.acos(R.dot(Q)/(R.mag()*Q.mag()))};N.prototype={set:function(Q,S,R){if(arguments.length===1){this.set(Q.x||Q[0]||0,Q.y||Q[1]||0,Q.z||Q[2]||0)}else{this.x=Q;this.y=S;this.z=R}},get:function(){return new N(this.x,this.y,this.z)},mag:function(){var Q=this.x,S=this.y,R=this.z;return q.sqrt(Q*Q+S*S+R*R)},add:function(Q,S,R){if(arguments.length===1){this.x+=Q.x;this.y+=Q.y;this.z+=Q.z}else{this.x+=Q;this.y+=S;this.z+=R}},sub:function(Q,S,R){if(arguments.length===1){this.x-=Q.x;this.y-=Q.y;this.z-=Q.z}else{this.x-=Q;this.y-=S;this.z-=R}},mult:function(Q){if(typeof Q===\"number\"){this.x*=Q;this.y*=Q;this.z*=Q}else{this.x*=Q.x;this.y*=Q.y;this.z*=Q.z}},div:function(Q){if(typeof Q===\"number\"){this.x/=Q;this.y/=Q;this.z/=Q}else{this.x/=Q.x;this.y/=Q.y;this.z/=Q.z}},dist:function(T){var S=this.x-T.x,R=this.y-T.y,Q=this.z-T.z;return q.sqrt(S*S+R*R+Q*Q)},dot:function(Q,S,R){if(arguments.length===1){return this.x*Q.x+this.y*Q.y+this.z*Q.z}return this.x*Q+this.y*S+this.z*R},cross:function(R){var Q=this.x,T=this.y,S=this.z;return new N(T*R.z-R.y*S,S*R.x-R.z*Q,Q*R.y-R.x*T)},normalize:function(){var Q=this.mag();if(Q>0){this.div(Q)}},limit:function(Q){if(this.mag()>Q){this.normalize();this.mult(Q)}},heading2D:function(){return -q.atan2(-this.y,this.x)},toString:function(){return\"[\"+this.x+\", \"+this.y+\", \"+this.z+\"]\"},array:function(){return[this.x,this.y,this.z]}};function O(Q){return function(T,S){var R=T.get();R[Q](S);return R}}for(var P in N.prototype){if(N.prototype.hasOwnProperty(P)&&!N.hasOwnProperty(P)){N[P]=O(P)}}return N}();function M(){}M.prototype=B;var g=new M;g.ArrayList=f;g.HashMap=x;g.PVector=A;g.ObjectIterator=o;g.PConstants=B;g.defineProperty=function(O,N,P){if(\"defineProperty\" in Object){Object.defineProperty(O,N,P)}else{if(P.hasOwnProperty(\"get\")){O.__defineGetter__(N,P.get)}if(P.hasOwnProperty(\"set\")){O.__defineSetter__(N,P.set)}}};function m(O,N,R){if(!O.hasOwnProperty(N)||typeof O[N]!==\"function\"){O[N]=R;return}var Q=O[N];if(\"$overloads\" in Q){Q.$defaultOverload=R;return}if(!(\"$overloads\" in R)&&Q.length===R.length){return}var T,P;if(\"$overloads\" in R){T=R.$overloads.slice(0);T[Q.length]=Q;P=R.$defaultOverload}else{T=[];T[R.length]=R;T[Q.length]=Q;P=Q}var S=function(){var U=S.$overloads[arguments.length]||(\"$methodArgsIndex\" in S&&arguments.length>S.$methodArgsIndex?S.$overloads[S.$methodArgsIndex]:null)||S.$defaultOverload;return U.apply(this,arguments)};S.$overloads=T;if(\"$methodArgsIndex\" in R){S.$methodArgsIndex=R.$methodArgsIndex}S.$defaultOverload=P;S.name=N;O[N]=S}function i(Q,P){function R(S){g.defineProperty(Q,S,{get:function(){return P[S]},set:function(T){P[S]=T},enumerable:true})}var O=[];for(var N in P){if(typeof P[N]===\"function\"){m(Q,N,P[N])}else{if(N.charAt(0)!==\"$\"&&!(N in Q)){O.push(N)}}}while(O.length>0){R(O.shift())}Q.$super=P}g.extendClassChain=function(O){var P=[O];for(var N=O.$upcast;N;N=N.$upcast){i(N,O);P.push(N);O=N}while(P.length>0){P.pop().$self=O}};g.extendStaticMembers=function(N,O){i(N,O)};g.extendInterfaceMembers=function(N,O){i(N,O)};g.addMethod=function(Q,P,S,R){var N=Q[P];if(N||R){var O=S.length;if(\"$overloads\" in N){N.$overloads[O]=S}else{var T=function(){var V=T.$overloads[arguments.length]||(\"$methodArgsIndex\" in T&&arguments.length>T.$methodArgsIndex?T.$overloads[T.$methodArgsIndex]:null)||T.$defaultOverload;return V.apply(this,arguments)};var U=[];if(N){U[N.length]=N}U[O]=S;T.$overloads=U;T.$defaultOverload=N||S;if(R){T.$methodArgsIndex=O}T.name=P;Q[P]=T}}else{Q[P]=S}};function l(N){if(typeof N!==\"string\"){return false}return[\"byte\",\"int\",\"char\",\"color\",\"float\",\"long\",\"double\"].indexOf(N)!==-1}g.createJavaArray=function(S,T){var O=null,P=null;if(typeof S===\"string\"){if(S===\"boolean\"){P=false}else{if(l(S)){P=0}}}if(typeof T[0]===\"number\"){var N=0|T[0];if(T.length<=1){O=[];O.length=N;for(var R=0;R<N;++R){O[R]=P}}else{O=[];var U=T.slice(1);for(var Q=0;Q<N;++Q){O.push(g.createJavaArray(S,U))}}}return O};var E={aliceblue:\"#f0f8ff\",antiquewhite:\"#faebd7\",aqua:\"#00ffff\",aquamarine:\"#7fffd4\",azure:\"#f0ffff\",beige:\"#f5f5dc\",bisque:\"#ffe4c4\",black:\"#000000\",blanchedalmond:\"#ffebcd\",blue:\"#0000ff\",blueviolet:\"#8a2be2\",brown:\"#a52a2a\",burlywood:\"#deb887\",cadetblue:\"#5f9ea0\",chartreuse:\"#7fff00\",chocolate:\"#d2691e\",coral:\"#ff7f50\",cornflowerblue:\"#6495ed\",cornsilk:\"#fff8dc\",crimson:\"#dc143c\",cyan:\"#00ffff\",darkblue:\"#00008b\",darkcyan:\"#008b8b\",darkgoldenrod:\"#b8860b\",darkgray:\"#a9a9a9\",darkgreen:\"#006400\",darkkhaki:\"#bdb76b\",darkmagenta:\"#8b008b\",darkolivegreen:\"#556b2f\",darkorange:\"#ff8c00\",darkorchid:\"#9932cc\",darkred:\"#8b0000\",darksalmon:\"#e9967a\",darkseagreen:\"#8fbc8f\",darkslateblue:\"#483d8b\",darkslategray:\"#2f4f4f\",darkturquoise:\"#00ced1\",darkviolet:\"#9400d3\",deeppink:\"#ff1493\",deepskyblue:\"#00bfff\",dimgray:\"#696969\",dodgerblue:\"#1e90ff\",firebrick:\"#b22222\",floralwhite:\"#fffaf0\",forestgreen:\"#228b22\",fuchsia:\"#ff00ff\",gainsboro:\"#dcdcdc\",ghostwhite:\"#f8f8ff\",gold:\"#ffd700\",goldenrod:\"#daa520\",gray:\"#808080\",green:\"#008000\",greenyellow:\"#adff2f\",honeydew:\"#f0fff0\",hotpink:\"#ff69b4\",indianred:\"#cd5c5c\",indigo:\"#4b0082\",ivory:\"#fffff0\",khaki:\"#f0e68c\",lavender:\"#e6e6fa\",lavenderblush:\"#fff0f5\",lawngreen:\"#7cfc00\",lemonchiffon:\"#fffacd\",lightblue:\"#add8e6\",lightcoral:\"#f08080\",lightcyan:\"#e0ffff\",lightgoldenrodyellow:\"#fafad2\",lightgrey:\"#d3d3d3\",lightgreen:\"#90ee90\",lightpink:\"#ffb6c1\",lightsalmon:\"#ffa07a\",lightseagreen:\"#20b2aa\",lightskyblue:\"#87cefa\",lightslategray:\"#778899\",lightsteelblue:\"#b0c4de\",lightyellow:\"#ffffe0\",lime:\"#00ff00\",limegreen:\"#32cd32\",linen:\"#faf0e6\",magenta:\"#ff00ff\",maroon:\"#800000\",mediumaquamarine:\"#66cdaa\",mediumblue:\"#0000cd\",mediumorchid:\"#ba55d3\",mediumpurple:\"#9370d8\",mediumseagreen:\"#3cb371\",mediumslateblue:\"#7b68ee\",mediumspringgreen:\"#00fa9a\",mediumturquoise:\"#48d1cc\",mediumvioletred:\"#c71585\",midnightblue:\"#191970\",mintcream:\"#f5fffa\",mistyrose:\"#ffe4e1\",moccasin:\"#ffe4b5\",navajowhite:\"#ffdead\",navy:\"#000080\",oldlace:\"#fdf5e6\",olive:\"#808000\",olivedrab:\"#6b8e23\",orange:\"#ffa500\",orangered:\"#ff4500\",orchid:\"#da70d6\",palegoldenrod:\"#eee8aa\",palegreen:\"#98fb98\",paleturquoise:\"#afeeee\",palevioletred:\"#d87093\",papayawhip:\"#ffefd5\",peachpuff:\"#ffdab9\",peru:\"#cd853f\",pink:\"#ffc0cb\",plum:\"#dda0dd\",powderblue:\"#b0e0e6\",purple:\"#800080\",red:\"#ff0000\",rosybrown:\"#bc8f8f\",royalblue:\"#4169e1\",saddlebrown:\"#8b4513\",salmon:\"#fa8072\",sandybrown:\"#f4a460\",seagreen:\"#2e8b57\",seashell:\"#fff5ee\",sienna:\"#a0522d\",silver:\"#c0c0c0\",skyblue:\"#87ceeb\",slateblue:\"#6a5acd\",slategray:\"#708090\",snow:\"#fffafa\",springgreen:\"#00ff7f\",steelblue:\"#4682b4\",tan:\"#d2b48c\",teal:\"#008080\",thistle:\"#d8bfd8\",tomato:\"#ff6347\",turquoise:\"#40e0d0\",violet:\"#ee82ee\",wheat:\"#f5deb3\",white:\"#ffffff\",whitesmoke:\"#f5f5f5\",yellow:\"#ffff00\",yellowgreen:\"#9acd32\"};(function(O){var R=(\"open() createOutput() createInput() BufferedReader selectFolder() dataPath() createWriter() selectOutput() beginRecord() saveStream() endRecord() selectInput() saveBytes() createReader() beginRaw() endRaw() PrintWriter delay()\").split(\" \"),Q=R.length,N,S;function P(T){return function(){throw\"Processing.js does not support \"+T+\".\"}}while(Q--){N=R[Q];S=N.replace(\"()\",\"\");O[S]=P(N)}})(g);g.defineProperty(g,\"screenWidth\",{get:function(){return D.innerWidth}});g.defineProperty(g,\"screenHeight\",{get:function(){return D.innerHeight}});g.defineProperty(g,\"online\",{get:function(){return true}});var k=[];var J={};var L=function(N){k.splice(J[N],1);delete J[N]};var a=function(N){if(N.externals.canvas.id===t||!N.externals.canvas.id.length){N.externals.canvas.id=\"__processing\"+k.length}J[N.externals.canvas.id]=k.length;k.push(N)};function p(X){var Q=250,ae=X.size/Q,N=d.createElement(\"canvas\");N.width=2*Q;N.height=2*Q;N.style.opacity=0;var W=X.getCSSDefinition(Q+\"px\",\"normal\"),Y=N.getContext(\"2d\");Y.font=W;var ac=\"dbflkhyjqpg\";N.width=Y.measureText(ac).width;Y.font=W;var T=d.createElement(\"div\");T.style.position=\"absolute\";T.style.opacity=0;T.style.fontFamily='\"'+X.name+'\"';T.style.fontSize=Q+\"px\";T.innerHTML=ac+\"<br/>\"+ac;d.body.appendChild(T);var U=N.width,ab=N.height,V=ab/2;Y.fillStyle=\"white\";Y.fillRect(0,0,U,ab);Y.fillStyle=\"black\";Y.fillText(ac,0,V);var P=Y.getImageData(0,0,U,ab).data;var Z=0,S=U*4,aa=P.length;while(++Z<aa&&P[Z]===255){G()}var R=q.round(Z/S);Z=aa-1;while(--Z>0&&P[Z]===255){G()}var ad=q.round(Z/S);X.ascent=ae*(V-R);X.descent=ae*(ad-V);if(d.defaultView.getComputedStyle){var O=d.defaultView.getComputedStyle(T,null).getPropertyValue(\"height\");O=ae*O.replace(\"px\",\"\");if(O>=X.size*2){X.leading=q.round(O/2)}}d.body.removeChild(T);if(X.caching){return Y}}function H(N,O){if(N===t){N=\"\"}this.name=N;if(O===t){O=0}this.size=O;this.glyph=false;this.ascent=0;this.descent=0;this.leading=1.2*O;var R=N.indexOf(\" Italic Bold\");if(R!==-1){N=N.substring(0,R)}this.style=\"normal\";var Q=N.indexOf(\" Italic\");if(Q!==-1){N=N.substring(0,Q);this.style=\"italic\"}this.weight=\"normal\";var P=N.indexOf(\" Bold\");if(P!==-1){N=N.substring(0,P);this.weight=\"bold\"}this.family=\"sans-serif\";if(N!==t){switch(N){case\"sans-serif\":case\"serif\":case\"monospace\":case\"fantasy\":case\"cursive\":this.family=N;break;default:this.family='\"'+N+'\", sans-serif';break}}this.context2d=p(this);this.css=this.getCSSDefinition();if(this.context2d){this.context2d.font=this.css}}H.prototype.caching=true;H.prototype.getCSSDefinition=function(P,N){if(P===t){P=this.size+\"px\"}if(N===t){N=this.leading+\"px\"}var O=[this.style,\"normal\",this.weight,P+\"/\"+N,this.family];return O.join(\" \")};H.prototype.measureTextWidth=function(N){return this.context2d.measureText(N).width};H.prototype.measureTextWidthFallback=function(P){var O=d.createElement(\"canvas\"),N=O.getContext(\"2d\");N.font=this.css;return N.measureText(P).width};H.PFontCache={length:0};H.get=function(Q,R){R=(R*10+0.5|0)/10;var O=H.PFontCache,N=Q+\"/\"+R;if(!O[N]){O[N]=new H(Q,R);O.length++;if(O.length===50){H.prototype.measureTextWidth=H.prototype.measureTextWidthFallback;H.prototype.caching=false;var P;for(P in O){if(P!==\"length\"){O[P].context2d=null}}return new H(Q,R)}if(O.length===400){H.PFontCache={};H.get=H.getFallback;return new H(Q,R)}}return O[N]};H.getFallback=function(N,O){return new H(N,O)};H.list=function(){return[\"sans-serif\",\"serif\",\"monospace\",\"fantasy\",\"cursive\"]};H.preloading={template:{},initialized:false,initialize:function(){var P=function(){var R=\"#E3KAI2wAgT1MvMg7Eo3VmNtYX7ABi3CxnbHlm7Abw3kaGVhZ7ACs3OGhoZWE7A53CRobXR47AY3AGbG9jYQ7G03Bm1heH7ABC3CBuYW1l7Ae3AgcG9zd7AI3AE#B3AQ2kgTY18PPPUACwAg3ALSRoo3#yld0xg32QAB77#E777773B#E3C#I#Q77773E#Q7777777772CMAIw7AB77732B#M#Q3wAB#g3B#E#E2BB//82BB////w#B7#gAEg3E77x2B32B#E#Q#MTcBAQ32gAe#M#QQJ#E32M#QQJ#I#g32Q77#\";var Q=function(S){return\"AAAAAAAA\".substr(~~S?7-S:6)};return R.replace(/[#237]/g,Q)};var N=d.createElement(\"style\");N.setAttribute(\"type\",\"text/css\");N.innerHTML='@font-face {\\n  font-family: \"PjsEmptyFont\";\\n  src: url(\\'data:application/x-font-ttf;base64,'+P()+\"')\\n       format('truetype');\\n}\";d.head.appendChild(N);var O=d.createElement(\"span\");O.style.cssText='position: absolute; top: 0; left: 0; opacity: 0; font-family: \"PjsEmptyFont\", fantasy;';O.innerHTML=\"AAAAAAAA\";d.body.appendChild(O);this.template=O;this.initialized=true},getElementWidth:function(N){return d.defaultView.getComputedStyle(N,\"\").getPropertyValue(\"width\")},timeAttempted:0,pending:function(R){if(!this.initialized){this.initialize()}var P,N,Q=this.getElementWidth(this.template);for(var O=0;O<this.fontList.length;O++){P=this.fontList[O];N=this.getElementWidth(P);if(this.timeAttempted<4000&&N===Q){this.timeAttempted+=R;return true}else{d.body.removeChild(P);this.fontList.splice(O--,1);this.timeAttempted=0}}if(this.fontList.length===0){return false}return true},fontList:[],addedList:{},add:function(N){if(!this.initialized){this.initialize()}var R=typeof N===\"object\"?N.fontFace:N,Q=typeof N===\"object\"?N.url:N;if(this.addedList[R]){return}var P=d.createElement(\"style\");P.setAttribute(\"type\",\"text/css\");P.innerHTML=\"@font-face{\\n  font-family: '\"+R+\"';\\n  src:  url('\"+Q+\"');\\n}\\n\";d.head.appendChild(P);this.addedList[R]=true;var O=d.createElement(\"span\");O.style.cssText=\"position: absolute; top: 0; left: 0; opacity: 0;\";O.style.fontFamily='\"'+R+'\", \"PjsEmptyFont\", fantasy';O.innerHTML=\"AAAAAAAA\";d.body.appendChild(O);this.fontList.push(O)}};g.PFont=H;var F=this.Processing=function(be,ba){if(!(this instanceof F)){throw\"called Processing constructor as if it were a function: missing 'new'.\"}var ae,cV=be===t&&ba===t;if(cV){ae=d.createElement(\"canvas\")}else{ae=typeof be===\"string\"?d.getElementById(be):be}if(!(ae instanceof HTMLCanvasElement)){throw\"called Processing constructor without passing canvas element reference or id.\"}function dw(ea){F.debug(\"Unimplemented - \"+ea)}var cW=this;cW.externals={canvas:ae,context:t,sketch:t};cW.name=\"Processing.js Instance\";cW.use3DContext=false;cW.focused=false;cW.breakShape=false;cW.glyphTable={};cW.pmouseX=0;cW.pmouseY=0;cW.mouseX=0;cW.mouseY=0;cW.mouseButton=0;cW.mouseScroll=0;cW.mouseClicked=t;cW.mouseDragged=t;cW.mouseMoved=t;cW.mousePressed=t;cW.mouseReleased=t;cW.mouseScrolled=t;cW.mouseOver=t;cW.mouseOut=t;cW.touchStart=t;cW.touchEnd=t;cW.touchMove=t;cW.touchCancel=t;cW.key=t;cW.keyCode=t;cW.keyPressed=G;cW.keyReleased=G;cW.keyTyped=G;cW.draw=t;cW.setup=t;cW.__mousePressed=false;cW.__keyPressed=false;cW.__frameRate=60;cW.frameCount=0;cW.width=100;cW.height=100;var d8,cQ,dY,bD=true,aH=true,bo=[1,1,1,1],a1=4294967295,aq=true,ce=true,c0=[0,0,0,1],cv=4278190080,b3=true,dW=1,ax=false,dO=false,aC=true,b4=0,bK=0,cN=3,a8=0,a7=0,a6=0,a2=0,dU=60,az=1000/dU,Z=\"default\",ck=ae.style.cursor,dR=20,cj=0,d6=[],aJ=0,Q=20,cM=false,a4=-3355444,cy=20,bU=255,bJ=255,bI=255,bG=255,cZ=false,aK=false,dN=0,d5=0,cY=1,bf=null,bw=null,a5=false,dq=Date.now(),dt=dq,P=0,cE,c3,aQ,aL,bz,cd,U,dC={attributes:{},locations:{}},dx,dQ,bT,bh,cJ,dk,aB,b2,bg,b8,at,aG,bC,aw,af,c7,bS,cs={width:0,height:0},d4=2,dT=false,cH,ac,R,N=37,c1=0,cI=4,Y=\"Arial\",d0=12,a3=9,dA=2,d7=14,W=H.get(Y,d0),aj,cn=null,dV=false,d3,bZ=1000,ag=[],dI=null,dX=[16,17,18,20,33,34,35,36,37,38,39,40,144,155,112,113,114,115,116,117,118,119,120,121,122,123,157];var ad,dp,aU,bX;if(d.defaultView&&d.defaultView.getComputedStyle){ad=parseInt(d.defaultView.getComputedStyle(ae,null)[\"paddingLeft\"],10)||0;dp=parseInt(d.defaultView.getComputedStyle(ae,null)[\"paddingTop\"],10)||0;aU=parseInt(d.defaultView.getComputedStyle(ae,null)[\"borderLeftWidth\"],10)||0;bX=parseInt(d.defaultView.getComputedStyle(ae,null)[\"borderTopWidth\"],10)||0}var dL=0;var bL=0,bM=0,bt=[],bs=[],br=[],ah=new e(720),bl=new e(720),cF,cA;var bV,ch,dJ,aT,am,da,ab,db,ap=false,ci=false,cK=60*(q.PI/180),dl=cW.width/2,dj=cW.height/2,di=dj/q.tan(cK/2),a0=di/10,av=di*10,b5=cW.width/cW.height;var bb=[],cb=[],c2=0,dP=false,aa=false,du=true;var S=0;var bm=[];var dh=new e([0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,-0.5,0.5,0.5,-0.5,0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,0.5,-0.5,0.5,0.5,0.5,0.5,0.5,0.5,-0.5,0.5,0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5,0.5,-0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,-0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,0.5,0.5,0.5,0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,0.5,0.5,0.5,0.5]);var bH=new e([0.5,0.5,0.5,0.5,-0.5,0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,0.5,-0.5,-0.5,0.5,0.5,0.5,0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,0.5,-0.5,0.5,0.5,0.5,0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,0.5,-0.5,0.5]);var df=new e([0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0]);var ak=new e([0,0,0,0,1,0,1,1,0,1,0,0]);var ai=new e([0,0,1,0,0,1,0,0,1,0,0,1]);var aO=\"varying vec4 vFrontColor;attribute vec3 aVertex;attribute vec4 aColor;uniform mat4 uView;uniform mat4 uProjection;uniform float uPointSize;void main(void) {  vFrontColor = aColor;  gl_PointSize = uPointSize;  gl_Position = uProjection * uView * vec4(aVertex, 1.0);}\";var bQ=\"#ifdef GL_ES\\nprecision highp float;\\n#endif\\nvarying vec4 vFrontColor;uniform bool uSmooth;void main(void){  if(uSmooth == true){    float dist = distance(gl_PointCoord, vec2(0.5));    if(dist > 0.5){      discard;    }  }  gl_FragColor = vFrontColor;}\";var dE=\"varying vec4 vFrontColor;attribute vec3 aVertex;attribute vec2 aTextureCoord;uniform vec4 uColor;uniform mat4 uModel;uniform mat4 uView;uniform mat4 uProjection;uniform float uPointSize;varying vec2 vTextureCoord;void main(void) {  gl_PointSize = uPointSize;  vFrontColor = uColor;  gl_Position = uProjection * uView * uModel * vec4(aVertex, 1.0);  vTextureCoord = aTextureCoord;}\";var aW=\"#ifdef GL_ES\\nprecision highp float;\\n#endif\\nvarying vec4 vFrontColor;varying vec2 vTextureCoord;uniform sampler2D uSampler;uniform int uIsDrawingText;uniform bool uSmooth;void main(void){  if(uSmooth == true){    float dist = distance(gl_PointCoord, vec2(0.5));    if(dist > 0.5){      discard;    }  }  if(uIsDrawingText == 1){    float alpha = texture2D(uSampler, vTextureCoord).a;    gl_FragColor = vec4(vFrontColor.rgb * alpha, alpha);  }  else{    gl_FragColor = vFrontColor;  }}\";var bA=/Windows/.test(navigator.userAgent);var dn=\"varying vec4 vFrontColor;attribute vec3 aVertex;attribute vec3 aNormal;attribute vec4 aColor;attribute vec2 aTexture;varying   vec2 vTexture;uniform vec4 uColor;uniform bool uUsingMat;uniform vec3 uSpecular;uniform vec3 uMaterialEmissive;uniform vec3 uMaterialAmbient;uniform vec3 uMaterialSpecular;uniform float uShininess;uniform mat4 uModel;uniform mat4 uView;uniform mat4 uProjection;uniform mat4 uNormalTransform;uniform int uLightCount;uniform vec3 uFalloff;struct Light {  int type;  vec3 color;  vec3 position;  vec3 direction;  float angle;  vec3 halfVector;  float concentration;};uniform Light uLights0;uniform Light uLights1;uniform Light uLights2;uniform Light uLights3;uniform Light uLights4;uniform Light uLights5;uniform Light uLights6;uniform Light uLights7;Light getLight(int index){  if(index == 0) return uLights0;  if(index == 1) return uLights1;  if(index == 2) return uLights2;  if(index == 3) return uLights3;  if(index == 4) return uLights4;  if(index == 5) return uLights5;  if(index == 6) return uLights6;  return uLights7;}void AmbientLight( inout vec3 totalAmbient, in vec3 ecPos, in Light light ) {  float d = length( light.position - ecPos );  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ));  totalAmbient += light.color * attenuation;}void DirectionalLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {  float powerFactor = 0.0;  float nDotVP = max(0.0, dot( vertNormal, normalize(-light.position) ));  float nDotVH = max(0.0, dot( vertNormal, normalize(-light.position-normalize(ecPos) )));  if( nDotVP != 0.0 ){    powerFactor = pow( nDotVH, uShininess );  }  col += light.color * nDotVP;  spec += uSpecular * powerFactor;}void PointLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {  float powerFactor;   vec3 VP = light.position - ecPos;  float d = length( VP );   VP = normalize( VP );  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ));  float nDotVP = max( 0.0, dot( vertNormal, VP ));  vec3 halfVector = normalize( VP - normalize(ecPos) );  float nDotHV = max( 0.0, dot( vertNormal, halfVector ));  if( nDotVP == 0.0 ) {    powerFactor = 0.0;  }  else {    powerFactor = pow( nDotHV, uShininess );  }  spec += uSpecular * powerFactor * attenuation;  col += light.color * nDotVP * attenuation;}void SpotLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {  float spotAttenuation;  float powerFactor = 0.0;  vec3 VP = light.position - ecPos;  vec3 ldir = normalize( -light.direction );  float d = length( VP );  VP = normalize( VP );  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ) );  float spotDot = dot( VP, ldir );\"+(bA?\"  spotAttenuation = 1.0; \":\"  if( spotDot > cos( light.angle ) ) {    spotAttenuation = pow( spotDot, light.concentration );  }  else{    spotAttenuation = 0.0;  }  attenuation *= spotAttenuation;\")+\"  float nDotVP = max( 0.0, dot( vertNormal, VP ) );  vec3 halfVector = normalize( VP - normalize(ecPos) );  float nDotHV = max( 0.0, dot( vertNormal, halfVector ) );  if( nDotVP != 0.0 ) {    powerFactor = pow( nDotHV, uShininess );  }  spec += uSpecular * powerFactor * attenuation;  col += light.color * nDotVP * attenuation;}void main(void) {  vec3 finalAmbient = vec3( 0.0 );  vec3 finalDiffuse = vec3( 0.0 );  vec3 finalSpecular = vec3( 0.0 );  vec4 col = uColor;  if ( uColor[0] == -1.0 ){    col = aColor;  }  vec3 norm = normalize(vec3( uNormalTransform * vec4( aNormal, 0.0 ) ));  vec4 ecPos4 = uView * uModel * vec4(aVertex, 1.0);  vec3 ecPos = (vec3(ecPos4))/ecPos4.w;  if( uLightCount == 0 ) {    vFrontColor = col + vec4(uMaterialSpecular, 1.0);  }  else {    for( int i = 0; i < 8; i++ ) {      Light l = getLight(i);      if( i >= uLightCount ){        break;      }      if( l.type == 0 ) {        AmbientLight( finalAmbient, ecPos, l );      }      else if( l.type == 1 ) {        DirectionalLight( finalDiffuse, finalSpecular, norm, ecPos, l );      }      else if( l.type == 2 ) {        PointLight( finalDiffuse, finalSpecular, norm, ecPos, l );      }      else {        SpotLight( finalDiffuse, finalSpecular, norm, ecPos, l );      }    }   if( uUsingMat == false ) {     vFrontColor = vec4(       vec3( col ) * finalAmbient +       vec3( col ) * finalDiffuse +       vec3( col ) * finalSpecular,       col[3] );   }   else{     vFrontColor = vec4(        uMaterialEmissive +        (vec3(col) * uMaterialAmbient * finalAmbient ) +        (vec3(col) * finalDiffuse) +        (uMaterialSpecular * finalSpecular),        col[3] );    }  }  vTexture.xy = aTexture.xy;  gl_Position = uProjection * uView * uModel * vec4( aVertex, 1.0 );}\";var aF=\"#ifdef GL_ES\\nprecision highp float;\\n#endif\\nvarying vec4 vFrontColor;uniform sampler2D uSampler;uniform bool uUsingTexture;varying vec2 vTexture;void main(void){  if( uUsingTexture ){    gl_FragColor = vec4(texture2D(uSampler, vTexture.xy)) * vFrontColor;  }  else{    gl_FragColor = vFrontColor;  }}\";function d2(ec,eb,ee,ed){var ea=dC.locations[ec];if(ea===t){ea=d8.getUniformLocation(eb,ee);dC.locations[ec]=ea}if(ea!==null){if(ed.length===4){d8.uniform4fv(ea,ed)}else{if(ed.length===3){d8.uniform3fv(ea,ed)}else{if(ed.length===2){d8.uniform2fv(ea,ed)}else{d8.uniform1f(ea,ed)}}}}}function dZ(ec,eb,ee,ed){var ea=dC.locations[ec];if(ea===t){ea=d8.getUniformLocation(eb,ee);dC.locations[ec]=ea}if(ea!==null){if(ed.length===4){d8.uniform4iv(ea,ed)}else{if(ed.length===3){d8.uniform3iv(ea,ed)}else{if(ed.length===2){d8.uniform2iv(ea,ed)}else{d8.uniform1i(ea,ed)}}}}}function a9(ee,ec,ef,ed,eb){var ea=dC.locations[ee];if(ea===t){ea=d8.getUniformLocation(ec,ef);dC.locations[ee]=ea}if(ea!==-1){if(eb.length===16){d8.uniformMatrix4fv(ea,ed,eb)}else{if(eb.length===9){d8.uniformMatrix3fv(ea,ed,eb)}else{d8.uniformMatrix2fv(ea,ed,eb)}}}}function dc(ee,ec,ef,eb,ed){var ea=dC.attributes[ee];if(ea===t){ea=d8.getAttribLocation(ec,ef);dC.attributes[ee]=ea}if(ea!==-1){d8.bindBuffer(d8.ARRAY_BUFFER,ed);d8.vertexAttribPointer(ea,eb,d8.FLOAT,false,0,0);d8.enableVertexAttribArray(ea)}}function cg(ec,eb,ed){var ea=dC.attributes[ec];if(ea===t){ea=d8.getAttribLocation(eb,ed);dC.attributes[ec]=ea}if(ea!==-1){d8.disableVertexAttribArray(ea)}}var bF=function(ec,ee,eb){var ef=ec.createShader(ec.VERTEX_SHADER);ec.shaderSource(ef,ee);ec.compileShader(ef);if(!ec.getShaderParameter(ef,ec.COMPILE_STATUS)){throw ec.getShaderInfoLog(ef)}var ed=ec.createShader(ec.FRAGMENT_SHADER);ec.shaderSource(ed,eb);ec.compileShader(ed);if(!ec.getShaderParameter(ed,ec.COMPILE_STATUS)){throw ec.getShaderInfoLog(ed)}var ea=ec.createProgram();ec.attachShader(ea,ef);ec.attachShader(ea,ed);ec.linkProgram(ea);if(!ec.getProgramParameter(ea,ec.LINK_STATUS)){throw\"Error linking shaders.\"}return ea};var aZ=function(ea,ee,eb,ed,ec){return{x:ea,y:ee,w:eb,h:ed}};var bk=aZ;var b1=function(ea,ee,eb,ed,ec){return{x:ea,y:ee,w:ec?eb:eb-ea,h:ec?ed:ed-ee}};var aN=function(ea,ee,eb,ed,ec){return{x:ea-eb/2,y:ee-ed/2,w:eb,h:ed}};var ds=function(){};var bR=function(){};var bB=function(){};var ca=function(){};bR.prototype=new ds;bR.prototype.constructor=bR;bB.prototype=new ds;bB.prototype.constructor=bB;ca.prototype=new ds;ca.prototype.constructor=ca;ds.prototype.a3DOnlyFunction=G;var cl={};var bP=cW.Character=function(ea){if(typeof ea===\"string\"&&ea.length===1){this.code=ea.charCodeAt(0)}else{if(typeof ea===\"number\"){this.code=ea}else{if(ea instanceof bP){this.code=ea}else{this.code=NaN}}}return cl[this.code]===t?cl[this.code]=this:cl[this.code]};bP.prototype.toString=function(){return String.fromCharCode(this.code)};bP.prototype.valueOf=function(){return this.code};var O=cW.PShape=function(ea){this.family=ea||0;this.visible=true;this.style=true;this.children=[];this.nameTable=[];this.params=[];this.name=\"\";this.image=null;this.matrix=null;this.kind=null;this.close=null;this.width=null;this.height=null;this.parent=null};O.prototype={isVisible:function(){return this.visible},setVisible:function(ea){this.visible=ea},disableStyle:function(){this.style=false;for(var eb=0,ea=this.children.length;eb<ea;eb++){this.children[eb].disableStyle()}},enableStyle:function(){this.style=true;for(var eb=0,ea=this.children.length;eb<ea;eb++){this.children[eb].enableStyle()}},getFamily:function(){return this.family},getWidth:function(){return this.width},getHeight:function(){return this.height},setName:function(ea){this.name=ea},getName:function(){return this.name},draw:function(ea){ea=ea||cW;if(this.visible){this.pre(ea);this.drawImpl(ea);this.post(ea)}},drawImpl:function(ea){if(this.family===0){this.drawGroup(ea)}else{if(this.family===1){this.drawPrimitive(ea)}else{if(this.family===3){this.drawGeometry(ea)}else{if(this.family===21){this.drawPath(ea)}}}}},drawPath:function(ec){var ed,eb;if(this.vertices.length===0){return}ec.beginShape();if(this.vertexCodes.length===0){if(this.vertices[0].length===2){for(ed=0,eb=this.vertices.length;ed<eb;ed++){ec.vertex(this.vertices[ed][0],this.vertices[ed][1])}}else{for(ed=0,eb=this.vertices.length;ed<eb;ed++){ec.vertex(this.vertices[ed][0],this.vertices[ed][1],this.vertices[ed][2])}}}else{var ea=0;if(this.vertices[0].length===2){for(ed=0,eb=this.vertexCodes.length;ed<eb;ed++){if(this.vertexCodes[ed]===0){ec.vertex(this.vertices[ea][0],this.vertices[ea][1],this.vertices[ea][\"moveTo\"]);ec.breakShape=false;ea++}else{if(this.vertexCodes[ed]===1){ec.bezierVertex(this.vertices[ea+0][0],this.vertices[ea+0][1],this.vertices[ea+1][0],this.vertices[ea+1][1],this.vertices[ea+2][0],this.vertices[ea+2][1]);ea+=3}else{if(this.vertexCodes[ed]===2){ec.curveVertex(this.vertices[ea][0],this.vertices[ea][1]);ea++}else{if(this.vertexCodes[ed]===3){ec.breakShape=true}}}}}}else{for(ed=0,eb=this.vertexCodes.length;ed<eb;ed++){if(this.vertexCodes[ed]===0){ec.vertex(this.vertices[ea][0],this.vertices[ea][1],this.vertices[ea][2]);if(this.vertices[ea][\"moveTo\"]===true){bb[bb.length-1][\"moveTo\"]=true}else{if(this.vertices[ea][\"moveTo\"]===false){bb[bb.length-1][\"moveTo\"]=false}}ec.breakShape=false}else{if(this.vertexCodes[ed]===1){ec.bezierVertex(this.vertices[ea+0][0],this.vertices[ea+0][1],this.vertices[ea+0][2],this.vertices[ea+1][0],this.vertices[ea+1][1],this.vertices[ea+1][2],this.vertices[ea+2][0],this.vertices[ea+2][1],this.vertices[ea+2][2]);ea+=3}else{if(this.vertexCodes[ed]===2){ec.curveVertex(this.vertices[ea][0],this.vertices[ea][1],this.vertices[ea][2]);ea++}else{if(this.vertexCodes[ed]===3){ec.breakShape=true}}}}}}}ec.endShape(this.close?2:1)},drawGeometry:function(ec){var ed,eb;ec.beginShape(this.kind);if(this.style){for(ed=0,eb=this.vertices.length;ed<eb;ed++){ec.vertex(this.vertices[ed])}}else{for(ed=0,eb=this.vertices.length;ed<eb;ed++){var ea=this.vertices[ed];if(ea[2]===0){ec.vertex(ea[0],ea[1])}else{ec.vertex(ea[0],ea[1],ea[2])}}}ec.endShape()},drawGroup:function(eb){for(var ec=0,ea=this.children.length;ec<ea;ec++){this.children[ec].draw(eb)}},drawPrimitive:function(ea){if(this.kind===2){ea.point(this.params[0],this.params[1])}else{if(this.kind===4){if(this.params.length===4){ea.line(this.params[0],this.params[1],this.params[2],this.params[3])}else{ea.line(this.params[0],this.params[1],this.params[2],this.params[3],this.params[4],this.params[5])}}else{if(this.kind===8){ea.triangle(this.params[0],this.params[1],this.params[2],this.params[3],this.params[4],this.params[5])}else{if(this.kind===16){ea.quad(this.params[0],this.params[1],this.params[2],this.params[3],this.params[4],this.params[5],this.params[6],this.params[7])}else{if(this.kind===30){if(this.image!==null){var ee=bk;ea.imageMode(0);ea.image(this.image,this.params[0],this.params[1],this.params[2],this.params[3]);bk=ee}else{var eb=bK;ea.rectMode(0);ea.rect(this.params[0],this.params[1],this.params[2],this.params[3]);bK=eb}}else{if(this.kind===31){var ec=cN;ea.ellipseMode(0);ea.ellipse(this.params[0],this.params[1],this.params[2],this.params[3]);cN=ec}else{if(this.kind===32){var ed=cN;ea.ellipseMode(0);ea.arc(this.params[0],this.params[1],this.params[2],this.params[3],this.params[4],this.params[5]);cN=ed}else{if(this.kind===41){if(this.params.length===1){ea.box(this.params[0])}else{ea.box(this.params[0],this.params[1],this.params[2])}}else{if(this.kind===40){ea.sphere(this.params[0])}}}}}}}}}},pre:function(ea){if(this.matrix){ea.pushMatrix();ea.transform(this.matrix)}if(this.style){ea.pushStyle();this.styles(ea)}},post:function(ea){if(this.matrix){ea.popMatrix()}if(this.style){ea.popStyle()}},styles:function(ea){if(this.stroke){ea.stroke(this.strokeColor);ea.strokeWeight(this.strokeWeight);ea.strokeCap(this.strokeCap);ea.strokeJoin(this.strokeJoin)}else{ea.noStroke()}if(this.fill){ea.fill(this.fillColor)}else{ea.noFill()}},getChild:function(ed){var eb,ea;if(typeof ed===\"number\"){return this.children[ed]}var ec;if(ed===\"\"||this.name===ed){return this}if(this.nameTable.length>0){for(eb=0,ea=this.nameTable.length;eb<ea||ec;eb++){if(this.nameTable[eb].getName===ed){ec=this.nameTable[eb];break}}if(ec){return ec}}for(eb=0,ea=this.children.length;eb<ea;eb++){ec=this.children[eb].getChild(ed);if(ec){return ec}}return null},getChildCount:function(){return this.children.length},addChild:function(ea){this.children.push(ea);ea.parent=this;if(ea.getName()!==null){this.addName(ea.getName(),ea)}},addName:function(eb,ea){if(this.parent!==null){this.parent.addName(eb,ea)}else{this.nameTable.push([eb,ea])}},translate:function(){if(arguments.length===2){this.checkMatrix(2);this.matrix.translate(arguments[0],arguments[1])}else{this.checkMatrix(3);this.matrix.translate(arguments[0],arguments[1],0)}},checkMatrix:function(ea){if(this.matrix===null){if(ea===2){this.matrix=new cW.PMatrix2D}else{this.matrix=new cW.PMatrix3D}}else{if(ea===3&&this.matrix instanceof cW.PMatrix2D){this.matrix=new cW.PMatrix3D}}},rotateX:function(ea){this.rotate(ea,1,0,0)},rotateY:function(ea){this.rotate(ea,0,1,0)},rotateZ:function(ea){this.rotate(ea,0,0,1)},rotate:function(){if(arguments.length===1){this.checkMatrix(2);this.matrix.rotate(arguments[0])}else{this.checkMatrix(3);this.matrix.rotate(arguments[0],arguments[1],arguments[2],arguments[3])}},scale:function(){if(arguments.length===2){this.checkMatrix(2);this.matrix.scale(arguments[0],arguments[1])}else{if(arguments.length===3){this.checkMatrix(2);this.matrix.scale(arguments[0],arguments[1],arguments[2])}else{this.checkMatrix(2);this.matrix.scale(arguments[0])}}},resetMatrix:function(){this.checkMatrix(2);this.matrix.reset()},applyMatrix:function(ea){if(arguments.length===1){this.applyMatrix(ea.elements[0],ea.elements[1],0,ea.elements[2],ea.elements[3],ea.elements[4],0,ea.elements[5],0,0,1,0,0,0,0,1)}else{if(arguments.length===6){this.checkMatrix(2);this.matrix.apply(arguments[0],arguments[1],arguments[2],0,arguments[3],arguments[4],arguments[5],0,0,0,1,0,0,0,0,1)}else{if(arguments.length===16){this.checkMatrix(3);this.matrix.apply(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15])}}}}};var cr=cW.PShapeSVG=function(){cW.PShape.call(this);if(arguments.length===1){this.element=arguments[0];this.vertexCodes=[];this.vertices=[];this.opacity=1;this.stroke=false;this.strokeColor=4278190080;this.strokeWeight=1;this.strokeCap=\"butt\";this.strokeJoin=\"miter\";this.strokeGradient=null;this.strokeGradientPaint=null;this.strokeName=null;this.strokeOpacity=1;this.fill=true;this.fillColor=4278190080;this.fillGradient=null;this.fillGradientPaint=null;this.fillName=null;this.fillOpacity=1;if(this.element.getName()!==\"svg\"){throw\"root is not <svg>, it's <\"+this.element.getName()+\">\"}}else{if(arguments.length===2){if(typeof arguments[1]===\"string\"){if(arguments[1].indexOf(\".svg\")>-1){this.element=new cW.XMLElement(cW,arguments[1]);this.vertexCodes=[];this.vertices=[];this.opacity=1;this.stroke=false;this.strokeColor=4278190080;this.strokeWeight=1;this.strokeCap=\"butt\";this.strokeJoin=\"miter\";this.strokeGradient=\"\";this.strokeGradientPaint=\"\";this.strokeName=\"\";this.strokeOpacity=1;this.fill=true;this.fillColor=4278190080;this.fillGradient=null;this.fillGradientPaint=null;this.fillOpacity=1}}else{if(arguments[0]){this.element=arguments[1];this.vertexCodes=arguments[0].vertexCodes.slice();this.vertices=arguments[0].vertices.slice();this.stroke=arguments[0].stroke;this.strokeColor=arguments[0].strokeColor;this.strokeWeight=arguments[0].strokeWeight;this.strokeCap=arguments[0].strokeCap;this.strokeJoin=arguments[0].strokeJoin;this.strokeGradient=arguments[0].strokeGradient;this.strokeGradientPaint=arguments[0].strokeGradientPaint;this.strokeName=arguments[0].strokeName;this.fill=arguments[0].fill;this.fillColor=arguments[0].fillColor;this.fillGradient=arguments[0].fillGradient;this.fillGradientPaint=arguments[0].fillGradientPaint;this.fillName=arguments[0].fillName;this.strokeOpacity=arguments[0].strokeOpacity;this.fillOpacity=arguments[0].fillOpacity;this.opacity=arguments[0].opacity}}}}this.name=this.element.getStringAttribute(\"id\");var ea=this.element.getStringAttribute(\"display\",\"inline\");this.visible=ea!==\"none\";var ef=this.element.getAttribute(\"transform\");if(ef){this.matrix=this.parseMatrix(ef)}var ec=this.element.getStringAttribute(\"viewBox\");if(ec!==null){var ee=ec.split(\" \");this.width=ee[2];this.height=ee[3]}var eb=this.element.getStringAttribute(\"width\");var ed=this.element.getStringAttribute(\"height\");if(eb!==null){this.width=this.parseUnitSize(eb);this.height=this.parseUnitSize(ed)}else{if(this.width===0||this.height===0){this.width=1;this.height=1;throw\"The width and/or height is not readable in the <svg> tag of this file.\"}}this.parseColors(this.element);this.parseChildren(this.element)};cr.prototype=new O;cr.prototype.parseMatrix=function(){function ea(ec){var eb=[];ec.replace(/\\((.*?)\\)/,function(){return function(ed,ee){eb=ee.replace(/,+/g,\" \").split(/\\s+/)}}());return eb}return function(ei){this.checkMatrix(2);var eb=[];ei.replace(/\\s*(\\w+)\\((.*?)\\)/g,function(el){eb.push(cW.trim(el))});if(eb.length===0){return null}for(var eg=0,ee=eb.length;eg<ee;eg++){var ec=ea(eb[eg]);if(eb[eg].indexOf(\"matrix\")!==-1){this.matrix.set(ec[0],ec[2],ec[4],ec[1],ec[3],ec[5])}else{if(eb[eg].indexOf(\"translate\")!==-1){var eh=ec[0];var ef=ec.length===2?ec[1]:0;this.matrix.translate(eh,ef)}else{if(eb[eg].indexOf(\"scale\")!==-1){var ek=ec[0];var ej=ec.length===2?ec[1]:ec[0];this.matrix.scale(ek,ej)}else{if(eb[eg].indexOf(\"rotate\")!==-1){var ed=ec[0];if(ec.length===1){this.matrix.rotate(cW.radians(ed))}else{if(ec.length===3){this.matrix.translate(ec[1],ec[2]);this.matrix.rotate(cW.radians(ec[0]));this.matrix.translate(-ec[1],-ec[2])}}}else{if(eb[eg].indexOf(\"skewX\")!==-1){this.matrix.skewX(parseFloat(ec[0]))}else{if(eb[eg].indexOf(\"skewY\")!==-1){this.matrix.skewY(ec[0])}else{if(eb[eg].indexOf(\"shearX\")!==-1){this.matrix.shearX(ec[0])}else{if(eb[eg].indexOf(\"shearY\")!==-1){this.matrix.shearY(ec[0])}}}}}}}}}return this.matrix}}();cr.prototype.parseChildren=function(ef){var eb=ef.getChildren();var ee=new cW.PShape;for(var ed=0,ec=eb.length;ed<ec;ed++){var ea=this.parseChild(eb[ed]);if(ea){ee.addChild(ea)}}this.children.push(ee)};cr.prototype.getName=function(){return this.name};cr.prototype.parseChild=function(ec){var eb=ec.getName();var ea;if(eb===\"g\"){ea=new cr(this,ec)}else{if(eb===\"defs\"){ea=new cr(this,ec)}else{if(eb===\"line\"){ea=new cr(this,ec);ea.parseLine()}else{if(eb===\"circle\"){ea=new cr(this,ec);ea.parseEllipse(true)}else{if(eb===\"ellipse\"){ea=new cr(this,ec);ea.parseEllipse(false)}else{if(eb===\"rect\"){ea=new cr(this,ec);ea.parseRect()}else{if(eb===\"polygon\"){ea=new cr(this,ec);ea.parsePoly(true)}else{if(eb===\"polyline\"){ea=new cr(this,ec);ea.parsePoly(false)}else{if(eb===\"path\"){ea=new cr(this,ec);ea.parsePath()}else{if(eb===\"radialGradient\"){dw(\"PShapeSVG.prototype.parseChild, name = radialGradient\")}else{if(eb===\"linearGradient\"){dw(\"PShapeSVG.prototype.parseChild, name = linearGradient\")}else{if(eb===\"text\"){dw(\"PShapeSVG.prototype.parseChild, name = text\")}else{if(eb===\"filter\"){dw(\"PShapeSVG.prototype.parseChild, name = filter\")}else{if(eb===\"mask\"){dw(\"PShapeSVG.prototype.parseChild, name = mask\")}else{G()}}}}}}}}}}}}}}return ea};cr.prototype.parsePath=function(){this.family=21;this.kind=0;var ef=[];var ez;var ey=cW.trim(this.element.getStringAttribute(\"d\").replace(/[\\s,]+/g,\" \"));if(ey===null){return}ey=cW.__toCharArray(ey);var ed=0,ec=0,ek=0,ei=0,ej=0,eh=0,eq=0,ep=0,eb=0,ea=0,em=0,el=0,eo=0,en=0,ex=0,et=0;var er=\"\";var ev=[];var ew=false;var eg;var ee;var eu,es;while(ex<ey.length){et=ey[ex].valueOf();if(et>=65&&et<=90||et>=97&&et<=122){eu=ex;ex++;if(ex<ey.length){ev=[];et=ey[ex].valueOf();while(!(et>=65&&et<=90||et>=97&&et<=100||et>=102&&et<=122)&&ew===false){if(et===32){if(er!==\"\"){ev.push(parseFloat(er));er=\"\"}ex++}else{if(et===45){if(ey[ex-1].valueOf()===101){er+=ey[ex].toString();ex++}else{if(er!==\"\"){ev.push(parseFloat(er))}er=ey[ex].toString();ex++}}else{er+=ey[ex].toString();ex++}}if(ex===ey.length){ew=true}else{et=ey[ex].valueOf()}}}if(er!==\"\"){ev.push(parseFloat(er));er=\"\"}ee=ey[eu];et=ee.valueOf();if(et===77){if(ev.length>=2&&ev.length%2===0){ed=ev[0];ec=ev[1];this.parsePathMoveto(ed,ec);if(ev.length>2){for(eu=2,es=ev.length;eu<es;eu+=2){ed=ev[eu];ec=ev[eu+1];this.parsePathLineto(ed,ec)}}}}else{if(et===109){if(ev.length>=2&&ev.length%2===0){ed+=ev[0];ec+=ev[1];this.parsePathMoveto(ed,ec);if(ev.length>2){for(eu=2,es=ev.length;eu<es;eu+=2){ed+=ev[eu];ec+=ev[eu+1];this.parsePathLineto(ed,ec)}}}}else{if(et===76){if(ev.length>=2&&ev.length%2===0){for(eu=0,es=ev.length;eu<es;eu+=2){ed=ev[eu];ec=ev[eu+1];this.parsePathLineto(ed,ec)}}}else{if(et===108){if(ev.length>=2&&ev.length%2===0){for(eu=0,es=ev.length;eu<es;eu+=2){ed+=ev[eu];ec+=ev[eu+1];this.parsePathLineto(ed,ec)}}}else{if(et===72){for(eu=0,es=ev.length;eu<es;eu++){ed=ev[eu];this.parsePathLineto(ed,ec)}}else{if(et===104){for(eu=0,es=ev.length;eu<es;eu++){ed+=ev[eu];this.parsePathLineto(ed,ec)}}else{if(et===86){for(eu=0,es=ev.length;eu<es;eu++){ec=ev[eu];this.parsePathLineto(ed,ec)}}else{if(et===118){for(eu=0,es=ev.length;eu<es;eu++){ec+=ev[eu];this.parsePathLineto(ed,ec)}}else{if(et===67){if(ev.length>=6&&ev.length%6===0){for(eu=0,es=ev.length;eu<es;eu+=6){ej=ev[eu];eq=ev[eu+1];eh=ev[eu+2];ep=ev[eu+3];eb=ev[eu+4];ea=ev[eu+5];this.parsePathCurveto(ej,eq,eh,ep,eb,ea);ed=eb;ec=ea}}}else{if(et===99){if(ev.length>=6&&ev.length%6===0){for(eu=0,es=ev.length;eu<es;eu+=6){ej=ed+ev[eu];eq=ec+ev[eu+1];eh=ed+ev[eu+2];ep=ec+ev[eu+3];eb=ed+ev[eu+4];ea=ec+ev[eu+5];this.parsePathCurveto(ej,eq,eh,ep,eb,ea);ed=eb;ec=ea}}}else{if(et===83){if(ev.length>=4&&ev.length%4===0){for(eu=0,es=ev.length;eu<es;eu+=4){if(eg.toLowerCase()===\"c\"||eg.toLowerCase()===\"s\"){em=this.vertices[this.vertices.length-2][0];el=this.vertices[this.vertices.length-2][1];eo=this.vertices[this.vertices.length-1][0];en=this.vertices[this.vertices.length-1][1];ej=eo+(eo-em);eq=en+(en-el)}else{ej=this.vertices[this.vertices.length-1][0];eq=this.vertices[this.vertices.length-1][1]}eh=ev[eu];ep=ev[eu+1];eb=ev[eu+2];ea=ev[eu+3];this.parsePathCurveto(ej,eq,eh,ep,eb,ea);ed=eb;ec=ea}}}else{if(et===115){if(ev.length>=4&&ev.length%4===0){for(eu=0,es=ev.length;eu<es;eu+=4){if(eg.toLowerCase()===\"c\"||eg.toLowerCase()===\"s\"){em=this.vertices[this.vertices.length-2][0];el=this.vertices[this.vertices.length-2][1];eo=this.vertices[this.vertices.length-1][0];en=this.vertices[this.vertices.length-1][1];ej=eo+(eo-em);eq=en+(en-el)}else{ej=this.vertices[this.vertices.length-1][0];eq=this.vertices[this.vertices.length-1][1]}eh=ed+ev[eu];ep=ec+ev[eu+1];eb=ed+ev[eu+2];ea=ec+ev[eu+3];this.parsePathCurveto(ej,eq,eh,ep,eb,ea);ed=eb;ec=ea}}}else{if(et===81){if(ev.length>=4&&ev.length%4===0){for(eu=0,es=ev.length;eu<es;eu+=4){ek=ev[eu];ei=ev[eu+1];eb=ev[eu+2];ea=ev[eu+3];this.parsePathQuadto(ed,ec,ek,ei,eb,ea);ed=eb;ec=ea}}}else{if(et===113){if(ev.length>=4&&ev.length%4===0){for(eu=0,es=ev.length;eu<es;eu+=4){ek=ed+ev[eu];ei=ec+ev[eu+1];eb=ed+ev[eu+2];ea=ec+ev[eu+3];this.parsePathQuadto(ed,ec,ek,ei,eb,ea);ed=eb;ec=ea}}}else{if(et===84){if(ev.length>=2&&ev.length%2===0){for(eu=0,es=ev.length;eu<es;eu+=2){if(eg.toLowerCase()===\"q\"||eg.toLowerCase()===\"t\"){em=this.vertices[this.vertices.length-2][0];el=this.vertices[this.vertices.length-2][1];eo=this.vertices[this.vertices.length-1][0];en=this.vertices[this.vertices.length-1][1];ek=eo+(eo-em);ei=en+(en-el)}else{ek=ed;ei=ec}eb=ev[eu];ea=ev[eu+1];this.parsePathQuadto(ed,ec,ek,ei,eb,ea);ed=eb;ec=ea}}}else{if(et===116){if(ev.length>=2&&ev.length%2===0){for(eu=0,es=ev.length;eu<es;eu+=2){if(eg.toLowerCase()===\"q\"||eg.toLowerCase()===\"t\"){em=this.vertices[this.vertices.length-2][0];el=this.vertices[this.vertices.length-2][1];eo=this.vertices[this.vertices.length-1][0];en=this.vertices[this.vertices.length-1][1];ek=eo+(eo-em);ei=en+(en-el)}else{ek=ed;ei=ec}eb=ed+ev[eu];ea=ec+ev[eu+1];this.parsePathQuadto(ed,ec,ek,ei,eb,ea);ed=eb;ec=ea}}}else{if(et===90||et===122){this.close=true}}}}}}}}}}}}}}}}}eg=ee.toString()}else{ex++}}};cr.prototype.parsePathQuadto=function(ec,ee,ea,ef,eb,ed){if(this.vertices.length>0){this.parsePathCode(1);this.parsePathVertex(ec+(ea-ec)*2/3,ee+(ef-ee)*2/3);this.parsePathVertex(eb+(ea-eb)*2/3,ed+(ef-ed)*2/3);this.parsePathVertex(eb,ed)}else{throw\"Path must start with M/m\"}};cr.prototype.parsePathCurveto=function(ed,ef,eb,ee,ea,ec){if(this.vertices.length>0){this.parsePathCode(1);this.parsePathVertex(ed,ef);this.parsePathVertex(eb,ee);this.parsePathVertex(ea,ec)}else{throw\"Path must start with M/m\"}};cr.prototype.parsePathLineto=function(eb,ea){if(this.vertices.length>0){this.parsePathCode(0);this.parsePathVertex(eb,ea);this.vertices[this.vertices.length-1][\"moveTo\"]=false}else{throw\"Path must start with M/m\"}};cr.prototype.parsePathMoveto=function(eb,ea){if(this.vertices.length>0){this.parsePathCode(3)}this.parsePathCode(0);this.parsePathVertex(eb,ea);this.vertices[this.vertices.length-1][\"moveTo\"]=true};cr.prototype.parsePathVertex=function(ea,ec){var eb=[];eb[0]=ea;eb[1]=ec;this.vertices.push(eb)};cr.prototype.parsePathCode=function(ea){this.vertexCodes.push(ea)};cr.prototype.parsePoly=function(ee){this.family=21;this.close=ee;var eb=cW.trim(this.element.getStringAttribute(\"points\").replace(/[,\\s]+/g,\" \"));if(eb!==null){var ea=eb.split(\" \");if(ea.length%2===0){for(var ed=0,ec=ea.length;ed<ec;ed++){var ef=[];ef[0]=ea[ed];ef[1]=ea[++ed];this.vertices.push(ef)}}else{throw\"Error parsing polygon points: odd number of coordinates provided\"}}};cr.prototype.parseRect=function(){this.kind=30;this.family=1;this.params=[];this.params[0]=this.element.getFloatAttribute(\"x\");this.params[1]=this.element.getFloatAttribute(\"y\");this.params[2]=this.element.getFloatAttribute(\"width\");this.params[3]=this.element.getFloatAttribute(\"height\");if(this.params[2]<0||this.params[3]<0){throw\"svg error: negative width or height found while parsing <rect>\"}};cr.prototype.parseEllipse=function(ec){this.kind=31;this.family=1;this.params=[];this.params[0]=this.element.getFloatAttribute(\"cx\")|0;this.params[1]=this.element.getFloatAttribute(\"cy\")|0;var eb,ea;if(ec){eb=ea=this.element.getFloatAttribute(\"r\");if(eb<0){throw\"svg error: negative radius found while parsing <circle>\"}}else{eb=this.element.getFloatAttribute(\"rx\");ea=this.element.getFloatAttribute(\"ry\");if(eb<0||ea<0){throw\"svg error: negative x-axis radius or y-axis radius found while parsing <ellipse>\"}}this.params[0]-=eb;this.params[1]-=ea;this.params[2]=eb*2;this.params[3]=ea*2};cr.prototype.parseLine=function(){this.kind=4;this.family=1;this.params=[];this.params[0]=this.element.getFloatAttribute(\"x1\");this.params[1]=this.element.getFloatAttribute(\"y1\");this.params[2]=this.element.getFloatAttribute(\"x2\");this.params[3]=this.element.getFloatAttribute(\"y2\")};cr.prototype.parseColors=function(ec){if(ec.hasAttribute(\"opacity\")){this.setOpacity(ec.getAttribute(\"opacity\"))}if(ec.hasAttribute(\"stroke\")){this.setStroke(ec.getAttribute(\"stroke\"))}if(ec.hasAttribute(\"stroke-width\")){this.setStrokeWeight(ec.getAttribute(\"stroke-width\"))}if(ec.hasAttribute(\"stroke-linejoin\")){this.setStrokeJoin(ec.getAttribute(\"stroke-linejoin\"))}if(ec.hasAttribute(\"stroke-linecap\")){this.setStrokeCap(ec.getStringAttribute(\"stroke-linecap\"))}if(ec.hasAttribute(\"fill\")){this.setFill(ec.getStringAttribute(\"fill\"))}if(ec.hasAttribute(\"style\")){var ef=ec.getStringAttribute(\"style\");var ed=ef.toString().split(\";\");for(var eb=0,ea=ed.length;eb<ea;eb++){var ee=cW.trim(ed[eb].split(\":\"));if(ee[0]===\"fill\"){this.setFill(ee[1])}else{if(ee[0]===\"fill-opacity\"){this.setFillOpacity(ee[1])}else{if(ee[0]===\"stroke\"){this.setStroke(ee[1])}else{if(ee[0]===\"stroke-width\"){this.setStrokeWeight(ee[1])}else{if(ee[0]===\"stroke-linecap\"){this.setStrokeCap(ee[1])}else{if(ee[0]===\"stroke-linejoin\"){this.setStrokeJoin(ee[1])}else{if(ee[0]===\"stroke-opacity\"){this.setStrokeOpacity(ee[1])}else{if(ee[0]===\"opacity\"){this.setOpacity(ee[1])}}}}}}}}}}};cr.prototype.setFillOpacity=function(ea){this.fillOpacity=parseFloat(ea);this.fillColor=this.fillOpacity*255<<24|this.fillColor&16777215};cr.prototype.setFill=function(ea){var eb=this.fillColor&4278190080;if(ea===\"none\"){this.fill=false}else{if(ea.indexOf(\"#\")===0){this.fill=true;if(ea.length===4){ea=ea.replace(/#(.)(.)(.)/,\"#$1$1$2$2$3$3\")}this.fillColor=eb|parseInt(ea.substring(1),16)&16777215}else{if(ea.indexOf(\"rgb\")===0){this.fill=true;this.fillColor=eb|this.parseRGB(ea)}else{if(ea.indexOf(\"url(#\")===0){this.fillName=ea.substring(5,ea.length-1)}else{if(E[ea]){this.fill=true;this.fillColor=eb|parseInt(E[ea].substring(1),16)&16777215}}}}}};cr.prototype.setOpacity=function(ea){this.strokeColor=parseFloat(ea)*255<<24|this.strokeColor&16777215;this.fillColor=parseFloat(ea)*255<<24|this.fillColor&16777215};cr.prototype.setStroke=function(ea){var eb=this.strokeColor&4278190080;if(ea===\"none\"){this.stroke=false}else{if(ea.charAt(0)===\"#\"){this.stroke=true;if(ea.length===4){ea=ea.replace(/#(.)(.)(.)/,\"#$1$1$2$2$3$3\")}this.strokeColor=eb|parseInt(ea.substring(1),16)&16777215}else{if(ea.indexOf(\"rgb\")===0){this.stroke=true;this.strokeColor=eb|this.parseRGB(ea)}else{if(ea.indexOf(\"url(#\")===0){this.strokeName=ea.substring(5,ea.length-1)}else{if(E[ea]){this.stroke=true;this.strokeColor=eb|parseInt(E[ea].substring(1),16)&16777215}}}}}};cr.prototype.setStrokeWeight=function(ea){this.strokeWeight=this.parseUnitSize(ea)};cr.prototype.setStrokeJoin=function(ea){if(ea===\"miter\"){this.strokeJoin=\"miter\"}else{if(ea===\"round\"){this.strokeJoin=\"round\"}else{if(ea===\"bevel\"){this.strokeJoin=\"bevel\"}}}};cr.prototype.setStrokeCap=function(ea){if(ea===\"butt\"){this.strokeCap=\"butt\"}else{if(ea===\"round\"){this.strokeCap=\"round\"}else{if(ea===\"square\"){this.strokeCap=\"square\"}}}};cr.prototype.setStrokeOpacity=function(ea){this.strokeOpacity=parseFloat(ea);this.strokeColor=this.strokeOpacity*255<<24|this.strokeColor&16777215};cr.prototype.parseRGB=function(eb){var ec=eb.substring(eb.indexOf(\"(\")+1,eb.indexOf(\")\"));var ea=ec.split(\", \");return ea[0]<<16|ea[1]<<8|ea[2]};cr.prototype.parseUnitSize=function(eb){var ea=eb.length-2;if(ea<0){return eb}if(eb.indexOf(\"pt\")===ea){return parseFloat(eb.substring(0,ea))*1.25}if(eb.indexOf(\"pc\")===ea){return parseFloat(eb.substring(0,ea))*15}if(eb.indexOf(\"mm\")===ea){return parseFloat(eb.substring(0,ea))*3.543307}if(eb.indexOf(\"cm\")===ea){return parseFloat(eb.substring(0,ea))*35.43307}if(eb.indexOf(\"in\")===ea){return parseFloat(eb.substring(0,ea))*90}if(eb.indexOf(\"px\")===ea){return parseFloat(eb.substring(0,ea))}return parseFloat(eb)};cW.shape=function(ec,eb,ee,ed,ea){if(arguments.length>=1&&arguments[0]!==null){if(ec.isVisible()){cW.pushMatrix();if(S===3){if(arguments.length===5){cW.translate(eb-ed/2,ee-ea/2);cW.scale(ed/ec.getWidth(),ea/ec.getHeight())}else{if(arguments.length===3){cW.translate(eb-ec.getWidth()/2,-ec.getHeight()/2)}else{cW.translate(-ec.getWidth()/2,-ec.getHeight()/2)}}}else{if(S===0){if(arguments.length===5){cW.translate(eb,ee);cW.scale(ed/ec.getWidth(),ea/ec.getHeight())}else{if(arguments.length===3){cW.translate(eb,ee)}}}else{if(S===1){if(arguments.length===5){ed-=eb;ea-=ee;cW.translate(eb,ee);cW.scale(ed/ec.getWidth(),ea/ec.getHeight())}else{if(arguments.length===3){cW.translate(eb,ee)}}}}}ec.draw(cW);if(arguments.length===1&&S===3||arguments.length>1){cW.popMatrix()}}}};cW.shapeMode=function(ea){S=ea};cW.loadShape=function(ea){if(arguments.length===1){if(ea.indexOf(\".svg\")>-1){return new cr(null,ea)}}return null};var cT=function(ee,ed,ea,eb,ec){this.fullName=ee||\"\";this.name=ed||\"\";this.namespace=ea||\"\";this.value=eb;this.type=ec};cT.prototype={getName:function(){return this.name},getFullName:function(){return this.fullName},getNamespace:function(){return this.namespace},getValue:function(){return this.value},getType:function(){return this.type},setValue:function(ea){this.value=ea}};var b9=cW.XMLElement=function(ea,ec,ed,eb){this.attributes=[];this.children=[];this.fullName=null;this.name=null;this.namespace=\"\";this.content=null;this.parent=null;this.lineNr=\"\";this.systemID=\"\";this.type=\"ELEMENT\";if(ea){if(typeof ea===\"string\"){if(ec===t&&ea.indexOf(\"<\")>-1){this.parse(ea)}else{this.fullName=ea;this.namespace=ec;this.systemId=ed;this.lineNr=eb}}else{this.parse(ec)}}};b9.prototype={parse:function(ea){var ec;try{var ee=ea.substring(ea.length-4);if(ee===\".xml\"||ee===\".svg\"){ea=w(ea)}ec=(new DOMParser).parseFromString(ea,\"text/xml\");var eb=ec.documentElement;if(eb){this.parseChildrenRecursive(null,eb)}else{throw\"Error loading document\"}return this}catch(ed){throw ed}},parseChildrenRecursive:function(ei,eg){var ef,eb,eh,ee,ed,ea;if(!ei){this.fullName=eg.localName;this.name=eg.nodeName;ef=this}else{ef=new b9(eg.nodeName);ef.parent=ei}if(eg.nodeType===3&&eg.textContent!==\"\"){return this.createPCDataElement(eg.textContent)}if(eg.nodeType===4){return this.createCDataElement(eg.textContent)}if(eg.attributes){for(ee=0,ed=eg.attributes.length;ee<ed;ee++){eh=eg.attributes[ee];eb=new cT(eh.getname,eh.nodeName,eh.namespaceURI,eh.nodeValue,eh.nodeType);ef.attributes.push(eb)}}if(eg.childNodes){for(ee=0,ed=eg.childNodes.length;ee<ed;ee++){var ec=eg.childNodes[ee];ea=ef.parseChildrenRecursive(ef,ec);if(ea!==null){ef.children.push(ea)}}}return ef},createElement:function(eb,ec,ed,ea){if(ed===t){return new b9(eb,ec)}return new b9(eb,ec,ed,ea)},createPCDataElement:function(eb,ea){if(eb.replace(/^\\s+$/g,\"\")===\"\"){return null}var ec=new b9;ec.type=\"TEXT\";ec.content=eb;return ec},createCDataElement:function(ec){var ed=this.createPCDataElement(ec);if(ed===null){return null}ed.type=\"CDATA\";var eb={\"<\":\"&lt;\",\">\":\"&gt;\",\"'\":\"&apos;\",'\"':\"&quot;\"},ea;for(ea in eb){if(!Object.hasOwnProperty(eb,ea)){ec=ec.replace(new RegExp(ea,\"g\"),eb[ea])}}ed.cdata=ec;return ed},hasAttribute:function(){if(arguments.length===1){return this.getAttribute(arguments[0])!==null}if(arguments.length===2){return this.getAttribute(arguments[0],arguments[1])!==null}},equals:function(ef){if(!(ef instanceof b9)){return false}var ec,eb;if(this.fullName!==ef.fullName){return false}if(this.attributes.length!==ef.getAttributeCount()){return false}if(this.attributes.length!==ef.attributes.length){return false}var ej,eh,ea,eg,ei;for(ec=0,eb=this.attributes.length;ec<eb;ec++){ej=this.attributes[ec].getName();eh=this.attributes[ec].getNamespace();ei=ef.findAttribute(ej,eh);if(ei===null){return false}if(this.attributes[ec].getValue()!==ei.getValue()){return false}if(this.attributes[ec].getType()!==ei.getType()){return false}}if(this.children.length!==ef.getChildCount()){return false}if(this.children.length>0){var ee,ed;for(ec=0,eb=this.children.length;ec<eb;ec++){ee=this.getChild(ec);ed=ef.getChild(ec);if(!ee.equals(ed)){return false}}return true}return this.content===ef.content},getContent:function(){if(this.type===\"TEXT\"||this.type===\"CDATA\"){return this.content}var ea=this.children;if(ea.length===1&&(ea[0].type===\"TEXT\"||ea[0].type===\"CDATA\")){return ea[0].content}return null},getAttribute:function(){var ea;if(arguments.length===2){ea=this.findAttribute(arguments[0]);if(ea){return ea.getValue()}return arguments[1]}else{if(arguments.length===1){ea=this.findAttribute(arguments[0]);if(ea){return ea.getValue()}return null}else{if(arguments.length===3){ea=this.findAttribute(arguments[0],arguments[1]);if(ea){return ea.getValue()}return arguments[2]}}}},getStringAttribute:function(){if(arguments.length===1){return this.getAttribute(arguments[0])}if(arguments.length===2){return this.getAttribute(arguments[0],arguments[1])}return this.getAttribute(arguments[0],arguments[1],arguments[2])},getString:function(ea){return this.getStringAttribute(ea)},getFloatAttribute:function(){if(arguments.length===1){return parseFloat(this.getAttribute(arguments[0],0))}if(arguments.length===2){return this.getAttribute(arguments[0],arguments[1])}return this.getAttribute(arguments[0],arguments[1],arguments[2])},getFloat:function(ea){return this.getFloatAttribute(ea)},getIntAttribute:function(){if(arguments.length===1){return this.getAttribute(arguments[0],0)}if(arguments.length===2){return this.getAttribute(arguments[0],arguments[1])}return this.getAttribute(arguments[0],arguments[1],arguments[2])},getInt:function(ea){return this.getIntAttribute(ea)},hasChildren:function(){return this.children.length>0},addChild:function(ea){if(ea!==null){ea.parent=this;this.children.push(ea)}},insertChild:function(ec,ea){if(ec){if(ec.getLocalName()===null&&!this.hasChildren()){var eb=this.children[this.children.length-1];if(eb.getLocalName()===null){eb.setContent(eb.getContent()+ec.getContent());return}}ec.parent=this;this.children.splice(ea,0,ec)}},getChild:function(eb){if(typeof eb===\"number\"){return this.children[eb]}if(eb.indexOf(\"/\")!==-1){return this.getChildRecursive(eb.split(\"/\"),0)}var ea,ee;for(var ed=0,ec=this.getChildCount();ed<ec;ed++){ea=this.getChild(ed);ee=ea.getName();if(ee!==null&&ee===eb){return ea}}return null},getChildren:function(){if(arguments.length===1){if(typeof arguments[0]===\"number\"){return this.getChild(arguments[0])}if(arguments[0].indexOf(\"/\")!==-1){return this.getChildrenRecursive(arguments[0].split(\"/\"),0)}var ee=[];var ea,ed;for(var ec=0,eb=this.getChildCount();ec<eb;ec++){ea=this.getChild(ec);ed=ea.getName();if(ed!==null&&ed===arguments[0]){ee.push(ea)}}return ee}return this.children},getChildCount:function(){return this.children.length},getChildRecursive:function(eb,eg){if(eg===eb.length){return this}var ea,ef,ee=eb[eg];for(var ed=0,ec=this.getChildCount();ed<ec;ed++){ea=this.getChild(ed);ef=ea.getName();if(ef!==null&&ef===ee){return ea.getChildRecursive(eb,eg+1)}}return null},getChildrenRecursive:function(ea,ee){if(ee===ea.length-1){return this.getChildren(ea[ee])}var ed=this.getChildren(ea[ee]);var ec=[];for(var eb=0;eb<ed.length;eb++){ec=ec.concat(ed[eb].getChildrenRecursive(ea,ee+1))}return ec},isLeaf:function(){return !this.hasChildren()},listChildren:function(){var ea=[];for(var ec=0,eb=this.children.length;ec<eb;ec++){ea.push(this.getChild(ec).getName())}return ea},removeAttribute:function(eb,ed){this.namespace=ed||\"\";for(var ec=0,ea=this.attributes.length;ec<ea;ec++){if(this.attributes[ec].getName()===eb&&this.attributes[ec].getNamespace()===this.namespace){this.attributes.splice(ec,1);break}}},removeChild:function(ec){if(ec){for(var eb=0,ea=this.children.length;eb<ea;eb++){if(this.children[eb].equals(ec)){this.children.splice(eb,1);break}}}},removeChildAtIndex:function(ea){if(this.children.length>ea){this.children.splice(ea,1)}},findAttribute:function(eb,ed){this.namespace=ed||\"\";for(var ec=0,ea=this.attributes.length;ec<ea;ec++){if(this.attributes[ec].getName()===eb&&this.attributes[ec].getNamespace()===this.namespace){return this.attributes[ec]}}return null},setAttribute:function(){var ea;if(arguments.length===3){var ec=arguments[0].indexOf(\":\");var eb=arguments[0].substring(ec+1);ea=this.findAttribute(eb,arguments[1]);if(ea){ea.setValue(arguments[2])}else{ea=new cT(arguments[0],eb,arguments[1],arguments[2],\"CDATA\");this.attributes.push(ea)}}else{ea=this.findAttribute(arguments[0]);if(ea){ea.setValue(arguments[1])}else{ea=new cT(arguments[0],arguments[0],null,arguments[1],\"CDATA\");this.attributes.push(ea)}}},setString:function(ea,eb){this.setAttribute(ea,eb)},setInt:function(ea,eb){this.setAttribute(ea,eb)},setFloat:function(ea,eb){this.setAttribute(ea,eb)},setContent:function(ea){if(this.children.length>0){F.debug(\"Tried to set content for XMLElement with children\")}this.content=ea},setName:function(){if(arguments.length===1){this.name=arguments[0];this.fullName=arguments[0];this.namespace=null}else{var ea=arguments[0].indexOf(\":\");if(arguments[1]===null||ea<0){this.name=arguments[0]}else{this.name=arguments[0].substring(ea+1)}this.fullName=arguments[0];this.namespace=arguments[1]}},getName:function(){return this.fullName},getLocalName:function(){return this.name},getAttributeCount:function(){return this.attributes.length},toString:function(){if(this.type===\"TEXT\"){return this.content}if(this.type===\"CDATA\"){return this.cdata}var ec=this.fullName;var ed=\"<\"+ec;var eb,ee;for(eb=0;eb<this.attributes.length;eb++){var ea=this.attributes[eb];ed+=\" \"+ea.getName()+'=\"'+ea.getValue()+'\"'}if(this.children.length===0){if(this.content===\"\"){ed+=\"/>\"}else{ed+=\">\"+this.content+\"</\"+ec+\">\"}}else{ed+=\">\";for(ee=0;ee<this.children.length;ee++){ed+=this.children[ee].toString()}ed+=\"</\"+ec+\">\"}return ed}};b9.parse=function(eb){var ea=new b9;ea.parse(eb);return ea};var dg=cW.XML=cW.XMLElement;cW.loadXML=function(ea){return new dg(cW,ea)};var cm=function(ed){var ea=0;for(var eb=0;eb<ed.length;eb++){if(eb!==0){ea=q.max(ea,q.abs(ed[eb]))}else{ea=q.abs(ed[eb])}}var ec=(ea+\"\").indexOf(\".\");if(ec===0){ec=1}else{if(ec===-1){ec=(ea+\"\").length}}return ec};var aX=cW.PMatrix2D=function(){if(arguments.length===0){this.reset()}else{if(arguments.length===1&&arguments[0] instanceof aX){this.set(arguments[0].array())}else{if(arguments.length===6){this.set(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5])}}}};aX.prototype={set:function(){if(arguments.length===6){var ea=arguments;this.set([ea[0],ea[1],ea[2],ea[3],ea[4],ea[5]])}else{if(arguments.length===1&&arguments[0] instanceof aX){this.elements=arguments[0].array()}else{if(arguments.length===1&&arguments[0] instanceof Array){this.elements=arguments[0].slice()}}}},get:function(){var ea=new aX;ea.set(this.elements);return ea},reset:function(){this.set([1,0,0,0,1,0])},array:function aE(){return this.elements.slice()},translate:function(eb,ea){this.elements[2]=eb*this.elements[0]+ea*this.elements[1]+this.elements[2];this.elements[5]=eb*this.elements[3]+ea*this.elements[4]+this.elements[5]},invTranslate:function(eb,ea){this.translate(-eb,-ea)},transpose:function(){},mult:function(eb,ec){var ea,ed;if(eb instanceof A){ea=eb.x;ed=eb.y;if(!ec){ec=new A}}else{if(eb instanceof Array){ea=eb[0];ed=eb[1];if(!ec){ec=[]}}}if(ec instanceof Array){ec[0]=this.elements[0]*ea+this.elements[1]*ed+this.elements[2];ec[1]=this.elements[3]*ea+this.elements[4]*ed+this.elements[5]}else{if(ec instanceof A){ec.x=this.elements[0]*ea+this.elements[1]*ed+this.elements[2];ec.y=this.elements[3]*ea+this.elements[4]*ed+this.elements[5];ec.z=0}}return ec},multX:function(ea,eb){return ea*this.elements[0]+eb*this.elements[1]+this.elements[2]},multY:function(ea,eb){return ea*this.elements[3]+eb*this.elements[4]+this.elements[5]},skewX:function(ea){this.apply(1,0,1,ea,0,0)},skewY:function(ea){this.apply(1,0,1,0,ea,0)},shearX:function(ea){this.apply(1,0,1,q.tan(ea),0,0)},shearY:function(ea){this.apply(1,0,1,0,q.tan(ea),0)},determinant:function(){return this.elements[0]*this.elements[4]-this.elements[1]*this.elements[3]},invert:function(){var ef=this.determinant();if(q.abs(ef)>-2147483648){var eb=this.elements[0];var eg=this.elements[1];var ee=this.elements[2];var ed=this.elements[3];var ec=this.elements[4];var ea=this.elements[5];this.elements[0]=ec/ef;this.elements[3]=-ed/ef;this.elements[1]=-eg/ef;this.elements[4]=eb/ef;this.elements[2]=(eg*ea-ec*ee)/ef;this.elements[5]=(ed*ee-eb*ea)/ef;return true}return false},scale:function(eb,ea){if(eb&&!ea){ea=eb}if(eb&&ea){this.elements[0]*=eb;this.elements[1]*=ea;this.elements[3]*=eb;this.elements[4]*=ea}},invScale:function(eb,ea){if(eb&&!ea){ea=eb}this.scale(1/eb,1/ea)},apply:function(){var ec;if(arguments.length===1&&arguments[0] instanceof aX){ec=arguments[0].array()}else{if(arguments.length===6){ec=Array.prototype.slice.call(arguments)}else{if(arguments.length===1&&arguments[0] instanceof Array){ec=arguments[0]}}}var ea=[0,0,this.elements[2],0,0,this.elements[5]];var ed=0;for(var ee=0;ee<2;ee++){for(var eb=0;eb<3;eb++,ed++){ea[ed]+=this.elements[ee*3+0]*ec[eb+0]+this.elements[ee*3+1]*ec[eb+3]}}this.elements=ea.slice()},preApply:function(){var eb;if(arguments.length===1&&arguments[0] instanceof aX){eb=arguments[0].array()}else{if(arguments.length===6){eb=Array.prototype.slice.call(arguments)}else{if(arguments.length===1&&arguments[0] instanceof Array){eb=arguments[0]}}}var ea=[0,0,eb[2],0,0,eb[5]];ea[2]=eb[2]+this.elements[2]*eb[0]+this.elements[5]*eb[1];ea[5]=eb[5]+this.elements[2]*eb[3]+this.elements[5]*eb[4];ea[0]=this.elements[0]*eb[0]+this.elements[3]*eb[1];ea[3]=this.elements[0]*eb[3]+this.elements[3]*eb[4];ea[1]=this.elements[1]*eb[0]+this.elements[4]*eb[1];ea[4]=this.elements[1]*eb[3]+this.elements[4]*eb[4];this.elements=ea.slice()},rotate:function(ec){var ee=q.cos(ec);var ea=q.sin(ec);var ed=this.elements[0];var eb=this.elements[1];this.elements[0]=ee*ed+ea*eb;this.elements[1]=-ea*ed+ee*eb;ed=this.elements[3];eb=this.elements[4];this.elements[3]=ee*ed+ea*eb;this.elements[4]=-ea*ed+ee*eb},rotateZ:function(ea){this.rotate(ea)},invRotateZ:function(ea){this.rotateZ(ea-q.PI)},print:function(){var eb=cm(this.elements);var ea=\"\"+cW.nfs(this.elements[0],eb,4)+\" \"+cW.nfs(this.elements[1],eb,4)+\" \"+cW.nfs(this.elements[2],eb,4)+\"\\n\"+cW.nfs(this.elements[3],eb,4)+\" \"+cW.nfs(this.elements[4],eb,4)+\" \"+cW.nfs(this.elements[5],eb,4)+\"\\n\\n\";cW.println(ea)}};var aP=cW.PMatrix3D=function(){this.reset()};aP.prototype={set:function(){if(arguments.length===16){this.elements=Array.prototype.slice.call(arguments)}else{if(arguments.length===1&&arguments[0] instanceof aP){this.elements=arguments[0].array()}else{if(arguments.length===1&&arguments[0] instanceof Array){this.elements=arguments[0].slice()}}}},get:function(){var ea=new aP;ea.set(this.elements);return ea},reset:function(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},array:function aE(){return this.elements.slice()},translate:function(eb,ea,ec){if(ec===t){ec=0}this.elements[3]+=eb*this.elements[0]+ea*this.elements[1]+ec*this.elements[2];this.elements[7]+=eb*this.elements[4]+ea*this.elements[5]+ec*this.elements[6];this.elements[11]+=eb*this.elements[8]+ea*this.elements[9]+ec*this.elements[10];this.elements[15]+=eb*this.elements[12]+ea*this.elements[13]+ec*this.elements[14]},transpose:function(){var ea=this.elements[4];this.elements[4]=this.elements[1];this.elements[1]=ea;ea=this.elements[8];this.elements[8]=this.elements[2];this.elements[2]=ea;ea=this.elements[6];this.elements[6]=this.elements[9];this.elements[9]=ea;ea=this.elements[3];this.elements[3]=this.elements[12];this.elements[12]=ea;ea=this.elements[7];this.elements[7]=this.elements[13];this.elements[13]=ea;ea=this.elements[11];this.elements[11]=this.elements[14];this.elements[14]=ea},mult:function(ec,ed){var ea,ef,ee,eb;if(ec instanceof A){ea=ec.x;ef=ec.y;ee=ec.z;eb=1;if(!ed){ed=new A}}else{if(ec instanceof Array){ea=ec[0];ef=ec[1];ee=ec[2];eb=ec[3]||1;if(!ed||ed.length!==3&&ed.length!==4){ed=[0,0,0]}}}if(ed instanceof Array){if(ed.length===3){ed[0]=this.elements[0]*ea+this.elements[1]*ef+this.elements[2]*ee+this.elements[3];ed[1]=this.elements[4]*ea+this.elements[5]*ef+this.elements[6]*ee+this.elements[7];ed[2]=this.elements[8]*ea+this.elements[9]*ef+this.elements[10]*ee+this.elements[11]}else{if(ed.length===4){ed[0]=this.elements[0]*ea+this.elements[1]*ef+this.elements[2]*ee+this.elements[3]*eb;ed[1]=this.elements[4]*ea+this.elements[5]*ef+this.elements[6]*ee+this.elements[7]*eb;ed[2]=this.elements[8]*ea+this.elements[9]*ef+this.elements[10]*ee+this.elements[11]*eb;ed[3]=this.elements[12]*ea+this.elements[13]*ef+this.elements[14]*ee+this.elements[15]*eb}}}if(ed instanceof A){ed.x=this.elements[0]*ea+this.elements[1]*ef+this.elements[2]*ee+this.elements[3];ed.y=this.elements[4]*ea+this.elements[5]*ef+this.elements[6]*ee+this.elements[7];ed.z=this.elements[8]*ea+this.elements[9]*ef+this.elements[10]*ee+this.elements[11]}return ed},preApply:function(){var ec;if(arguments.length===1&&arguments[0] instanceof aP){ec=arguments[0].array()}else{if(arguments.length===16){ec=Array.prototype.slice.call(arguments)}else{if(arguments.length===1&&arguments[0] instanceof Array){ec=arguments[0]}}}var ea=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];var ed=0;for(var ee=0;ee<4;ee++){for(var eb=0;eb<4;eb++,ed++){ea[ed]+=this.elements[eb+0]*ec[ee*4+0]+this.elements[eb+4]*ec[ee*4+1]+this.elements[eb+8]*ec[ee*4+2]+this.elements[eb+12]*ec[ee*4+3]}}this.elements=ea.slice()},apply:function(){var ec;if(arguments.length===1&&arguments[0] instanceof aP){ec=arguments[0].array()}else{if(arguments.length===16){ec=Array.prototype.slice.call(arguments)}else{if(arguments.length===1&&arguments[0] instanceof Array){ec=arguments[0]}}}var ea=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];var ed=0;for(var ee=0;ee<4;ee++){for(var eb=0;eb<4;eb++,ed++){ea[ed]+=this.elements[ee*4+0]*ec[eb+0]+this.elements[ee*4+1]*ec[eb+4]+this.elements[ee*4+2]*ec[eb+8]+this.elements[ee*4+3]*ec[eb+12]}}this.elements=ea.slice()},rotate:function(ee,ea,eg,ed){if(!eg){this.rotateZ(ee)}else{var ef=cW.cos(ee);var ec=cW.sin(ee);var eb=1-ef;this.apply(eb*ea*ea+ef,eb*ea*eg-ec*ed,eb*ea*ed+ec*eg,0,eb*ea*eg+ec*ed,eb*eg*eg+ef,eb*eg*ed-ec*ea,0,eb*ea*ed-ec*eg,eb*eg*ed+ec*ea,eb*ed*ed+ef,0,0,0,0,1)}},invApply:function(){if(ab===t){ab=new aP}var ea=arguments;ab.set(ea[0],ea[1],ea[2],ea[3],ea[4],ea[5],ea[6],ea[7],ea[8],ea[9],ea[10],ea[11],ea[12],ea[13],ea[14],ea[15]);if(!ab.invert()){return false}this.preApply(ab);return true},rotateX:function(eb){var ec=cW.cos(eb);var ea=cW.sin(eb);this.apply([1,0,0,0,0,ec,-ea,0,0,ea,ec,0,0,0,0,1])},rotateY:function(eb){var ec=cW.cos(eb);var ea=cW.sin(eb);this.apply([ec,0,ea,0,0,1,0,0,-ea,0,ec,0,0,0,0,1])},rotateZ:function(eb){var ec=q.cos(eb);var ea=q.sin(eb);this.apply([ec,-ea,0,0,ea,ec,0,0,0,0,1,0,0,0,0,1])},scale:function(ec,eb,ea){if(ec&&!eb&&!ea){eb=ea=ec}else{if(ec&&eb&&!ea){ea=1}}if(ec&&eb&&ea){this.elements[0]*=ec;this.elements[1]*=eb;this.elements[2]*=ea;this.elements[4]*=ec;this.elements[5]*=eb;this.elements[6]*=ea;this.elements[8]*=ec;this.elements[9]*=eb;this.elements[10]*=ea;this.elements[12]*=ec;this.elements[13]*=eb;this.elements[14]*=ea}},skewX:function(eb){var ea=q.tan(eb);this.apply(1,ea,0,0,0,1,0,0,0,0,1,0,0,0,0,1)},skewY:function(eb){var ea=q.tan(eb);this.apply(1,0,0,0,ea,1,0,0,0,0,1,0,0,0,0,1)},shearX:function(eb){var ea=q.tan(eb);this.apply(1,ea,0,0,0,1,0,0,0,0,1,0,0,0,0,1)},shearY:function(eb){var ea=q.tan(eb);this.apply(1,0,0,0,ea,1,0,0,0,0,1,0,0,0,0,1)},multX:function(ea,ed,ec,eb){if(!ec){return this.elements[0]*ea+this.elements[1]*ed+this.elements[3]}if(!eb){return this.elements[0]*ea+this.elements[1]*ed+this.elements[2]*ec+this.elements[3]}return this.elements[0]*ea+this.elements[1]*ed+this.elements[2]*ec+this.elements[3]*eb},multY:function(ea,ed,ec,eb){if(!ec){return this.elements[4]*ea+this.elements[5]*ed+this.elements[7]}if(!eb){return this.elements[4]*ea+this.elements[5]*ed+this.elements[6]*ec+this.elements[7]}return this.elements[4]*ea+this.elements[5]*ed+this.elements[6]*ec+this.elements[7]*eb},multZ:function(ea,ed,ec,eb){if(!eb){return this.elements[8]*ea+this.elements[9]*ed+this.elements[10]*ec+this.elements[11]}return this.elements[8]*ea+this.elements[9]*ed+this.elements[10]*ec+this.elements[11]*eb},multW:function(ea,ed,ec,eb){if(!eb){return this.elements[12]*ea+this.elements[13]*ed+this.elements[14]*ec+this.elements[15]}return this.elements[12]*ea+this.elements[13]*ed+this.elements[14]*ec+this.elements[15]*eb},invert:function(){var ej=this.elements[0]*this.elements[5]-this.elements[1]*this.elements[4];var ei=this.elements[0]*this.elements[6]-this.elements[2]*this.elements[4];var eh=this.elements[0]*this.elements[7]-this.elements[3]*this.elements[4];var eg=this.elements[1]*this.elements[6]-this.elements[2]*this.elements[5];var ef=this.elements[1]*this.elements[7]-this.elements[3]*this.elements[5];var ee=this.elements[2]*this.elements[7]-this.elements[3]*this.elements[6];var ed=this.elements[8]*this.elements[13]-this.elements[9]*this.elements[12];var ec=this.elements[8]*this.elements[14]-this.elements[10]*this.elements[12];var eb=this.elements[8]*this.elements[15]-this.elements[11]*this.elements[12];var eo=this.elements[9]*this.elements[14]-this.elements[10]*this.elements[13];var em=this.elements[9]*this.elements[15]-this.elements[11]*this.elements[13];var el=this.elements[10]*this.elements[15]-this.elements[11]*this.elements[14];var en=ej*el-ei*em+eh*eo+eg*eb-ef*ec+ee*ed;if(q.abs(en)<=1e-9){return false}var ek=[];ek[0]=+this.elements[5]*el-this.elements[6]*em+this.elements[7]*eo;ek[4]=-this.elements[4]*el+this.elements[6]*eb-this.elements[7]*ec;ek[8]=+this.elements[4]*em-this.elements[5]*eb+this.elements[7]*ed;ek[12]=-this.elements[4]*eo+this.elements[5]*ec-this.elements[6]*ed;ek[1]=-this.elements[1]*el+this.elements[2]*em-this.elements[3]*eo;ek[5]=+this.elements[0]*el-this.elements[2]*eb+this.elements[3]*ec;ek[9]=-this.elements[0]*em+this.elements[1]*eb-this.elements[3]*ed;ek[13]=+this.elements[0]*eo-this.elements[1]*ec+this.elements[2]*ed;ek[2]=+this.elements[13]*ee-this.elements[14]*ef+this.elements[15]*eg;ek[6]=-this.elements[12]*ee+this.elements[14]*eh-this.elements[15]*ei;ek[10]=+this.elements[12]*ef-this.elements[13]*eh+this.elements[15]*ej;ek[14]=-this.elements[12]*eg+this.elements[13]*ei-this.elements[14]*ej;ek[3]=-this.elements[9]*ee+this.elements[10]*ef-this.elements[11]*eg;ek[7]=+this.elements[8]*ee-this.elements[10]*eh+this.elements[11]*ei;ek[11]=-this.elements[8]*ef+this.elements[9]*eh-this.elements[11]*ej;ek[15]=+this.elements[8]*eg-this.elements[9]*ei+this.elements[10]*ej;var ea=1/en;ek[0]*=ea;ek[1]*=ea;ek[2]*=ea;ek[3]*=ea;ek[4]*=ea;ek[5]*=ea;ek[6]*=ea;ek[7]*=ea;ek[8]*=ea;ek[9]*=ea;ek[10]*=ea;ek[11]*=ea;ek[12]*=ea;ek[13]*=ea;ek[14]*=ea;ek[15]*=ea;this.elements=ek.slice();return true},toString:function(){var eb=\"\";for(var ea=0;ea<15;ea++){eb+=this.elements[ea]+\", \"}eb+=this.elements[15];return eb},print:function(){var eb=cm(this.elements);var ea=\"\"+cW.nfs(this.elements[0],eb,4)+\" \"+cW.nfs(this.elements[1],eb,4)+\" \"+cW.nfs(this.elements[2],eb,4)+\" \"+cW.nfs(this.elements[3],eb,4)+\"\\n\"+cW.nfs(this.elements[4],eb,4)+\" \"+cW.nfs(this.elements[5],eb,4)+\" \"+cW.nfs(this.elements[6],eb,4)+\" \"+cW.nfs(this.elements[7],eb,4)+\"\\n\"+cW.nfs(this.elements[8],eb,4)+\" \"+cW.nfs(this.elements[9],eb,4)+\" \"+cW.nfs(this.elements[10],eb,4)+\" \"+cW.nfs(this.elements[11],eb,4)+\"\\n\"+cW.nfs(this.elements[12],eb,4)+\" \"+cW.nfs(this.elements[13],eb,4)+\" \"+cW.nfs(this.elements[14],eb,4)+\" \"+cW.nfs(this.elements[15],eb,4)+\"\\n\\n\";cW.println(ea)},invTranslate:function(eb,ea,ec){this.preApply(1,0,0,-eb,0,1,0,-ea,0,0,1,-ec,0,0,0,1)},invRotateX:function(eb){var ec=q.cos(-eb);var ea=q.sin(-eb);this.preApply([1,0,0,0,0,ec,-ea,0,0,ea,ec,0,0,0,0,1])},invRotateY:function(eb){var ec=q.cos(-eb);var ea=q.sin(-eb);this.preApply([ec,0,ea,0,0,1,0,0,-ea,0,ec,0,0,0,0,1])},invRotateZ:function(eb){var ec=q.cos(-eb);var ea=q.sin(-eb);this.preApply([ec,-ea,0,0,ea,ec,0,0,0,0,1,0,0,0,0,1])},invScale:function(ea,ec,eb){this.preApply([1/ea,0,0,0,0,1/ec,0,0,0,0,1/eb,0,0,0,0,1])}};var V=cW.PMatrixStack=function(){this.matrixStack=[]};V.prototype.load=function(){var ea=dY.$newPMatrix();if(arguments.length===1){ea.set(arguments[0])}else{ea.set(arguments)}this.matrixStack.push(ea)};bR.prototype.$newPMatrix=function(){return new aX};bB.prototype.$newPMatrix=function(){return new aP};V.prototype.push=function(){this.matrixStack.push(this.peek())};V.prototype.pop=function(){return this.matrixStack.pop()};V.prototype.peek=function(){var ea=dY.$newPMatrix();ea.set(this.matrixStack[this.matrixStack.length-1]);return ea};V.prototype.mult=function(ea){this.matrixStack[this.matrixStack.length-1].apply(ea)};cW.split=function(eb,ea){return eb.split(ea)};cW.splitTokens=function(eg,ef){if(ef===t){return eg.split(/\\s+/g)}var ed=ef.split(/()/g),eb=\"\",ea=eg.length,ec,eh,ee=[];for(ec=0;ec<ea;ec++){eh=eg[ec];if(ed.indexOf(eh)>-1){if(eb!==\"\"){ee.push(eb)}eb=\"\"}else{eb+=eh}}if(eb!==\"\"){ee.push(eb)}return ee};cW.append=function(eb,ea){eb[eb.length]=ea;return eb};cW.concat=function(eb,ea){return eb.concat(ea)};cW.sort=function(ef,ed){var eb=[];if(ef.length>0){var ee=ed>0?ed:ef.length;for(var ec=0;ec<ee;ec++){eb.push(ef[ec])}if(typeof ef[0]===\"string\"){eb.sort()}else{eb.sort(function(eh,eg){return eh-eg})}if(ed>0){for(var ea=eb.length;ea<ef.length;ea++){eb.push(ef[ea])}}}return eb};cW.splice=function(ee,ed,eb){if(ed.length===0){return ee}if(ed instanceof Array){for(var ec=0,ea=eb;ec<ed.length;ea++,ec++){ee.splice(ea,0,ed[ec])}}else{ee.splice(eb,0,ed)}return ee};cW.subset=function(ed,ec,eb){var ea=eb!==t?ec+eb:ed.length;return ed.slice(ec,ea)};cW.join=function(eb,ea){return eb.join(ea)};cW.shorten=function(ed){var eb=[];var ea=ed.length;for(var ec=0;ec<ea;ec++){eb[ec]=ed[ec]}eb.pop();return eb};cW.expand=function(ec,ed){var eb=ec.slice(0),ea=ed||ec.length*2;eb.length=ea;return eb};cW.arrayCopy=function(){var eg,ee=0,ec,eb=0,ef;if(arguments.length===2){eg=arguments[0];ec=arguments[1];ef=eg.length}else{if(arguments.length===3){eg=arguments[0];ec=arguments[1];ef=arguments[2]}else{if(arguments.length===5){eg=arguments[0];ee=arguments[1];ec=arguments[2];eb=arguments[3];ef=arguments[4]}}}for(var ed=ee,ea=eb;ed<ef+ee;ed++,ea++){if(ec[ea]!==t){ec[ea]=eg[ed]}else{throw\"array index out of bounds exception\"}}};cW.reverse=function(ea){return ea.reverse()};cW.mix=function(eb,ea,ec){return eb+((ea-eb)*ec>>8)};cW.peg=function(ea){return ea<0?0:ea>255?255:ea};cW.modes=function(){var ef=4278190080,ec=16711680,eb=65280,ee=255,ed=q.min,ea=q.max;function eg(el,eo,ek,et,ev,eu,em,eq,ep,ei,ej){var es=ed(((el&4278190080)>>>24)+eo,255)<<24;var eh=ek+((ep-ek)*eo>>8);eh=(eh<0?0:eh>255?255:eh)<<16;var en=et+((ei-et)*eo>>8);en=(en<0?0:en>255?255:en)<<8;var er=ev+((ej-ev)*eo>>8);er=er<0?0:er>255?255:er;return es|eh|en|er}return{replace:function(ei,eh){return eh},blend:function(ej,ei){var el=(ei&ef)>>>24,eh=ej&ec,en=ej&eb,ep=ej&ee,eo=ei&ec,ek=ei&eb,em=ei&ee;return ed(((ej&ef)>>>24)+el,255)<<24|eh+((eo-eh)*el>>8)&ec|en+((ek-en)*el>>8)&eb|ep+((em-ep)*el>>8)&ee},add:function(ei,eh){var ej=(eh&ef)>>>24;return ed(((ei&ef)>>>24)+ej,255)<<24|ed((ei&ec)+((eh&ec)>>8)*ej,ec)&ec|ed((ei&eb)+((eh&eb)>>8)*ej,eb)&eb|ed((ei&ee)+((eh&ee)*ej>>8),ee)},subtract:function(ei,eh){var ej=(eh&ef)>>>24;return ed(((ei&ef)>>>24)+ej,255)<<24|ea((ei&ec)-((eh&ec)>>8)*ej,eb)&ec|ea((ei&eb)-((eh&eb)>>8)*ej,ee)&eb|ea((ei&ee)-((eh&ee)*ej>>8),0)},lightest:function(ei,eh){var ej=(eh&ef)>>>24;return ed(((ei&ef)>>>24)+ej,255)<<24|ea(ei&ec,((eh&ec)>>8)*ej)&ec|ea(ei&eb,((eh&eb)>>8)*ej)&eb|ea(ei&ee,(eh&ee)*ej>>8)},darkest:function(ej,ei){var el=(ei&ef)>>>24,eh=ej&ec,en=ej&eb,ep=ej&ee,eo=ed(ej&ec,((ei&ec)>>8)*el),ek=ed(ej&eb,((ei&eb)>>8)*el),em=ed(ej&ee,(ei&ee)*el>>8);return ed(((ej&ef)>>>24)+el,255)<<24|eh+((eo-eh)*el>>8)&ec|en+((ek-en)*el>>8)&eb|ep+((em-ep)*el>>8)&ee},difference:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee,eo=ej>er?ej-er:er-ej,eh=eq>em?eq-em:em-eq,ei=es>ep?es-ep:ep-es;return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)},exclusion:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee,eo=ej+er-(ej*er>>7),eh=eq+em-(eq*em>>7),ei=es+ep-(es*ep>>7);return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)},multiply:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee,eo=ej*er>>8,eh=eq*em>>8,ei=es*ep>>8;return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)},screen:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee,eo=255-((255-ej)*(255-er)>>8),eh=255-((255-eq)*(255-em)>>8),ei=255-((255-es)*(255-ep)>>8);return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)},hard_light:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee,eo=er<128?ej*er>>7:255-((255-ej)*(255-er)>>7),eh=em<128?eq*em>>7:255-((255-eq)*(255-em)>>7),ei=ep<128?es*ep>>7:255-((255-es)*(255-ep)>>7);return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)},soft_light:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee,eo=(ej*er>>7)+(ej*ej>>8)-(ej*ej*er>>15),eh=(eq*em>>7)+(eq*eq>>8)-(eq*eq*em>>15),ei=(es*ep>>7)+(es*es>>8)-(es*es*ep>>15);return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)},overlay:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee,eo=ej<128?ej*er>>7:255-((255-ej)*(255-er)>>7),eh=eq<128?eq*em>>7:255-((255-eq)*(255-em)>>7),ei=es<128?es*ep>>7:255-((255-es)*(255-ep)>>7);return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)},dodge:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee;var eo=255;if(er!==255){eo=(ej<<8)/(255-er);eo=eo<0?0:eo>255?255:eo}var eh=255;if(em!==255){eh=(eq<<8)/(255-em);eh=eh<0?0:eh>255?255:eh}var ei=255;if(ep!==255){ei=(es<<8)/(255-ep);ei=ei<0?0:ei>255?255:ei}return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)},burn:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee;var eo=0;if(er!==0){eo=(255-ej<<8)/er;eo=255-(eo<0?0:eo>255?255:eo)}var eh=0;if(em!==0){eh=(255-eq<<8)/em;eh=255-(eh<0?0:eh>255?255:eh)}var ei=0;if(ep!==0){ei=(255-es<<8)/ep;ei=255-(ei<0?0:ei>255?255:ei)}return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)}}}();function dH(ef,ee,ec,eb){var ea,ed,eh,ei;if(cY===3){var eg=cW.color.toRGB(ef,ee,ec);ea=eg[0];ed=eg[1];eh=eg[2]}else{ea=q.round(255*(ef/bJ));ed=q.round(255*(ee/bI));eh=q.round(255*(ec/bG))}ei=q.round(255*(eb/bU));ea=ea<0?0:ea;ed=ed<0?0:ed;eh=eh<0?0:eh;ei=ei<0?0:ei;ea=ea>255?255:ea;ed=ed>255?255:ed;eh=eh>255?255:eh;ei=ei>255?255:ei;return ei<<24&4278190080|ea<<16&16711680|ed<<8&65280|eh&255}function dK(ea,ec){var eb;if(ea&4278190080){eb=q.round(255*(ec/bU));eb=eb>255?255:eb;eb=eb<0?0:eb;return ea-(ea&4278190080)+(eb<<24&4278190080)}if(cY===1){return dH(ea,ea,ea,ec)}if(cY===3){return dH(0,0,ea/bJ*bG,ec)}}function dM(ea){if(ea<=bJ&&ea>=0){if(cY===1){return dH(ea,ea,ea,bU)}if(cY===3){return dH(0,0,ea/bJ*bG,bU)}}if(ea){if(ea>2147483647){ea-=4294967296}return ea}}cW.color=function(ea,ed,ec,eb){if(ea!==t&&ed!==t&&ec!==t&&eb!==t){return dH(ea,ed,ec,eb)}if(ea!==t&&ed!==t&&ec!==t){return dH(ea,ed,ec,bU)}if(ea!==t&&ed!==t){return dK(ea,ed)}if(typeof ea===\"number\"){return dM(ea)}return dH(bJ,bI,bG,bU)};cW.color.toString=function(ea){return\"rgba(\"+((ea>>16)&255)+\",\"+((ea>>8)&255)+\",\"+(ea&255)+\",\"+((ea>>24)&255)/255+\")\"};cW.color.toInt=function(ed,ec,ea,eb){return eb<<24&4278190080|ed<<16&16711680|ec<<8&65280|ea&255};cW.color.toArray=function(ea){return[(ea>>16)&255,(ea>>8)&255,ea&255,(ea>>24)&255]};cW.color.toGLArray=function(ea){return[((ea&16711680)>>>16)/255,((ea>>8)&255)/255,(ea&255)/255,((ea>>24)&255)/255]};cW.color.toRGB=function(ec,ei,ef){ec=ec>bJ?bJ:ec;ei=ei>bI?bI:ei;ef=ef>bG?bG:ef;ec=ec/bJ*360;ei=ei/bI*100;ef=ef/bG*100;var eh=q.round(ef/100*255);if(ei===0){return[eh,eh,eh]}var ed=ec%360;var ee=ed%60;var eb=q.round(ef*(100-ei)/10000*255);var ea=q.round(ef*(6000-ei*ee)/600000*255);var eg=q.round(ef*(6000-ei*(60-ee))/600000*255);switch(q.floor(ed/60)){case 0:return[eh,eg,eb];case 1:return[ea,eh,eb];case 2:return[eb,eh,eg];case 3:return[eb,ea,eh];case 4:return[eg,eb,eh];case 5:return[eh,eb,ea]}};function aS(eh){var eg,ef,eb;eg=((eh>>16)&255)/255;ef=((eh>>8)&255)/255;eb=(eh&255)/255;var ea=cW.max(cW.max(eg,ef),eb),ed=cW.min(cW.min(eg,ef),eb),ec,ee;if(ed===ea){return[0,0,ea*bG]}ee=(ea-ed)/ea;if(eg===ea){ec=(ef-eb)/(ea-ed)}else{if(ef===ea){ec=2+(eb-eg)/(ea-ed)}else{ec=4+(eg-ef)/(ea-ed)}}ec/=6;if(ec<0){ec+=1}else{if(ec>1){ec-=1}}return[ec*bJ,ee*bI,ea*bG]}cW.brightness=function(ea){return aS(ea)[2]};cW.saturation=function(ea){return aS(ea)[1]};cW.hue=function(ea){return aS(ea)[0]};cW.red=function(ea){return((ea>>16)&255)/255*bJ};cW.green=function(ea){return((ea&65280)>>>8)/255*bI};cW.blue=function(ea){return(ea&255)/255*bG};cW.alpha=function(ea){return((ea>>24)&255)/255*bU};cW.lerpColor=function(em,el,ef){var ek,eq,er,es,eo,ea,eg,eu,en,ev,ee,et;var ei,eh,eb,ep,ej;var ed=cW.color(em);var ec=cW.color(el);if(cY===3){ei=aS(ed);eu=((ed>>24)&255)/bU;eh=aS(ec);et=((ec&4278190080)>>>24)/bU;ep=cW.lerp(ei[0],eh[0],ef);ej=cW.lerp(ei[1],eh[1],ef);er=cW.lerp(ei[2],eh[2],ef);eb=cW.color.toRGB(ep,ej,er);es=cW.lerp(eu,et,ef)*bU;return es<<24&4278190080|(eb[0]&255)<<16|(eb[1]&255)<<8|eb[2]&255}eo=(ed>>16)&255;ea=(ed>>8)&255;eg=ed&255;eu=((ed>>24)&255)/bU;en=(ec&16711680)>>>16;ev=(ec>>8)&255;ee=ec&255;et=((ec>>24)&255)/bU;ek=cW.lerp(eo,en,ef)|0;eq=cW.lerp(ea,ev,ef)|0;er=cW.lerp(eg,ee,ef)|0;es=cW.lerp(eu,et,ef)*bU;return es<<24&4278190080|ek<<16&16711680|eq<<8&65280|er&255};cW.colorMode=function(){cY=arguments[0];if(arguments.length>1){bJ=arguments[1];bI=arguments[2]||arguments[1];bG=arguments[3]||arguments[1];bU=arguments[4]||arguments[1]}};cW.blendColor=function(eb,ea,ec){if(ec===0){return cW.modes.replace(eb,ea)}else{if(ec===1){return cW.modes.blend(eb,ea)}else{if(ec===2){return cW.modes.add(eb,ea)}else{if(ec===4){return cW.modes.subtract(eb,ea)}else{if(ec===8){return cW.modes.lightest(eb,ea)}else{if(ec===16){return cW.modes.darkest(eb,ea)}else{if(ec===32){return cW.modes.difference(eb,ea)}else{if(ec===64){return cW.modes.exclusion(eb,ea)}else{if(ec===128){return cW.modes.multiply(eb,ea)}else{if(ec===256){return cW.modes.screen(eb,ea)}else{if(ec===1024){return cW.modes.hard_light(eb,ea)}else{if(ec===2048){return cW.modes.soft_light(eb,ea)}else{if(ec===512){return cW.modes.overlay(eb,ea)}else{if(ec===4096){return cW.modes.dodge(eb,ea)}else{if(ec===8192){return cW.modes.burn(eb,ea)}}}}}}}}}}}}}}}};function aD(){d8.save()}function cP(){d8.restore();b3=true;aq=true}cW.printMatrix=function(){dJ.print()};bR.prototype.translate=function(ea,eb){dJ.translate(ea,eb);aT.invTranslate(ea,eb);d8.translate(ea,eb)};bB.prototype.translate=function(ea,ec,eb){dJ.translate(ea,ec,eb);aT.invTranslate(ea,ec,eb)};bR.prototype.scale=function(ea,eb){dJ.scale(ea,eb);aT.invScale(ea,eb);d8.scale(ea,eb||ea)};bB.prototype.scale=function(ea,ec,eb){dJ.scale(ea,ec,eb);aT.invScale(ea,ec,eb)};bR.prototype.transform=function(eb){var ea=eb.array();d8.transform(ea[0],ea[3],ea[1],ea[4],ea[2],ea[5])};bB.prototype.transformm=function(ea){throw\"p.transform is currently not supported in 3D mode\"};bR.prototype.pushMatrix=function(){am.load(dJ);da.load(aT);aD()};bB.prototype.pushMatrix=function(){am.load(dJ);da.load(aT)};bR.prototype.popMatrix=function(){dJ.set(am.pop());aT.set(da.pop());cP()};bB.prototype.popMatrix=function(){dJ.set(am.pop());aT.set(da.pop())};bR.prototype.resetMatrix=function(){dJ.reset();aT.reset();d8.setTransform(1,0,0,1,0,0)};bB.prototype.resetMatrix=function(){dJ.reset();aT.reset()};ds.prototype.applyMatrix=function(){var ea=arguments;dJ.apply(ea[0],ea[1],ea[2],ea[3],ea[4],ea[5],ea[6],ea[7],ea[8],ea[9],ea[10],ea[11],ea[12],ea[13],ea[14],ea[15]);aT.invApply(ea[0],ea[1],ea[2],ea[3],ea[4],ea[5],ea[6],ea[7],ea[8],ea[9],ea[10],ea[11],ea[12],ea[13],ea[14],ea[15])};bR.prototype.applyMatrix=function(){var ea=arguments;for(var eb=ea.length;eb<16;eb++){ea[eb]=0}ea[10]=ea[15]=1;ds.prototype.applyMatrix.apply(this,ea)};cW.rotateX=function(ea){dJ.rotateX(ea);aT.invRotateX(ea)};bR.prototype.rotateZ=function(){throw\"rotateZ() is not supported in 2D mode. Use rotate(float) instead.\"};bB.prototype.rotateZ=function(ea){dJ.rotateZ(ea);aT.invRotateZ(ea)};cW.rotateY=function(ea){dJ.rotateY(ea);aT.invRotateY(ea)};bR.prototype.rotate=function(ea){dJ.rotateZ(ea);aT.invRotateZ(ea);d8.rotate(ea)};bB.prototype.rotate=function(ea){cW.rotateZ(ea)};bR.prototype.shearX=function(ea){dJ.shearX(ea);d8.transform(1,0,ea,1,0,0)};bB.prototype.shearX=function(ea){dJ.shearX(ea)};bR.prototype.shearY=function(ea){dJ.shearY(ea);d8.transform(1,ea,0,1,0,0)};bB.prototype.shearY=function(ea){dJ.shearY(ea)};cW.pushStyle=function(){aD();cW.pushMatrix();var ea={doFill:aH,currentFillColor:a1,doStroke:ce,currentStrokeColor:cv,curTint:bf,curRectMode:bK,curColorMode:cY,colorModeX:bJ,colorModeZ:bG,colorModeY:bI,colorModeA:bU,curTextFont:W,horizontalTextAlignment:N,verticalTextAlignment:c1,textMode:cI,curFontName:Y,curTextSize:d0,curTextAscent:a3,curTextDescent:dA,curTextLeading:d7};bm.push(ea)};cW.popStyle=function(){var ea=bm.pop();if(ea){cP();cW.popMatrix();aH=ea.doFill;a1=ea.currentFillColor;ce=ea.doStroke;cv=ea.currentStrokeColor;bf=ea.curTint;bK=ea.curRectMode;cY=ea.curColorMode;bJ=ea.colorModeX;bG=ea.colorModeZ;bI=ea.colorModeY;bU=ea.colorModeA;W=ea.curTextFont;Y=ea.curFontName;d0=ea.curTextSize;N=ea.horizontalTextAlignment;c1=ea.verticalTextAlignment;cI=ea.textMode;a3=ea.curTextAscent;dA=ea.curTextDescent;d7=ea.curTextLeading}else{throw\"Too many popStyle() without enough pushStyle()\"}};cW.year=function(){return(new Date).getFullYear()};cW.month=function(){return(new Date).getMonth()+1};cW.day=function(){return(new Date).getDate()};cW.hour=function(){return(new Date).getHours()};cW.minute=function(){return(new Date).getMinutes()};cW.second=function(){return(new Date).getSeconds()};cW.millis=function(){return Date.now()-dq};function ct(){var ea=(Date.now()-dt)/1000;P++;var eb=P/ea;if(ea>0.5){dt=Date.now();P=0;cW.__frameRate=eb}cW.frameCount++}bR.prototype.redraw=function(){ct();d8.lineWidth=dW;var ea=cW.pmouseX,eb=cW.pmouseY;cW.pmouseX=dN;cW.pmouseY=d5;aD();cW.draw();cP();dN=cW.mouseX;d5=cW.mouseY;cW.pmouseX=ea;cW.pmouseY=eb};bB.prototype.redraw=function(){ct();var ea=cW.pmouseX,eb=cW.pmouseY;cW.pmouseX=dN;cW.pmouseY=d5;d8.clear(d8.DEPTH_BUFFER_BIT);dC={attributes:{},locations:{}};cW.noLights();cW.lightFalloff(1,0,0);cW.shininess(1);cW.ambient(255,255,255);cW.specular(0,0,0);cW.emissive(0,0,0);cW.camera();cW.draw();dN=cW.mouseX;d5=cW.mouseY;cW.pmouseX=ea;cW.pmouseY=eb};cW.noLoop=function(){aC=false;ax=false;clearInterval(b4);cQ.onPause()};cW.loop=function(){if(ax){return}dt=Date.now();P=0;b4=D.setInterval(function(){try{cQ.onFrameStart();cW.redraw();cQ.onFrameEnd()}catch(ea){D.clearInterval(b4);throw ea}},az);aC=true;ax=true;cQ.onLoop()};cW.frameRate=function(ea){dU=ea;az=1000/dU;if(aC){cW.noLoop();cW.loop()}};var au=[];function bO(ec,eb,ea){if(ec.addEventListener){ec.addEventListener(eb,ea,false)}else{ec.attachEvent(\"on\"+eb,ea)}au.push({elem:ec,type:eb,fn:ea})}function de(ea){var ed=ea.elem,ec=ea.type,eb=ea.fn;if(ed.removeEventListener){ed.removeEventListener(ec,eb,false)}else{if(ed.detachEvent){ed.detachEvent(\"on\"+ec,eb)}}}cW.exit=function(){D.clearInterval(b4);L(cW.externals.canvas.id);delete ae.onmousedown;for(var eb in F.lib){if(F.lib.hasOwnProperty(eb)){if(F.lib[eb].hasOwnProperty(\"detach\")){F.lib[eb].detach(cW)}}}var ea=au.length;while(ea--){de(au[ea])}cQ.onExit()};cW.cursor=function(){if(arguments.length>1||arguments.length===1&&arguments[0] instanceof cW.PImage){var ed=arguments[0],ea,ef;if(arguments.length>=3){ea=arguments[1];ef=arguments[2];if(ea<0||ef<0||ef>=ed.height||ea>=ed.width){throw\"x and y must be non-negative and less than the dimensions of the image\"}}else{ea=ed.width>>>1;ef=ed.height>>>1}var eb=ed.toDataURL();var ec='url(\"'+eb+'\") '+ea+\" \"+ef+\", default\";Z=ae.style.cursor=ec}else{if(arguments.length===1){var ee=arguments[0];Z=ae.style.cursor=ee}else{Z=ae.style.cursor=ck}}};cW.noCursor=function(){Z=ae.style.cursor=B.NOCURSOR};cW.link=function(ea,eb){if(eb!==t){D.open(ea,eb)}else{D.location=ea}};cW.beginDraw=G;cW.endDraw=G;bR.prototype.toImageData=function(ea,ed,eb,ec){ea=ea!==t?ea:0;ed=ed!==t?ed:0;eb=eb!==t?eb:cW.width;ec=ec!==t?ec:cW.height;return d8.getImageData(ea,ed,eb,ec)};bB.prototype.toImageData=function(ei,eh,ej,ee){ei=ei!==t?ei:0;eh=eh!==t?eh:0;ej=ej!==t?ej:cW.width;ee=ee!==t?ee:cW.height;var eg=d.createElement(\"canvas\"),ek=eg.getContext(\"2d\"),ed=ek.createImageData(ej,ee),eb=new b(ej*ee*4);d8.readPixels(ei,eh,ej,ee,d8.RGBA,d8.UNSIGNED_BYTE,eb);for(var ec=0,ef=eb.length,ea=ed.data;ec<ef;ec++){ea[ec]=eb[(ee-1-q.floor(ec/4/ej))*ej*4+ec%(ej*4)]}return ed};cW.status=function(ea){D.status=ea};cW.binary=function(eb,ec){var ed;if(ec>0){ed=ec}else{if(eb instanceof bP){ed=16;eb|=0}else{ed=32;while(ed>1&&!(eb>>>ed-1&1)){ed--}}}var ea=\"\";while(ed>0){ea+=eb>>>--ed&1?\"1\":\"0\"}return ea};cW.unbinary=function(eb){var ed=eb.length-1,ec=1,ea=0;while(ed>=0){var ee=eb[ed--];if(ee!==\"0\"&&ee!==\"1\"){throw\"the value passed into unbinary was not an 8 bit binary number\"}if(ee===\"1\"){ea+=ec}ec<<=1}return ea};function cX(em,ek,ee,ep,eg,en){var ec=em<0?ee:ek;var eb=eg===0;var el=eg===t||eg<0?0:eg;var ej=q.abs(em);if(eb){el=1;ej*=10;while(q.abs(q.round(ej)-ej)>0.000001&&el<7){++el;ej*=10}}else{if(el!==0){ej*=q.pow(10,el)}}var ed,ei=ej*2;if(q.floor(ej)===ej){ed=ej}else{if(q.floor(ei)===ei){var ea=q.floor(ej);ed=ea+ea%2}else{ed=q.round(ej)}}var ef=\"\";var eo=ep+el;while(eo>0||ed>0){eo--;ef=\"\"+ed%10+ef;ed=q.floor(ed/10)}if(en!==t){var eh=ef.length-3-el;while(eh>0){ef=ef.substring(0,eh)+en+ef.substring(eh);eh-=3}}if(el>0){return ec+ef.substring(0,ef.length-el)+\".\"+ef.substring(ef.length-el,ef.length)}return ec+ef}function ao(eg,ef,ea,ei,eb,eh){if(eg instanceof Array){var ed=[];for(var ec=0,ee=eg.length;ec<ee;ec++){ed.push(cX(eg[ec],ef,ea,ei,eb,eh))}return ed}return cX(eg,ef,ea,ei,eb,eh)}cW.nf=function(ec,ea,eb){return ao(ec,\"\",\"-\",ea,eb)};cW.nfs=function(ec,ea,eb){return ao(ec,\" \",\"-\",ea,eb)};cW.nfp=function(ec,ea,eb){return ao(ec,\"+\",\"-\",ea,eb)};cW.nfc=function(ec,ea,eb){return ao(ec,\"\",\"-\",ea,eb,\",\")};var aM=function(ec,eb){eb=eb===t||eb===null?eb=8:eb;if(ec<0){ec=4294967295+ec+1}var ea=Number(ec).toString(16).toUpperCase();while(ea.length<eb){ea=\"0\"+ea}if(ea.length>=eb){ea=ea.substring(ea.length-eb,ea.length)}return ea};cW.hex=function(eb,ea){if(arguments.length===1){if(eb instanceof bP){ea=4}else{ea=8}}return aM(eb,ea)};function dF(ea){var eb=parseInt(\"0x\"+ea,16);if(eb>2147483647){eb-=4294967296}return eb}cW.unhex=function(ec){if(ec instanceof Array){var ea=[];for(var eb=0;eb<ec.length;eb++){ea.push(dF(ec[eb]))}return ea}return dF(ec)};cW.loadStrings=function(eb){if(localStorage[eb]){return localStorage[eb].split(\"\\n\")}var ea=w(eb);if(typeof ea!==\"string\"||ea===\"\"){return[]}ea=ea.replace(/(\\r\\n?)/g,\"\\n\").replace(/\\n$/,\"\");return ea.split(\"\\n\")};cW.saveStrings=function(eb,ea){localStorage[eb]=ea.join(\"\\n\")};cW.loadBytes=function(ec){var eb=w(ec);var ea=[];for(var ed=0;ed<eb.length;ed++){ea.push(eb.charCodeAt(ed))}return ea};function bc(ea){return Array.prototype.slice.call(ea,1)}cW.matchAll=function(eb,ea){var ed=[],ec;var ee=new RegExp(ea,\"g\");while((ec=ee.exec(eb))!==null){ed.push(ec);if(ec[0].length===0){++ee.lastIndex}}return ed.length>0?ed:null};cW.__contains=function(eb,ea){if(typeof eb!==\"string\"){return eb.contains.apply(eb,bc(arguments))}return eb!==null&&ea!==null&&typeof ea===\"string\"&&eb.indexOf(ea)>-1};cW.__replaceAll=function(ea,ec,eb){if(typeof ea!==\"string\"){return ea.replaceAll.apply(ea,bc(arguments))}return ea.replace(new RegExp(ec,\"g\"),eb)};cW.__replaceFirst=function(ea,ec,eb){if(typeof ea!==\"string\"){return ea.replaceFirst.apply(ea,bc(arguments))}return ea.replace(new RegExp(ec,\"\"),eb)};cW.__replace=function(ed,ef,ee){if(typeof ed!==\"string\"){return ed.replace.apply(ed,bc(arguments))}if(ef instanceof RegExp){return ed.replace(ef,ee)}if(typeof ef!==\"string\"){ef=ef.toString()}if(ef===\"\"){return ed}var ec=ed.indexOf(ef);if(ec<0){return ed}var eb=0,ea=\"\";do{ea+=ed.substring(eb,ec)+ee;eb=ec+ef.length}while((ec=ed.indexOf(ef,eb))>=0);return ea+ed.substring(eb)};cW.__equals=function(eb,ea){if(eb.equals instanceof Function){return eb.equals.apply(eb,bc(arguments))}return eb.valueOf()===ea.valueOf()};cW.__equalsIgnoreCase=function(eb,ea){if(typeof eb!==\"string\"){return eb.equalsIgnoreCase.apply(eb,bc(arguments))}return eb.toLowerCase()===ea.toLowerCase()};cW.__toCharArray=function(ec){if(typeof ec!==\"string\"){return ec.toCharArray.apply(ec,bc(arguments))}var ed=[];for(var eb=0,ea=ec.length;eb<ea;++eb){ed[eb]=new bP(ec.charAt(eb))}return ed};cW.__split=function(ed,ee,eb){if(typeof ed!==\"string\"){return ed.split.apply(ed,bc(arguments))}var eg=new RegExp(ee);if(eb===t||eb<1){return ed.split(eg)}var ea=[],ef=ed,eh;while((eh=ef.search(eg))!==-1&&ea.length<eb-1){var ec=eg.exec(ef).toString();ea.push(ef.substring(0,eh));ef=ef.substring(eh+ec.length)}if(eh!==-1||ef!==\"\"){ea.push(ef)}return ea};cW.__codePointAt=function(ed,eb){var ee=ed.charCodeAt(eb),ec,ea;if(55296<=ee&&ee<=56319){ec=ee;ea=ed.charCodeAt(eb+1);return(ec-55296)*1024+(ea-56320)+65536}return ee};cW.match=function(eb,ea){return eb.match(ea)};cW.__matches=function(eb,ea){return(new RegExp(ea)).test(eb)};cW.__startsWith=function(ea,ec,eb){if(typeof ea!==\"string\"){return ea.startsWith.apply(ea,bc(arguments))}eb=eb||0;if(eb<0||eb>ea.length){return false}return ec===\"\"||ec===ea?true:ea.indexOf(ec)===eb};cW.__endsWith=function(eb,ec){if(typeof eb!==\"string\"){return eb.endsWith.apply(eb,bc(arguments))}var ea=ec?ec.length:0;return ec===\"\"||ec===eb?true:eb.indexOf(ec)===eb.length-ea};cW.__hashCode=function(ea){if(ea.hashCode instanceof Function){return ea.hashCode.apply(ea,bc(arguments))}return h(ea)};cW.__printStackTrace=function(ea){cW.println(\"Exception: \"+ea.toString())};var d9=[];cW.println=function(ea){var eb=d9.length;if(eb){F.logger.log(d9.join(\"\"));d9.length=0}if(arguments.length===0&&eb===0){F.logger.log(\"\")}else{if(arguments.length!==0){F.logger.log(ea)}}};cW.print=function(ea){d9.push(ea)};cW.str=function(ec){if(ec instanceof Array){var ea=[];for(var eb=0;eb<ec.length;eb++){ea.push(ec[eb].toString()+\"\")}return ea}return ec.toString()+\"\"};cW.trim=function(ec){if(ec instanceof Array){var ea=[];for(var eb=0;eb<ec.length;eb++){ea.push(ec[eb].replace(/^\\s*/,\"\").replace(/\\s*$/,\"\").replace(/\\r*$/,\"\"))}return ea}return ec.replace(/^\\s*/,\"\").replace(/\\s*$/,\"\").replace(/\\r*$/,\"\")};function aR(ea){if(typeof ea===\"number\"){return ea!==0}if(typeof ea===\"boolean\"){return ea}if(typeof ea===\"string\"){return ea.toLowerCase()===\"true\"}if(ea instanceof bP){return ea.code===49||ea.code===84||ea.code===116}}cW.parseBoolean=function(ec){if(ec instanceof Array){var ea=[];for(var eb=0;eb<ec.length;eb++){ea.push(aR(ec[eb]))}return ea}return aR(ec)};cW.parseByte=function(ec){if(ec instanceof Array){var ea=[];for(var eb=0;eb<ec.length;eb++){ea.push(0-(ec[eb]&128)|ec[eb]&127)}return ea}return 0-(ec&128)|ec&127};cW.parseChar=function(ec){if(typeof ec===\"number\"){return new bP(String.fromCharCode(ec&65535))}if(ec instanceof Array){var ea=[];for(var eb=0;eb<ec.length;eb++){ea.push(new bP(String.fromCharCode(ec[eb]&65535)))}return ea}throw\"char() may receive only one argument of type int, byte, int[], or byte[].\"};function cO(ea){if(typeof ea===\"number\"){return ea}if(typeof ea===\"boolean\"){return ea?1:0}if(typeof ea===\"string\"){return parseFloat(ea)}if(ea instanceof bP){return ea.code}}cW.parseFloat=function(ec){if(ec instanceof Array){var ea=[];for(var eb=0;eb<ec.length;eb++){ea.push(cO(ec[eb]))}return ea}return cO(ec)};function al(ec,ea){if(typeof ec===\"number\"){return ec&4294967295}if(typeof ec===\"boolean\"){return ec?1:0}if(typeof ec===\"string\"){var eb=parseInt(ec,ea||10);return eb&4294967295}if(ec instanceof bP){return ec.code}}cW.parseInt=function(ed,ec){if(ed instanceof Array){var ea=[];for(var eb=0;eb<ed.length;eb++){if(typeof ed[eb]===\"string\"&&!/^\\s*[+\\-]?\\d+\\s*$/.test(ed[eb])){ea.push(0)}else{ea.push(al(ed[eb],ec))}}return ea}return al(ed,ec)};cW.__int_cast=function(ea){return 0|ea};cW.__instanceof=function(ec,eb){if(typeof eb!==\"function\"){throw\"Function is expected as type argument for instanceof operator\"}if(typeof ec===\"string\"){return eb===Object||eb===String}if(ec instanceof eb){return true}if(typeof ec!==\"object\"||ec===null){return false}var ee=ec.constructor;if(eb.$isInterface){var ed=[];while(ee){if(ee.$interfaces){ed=ed.concat(ee.$interfaces)}ee=ee.$base}while(ed.length>0){var ea=ed.shift();if(ea===eb){return true}if(ea.$interfaces){ed=ed.concat(ea.$interfaces)}}return false}while(ee.hasOwnProperty(\"$base\")){ee=ee.$base;if(ee===eb){return true}}return false};cW.abs=q.abs;cW.ceil=q.ceil;cW.constrain=function(eb,ec,ea){return eb>ea?ea:eb<ec?ec:eb};cW.dist=function(){var ec,eb,ea;if(arguments.length===4){ec=arguments[0]-arguments[2];eb=arguments[1]-arguments[3];return q.sqrt(ec*ec+eb*eb)}if(arguments.length===6){ec=arguments[0]-arguments[3];eb=arguments[1]-arguments[4];ea=arguments[2]-arguments[5];return q.sqrt(ec*ec+eb*eb+ea*ea)}};cW.exp=q.exp;cW.floor=q.floor;cW.lerp=function(eb,ea,ec){return(ea-eb)*ec+eb};cW.log=q.log;cW.mag=function(eb,ea,ec){if(ec){return q.sqrt(eb*eb+ea*ea+ec*ec)}return q.sqrt(eb*eb+ea*ea)};cW.map=function(ed,eb,ec,ea,ee){return ea+(ee-ea)*((ed-eb)/(ec-eb))};cW.max=function(){if(arguments.length===2){return arguments[0]<arguments[1]?arguments[1]:arguments[0]}var eb=arguments.length===1?arguments[0]:arguments;if(!(\"length\" in eb&&eb.length>0)){throw\"Non-empty array is expected\"}var ea=eb[0],ed=eb.length;for(var ec=1;ec<ed;++ec){if(ea<eb[ec]){ea=eb[ec]}}return ea};cW.min=function(){if(arguments.length===2){return arguments[0]<arguments[1]?arguments[0]:arguments[1]}var ea=arguments.length===1?arguments[0]:arguments;if(!(\"length\" in ea&&ea.length>0)){throw\"Non-empty array is expected\"}var ec=ea[0],ed=ea.length;for(var eb=1;eb<ed;++eb){if(ec>ea[eb]){ec=ea[eb]}}return ec};cW.norm=function(eb,ea,ec){return(eb-ea)/(ec-ea)};cW.pow=q.pow;cW.round=q.round;cW.sq=function(ea){return ea*ea};cW.sqrt=q.sqrt;cW.acos=q.acos;cW.asin=q.asin;cW.atan=q.atan;cW.atan2=q.atan2;cW.cos=q.cos;cW.degrees=function(ea){return ea*180/q.PI};cW.radians=function(ea){return ea/180*q.PI};cW.sin=q.sin;cW.tan=q.tan;var bY=q.random;cW.random=function(){if(arguments.length===0){return bY()}if(arguments.length===1){return bY()*arguments[0]}var eb=arguments[0],ea=arguments[1];return bY()*(ea-eb)+eb};function co(ec,eb){var ee=ec||362436069,ea=eb||521288629;var ed=function(){ee=36969*(ee&65535)+(ee>>>16)&4294967295;ea=18000*(ea&65535)+(ea>>>16)&4294967295;return((ee&65535)<<16|ea&65535)&4294967295};this.nextDouble=function(){var ef=ed()/4294967296;return ef<0?1+ef:ef};this.nextInt=ed}co.createRandomized=function(){var ea=new Date;return new co(ea/60000&4294967295,ea&4294967295)};cW.randomSeed=function(ea){bY=(new co(ea)).nextDouble};cW.Random=function(ea){var ed=false,eb,ec;this.nextGaussian=function(){if(ed){ed=false;return eb}var eh,ef,ee;do{eh=2*ec()-1;ef=2*ec()-1;ee=eh*eh+ef*ef}while(ee>=1||ee===0);var eg=q.sqrt(-2*q.log(ee)/ee);eb=ef*eg;ed=true;return eh*eg};ec=ea===t?q.random:(new co(ea)).nextDouble};function dz(eh){var eb=eh!==t?new co(eh):co.createRandomized();var eg,ee;var ed=new b(512);for(eg=0;eg<256;++eg){ed[eg]=eg}for(eg=0;eg<256;++eg){var ej=ed[ee=eb.nextInt()&255];ed[ee]=ed[eg];ed[eg]=ej}for(eg=0;eg<256;++eg){ed[eg+256]=ed[eg]}function ea(en,ek,eq,ep){var eo=en&15;var em=eo<8?ek:eq,el=eo<4?eq:eo===12||eo===14?ek:ep;return((eo&1)===0?em:-em)+((eo&2)===0?el:-el)}function ef(em,ek,en){var el=(em&1)===0?ek:en;return(em&2)===0?-el:el}function ei(el,ek){return(el&1)===0?-ek:ek}function ec(em,el,ek){return el+em*(ek-el)}this.noise3d=function(ew,ev,eu){var en=q.floor(ew)&255,el=q.floor(ev)&255,ek=q.floor(eu)&255;ew-=q.floor(ew);ev-=q.floor(ev);eu-=q.floor(eu);var er=(3-2*ew)*ew*ew,eq=(3-2*ev)*ev*ev,ep=(3-2*eu)*eu*eu;var ey=ed[en]+el,et=ed[ey]+ek,es=ed[ey+1]+ek,ex=ed[en+1]+el,eo=ed[ex]+ek,em=ed[ex+1]+ek;return ec(ep,ec(eq,ec(er,ea(ed[et],ew,ev,eu),ea(ed[eo],ew-1,ev,eu)),ec(er,ea(ed[es],ew,ev-1,eu),ea(ed[em],ew-1,ev-1,eu))),ec(eq,ec(er,ea(ed[et+1],ew,ev,eu-1),ea(ed[eo+1],ew-1,ev,eu-1)),ec(er,ea(ed[es+1],ew,ev-1,eu-1),ea(ed[em+1],ew-1,ev-1,eu-1))))};this.noise2d=function(ek,er){var eq=q.floor(ek)&255,eo=q.floor(er)&255;ek-=q.floor(ek);er-=q.floor(er);var em=(3-2*ek)*ek*ek,el=(3-2*er)*er*er;var ep=ed[eq]+eo,en=ed[eq+1]+eo;return ec(el,ec(em,ef(ed[ep],ek,er),ef(ed[en],ek-1,er)),ec(em,ef(ed[ep+1],ek,er-1),ef(ed[en+1],ek-1,er-1)))};this.noise1d=function(ek){var em=q.floor(ek)&255;ek-=q.floor(ek);var el=(3-2*ek)*ek*ek;return ec(el,ei(ed[em],ek),ei(ed[em+1],ek-1))}}var bW={generator:t,octaves:4,fallout:0.5,seed:t};cW.noise=function(ea,eh,eg){if(bW.generator===t){bW.generator=new dz(bW.seed)}var ef=bW.generator;var ee=1,eb=1,ed=0;for(var ec=0;ec<bW.octaves;++ec){ee*=bW.fallout;switch(arguments.length){case 1:ed+=ee*(1+ef.noise1d(eb*ea))/2;break;case 2:ed+=ee*(1+ef.noise2d(eb*ea,eb*eh))/2;break;case 3:ed+=ee*(1+ef.noise3d(eb*ea,eb*eh,eb*eg))/2;break}eb*=2}return ed};cW.noiseDetail=function(eb,ea){bW.octaves=eb;if(ea!==t){bW.fallout=ea}};cW.noiseSeed=function(ea){bW.seed=ea;bW.generator=t};ds.prototype.size=function(eb,ee,ed){if(ce){cW.stroke(0)}if(aH){cW.fill(255)}var ec={fillStyle:d8.fillStyle,strokeStyle:d8.strokeStyle,lineCap:d8.lineCap,lineJoin:d8.lineJoin};if(ae.style.length>0){ae.style.removeProperty(\"width\");ae.style.removeProperty(\"height\")}ae.width=cW.width=eb||100;ae.height=cW.height=ee||100;for(var ef in ec){if(ec.hasOwnProperty(ef)){d8[ef]=ec[ef]}}cW.textFont(W);cW.background();bZ=q.max(1000,eb*ee*0.05);cW.externals.context=d8;for(var ea=0;ea<720;ea++){ah[ea]=cW.sin(ea*(q.PI/180)*0.5);bl[ea]=cW.cos(ea*(q.PI/180)*0.5)}};bR.prototype.size=function(ea,ec,eb){if(d8===t){d8=ae.getContext(\"2d\");am=new V;da=new V;dJ=new aX;aT=new aX}ds.prototype.size.apply(this,arguments)};bB.prototype.size=function(){var eb=false;return function ea(ed,ef,ee){if(eb){throw\"Multiple calls to size() for 3D renders are not allowed.\"}eb=true;function eg(ei){var el=[\"experimental-webgl\",\"webgl\",\"webkit-3d\"],ek;for(var ej=0,eh=el.length;ej<eh;ej++){ek=ei.getContext(el[ej],{antialias:false,preserveDrawingBuffer:true});if(ek){break}}return ek}try{ae.width=cW.width=ed||100;ae.height=cW.height=ef||100;d8=eg(ae);c7=d8.createTexture();bS=d8.createTexture()}catch(ec){F.debug(ec)}if(!d8){throw\"WebGL context is not supported on this browser.\"}d8.viewport(0,0,ae.width,ae.height);d8.enable(d8.DEPTH_TEST);d8.enable(d8.BLEND);d8.blendFunc(d8.SRC_ALPHA,d8.ONE_MINUS_SRC_ALPHA);dQ=bF(d8,dE,aW);bT=bF(d8,aO,bQ);cW.strokeWeight(1);dx=bF(d8,dn,aF);d8.useProgram(dx);dZ(\"usingTexture3d\",dx,\"usingTexture\",dT);cW.lightFalloff(1,0,0);cW.shininess(1);cW.ambient(255,255,255);cW.specular(0,0,0);cW.emissive(0,0,0);bh=d8.createBuffer();d8.bindBuffer(d8.ARRAY_BUFFER,bh);d8.bufferData(d8.ARRAY_BUFFER,dh,d8.STATIC_DRAW);cJ=d8.createBuffer();d8.bindBuffer(d8.ARRAY_BUFFER,cJ);d8.bufferData(d8.ARRAY_BUFFER,df,d8.STATIC_DRAW);dk=d8.createBuffer();d8.bindBuffer(d8.ARRAY_BUFFER,dk);d8.bufferData(d8.ARRAY_BUFFER,bH,d8.STATIC_DRAW);aB=d8.createBuffer();d8.bindBuffer(d8.ARRAY_BUFFER,aB);d8.bufferData(d8.ARRAY_BUFFER,ak,d8.STATIC_DRAW);b2=d8.createBuffer();d8.bindBuffer(d8.ARRAY_BUFFER,b2);d8.bufferData(d8.ARRAY_BUFFER,ai,d8.STATIC_DRAW);bg=d8.createBuffer();b8=d8.createBuffer();at=d8.createBuffer();aG=d8.createBuffer();bC=d8.createBuffer();af=d8.createBuffer();aw=d8.createBuffer();d8.bindBuffer(d8.ARRAY_BUFFER,aw);d8.bufferData(d8.ARRAY_BUFFER,new e([0,0,0]),d8.STATIC_DRAW);cH=d8.createBuffer();d8.bindBuffer(d8.ARRAY_BUFFER,cH);d8.bufferData(d8.ARRAY_BUFFER,new e([1,1,0,-1,1,0,-1,-1,0,1,-1,0]),d8.STATIC_DRAW);ac=d8.createBuffer();d8.bindBuffer(d8.ARRAY_BUFFER,ac);d8.bufferData(d8.ARRAY_BUFFER,new e([0,0,1,0,1,1,0,1]),d8.STATIC_DRAW);R=d8.createBuffer();d8.bindBuffer(d8.ELEMENT_ARRAY_BUFFER,R);d8.bufferData(d8.ELEMENT_ARRAY_BUFFER,new y([0,1,2,2,3,0]),d8.STATIC_DRAW);bV=new aP;ch=new aP;dJ=new aP;aT=new aP;db=new aP;cW.camera();cW.perspective();am=new V;da=new V;c3=new aP;aQ=new aP;aL=new aP;bz=new aP;cd=new aP;U=new aP;U.set(-1,3,-3,1,3,-6,3,0,-3,3,0,0,1,0,0,0);ds.prototype.size.apply(this,arguments)}}();bR.prototype.ambientLight=ds.prototype.a3DOnlyFunction;bB.prototype.ambientLight=function(ea,ed,ei,ej,ef,ee){if(dL===8){throw\"can only create \"+8+\" lights\"}var eg=new A(ej,ef,ee);var eh=new aP;eh.scale(1,-1,1);eh.apply(dJ.array());eh.mult(eg,eg);var eb=dH(ea,ed,ei,0);var ec=[((eb>>16)&255)/255,((eb>>8)&255)/255,(eb&255)/255];d8.useProgram(dx);d2(\"uLights.color.3d.\"+dL,dx,\"uLights\"+dL+\".color\",ec);d2(\"uLights.position.3d.\"+dL,dx,\"uLights\"+dL+\".position\",eg.array());dZ(\"uLights.type.3d.\"+dL,dx,\"uLights\"+dL+\".type\",0);dZ(\"uLightCount3d\",dx,\"uLightCount\",++dL)};bR.prototype.directionalLight=ds.prototype.a3DOnlyFunction;bB.prototype.directionalLight=function(ea,eg,ei,eh,ef,ee){if(dL===8){throw\"can only create \"+8+\" lights\"}d8.useProgram(dx);var ej=new aP;ej.scale(1,-1,1);ej.apply(dJ.array());ej=ej.array();var ec=[ej[0]*eh+ej[4]*ef+ej[8]*ee,ej[1]*eh+ej[5]*ef+ej[9]*ee,ej[2]*eh+ej[6]*ef+ej[10]*ee];var eb=dH(ea,eg,ei,0);var ed=[((eb>>16)&255)/255,((eb>>8)&255)/255,(eb&255)/255];d2(\"uLights.color.3d.\"+dL,dx,\"uLights\"+dL+\".color\",ed);d2(\"uLights.position.3d.\"+dL,dx,\"uLights\"+dL+\".position\",ec);dZ(\"uLights.type.3d.\"+dL,dx,\"uLights\"+dL+\".type\",1);dZ(\"uLightCount3d\",dx,\"uLightCount\",++dL)};bR.prototype.lightFalloff=ds.prototype.a3DOnlyFunction;bB.prototype.lightFalloff=function(eb,ea,ec){d8.useProgram(dx);d2(\"uFalloff3d\",dx,\"uFalloff\",[eb,ea,ec])};bR.prototype.lightSpecular=ds.prototype.a3DOnlyFunction;bB.prototype.lightSpecular=function(ee,ed,ea){var eb=dH(ee,ed,ea,0);var ec=[((eb>>16)&255)/255,((eb>>8)&255)/255,(eb&255)/255];d8.useProgram(dx);d2(\"uSpecular3d\",dx,\"uSpecular\",ec)};cW.lights=function(){cW.ambientLight(128,128,128);cW.directionalLight(128,128,128,0,0,-1);cW.lightFalloff(1,0,0);cW.lightSpecular(0,0,0)};bR.prototype.pointLight=ds.prototype.a3DOnlyFunction;bB.prototype.pointLight=function(ea,ed,ei,ej,ef,ee){if(dL===8){throw\"can only create \"+8+\" lights\"}var eg=new A(ej,ef,ee);var eh=new aP;eh.scale(1,-1,1);eh.apply(dJ.array());eh.mult(eg,eg);var eb=dH(ea,ed,ei,0);var ec=[((eb>>16)&255)/255,((eb>>8)&255)/255,(eb&255)/255];d8.useProgram(dx);d2(\"uLights.color.3d.\"+dL,dx,\"uLights\"+dL+\".color\",ec);d2(\"uLights.position.3d.\"+dL,dx,\"uLights\"+dL+\".position\",eg.array());dZ(\"uLights.type.3d.\"+dL,dx,\"uLights\"+dL+\".type\",2);dZ(\"uLightCount3d\",dx,\"uLightCount\",++dL)};bR.prototype.noLights=ds.prototype.a3DOnlyFunction;bB.prototype.noLights=function(){dL=0;d8.useProgram(dx);dZ(\"uLightCount3d\",dx,\"uLightCount\",dL)};bR.prototype.spotLight=ds.prototype.a3DOnlyFunction;bB.prototype.spotLight=function(ea,ei,en,eo,em,ek,ej,eh,ef,ee,eg){if(dL===8){throw\"can only create \"+8+\" lights\"}d8.useProgram(dx);var el=new A(eo,em,ek);var ep=new aP;ep.scale(1,-1,1);ep.apply(dJ.array());ep.mult(el,el);ep=ep.array();var ec=[ep[0]*ej+ep[4]*eh+ep[8]*ef,ep[1]*ej+ep[5]*eh+ep[9]*ef,ep[2]*ej+ep[6]*eh+ep[10]*ef];var eb=dH(ea,ei,en,0);var ed=[((eb>>16)&255)/255,((eb>>8)&255)/255,(eb&255)/255];d2(\"uLights.color.3d.\"+dL,dx,\"uLights\"+dL+\".color\",ed);d2(\"uLights.position.3d.\"+dL,dx,\"uLights\"+dL+\".position\",el.array());d2(\"uLights.direction.3d.\"+dL,dx,\"uLights\"+dL+\".direction\",ec);d2(\"uLights.concentration.3d.\"+dL,dx,\"uLights\"+dL+\".concentration\",eg);d2(\"uLights.angle.3d.\"+dL,dx,\"uLights\"+dL+\".angle\",ee);dZ(\"uLights.type.3d.\"+dL,dx,\"uLights\"+dL+\".type\",3);dZ(\"uLightCount3d\",dx,\"uLightCount\",++dL)};bR.prototype.beginCamera=function(){throw\"beginCamera() is not available in 2D mode\"};bB.prototype.beginCamera=function(){if(ap){throw\"You cannot call beginCamera() again before calling endCamera()\"}ap=true;dJ=ch;aT=bV};bR.prototype.endCamera=function(){throw\"endCamera() is not available in 2D mode\"};bB.prototype.endCamera=function(){if(!ap){throw\"You cannot call endCamera() before calling beginCamera()\"}dJ.set(bV);aT.set(ch);ap=false};cW.camera=function(el,ek,ei,eg,ee,ed,et,er,ep){if(el===t){dl=cW.width/2;dj=cW.height/2;di=dj/q.tan(cK/2);el=dl;ek=dj;ei=di;eg=dl;ee=dj;ed=0;et=0;er=1;ep=0}var ef=new A(el-eg,ek-ee,ei-ed);var eh=new A(et,er,ep);ef.normalize();var ej=A.cross(eh,ef);eh=A.cross(ef,ej);ej.normalize();eh.normalize();var eu=ej.x,es=ej.y,eq=ej.z;var ec=eh.x,eb=eh.y,ea=eh.z;var eo=ef.x,en=ef.y,em=ef.z;bV.set(eu,es,eq,0,ec,eb,ea,0,eo,en,em,0,0,0,0,1);bV.translate(-el,-ek,-ei);ch.reset();ch.invApply(eu,es,eq,0,ec,eb,ea,0,eo,en,em,0,0,0,0,1);ch.translate(el,ek,ei);dJ.set(bV);aT.set(ch)};cW.perspective=function(ee,ec,ef,eb){if(arguments.length===0){dj=ae.height/2;di=dj/q.tan(cK/2);a0=di/10;av=di*10;b5=cW.width/cW.height;ee=cK;ec=b5;ef=a0;eb=av}var eg,ea,eh,ed;eg=ef*q.tan(ee/2);ea=-eg;eh=eg*ec;ed=ea*ec;cW.frustum(ed,eh,ea,eg,ef,eb)};bR.prototype.frustum=function(){throw\"Processing.js: frustum() is not supported in 2D mode\"};bB.prototype.frustum=function(eg,ec,eb,ef,ee,ea){ci=true;db=new aP;db.set(2*ee/(ec-eg),0,(ec+eg)/(ec-eg),0,0,2*ee/(ef-eb),(ef+eb)/(ef-eb),0,0,0,-(ea+ee)/(ea-ee),-(2*ea*ee)/(ea-ee),0,0,-1,0);var ed=new aP;ed.set(db);ed.transpose();d8.useProgram(dQ);a9(\"projection2d\",dQ,\"uProjection\",false,ed.array());d8.useProgram(dx);a9(\"projection3d\",dx,\"uProjection\",false,ed.array());d8.useProgram(bT);a9(\"uProjectionUS\",bT,\"uProjection\",false,ed.array())};cW.ortho=function(eb,em,ea,ek,eh,eg){if(arguments.length===0){eb=0;em=cW.width;ea=0;ek=cW.height;eh=-10;eg=10}var el=2/(em-eb);var ej=2/(ek-ea);var ei=-2/(eg-eh);var ef=-(em+eb)/(em-eb);var ee=-(ek+ea)/(ek-ea);var ed=-(eg+eh)/(eg-eh);db=new aP;db.set(el,0,0,ef,0,ej,0,ee,0,0,ei,ed,0,0,0,1);var ec=new aP;ec.set(db);ec.transpose();d8.useProgram(dQ);a9(\"projection2d\",dQ,\"uProjection\",false,ec.array());d8.useProgram(dx);a9(\"projection3d\",dx,\"uProjection\",false,ec.array());d8.useProgram(bT);a9(\"uProjectionUS\",bT,\"uProjection\",false,ec.array());ci=false};cW.printProjection=function(){db.print()};cW.printCamera=function(){bV.print()};bR.prototype.box=ds.prototype.a3DOnlyFunction;bB.prototype.box=function(ec,ef,eh){if(!ef||!eh){ef=eh=ec}var ee=new aP;ee.scale(ec,ef,eh);var eb=new aP;eb.scale(1,-1,1);eb.apply(dJ.array());eb.transpose();if(aH){d8.useProgram(dx);a9(\"model3d\",dx,\"uModel\",false,ee.array());a9(\"view3d\",dx,\"uView\",false,eb.array());d8.enable(d8.POLYGON_OFFSET_FILL);d8.polygonOffset(1,1);d2(\"color3d\",dx,\"uColor\",bo);if(dL>0){var ed=new aP;ed.set(eb);var ea=new aP;ea.set(ee);ed.mult(ea);var eg=new aP;eg.set(ed);eg.invert();eg.transpose();a9(\"uNormalTransform3d\",dx,\"uNormalTransform\",false,eg.array());dc(\"aNormal3d\",dx,\"aNormal\",3,cJ)}else{cg(\"aNormal3d\",dx,\"aNormal\")}dc(\"aVertex3d\",dx,\"aVertex\",3,bh);cg(\"aColor3d\",dx,\"aColor\");cg(\"aTexture3d\",dx,\"aTexture\");d8.drawArrays(d8.TRIANGLES,0,dh.length/3);d8.disable(d8.POLYGON_OFFSET_FILL)}if(dW>0&&ce){d8.useProgram(dQ);a9(\"uModel2d\",dQ,\"uModel\",false,ee.array());a9(\"uView2d\",dQ,\"uView\",false,eb.array());d2(\"uColor2d\",dQ,\"uColor\",c0);dZ(\"uIsDrawingText2d\",dQ,\"uIsDrawingText\",false);dc(\"vertex2d\",dQ,\"aVertex\",3,dk);cg(\"aTextureCoord2d\",dQ,\"aTextureCoord\");d8.drawArrays(d8.LINES,0,bH.length/3)}};var cD=function(){var eb;cF=[];for(eb=0;eb<bM;eb++){cF.push(0);cF.push(-1);cF.push(0);cF.push(bt[eb]);cF.push(bs[eb]);cF.push(br[eb])}cF.push(0);cF.push(-1);cF.push(0);cF.push(bt[0]);cF.push(bs[0]);cF.push(br[0]);var ef,ec,ee;var ed=0;for(eb=2;eb<bL;eb++){ef=ec=ed;ed+=bM;ee=ed;for(var ea=0;ea<bM;ea++){cF.push(bt[ef]);cF.push(bs[ef]);cF.push(br[ef++]);cF.push(bt[ee]);cF.push(bs[ee]);cF.push(br[ee++])}ef=ec;ee=ed;cF.push(bt[ef]);cF.push(bs[ef]);cF.push(br[ef]);cF.push(bt[ee]);cF.push(bs[ee]);cF.push(br[ee])}for(eb=0;eb<bM;eb++){ee=ed+eb;cF.push(bt[ee]);cF.push(bs[ee]);cF.push(br[ee]);cF.push(0);cF.push(1);cF.push(0)}cF.push(bt[ed]);cF.push(bs[ed]);cF.push(br[ed]);cF.push(0);cF.push(1);cF.push(0);d8.bindBuffer(d8.ARRAY_BUFFER,bg);d8.bufferData(d8.ARRAY_BUFFER,new e(cF),d8.STATIC_DRAW)};cW.sphereDetail=function(eb,em){var eh;if(arguments.length===1){eb=em=arguments[0]}if(eb<3){eb=3}if(em<2){em=2}if(eb===bM&&em===bL){return}var el=720/eb;var ef=new e(eb);var ec=new e(eb);for(eh=0;eh<eb;eh++){ef[eh]=bl[eh*el%720|0];ec[eh]=ah[eh*el%720|0]}var ek=eb*(em-1)+2;var ej=0;bt=new e(ek);bs=new e(ek);br=new e(ek);var ei=720*0.5/em;var ee=ei;for(eh=1;eh<em;eh++){var ed=ah[ee%720|0];var ea=-bl[ee%720|0];for(var eg=0;eg<eb;eg++){bt[ej]=ef[eg]*ed;bs[ej]=ea;br[ej++]=ec[eg]*ed}ee+=ei}bM=eb;bL=em;cD()};bR.prototype.sphere=ds.prototype.a3DOnlyFunction;bB.prototype.sphere=function(){var ee=arguments[0];if(bM<3||bL<2){cW.sphereDetail(30)}var ed=new aP;ed.scale(ee,ee,ee);var eb=new aP;eb.scale(1,-1,1);eb.apply(dJ.array());eb.transpose();if(aH){if(dL>0){var ec=new aP;ec.set(eb);var ea=new aP;ea.set(ed);ec.mult(ea);var ef=new aP;ef.set(ec);ef.invert();ef.transpose();a9(\"uNormalTransform3d\",dx,\"uNormalTransform\",false,ef.array());dc(\"aNormal3d\",dx,\"aNormal\",3,bg)}else{cg(\"aNormal3d\",dx,\"aNormal\")}d8.useProgram(dx);cg(\"aTexture3d\",dx,\"aTexture\");a9(\"uModel3d\",dx,\"uModel\",false,ed.array());a9(\"uView3d\",dx,\"uView\",false,eb.array());dc(\"aVertex3d\",dx,\"aVertex\",3,bg);cg(\"aColor3d\",dx,\"aColor\");d8.enable(d8.POLYGON_OFFSET_FILL);d8.polygonOffset(1,1);d2(\"uColor3d\",dx,\"uColor\",bo);d8.drawArrays(d8.TRIANGLE_STRIP,0,cF.length/3);d8.disable(d8.POLYGON_OFFSET_FILL)}if(dW>0&&ce){d8.useProgram(dQ);a9(\"uModel2d\",dQ,\"uModel\",false,ed.array());a9(\"uView2d\",dQ,\"uView\",false,eb.array());dc(\"aVertex2d\",dQ,\"aVertex\",3,bg);cg(\"aTextureCoord2d\",dQ,\"aTextureCoord\");d2(\"uColor2d\",dQ,\"uColor\",c0);dZ(\"uIsDrawingText\",dQ,\"uIsDrawingText\",false);d8.drawArrays(d8.LINE_STRIP,0,cF.length/3)}};cW.modelX=function(eg,ef,ee){var ei=dJ.array();var ek=ch.array();var ea=ei[0]*eg+ei[1]*ef+ei[2]*ee+ei[3];var ej=ei[4]*eg+ei[5]*ef+ei[6]*ee+ei[7];var eh=ei[8]*eg+ei[9]*ef+ei[10]*ee+ei[11];var eb=ei[12]*eg+ei[13]*ef+ei[14]*ee+ei[15];var ec=ek[0]*ea+ek[1]*ej+ek[2]*eh+ek[3]*eb;var ed=ek[12]*ea+ek[13]*ej+ek[14]*eh+ek[15]*eb;return ed!==0?ec/ed:ec};cW.modelY=function(eg,ef,ee){var ei=dJ.array();var ek=ch.array();var ea=ei[0]*eg+ei[1]*ef+ei[2]*ee+ei[3];var ej=ei[4]*eg+ei[5]*ef+ei[6]*ee+ei[7];var eh=ei[8]*eg+ei[9]*ef+ei[10]*ee+ei[11];var eb=ei[12]*eg+ei[13]*ef+ei[14]*ee+ei[15];var ec=ek[4]*ea+ek[5]*ej+ek[6]*eh+ek[7]*eb;var ed=ek[12]*ea+ek[13]*ej+ek[14]*eh+ek[15]*eb;return ed!==0?ec/ed:ec};cW.modelZ=function(eg,ef,ee){var ei=dJ.array();var ek=ch.array();var ea=ei[0]*eg+ei[1]*ef+ei[2]*ee+ei[3];var ej=ei[4]*eg+ei[5]*ef+ei[6]*ee+ei[7];var eh=ei[8]*eg+ei[9]*ef+ei[10]*ee+ei[11];var ec=ei[12]*eg+ei[13]*ef+ei[14]*ee+ei[15];var eb=ek[8]*ea+ek[9]*ej+ek[10]*eh+ek[11]*ec;var ed=ek[12]*ea+ek[13]*ej+ek[14]*eh+ek[15]*ec;return ed!==0?eb/ed:eb};bR.prototype.ambient=ds.prototype.a3DOnlyFunction;bB.prototype.ambient=function(ed,ec,eb){d8.useProgram(dx);dZ(\"uUsingMat3d\",dx,\"uUsingMat\",true);var ea=cW.color(ed,ec,eb);d2(\"uMaterialAmbient3d\",dx,\"uMaterialAmbient\",cW.color.toGLArray(ea).slice(0,3))};bR.prototype.emissive=ds.prototype.a3DOnlyFunction;bB.prototype.emissive=function(ed,ec,eb){d8.useProgram(dx);dZ(\"uUsingMat3d\",dx,\"uUsingMat\",true);var ea=cW.color(ed,ec,eb);d2(\"uMaterialEmissive3d\",dx,\"uMaterialEmissive\",cW.color.toGLArray(ea).slice(0,3))};bR.prototype.shininess=ds.prototype.a3DOnlyFunction;bB.prototype.shininess=function(ea){d8.useProgram(dx);dZ(\"uUsingMat3d\",dx,\"uUsingMat\",true);d2(\"uShininess3d\",dx,\"uShininess\",ea)};bR.prototype.specular=ds.prototype.a3DOnlyFunction;bB.prototype.specular=function(ed,ec,eb){d8.useProgram(dx);dZ(\"uUsingMat3d\",dx,\"uUsingMat\",true);var ea=cW.color(ed,ec,eb);d2(\"uMaterialSpecular3d\",dx,\"uMaterialSpecular\",cW.color.toGLArray(ea).slice(0,3))};cW.screenX=function(eh,eg,ef){var ej=dJ.array();if(ej.length===16){var ea=ej[0]*eh+ej[1]*eg+ej[2]*ef+ej[3];var ek=ej[4]*eh+ej[5]*eg+ej[6]*ef+ej[7];var ei=ej[8]*eh+ej[9]*eg+ej[10]*ef+ej[11];var eb=ej[12]*eh+ej[13]*eg+ej[14]*ef+ej[15];var ee=db.array();var ec=ee[0]*ea+ee[1]*ek+ee[2]*ei+ee[3]*eb;var ed=ee[12]*ea+ee[13]*ek+ee[14]*ei+ee[15]*eb;if(ed!==0){ec/=ed}return cW.width*(1+ec)/2}return dJ.multX(eh,eg)};cW.screenY=function aA(eh,eg,ef){var ej=dJ.array();if(ej.length===16){var ea=ej[0]*eh+ej[1]*eg+ej[2]*ef+ej[3];var ek=ej[4]*eh+ej[5]*eg+ej[6]*ef+ej[7];var ei=ej[8]*eh+ej[9]*eg+ej[10]*ef+ej[11];var eb=ej[12]*eh+ej[13]*eg+ej[14]*ef+ej[15];var ee=db.array();var ec=ee[4]*ea+ee[5]*ek+ee[6]*ei+ee[7]*eb;var ed=ee[12]*ea+ee[13]*ek+ee[14]*ei+ee[15]*eb;if(ed!==0){ec/=ed}return cW.height*(1+ec)/2}return dJ.multY(eh,eg)};cW.screenZ=function ay(eh,eg,ef){var ej=dJ.array();if(ej.length!==16){return 0}var ee=db.array();var ea=ej[0]*eh+ej[1]*eg+ej[2]*ef+ej[3];var ek=ej[4]*eh+ej[5]*eg+ej[6]*ef+ej[7];var ei=ej[8]*eh+ej[9]*eg+ej[10]*ef+ej[11];var ec=ej[12]*eh+ej[13]*eg+ej[14]*ef+ej[15];var eb=ee[8]*ea+ee[9]*ek+ee[10]*ei+ee[11]*ec;var ed=ee[12]*ea+ee[13]*ek+ee[14]*ei+ee[15]*ec;if(ed!==0){eb/=ed}return(eb+1)/2};ds.prototype.fill=function(){var ea=cW.color(arguments[0],arguments[1],arguments[2],arguments[3]);if(ea===a1&&aH){return}aH=true;a1=ea};bR.prototype.fill=function(){ds.prototype.fill.apply(this,arguments);aq=true};bB.prototype.fill=function(){ds.prototype.fill.apply(this,arguments);bo=cW.color.toGLArray(a1)};function bn(){if(aH){if(aq){d8.fillStyle=cW.color.toString(a1);aq=false}d8.fill()}}cW.noFill=function(){aH=false};ds.prototype.stroke=function(){var ea=cW.color(arguments[0],arguments[1],arguments[2],arguments[3]);if(ea===cv&&ce){return}ce=true;cv=ea};bR.prototype.stroke=function(){ds.prototype.stroke.apply(this,arguments);b3=true};bB.prototype.stroke=function(){ds.prototype.stroke.apply(this,arguments);c0=cW.color.toGLArray(cv)};function dd(){if(ce){if(b3){d8.strokeStyle=cW.color.toString(cv);b3=false}d8.stroke()}}cW.noStroke=function(){ce=false};ds.prototype.strokeWeight=function(ea){dW=ea};bR.prototype.strokeWeight=function(ea){ds.prototype.strokeWeight.apply(this,arguments);d8.lineWidth=ea};bB.prototype.strokeWeight=function(ea){ds.prototype.strokeWeight.apply(this,arguments);d8.useProgram(dQ);d2(\"pointSize2d\",dQ,\"uPointSize\",ea);d8.useProgram(bT);d2(\"pointSizeUnlitShape\",bT,\"uPointSize\",ea);d8.lineWidth(ea)};cW.strokeCap=function(ea){dY.$ensureContext().lineCap=ea};cW.strokeJoin=function(ea){dY.$ensureContext().lineJoin=ea};bR.prototype.smooth=function(){dO=true;var ea=ae.style;ea.setProperty(\"image-rendering\",\"optimizeQuality\",\"important\");ea.setProperty(\"-ms-interpolation-mode\",\"bicubic\",\"important\");if(d8.hasOwnProperty(\"mozImageSmoothingEnabled\")){d8.mozImageSmoothingEnabled=true}};bB.prototype.smooth=function(){dO=true};bR.prototype.noSmooth=function(){dO=false;var ea=ae.style;ea.setProperty(\"image-rendering\",\"optimizeSpeed\",\"important\");ea.setProperty(\"image-rendering\",\"-moz-crisp-edges\",\"important\");ea.setProperty(\"image-rendering\",\"-webkit-optimize-contrast\",\"important\");ea.setProperty(\"image-rendering\",\"optimize-contrast\",\"important\");ea.setProperty(\"-ms-interpolation-mode\",\"nearest-neighbor\",\"important\");if(d8.hasOwnProperty(\"mozImageSmoothingEnabled\")){d8.mozImageSmoothingEnabled=false}};bB.prototype.noSmooth=function(){dO=false};bR.prototype.point=function(ea,eb){if(!ce){return}ea=q.round(ea);eb=q.round(eb);d8.fillStyle=cW.color.toString(cv);aq=true;if(dW>1){d8.beginPath();d8.arc(ea,eb,dW/2,0,6.283185307179586,false);d8.fill()}else{d8.fillRect(ea,eb,1,1)}};bB.prototype.point=function(ea,ee,ed){var ec=new aP;ec.translate(ea,ee,ed||0);ec.transpose();var eb=new aP;eb.scale(1,-1,1);eb.apply(dJ.array());eb.transpose();d8.useProgram(dQ);a9(\"uModel2d\",dQ,\"uModel\",false,ec.array());a9(\"uView2d\",dQ,\"uView\",false,eb.array());if(dW>0&&ce){d2(\"uColor2d\",dQ,\"uColor\",c0);dZ(\"uIsDrawingText2d\",dQ,\"uIsDrawingText\",false);dZ(\"uSmooth2d\",dQ,\"uSmooth\",dO);dc(\"aVertex2d\",dQ,\"aVertex\",3,aw);cg(\"aTextureCoord2d\",dQ,\"aTextureCoord\");d8.drawArrays(d8.POINTS,0,1)}};cW.beginShape=function(ea){dR=ea;d6=[];bb=[]};bR.prototype.vertex=function(eb,ed,ea){var ec=[];if(du){du=false}ec.isVert=true;ec[0]=eb;ec[1]=ed;ec[2]=0;ec[3]=0;ec[4]=0;ec[5]=a1;ec[6]=cv;bb.push(ec);if(ea){bb[bb.length-1][\"moveTo\"]=ea}};bB.prototype.vertex=function(ea,ef,ee,ed,ec){var eb=[];if(du){du=false}eb.isVert=true;if(ec===t&&dT){ec=ed;ed=ee;ee=0}if(ed!==t&&ec!==t){if(d4===2){ed/=cs.width;ec/=cs.height}ed=ed>1?1:ed;ed=ed<0?0:ed;ec=ec>1?1:ec;ec=ec<0?0:ec}eb[0]=ea;eb[1]=ef;eb[2]=ee||0;eb[3]=ed||0;eb[4]=ec||0;eb[5]=bo[0];eb[6]=bo[1];eb[7]=bo[2];eb[8]=bo[3];eb[9]=c0[0];eb[10]=c0[1];eb[11]=c0[2];eb[12]=c0[3];eb[13]=a8;eb[14]=a7;eb[15]=a6;bb.push(eb)};var d1=function(ec,eb){var ea=new aP;ea.scale(1,-1,1);ea.apply(dJ.array());ea.transpose();d8.useProgram(bT);a9(\"uViewUS\",bT,\"uView\",false,ea.array());dZ(\"uSmoothUS\",bT,\"uSmooth\",dO);dc(\"aVertexUS\",bT,\"aVertex\",3,aw);d8.bufferData(d8.ARRAY_BUFFER,new e(ec),d8.STREAM_DRAW);dc(\"aColorUS\",bT,\"aColor\",4,aG);d8.bufferData(d8.ARRAY_BUFFER,new e(eb),d8.STREAM_DRAW);d8.drawArrays(d8.POINTS,0,ec.length/3)};var bj=function(ee,ed,ec){var eb;if(ed===\"LINES\"){eb=d8.LINES}else{if(ed===\"LINE_LOOP\"){eb=d8.LINE_LOOP}else{eb=d8.LINE_STRIP}}var ea=new aP;ea.scale(1,-1,1);ea.apply(dJ.array());ea.transpose();d8.useProgram(bT);a9(\"uViewUS\",bT,\"uView\",false,ea.array());dc(\"aVertexUS\",bT,\"aVertex\",3,b8);d8.bufferData(d8.ARRAY_BUFFER,new e(ee),d8.STREAM_DRAW);dc(\"aColorUS\",bT,\"aColor\",4,bC);d8.bufferData(d8.ARRAY_BUFFER,new e(ec),d8.STREAM_DRAW);d8.drawArrays(eb,0,ee.length/3)};var dm=function(ef,ee,ed,ec){var eb;if(ee===\"TRIANGLES\"){eb=d8.TRIANGLES}else{if(ee===\"TRIANGLE_FAN\"){eb=d8.TRIANGLE_FAN}else{eb=d8.TRIANGLE_STRIP}}var ea=new aP;ea.scale(1,-1,1);ea.apply(dJ.array());ea.transpose();d8.useProgram(dx);a9(\"model3d\",dx,\"uModel\",false,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);a9(\"view3d\",dx,\"uView\",false,ea.array());d8.enable(d8.POLYGON_OFFSET_FILL);d8.polygonOffset(1,1);d2(\"color3d\",dx,\"uColor\",[-1,0,0,0]);dc(\"vertex3d\",dx,\"aVertex\",3,at);d8.bufferData(d8.ARRAY_BUFFER,new e(ef),d8.STREAM_DRAW);if(dT&&bf!==null){bw(ed)}dc(\"aColor3d\",dx,\"aColor\",4,aG);d8.bufferData(d8.ARRAY_BUFFER,new e(ed),d8.STREAM_DRAW);cg(\"aNormal3d\",dx,\"aNormal\");if(dT){dZ(\"uUsingTexture3d\",dx,\"uUsingTexture\",dT);dc(\"aTexture3d\",dx,\"aTexture\",2,af);d8.bufferData(d8.ARRAY_BUFFER,new e(ec),d8.STREAM_DRAW)}d8.drawArrays(eb,0,ef.length/3);d8.disable(d8.POLYGON_OFFSET_FILL)};function cS(){bn();dd();d8.closePath()}bR.prototype.endShape=function(eh){if(bb.length===0){return}var ed=eh===2;if(ed){bb.push(bb[0])}var ec=[];var ea=[];var ej=[];var em=[];var ef=[];var ei;du=true;var eg,ee,eb;var el=bb.length;for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=0;ee<3;ee++){ea.push(ei[ee])}}for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=5;ee<9;ee++){ej.push(ei[ee])}}for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=9;ee<13;ee++){em.push(ei[ee])}}for(eg=0;eg<el;eg++){ei=bb[eg];ef.push(ei[3]);ef.push(ei[4])}if(dP&&(dR===20||dR===t)){if(el>3){var ek=[],en=1-aJ;d8.beginPath();d8.moveTo(bb[1][0],bb[1][1]);for(eg=1;eg+2<el;eg++){ei=bb[eg];ek[0]=[ei[0],ei[1]];ek[1]=[ei[0]+(en*bb[eg+1][0]-en*bb[eg-1][0])/6,ei[1]+(en*bb[eg+1][1]-en*bb[eg-1][1])/6];ek[2]=[bb[eg+1][0]+(en*bb[eg][0]-en*bb[eg+2][0])/6,bb[eg+1][1]+(en*bb[eg][1]-en*bb[eg+2][1])/6];ek[3]=[bb[eg+1][0],bb[eg+1][1]];d8.bezierCurveTo(ek[1][0],ek[1][1],ek[2][0],ek[2][1],ek[3][0],ek[3][1])}cS()}}else{if(aa&&(dR===20||dR===t)){d8.beginPath();for(eg=0;eg<el;eg++){ei=bb[eg];if(bb[eg][\"isVert\"]){if(bb[eg][\"moveTo\"]){d8.moveTo(ei[0],ei[1])}else{d8.lineTo(ei[0],ei[1])}}else{d8.bezierCurveTo(bb[eg][0],bb[eg][1],bb[eg][2],bb[eg][3],bb[eg][4],bb[eg][5])}}cS()}else{if(dR===2){for(eg=0;eg<el;eg++){ei=bb[eg];if(ce){cW.stroke(ei[6])}cW.point(ei[0],ei[1])}}else{if(dR===4){for(eg=0;eg+1<el;eg+=2){ei=bb[eg];if(ce){cW.stroke(bb[eg+1][6])}cW.line(ei[0],ei[1],bb[eg+1][0],bb[eg+1][1])}}else{if(dR===9){for(eg=0;eg+2<el;eg+=3){ei=bb[eg];d8.beginPath();d8.moveTo(ei[0],ei[1]);d8.lineTo(bb[eg+1][0],bb[eg+1][1]);d8.lineTo(bb[eg+2][0],bb[eg+2][1]);d8.lineTo(ei[0],ei[1]);if(aH){cW.fill(bb[eg+2][5]);bn()}if(ce){cW.stroke(bb[eg+2][6]);dd()}d8.closePath()}}else{if(dR===10){for(eg=0;eg+1<el;eg++){ei=bb[eg];d8.beginPath();d8.moveTo(bb[eg+1][0],bb[eg+1][1]);d8.lineTo(ei[0],ei[1]);if(ce){cW.stroke(bb[eg+1][6])}if(aH){cW.fill(bb[eg+1][5])}if(eg+2<el){d8.lineTo(bb[eg+2][0],bb[eg+2][1]);if(ce){cW.stroke(bb[eg+2][6])}if(aH){cW.fill(bb[eg+2][5])}}cS()}}else{if(dR===11){if(el>2){d8.beginPath();d8.moveTo(bb[0][0],bb[0][1]);d8.lineTo(bb[1][0],bb[1][1]);d8.lineTo(bb[2][0],bb[2][1]);if(aH){cW.fill(bb[2][5]);bn()}if(ce){cW.stroke(bb[2][6]);dd()}d8.closePath();for(eg=3;eg<el;eg++){ei=bb[eg];d8.beginPath();d8.moveTo(bb[0][0],bb[0][1]);d8.lineTo(bb[eg-1][0],bb[eg-1][1]);d8.lineTo(ei[0],ei[1]);if(aH){cW.fill(ei[5]);bn()}if(ce){cW.stroke(ei[6]);dd()}d8.closePath()}}}else{if(dR===16){for(eg=0;eg+3<el;eg+=4){ei=bb[eg];d8.beginPath();d8.moveTo(ei[0],ei[1]);for(ee=1;ee<4;ee++){d8.lineTo(bb[eg+ee][0],bb[eg+ee][1])}d8.lineTo(ei[0],ei[1]);if(aH){cW.fill(bb[eg+3][5]);bn()}if(ce){cW.stroke(bb[eg+3][6]);dd()}d8.closePath()}}else{if(dR===17){if(el>3){for(eg=0;eg+1<el;eg+=2){ei=bb[eg];d8.beginPath();if(eg+3<el){d8.moveTo(bb[eg+2][0],bb[eg+2][1]);d8.lineTo(ei[0],ei[1]);d8.lineTo(bb[eg+1][0],bb[eg+1][1]);d8.lineTo(bb[eg+3][0],bb[eg+3][1]);if(aH){cW.fill(bb[eg+3][5])}if(ce){cW.stroke(bb[eg+3][6])}}else{d8.moveTo(ei[0],ei[1]);d8.lineTo(bb[eg+1][0],bb[eg+1][1])}cS()}}}else{d8.beginPath();d8.moveTo(bb[0][0],bb[0][1]);for(eg=1;eg<el;eg++){ei=bb[eg];if(ei.isVert){if(ei.moveTo){d8.moveTo(ei[0],ei[1])}else{d8.lineTo(ei[0],ei[1])}}}cS()}}}}}}}}}dP=false;aa=false;cb=[];c2=0;if(ed){bb.pop()}};bB.prototype.endShape=function(eh){if(bb.length===0){return}var ed=eh===2;var ec=[];var ea=[];var ej=[];var em=[];var ef=[];var ei;du=true;var eg,ee,eb;var el=bb.length;for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=0;ee<3;ee++){ea.push(ei[ee])}}for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=5;ee<9;ee++){ej.push(ei[ee])}}for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=9;ee<13;ee++){em.push(ei[ee])}}for(eg=0;eg<el;eg++){ei=bb[eg];ef.push(ei[3]);ef.push(ei[4])}if(ed){ea.push(bb[0][0]);ea.push(bb[0][1]);ea.push(bb[0][2]);for(eg=5;eg<9;eg++){ej.push(bb[0][eg])}for(eg=9;eg<13;eg++){em.push(bb[0][eg])}ef.push(bb[0][3]);ef.push(bb[0][4])}if(dP&&(dR===20||dR===t)){ec=ea;if(ce){bj(ec,null,em)}if(aH){dm(ea,null,ej)}}else{if(aa&&(dR===20||dR===t)){ec=ea;ec.splice(ec.length-3);em.splice(em.length-4);if(ce){bj(ec,null,em)}if(aH){dm(ea,\"TRIANGLES\",ej)}}else{if(dR===2){for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=0;ee<3;ee++){ec.push(ei[ee])}}d1(ec,em)}else{if(dR===4){for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=0;ee<3;ee++){ec.push(ei[ee])}}for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=5;ee<9;ee++){ej.push(ei[ee])}}bj(ec,\"LINES\",em)}else{if(dR===9){if(el>2){for(eg=0;eg+2<el;eg+=3){ea=[];ef=[];ec=[];ej=[];em=[];for(ee=0;ee<3;ee++){for(eb=0;eb<3;eb++){ec.push(bb[eg+ee][eb]);ea.push(bb[eg+ee][eb])}}for(ee=0;ee<3;ee++){for(eb=3;eb<5;eb++){ef.push(bb[eg+ee][eb])}}for(ee=0;ee<3;ee++){for(eb=5;eb<9;eb++){ej.push(bb[eg+ee][eb]);em.push(bb[eg+ee][eb+4])}}if(ce){bj(ec,\"LINE_LOOP\",em)}if(aH||dT){dm(ea,\"TRIANGLES\",ej,ef)}}}}else{if(dR===10){if(el>2){for(eg=0;eg+2<el;eg++){ec=[];ea=[];em=[];ej=[];ef=[];for(ee=0;ee<3;ee++){for(eb=0;eb<3;eb++){ec.push(bb[eg+ee][eb]);ea.push(bb[eg+ee][eb])}}for(ee=0;ee<3;ee++){for(eb=3;eb<5;eb++){ef.push(bb[eg+ee][eb])}}for(ee=0;ee<3;ee++){for(eb=5;eb<9;eb++){em.push(bb[eg+ee][eb+4]);ej.push(bb[eg+ee][eb])}}if(aH||dT){dm(ea,\"TRIANGLE_STRIP\",ej,ef)}if(ce){bj(ec,\"LINE_LOOP\",em)}}}}else{if(dR===11){if(el>2){for(eg=0;eg<3;eg++){ei=bb[eg];for(ee=0;ee<3;ee++){ec.push(ei[ee])}}for(eg=0;eg<3;eg++){ei=bb[eg];for(ee=9;ee<13;ee++){em.push(ei[ee])}}if(ce){bj(ec,\"LINE_LOOP\",em)}for(eg=2;eg+1<el;eg++){ec=[];em=[];ec.push(bb[0][0]);ec.push(bb[0][1]);ec.push(bb[0][2]);em.push(bb[0][9]);em.push(bb[0][10]);em.push(bb[0][11]);em.push(bb[0][12]);for(ee=0;ee<2;ee++){for(eb=0;eb<3;eb++){ec.push(bb[eg+ee][eb])}}for(ee=0;ee<2;ee++){for(eb=9;eb<13;eb++){em.push(bb[eg+ee][eb])}}if(ce){bj(ec,\"LINE_STRIP\",em)}}if(aH||dT){dm(ea,\"TRIANGLE_FAN\",ej,ef)}}}else{if(dR===16){for(eg=0;eg+3<el;eg+=4){ec=[];for(ee=0;ee<4;ee++){ei=bb[eg+ee];for(eb=0;eb<3;eb++){ec.push(ei[eb])}}if(ce){bj(ec,\"LINE_LOOP\",em)}if(aH){ea=[];ej=[];ef=[];for(ee=0;ee<3;ee++){ea.push(bb[eg][ee])}for(ee=5;ee<9;ee++){ej.push(bb[eg][ee])}for(ee=0;ee<3;ee++){ea.push(bb[eg+1][ee])}for(ee=5;ee<9;ee++){ej.push(bb[eg+1][ee])}for(ee=0;ee<3;ee++){ea.push(bb[eg+3][ee])}for(ee=5;ee<9;ee++){ej.push(bb[eg+3][ee])}for(ee=0;ee<3;ee++){ea.push(bb[eg+2][ee])}for(ee=5;ee<9;ee++){ej.push(bb[eg+2][ee])}if(dT){ef.push(bb[eg+0][3]);ef.push(bb[eg+0][4]);ef.push(bb[eg+1][3]);ef.push(bb[eg+1][4]);ef.push(bb[eg+3][3]);ef.push(bb[eg+3][4]);ef.push(bb[eg+2][3]);ef.push(bb[eg+2][4])}dm(ea,\"TRIANGLE_STRIP\",ej,ef)}}}else{if(dR===17){var ek=[];if(el>3){for(eg=0;eg<2;eg++){ei=bb[eg];for(ee=0;ee<3;ee++){ec.push(ei[ee])}}for(eg=0;eg<2;eg++){ei=bb[eg];for(ee=9;ee<13;ee++){em.push(ei[ee])}}bj(ec,\"LINE_STRIP\",em);if(el>4&&el%2>0){ek=ea.splice(ea.length-3);bb.pop()}for(eg=0;eg+3<el;eg+=2){ec=[];em=[];for(ee=0;ee<3;ee++){ec.push(bb[eg+1][ee])}for(ee=0;ee<3;ee++){ec.push(bb[eg+3][ee])}for(ee=0;ee<3;ee++){ec.push(bb[eg+2][ee])}for(ee=0;ee<3;ee++){ec.push(bb[eg+0][ee])}for(ee=9;ee<13;ee++){em.push(bb[eg+1][ee])}for(ee=9;ee<13;ee++){em.push(bb[eg+3][ee])}for(ee=9;ee<13;ee++){em.push(bb[eg+2][ee])}for(ee=9;ee<13;ee++){em.push(bb[eg+0][ee])}if(ce){bj(ec,\"LINE_STRIP\",em)}}if(aH||dT){dm(ea,\"TRIANGLE_LIST\",ej,ef)}}}else{if(el===1){for(ee=0;ee<3;ee++){ec.push(bb[0][ee])}for(ee=9;ee<13;ee++){em.push(bb[0][ee])}d1(ec,em)}else{for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=0;ee<3;ee++){ec.push(ei[ee])}for(ee=5;ee<9;ee++){em.push(ei[ee])}}if(ce&&ed){bj(ec,\"LINE_LOOP\",em)}else{if(ce&&!ed){bj(ec,\"LINE_STRIP\",em)}}if(aH||dT){dm(ea,\"TRIANGLE_FAN\",ej,ef)}}}}}}}}}dT=false;d8.useProgram(dx);dZ(\"usingTexture3d\",dx,\"uUsingTexture\",dT)}}dP=false;aa=false;cb=[];c2=0};var aY=function(ed,ec){var ee=1/ed;var eb=ee*ee;var ea=eb*ee;ec.set(0,0,0,1,ea,eb,ee,0,6*ea,2*eb,0,0,6*ea,0,0,0)};var dr=function(){if(!aL){c3=new aP;aL=new aP;cM=true}var ea=aJ;c3.set((ea-1)/2,(ea+3)/2,(-3-ea)/2,(1-ea)/2,1-ea,(-5-ea)/2,ea+2,(ea-1)/2,(ea-1)/2,0,(1-ea)/2,0,0,1,0,0);aY(Q,aL);if(!cd){aQ=new aP}aQ.set(c3);aQ.preApply(cd);aL.apply(c3)};bR.prototype.bezierVertex=function(){aa=true;var ea=[];if(du){throw\"vertex() must be used at least once before calling bezierVertex()\"}for(var eb=0;eb<arguments.length;eb++){ea[eb]=arguments[eb]}bb.push(ea);bb[bb.length-1][\"isVert\"]=false};bB.prototype.bezierVertex=function(){aa=true;var eh=[];if(du){throw\"vertex() must be used at least once before calling bezierVertex()\"}if(arguments.length===9){if(bz===t){bz=new aP}var em=bb.length-1;aY(cy,bz);bz.apply(U);var eo=bz.array();var ed=bb[em][0],en=bb[em][1],eg=bb[em][2];var ej=eo[4]*ed+eo[5]*arguments[0]+eo[6]*arguments[3]+eo[7]*arguments[6];var ei=eo[8]*ed+eo[9]*arguments[0]+eo[10]*arguments[3]+eo[11]*arguments[6];var ef=eo[12]*ed+eo[13]*arguments[0]+eo[14]*arguments[3]+eo[15]*arguments[6];var ep=eo[4]*en+eo[5]*arguments[1]+eo[6]*arguments[4]+eo[7]*arguments[7];var el=eo[8]*en+eo[9]*arguments[1]+eo[10]*arguments[4]+eo[11]*arguments[7];var ek=eo[12]*en+eo[13]*arguments[1]+eo[14]*arguments[4]+eo[15]*arguments[7];var ec=eo[4]*eg+eo[5]*arguments[2]+eo[6]*arguments[5]+eo[7]*arguments[8];var eb=eo[8]*eg+eo[9]*arguments[2]+eo[10]*arguments[5]+eo[11]*arguments[8];var ea=eo[12]*eg+eo[13]*arguments[2]+eo[14]*arguments[5]+eo[15]*arguments[8];for(var ee=0;ee<cy;ee++){ed+=ej;ej+=ei;ei+=ef;en+=ep;ep+=el;el+=ek;eg+=ec;ec+=eb;eb+=ea;cW.vertex(ed,en,eg)}cW.vertex(arguments[6],arguments[7],arguments[8])}};cW.texture=function(ed){var eb=dY.$ensureContext();if(ed.__texture){eb.bindTexture(eb.TEXTURE_2D,ed.__texture)}else{if(ed.localName===\"canvas\"){eb.bindTexture(eb.TEXTURE_2D,c7);eb.texImage2D(eb.TEXTURE_2D,0,eb.RGBA,eb.RGBA,eb.UNSIGNED_BYTE,ed);eb.texParameteri(eb.TEXTURE_2D,eb.TEXTURE_MAG_FILTER,eb.LINEAR);eb.texParameteri(eb.TEXTURE_2D,eb.TEXTURE_MIN_FILTER,eb.LINEAR);eb.generateMipmap(eb.TEXTURE_2D);cs.width=ed.width;cs.height=ed.height}else{var ec=eb.createTexture(),ef=d.createElement(\"canvas\"),ea=ef.getContext(\"2d\"),ee;if(ed.width&ed.width-1===0){ef.width=ed.width}else{ee=1;while(ee<ed.width){ee*=2}ef.width=ee}if(ed.height&ed.height-1===0){ef.height=ed.height}else{ee=1;while(ee<ed.height){ee*=2}ef.height=ee}ea.drawImage(ed.sourceImg,0,0,ed.width,ed.height,0,0,ef.width,ef.height);eb.bindTexture(eb.TEXTURE_2D,ec);eb.texParameteri(eb.TEXTURE_2D,eb.TEXTURE_MIN_FILTER,eb.LINEAR_MIPMAP_LINEAR);eb.texParameteri(eb.TEXTURE_2D,eb.TEXTURE_MAG_FILTER,eb.LINEAR);eb.texParameteri(eb.TEXTURE_2D,eb.TEXTURE_WRAP_T,eb.CLAMP_TO_EDGE);eb.texParameteri(eb.TEXTURE_2D,eb.TEXTURE_WRAP_S,eb.CLAMP_TO_EDGE);eb.texImage2D(eb.TEXTURE_2D,0,eb.RGBA,eb.RGBA,eb.UNSIGNED_BYTE,ef);eb.generateMipmap(eb.TEXTURE_2D);ed.__texture=ec;cs.width=ed.width;cs.height=ed.height}}dT=true;eb.useProgram(dx);dZ(\"usingTexture3d\",dx,\"uUsingTexture\",dT)};cW.textureMode=function(ea){d4=ea};var ar=function(ev,eg,em,et,ef,el,er,ee,ek,ep,ed,ei){var ew=et;var eh=ef;var en=el;var ej=aL.array();var eu=ej[4]*ev+ej[5]*et+ej[6]*er+ej[7]*ep;var es=ej[8]*ev+ej[9]*et+ej[10]*er+ej[11]*ep;var eq=ej[12]*ev+ej[13]*et+ej[14]*er+ej[15]*ep;var ez=ej[4]*eg+ej[5]*ef+ej[6]*ee+ej[7]*ed;var ey=ej[8]*eg+ej[9]*ef+ej[10]*ee+ej[11]*ed;var ex=ej[12]*eg+ej[13]*ef+ej[14]*ee+ej[15]*ed;var ec=ej[4]*em+ej[5]*el+ej[6]*ek+ej[7]*ei;var eb=ej[8]*em+ej[9]*el+ej[10]*ek+ej[11]*ei;var ea=ej[12]*em+ej[13]*el+ej[14]*ek+ej[15]*ei;cW.vertex(ew,eh,en);for(var eo=0;eo<Q;eo++){ew+=eu;eu+=es;es+=eq;eh+=ez;ez+=ey;ey+=ex;en+=ec;ec+=eb;eb+=ea;cW.vertex(ew,eh,en)}};bR.prototype.curveVertex=function(ea,eb){dP=true;cW.vertex(ea,eb)};bB.prototype.curveVertex=function(ea,ed,ec){dP=true;if(!cM){dr()}var eb=[];eb[0]=ea;eb[1]=ed;eb[2]=ec;cb.push(eb);c2++;if(c2>3){ar(cb[c2-4][0],cb[c2-4][1],cb[c2-4][2],cb[c2-3][0],cb[c2-3][1],cb[c2-3][2],cb[c2-2][0],cb[c2-2][1],cb[c2-2][2],cb[c2-1][0],cb[c2-1][1],cb[c2-1][2])}};bR.prototype.curve=function(ef,eh,ed,eg,eb,ee,ea,ec){cW.beginShape();cW.curveVertex(ef,eh);cW.curveVertex(ed,eg);cW.curveVertex(eb,ee);cW.curveVertex(ea,ec);cW.endShape()};bB.prototype.curve=function(ec,ek,eg,eb,ej,ef,ea,ei,ee,el,eh,ed){if(ed!==t){cW.beginShape();cW.curveVertex(ec,ek,eg);cW.curveVertex(eb,ej,ef);cW.curveVertex(ea,ei,ee);cW.curveVertex(el,eh,ed);cW.endShape();return}cW.beginShape();cW.curveVertex(ec,ek);cW.curveVertex(eg,eb);cW.curveVertex(ej,ef);cW.curveVertex(ea,ei);cW.endShape()};cW.curveTightness=function(ea){aJ=ea};cW.curveDetail=function(ea){Q=ea;dr()};cW.rectMode=function(ea){bK=ea};cW.imageMode=function(ea){switch(ea){case 0:bk=aZ;break;case 1:bk=b1;break;case 3:bk=aN;break;default:throw\"Invalid imageMode\"}};cW.ellipseMode=function(ea){cN=ea};cW.arc=function(em,ek,ed,eo,ec,el){if(ed<=0||el<ec){return}if(cN===1){ed=ed-em;eo=eo-ek}else{if(cN===2){em=em-ed;ek=ek-eo;ed=ed*2;eo=eo*2}else{if(cN===3){em=em-ed/2;ek=ek-eo/2}}}while(ec<0){ec+=6.283185307179586;el+=6.283185307179586}if(el-ec>6.283185307179586){ec=0;el=6.283185307179586}var en=ed/2,ep=eo/2,eh=em+en,ef=ek+ep,eb=0|0.5+ec*cW.RAD_TO_DEG*2,ej=0|0.5+el*cW.RAD_TO_DEG*2,ei,eg;if(aH){var ee=ce;ce=false;cW.beginShape();cW.vertex(eh,ef);for(ei=eb;ei<=ej;ei++){eg=ei%720;cW.vertex(eh+bl[eg]*en,ef+ah[eg]*ep)}cW.endShape(2);ce=ee}if(ce){var ea=aH;aH=false;cW.beginShape();for(ei=eb;ei<=ej;ei++){eg=ei%720;cW.vertex(eh+bl[eg]*en,ef+ah[eg]*ep)}cW.endShape();aH=ea}};bR.prototype.line=function(eb,ei,ea,eg){if(!ce){return}eb=q.round(eb);ea=q.round(ea);ei=q.round(ei);eg=q.round(eg);if(eb===ea&&ei===eg){cW.point(eb,ei);return}var ec=t,ej=t,ef=true,eh=dJ.array(),ed=[1,0,0,0,1,0];for(var ee=0;ee<6&&ef;ee++){ef=eh[ee]===ed[ee]}if(ef){if(eb===ea){if(ei>eg){ec=ei;ei=eg;eg=ec}eg++;if(dW%2===1){d8.translate(0.5,0)}}else{if(ei===eg){if(eb>ea){ec=eb;eb=ea;ea=ec}ea++;if(dW%2===1){d8.translate(0,0.5)}}}if(dW===1){ej=d8.lineCap;d8.lineCap=\"butt\"}}d8.beginPath();d8.moveTo(eb||0,ei||0);d8.lineTo(ea||0,eg||0);dd();if(ef){if(eb===ea&&dW%2===1){d8.translate(-0.5,0)}else{if(ei===eg&&dW%2===1){d8.translate(0,-0.5)}}if(dW===1){d8.lineCap=ej}}};bB.prototype.line=function(ec,ef,eh,eb,ed,eg){if(ed===t||eg===t){eg=0;ed=eb;eb=eh;eh=0}if(ec===eb&&ef===ed&&eh===eg){cW.point(ec,ef,eh);return}var ee=[ec,ef,eh,eb,ed,eg];var ea=new aP;ea.scale(1,-1,1);ea.apply(dJ.array());ea.transpose();if(dW>0&&ce){d8.useProgram(dQ);a9(\"uModel2d\",dQ,\"uModel\",false,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);a9(\"uView2d\",dQ,\"uView\",false,ea.array());d2(\"uColor2d\",dQ,\"uColor\",c0);dZ(\"uIsDrawingText\",dQ,\"uIsDrawingText\",false);dc(\"aVertex2d\",dQ,\"aVertex\",3,b8);cg(\"aTextureCoord2d\",dQ,\"aTextureCoord\");d8.bufferData(d8.ARRAY_BUFFER,new e(ee),d8.STREAM_DRAW);d8.drawArrays(d8.LINES,0,2)}};bR.prototype.bezier=function(){if(arguments.length!==8){throw\"You must use 8 parameters for bezier() in 2D mode\"}cW.beginShape();cW.vertex(arguments[0],arguments[1]);cW.bezierVertex(arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);cW.endShape()};bB.prototype.bezier=function(){if(arguments.length!==12){throw\"You must use 12 parameters for bezier() in 3D mode\"}cW.beginShape();cW.vertex(arguments[0],arguments[1],arguments[2]);cW.bezierVertex(arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);cW.endShape()};cW.bezierDetail=function(ea){cy=ea};cW.bezierPoint=function(eb,ea,ee,ed,ec){return(1-ec)*(1-ec)*(1-ec)*eb+3*(1-ec)*(1-ec)*ec*ea+3*(1-ec)*ec*ec*ee+ec*ec*ec*ed};cW.bezierTangent=function(eb,ea,ee,ed,ec){return 3*ec*ec*(-eb+3*ea-3*ee+ed)+6*ec*(eb-2*ea+ee)+3*(-eb+ea)};cW.curvePoint=function(eb,ea,ee,ed,ec){return 0.5*(2*ea+(-eb+ee)*ec+(2*eb-5*ea+4*ee-ed)*ec*ec+(-eb+3*ea-3*ee+ed)*ec*ec*ec)};cW.curveTangent=function(eb,ea,ee,ed,ec){return 0.5*(-eb+ee+2*(2*eb-5*ea+4*ee-ed)*ec+3*(-eb+3*ea-3*ee+ed)*ec*ec)};cW.triangle=function(ed,ef,eb,ee,ea,ec){cW.beginShape(9);cW.vertex(ed,ef,0);cW.vertex(eb,ee,0);cW.vertex(ea,ec,0);cW.endShape()};cW.quad=function(ef,eh,ed,eg,eb,ee,ea,ec){cW.beginShape(16);cW.vertex(ef,eh,0);cW.vertex(ed,eg,0);cW.vertex(eb,ee,0);cW.vertex(ea,ec,0);cW.endShape()};var bN=function(eg,ef,ea,eh,ej,ee,ei,eb){if(eb===t){ee=ej;ei=ej;eb=ej}var ec=ea/2,ed=eh/2;if(ej>ec||ej>ed){ej=q.min(ec,ed)}if(ee>ec||ee>ed){ee=q.min(ec,ed)}if(ei>ec||ei>ed){ei=q.min(ec,ed)}if(eb>ec||eb>ed){eb=q.min(ec,ed)}if(!aH||ce){d8.translate(0.5,0.5)}d8.beginPath();d8.moveTo(eg+ej,ef);d8.lineTo(eg+ea-ee,ef);d8.quadraticCurveTo(eg+ea,ef,eg+ea,ef+ee);d8.lineTo(eg+ea,ef+eh-ei);d8.quadraticCurveTo(eg+ea,ef+eh,eg+ea-ei,ef+eh);d8.lineTo(eg+eb,ef+eh);d8.quadraticCurveTo(eg,ef+eh,eg,ef+eh-eb);d8.lineTo(eg,ef+ej);d8.quadraticCurveTo(eg,ef,eg+ej,ef);if(!aH||ce){d8.translate(-0.5,-0.5)}bn();dd()};bR.prototype.rect=function(eb,eh,ee,ea,ec,ef,ed,eg){if(!ee&&!ea){return}if(bK===1){ee-=eb;ea-=eh}else{if(bK===2){ee*=2;ea*=2;eb-=ee/2;eh-=ea/2}else{if(bK===3){eb-=ee/2;eh-=ea/2}}}eb=q.round(eb);eh=q.round(eh);ee=q.round(ee);ea=q.round(ea);if(ec!==t){bN(eb,eh,ee,ea,ec,ef,ed,eg);return}if(ce&&dW%2===1){d8.translate(0.5,0.5)}d8.beginPath();d8.rect(eb,eh,ee,ea);bn();dd();if(ce&&dW%2===1){d8.translate(-0.5,-0.5)}};bB.prototype.rect=function(ei,eh,ea,ek,em,ef,el,eb){if(em!==t){throw\"rect() with rounded corners is not supported in 3D mode\"}if(bK===1){ea-=ei;ek-=eh}else{if(bK===2){ea*=2;ek*=2;ei-=ea/2;eh-=ek/2}else{if(bK===3){ei-=ea/2;eh-=ek/2}}}var ee=new aP;ee.translate(ei,eh,0);ee.scale(ea,ek,1);ee.transpose();var eg=new aP;eg.scale(1,-1,1);eg.apply(dJ.array());eg.transpose();if(dW>0&&ce){d8.useProgram(dQ);a9(\"uModel2d\",dQ,\"uModel\",false,ee.array());a9(\"uView2d\",dQ,\"uView\",false,eg.array());d2(\"uColor2d\",dQ,\"uColor\",c0);dZ(\"uIsDrawingText2d\",dQ,\"uIsDrawingText\",false);dc(\"aVertex2d\",dQ,\"aVertex\",3,aB);cg(\"aTextureCoord2d\",dQ,\"aTextureCoord\");d8.drawArrays(d8.LINE_LOOP,0,ak.length/3)}if(aH){d8.useProgram(dx);a9(\"uModel3d\",dx,\"uModel\",false,ee.array());a9(\"uView3d\",dx,\"uView\",false,eg.array());d8.enable(d8.POLYGON_OFFSET_FILL);d8.polygonOffset(1,1);d2(\"color3d\",dx,\"uColor\",bo);if(dL>0){var ej=new aP;ej.set(eg);var ec=new aP;ec.set(ee);ej.mult(ec);var ed=new aP;ed.set(ej);ed.invert();ed.transpose();a9(\"uNormalTransform3d\",dx,\"uNormalTransform\",false,ed.array());dc(\"aNormal3d\",dx,\"aNormal\",3,b2)}else{cg(\"normal3d\",dx,\"aNormal\")}dc(\"vertex3d\",dx,\"aVertex\",3,aB);d8.drawArrays(d8.TRIANGLE_FAN,0,ak.length/3);d8.disable(d8.POLYGON_OFFSET_FILL)}};bR.prototype.ellipse=function(eg,ef,eb,ei){eg=eg||0;ef=ef||0;if(eb<=0&&ei<=0){return}if(cN===2){eb*=2;ei*=2}else{if(cN===1){eb=eb-eg;ei=ei-ef;eg+=eb/2;ef+=ei/2}else{if(cN===0){eg+=eb/2;ef+=ei/2}}}if(eb===ei){d8.beginPath();d8.arc(eg,ef,eb/2,0,6.283185307179586,false);bn();dd()}else{var eh=eb/2,ee=ei/2,ea=0.5522847498307933,ed=ea*eh,ec=ea*ee;cW.beginShape();cW.vertex(eg+eh,ef);cW.bezierVertex(eg+eh,ef-ec,eg+ed,ef-ee,eg,ef-ee);cW.bezierVertex(eg-ed,ef-ee,eg-eh,ef-ec,eg-eh,ef);cW.bezierVertex(eg-eh,ef+ec,eg-ed,ef+ee,eg,ef+ee);cW.bezierVertex(eg+ed,ef+ee,eg+eh,ef+ec,eg+eh,ef);cW.endShape()}};bB.prototype.ellipse=function(en,em,ec,ep){en=en||0;em=em||0;if(ec<=0&&ep<=0){return}if(cN===2){ec*=2;ep*=2}else{if(cN===1){ec=ec-en;ep=ep-em;en+=ec/2;em+=ep/2}else{if(cN===0){en+=ec/2;em+=ep/2}}}var eo=ec/2,ej=ep/2,ea=0.5522847498307933,ee=ea*eo,ed=ea*ej;cW.beginShape();cW.vertex(en+eo,em);cW.bezierVertex(en+eo,em-ed,0,en+ee,em-ej,0,en,em-ej,0);cW.bezierVertex(en-ee,em-ej,0,en-eo,em-ed,0,en-eo,em,0);cW.bezierVertex(en-eo,em+ed,0,en-ee,em+ej,0,en,em+ej,0);cW.bezierVertex(en+ee,em+ej,0,en+eo,em+ed,0,en+eo,em,0);cW.endShape();if(aH){var ef=0,ek=0,eh,eg;for(eh=0;eh<bb.length;eh++){ef+=bb[eh][0];ek+=bb[eh][1]}ef/=bb.length;ek/=bb.length;var ei=[],eb=[],el=[];ei[0]=ef;ei[1]=ek;ei[2]=0;ei[3]=0;ei[4]=0;ei[5]=bo[0];ei[6]=bo[1];ei[7]=bo[2];ei[8]=bo[3];ei[9]=c0[0];ei[10]=c0[1];ei[11]=c0[2];ei[12]=c0[3];ei[13]=a8;ei[14]=a7;ei[15]=a6;bb.unshift(ei);for(eh=0;eh<bb.length;eh++){for(eg=0;eg<3;eg++){eb.push(bb[eh][eg])}for(eg=5;eg<9;eg++){el.push(bb[eh][eg])}}dm(eb,\"TRIANGLE_FAN\",el)}};cW.normal=function(ea,ec,eb){if(arguments.length!==3||!(typeof ea===\"number\"&&typeof ec===\"number\"&&typeof eb===\"number\")){throw\"normal() requires three numeric arguments.\"}a8=ea;a7=ec;a6=eb;if(dR!==0){if(a2===0){a2=1}else{if(a2===1){a2=2}}}};cW.save=function(eb,ea){if(ea!==t){return D.open(ea.toDataURL(),\"_blank\")}return D.open(cW.externals.canvas.toDataURL(),\"_blank\")};var cw=0;cW.saveFrame=function(ea){if(ea===t){ea=\"screen-####.png\"}var eb=ea.replace(/#+/,function(ed){var ec=\"\"+cw++;while(ec.length<ed.length){ec=\"0\"+ec}return ec});cW.save(eb)};var cc=d.createElement(\"canvas\").getContext(\"2d\");var X=[t,t,t];function by(eh,eb,eg){var ed=X.shift();if(ed===t){ed={};ed.canvas=d.createElement(\"canvas\");ed.context=ed.canvas.getContext(\"2d\")}X.push(ed);var ec=ed.canvas,ee=ed.context,ef=eb||eh.width,ea=eg||eh.height;ec.width=ef;ec.height=ea;if(!eh){ee.clearRect(0,0,ef,ea)}else{if(\"data\" in eh){ee.putImageData(eh,0,0)}else{ee.clearRect(0,0,ef,ea);ee.drawImage(eh,0,0,ef,ea)}}return ed}function b0(ea){return{getLength:function(eb){return function(){if(eb.isRemote){throw\"Image is loaded remotely. Cannot get length.\"}else{return eb.imageData.data.length?eb.imageData.data.length/4:0}}}(ea),getPixel:function(eb){return function(ec){var ee=ec*4,ed=eb.imageData.data;if(eb.isRemote){throw\"Image is loaded remotely. Cannot get pixels.\"}return(ed[ee+3]&255)<<24|(ed[ee]&255)<<16|(ed[ee+1]&255)<<8|ed[ee+2]&255}}(ea),setPixel:function(eb){return function(ec,ef){var ee=ec*4,ed=eb.imageData.data;if(eb.isRemote){throw\"Image is loaded remotely. Cannot set pixel.\"}ed[ee+0]=(ef>>16)&255;ed[ee+1]=(ef>>8)&255;ed[ee+2]=ef&255;ed[ee+3]=(ef>>24)&255;eb.__isDirty=true}}(ea),toArray:function(eb){return function(){var ec=[],ef=eb.imageData.data,ee=eb.width*eb.height;if(eb.isRemote){throw\"Image is loaded remotely. Cannot get pixels.\"}for(var ed=0,eg=0;ed<ee;ed++,eg+=4){ec.push((ef[eg+3]&255)<<24|(ef[eg]&255)<<16|(ef[eg+1]&255)<<8|ef[eg+2]&255)}return ec}}(ea),set:function(eb){return function(ec){var eg,ef,eh;if(this.isRemote){throw\"Image is loaded remotely. Cannot set pixels.\"}ef=eb.imageData.data;for(var ed=0,ee=ec.length;ed<ee;ed++){eh=ec[ed];eg=ed*4;ef[eg+0]=(eh>>16)&255;ef[eg+1]=(eh>>8)&255;ef[eg+2]=eh&255;ef[eg+3]=(eh>>24)&255}eb.__isDirty=true}}(ea)}}var cG=function(ed,eg,ee){this.__isDirty=false;if(ed instanceof HTMLImageElement){this.fromHTMLImageData(ed)}else{if(eg||ee){this.width=ed||1;this.height=eg||1;var eb=this.sourceImg=d.createElement(\"canvas\");eb.width=this.width;eb.height=this.height;var eh=this.imageData=eb.getContext(\"2d\").createImageData(this.width,this.height);this.format=ee===2||ee===4?ee:1;if(this.format===1){for(var ec=3,ef=this.imageData.data,ea=ef.length;ec<ea;ec+=4){ef[ec]=255}}this.__isDirty=true;this.updatePixels()}else{this.width=0;this.height=0;this.imageData=cc.createImageData(1,1);this.format=2}}this.pixels=b0(this)};cG.prototype={__isPImage:true,updatePixels:function(){var ea=this.sourceImg;if(ea&&ea instanceof HTMLCanvasElement&&this.__isDirty){ea.getContext(\"2d\").putImageData(this.imageData,0,0)}this.__isDirty=false},fromHTMLImageData:function(ea){var eb=by(ea);try{var ed=eb.context.getImageData(0,0,ea.width,ea.height);this.fromImageData(ed)}catch(ec){if(ea.width&&ea.height){this.isRemote=true;this.width=ea.width;this.height=ea.height}}this.sourceImg=ea},get:function(ea,ed,eb,ec){if(!arguments.length){return cW.get(this)}if(arguments.length===2){return cW.get(ea,ed,this)}if(arguments.length===4){return cW.get(ea,ed,eb,ec,this)}},set:function(ea,ec,eb){cW.set(ea,ec,eb,this);this.__isDirty=true},blend:function(ei,ee,ed,eb,eg,ej,eh,ef,ea,ec){if(arguments.length===9){cW.blend(this,ei,ee,ed,eb,eg,ej,eh,ef,ea,this)}else{if(arguments.length===10){cW.blend(ei,ee,ed,eb,eg,ej,eh,ef,ea,ec,this)}}delete this.sourceImg},copy:function(eh,ee,ed,ec,eb,ei,eg,ef,ea){if(arguments.length===8){cW.blend(this,eh,ee,ed,ec,eb,ei,eg,ef,0,this)}else{if(arguments.length===9){cW.blend(eh,ee,ed,ec,eb,ei,eg,ef,ea,0,this)}}delete this.sourceImg},filter:function(eb,ea){if(arguments.length===2){cW.filter(eb,ea,this)}else{if(arguments.length===1){cW.filter(eb,null,this)}}delete this.sourceImg},save:function(ea){cW.save(ea,this)},resize:function(ea,ec){if(this.isRemote){throw\"Image is loaded remotely. Cannot resize.\"}if(this.width!==0||this.height!==0){if(ea===0&&ec!==0){ea=q.floor(this.width/this.height*ec)}else{if(ec===0&&ea!==0){ec=q.floor(this.height/this.width*ea)}}var eb=by(this.imageData).canvas;var ed=by(eb,ea,ec).context.getImageData(0,0,ea,ec);this.fromImageData(ed)}},mask:function(ea){var ed=this.toImageData(),ec,eb;if(ea instanceof cG||ea.__isPImage){if(ea.width===this.width&&ea.height===this.height){ea=ea.toImageData();for(ec=2,eb=this.width*this.height*4;ec<eb;ec+=4){ed.data[ec+1]=ea.data[ec]}}else{throw\"mask must have the same dimensions as PImage.\"}}else{if(ea instanceof Array){if(this.width*this.height===ea.length){for(ec=0,eb=ea.length;ec<eb;++ec){ed.data[ec*4+3]=ea[ec]}}else{throw\"mask array must be the same length as PImage pixels array.\"}}}this.fromImageData(ed)},loadPixels:G,toImageData:function(){if(this.isRemote){return this.sourceImg}if(!this.__isDirty){return this.imageData}var ea=by(this.sourceImg);return ea.context.getImageData(0,0,this.width,this.height)},toDataURL:function(){if(this.isRemote){throw\"Image is loaded remotely. Cannot create dataURI.\"}var ea=by(this.imageData);return ea.canvas.toDataURL()},fromImageData:function(ee){var eb=ee.width,ed=ee.height,ec=d.createElement(\"canvas\"),ea=ec.getContext(\"2d\");this.width=ec.width=eb;this.height=ec.height=ed;ea.putImageData(ee,0,0);this.format=2;this.imageData=ee;this.sourceImg=ec}};cW.PImage=cG;cW.createImage=function(ea,eb,ec){return new cG(ea,eb,ec)};cW.loadImage=function(eb,ec,ee){if(ec){eb=eb+\".\"+ec}var ed;if(cQ.imageCache.images[eb]){ed=new cG(cQ.imageCache.images[eb]);ed.loaded=true;return ed}ed=new cG;var ea=d.createElement(\"img\");ed.sourceImg=ea;ea.onload=function(ei,eg,ef){var ej=ei;var eh=eg;var ek=ef;return function(){eh.fromHTMLImageData(ej);eh.loaded=true;if(ek){ek()}}}(ea,ed,ee);ea.src=eb;return ed};cW.requestImage=cW.loadImage;function c9(ea,ed){var eb;if(ea>=cW.width||ea<0||ed<0||ed>=cW.height){return 0}if(dV){var ec=((0|ea)+cW.width*(0|ed))*4;eb=cW.imageData.data;return(eb[ec+3]&255)<<24|(eb[ec]&255)<<16|(eb[ec+1]&255)<<8|eb[ec+2]&255}eb=cW.toImageData(0|ea,0|ed,1,1).data;return(eb[3]&255)<<24|(eb[0]&255)<<16|(eb[1]&255)<<8|eb[2]&255}function c8(ea,ee,eb){if(eb.isRemote){throw\"Image is loaded remotely. Cannot get x,y.\"}var ed=ee*eb.width*4+ea*4,ec=eb.imageData.data;return(ec[ed+3]&255)<<24|(ec[ed]&255)<<16|(ec[ed+1]&255)<<8|ec[ed+2]&255}function c6(ea,ee,eb,ec){var ed=new cG(eb,ec,2);ed.fromImageData(cW.toImageData(ea,ee,eb,ec));return ed}function c5(ef,ee,eg,el,er){if(er.isRemote){throw\"Image is loaded remotely. Cannot get x,y,w,h.\"}var ep=new cG(eg,el,2),ec=ep.imageData.data,ed=er.width,em=er.height,eo=er.imageData.data;var ea=q.max(0,-ee),eb=q.max(0,-ef),eh=q.min(el,em-ee),ei=q.min(eg,ed-ef);for(var ek=ea;ek<eh;++ek){var en=((ee+ek)*ed+(ef+eb))*4;var eq=(ek*eg+eb)*4;for(var ej=eb;ej<ei;++ej){ec[eq++]=eo[en++];ec[eq++]=eo[en++];ec[eq++]=eo[en++];ec[eq++]=eo[en++]}}ep.__isDirty=true;return ep}cW.get=function(ea,ee,eb,ed,ec){if(ec!==undefined){return c5(ea,ee,eb,ed,ec)}if(ed!==undefined){return c6(ea,ee,eb,ed)}if(eb!==undefined){return c8(ea,ee,eb)}if(ee!==undefined){return c9(ea,ee)}if(ea!==undefined){return c5(0,0,ea.width,ea.height,ea)}return c6(0,0,cW.width,cW.height)};cW.createGraphics=function(ea,ec,eb){var ed=new F;ed.size(ea,ec,eb);ed.background(0,0);return ed};function T(){if(dV){d8=aj;dV=false;cW.updatePixels()}}function cq(){function eb(ef,ed){function ee(){T();d8[ed].apply(d8,arguments)}ef[ed]=ee}function ea(eg,ee){function ed(){T();return d8[ee]}function ef(eh){T();d8[ee]=eh}cW.defineProperty(eg,ee,{get:ed,set:ef})}for(var ec in d8){if(typeof d8[ec]===\"function\"){eb(this,ec)}else{ea(this,ec)}}}function cC(){if(dV){return}cW.loadPixels();if(cn===null){aj=d8;cn=new cq}dV=true;d8=cn;d3=0}function bx(ea,ec,eb){if(ea<cW.width&&ea>=0&&ec>=0&&ec<cW.height){cC();cW.pixels.setPixel((0|ea)+cW.width*(0|ec),eb);if(++d3>bZ){T()}}}function bv(ea,eg,ed,eb){if(eb.isRemote){throw\"Image is loaded remotely. Cannot set x,y.\"}var ef=cW.color.toArray(ed);var ee=eg*eb.width*4+ea*4;var ec=eb.imageData.data;ec[ee]=ef[0];ec[ee+1]=ef[1];ec[ee+2]=ef[2];ec[ee+3]=ef[3]}cW.set=function(ea,ef,ed,ec){var eb,ee;if(arguments.length===3){if(typeof ed===\"number\"){bx(ea,ef,ed)}else{if(ed instanceof cG||ed.__isPImage){cW.image(ed,ea,ef)}}}else{if(arguments.length===4){bv(ea,ef,ed,ec)}}};cW.imageData={};cW.pixels={getLength:function(){return cW.imageData.data.length?cW.imageData.data.length/4:0},getPixel:function(ea){var ec=ea*4,eb=cW.imageData.data;return eb[ec+3]<<24&4278190080|eb[ec+0]<<16&16711680|eb[ec+1]<<8&65280|eb[ec+2]&255},setPixel:function(ea,ed){var ec=ea*4,eb=cW.imageData.data;eb[ec+0]=(ed&16711680)>>>16;eb[ec+1]=(ed&65280)>>>8;eb[ec+2]=ed&255;eb[ec+3]=(ed&4278190080)>>>24},toArray:function(){var ea=[],ec=cW.imageData.width*cW.imageData.height,ed=cW.imageData.data;for(var eb=0,ee=0;eb<ec;eb++,ee+=4){ea.push(ed[ee+3]<<24&4278190080|ed[ee+0]<<16&16711680|ed[ee+1]<<8&65280|ed[ee+2]&255)}return ea},set:function(ea){for(var eb=0,ec=ea.length;eb<ec;eb++){this.setPixel(eb,ea[eb])}}};cW.loadPixels=function(){cW.imageData=dY.$ensureContext().getImageData(0,0,cW.width,cW.height)};cW.updatePixels=function(){if(cW.imageData){dY.$ensureContext().putImageData(cW.imageData,0,0)}};cW.hint=function(eb){var ea=dY.$ensureContext();if(eb===4){ea.disable(ea.DEPTH_TEST);ea.depthMask(false);ea.clear(ea.DEPTH_BUFFER_BIT)}else{if(eb===-4){ea.enable(ea.DEPTH_TEST);ea.depthMask(true)}else{if(eb===-1||eb===2){dO=true}else{if(eb===1){dO=false}}}}};var bE=function(ed,ec,eb,ea){var ee;if(ed instanceof cG||ed.__isPImage){ee=ed;if(!ee.loaded){throw\"Error using image in background(): PImage not loaded.\"}if(ee.width!==cW.width||ee.height!==cW.height){throw\"Background image must be the same dimensions as the canvas.\"}}else{ee=cW.color(ed,ec,eb,ea)}a4=ee};bR.prototype.background=function(ed,ec,eb,ea){if(ed!==t){bE(ed,ec,eb,ea)}if(a4 instanceof cG||a4.__isPImage){aD();d8.setTransform(1,0,0,1,0,0);cW.image(a4,0,0);cP()}else{aD();d8.setTransform(1,0,0,1,0,0);if(cW.alpha(a4)!==bU){d8.clearRect(0,0,cW.width,cW.height)}d8.fillStyle=cW.color.toString(a4);d8.fillRect(0,0,cW.width,cW.height);aq=true;cP()}};bB.prototype.background=function(ed,ec,eb,ea){if(arguments.length>0){bE(ed,ec,eb,ea)}var ee=cW.color.toGLArray(a4);d8.clearColor(ee[0],ee[1],ee[2],ee[3]);d8.clear(d8.COLOR_BUFFER_BIT|d8.DEPTH_BUFFER_BIT)};bR.prototype.image=function(ed,ei,eg,ej,ee){ei=q.round(ei);eg=q.round(eg);if(ed.width>0){var ek=ej||ed.width;var eh=ee||ed.height;var ea=bk(ei||0,eg||0,ej||ed.width,ee||ed.height,arguments.length<4);var ef=!!ed.sourceImg&&bf===null;if(ef){var eb=ed.sourceImg;if(ed.__isDirty){ed.updatePixels()}d8.drawImage(eb,0,0,eb.width,eb.height,ea.x,ea.y,ea.w,ea.h)}else{var ec=ed.toImageData();if(bf!==null){bf(ec);ed.__isDirty=true}d8.drawImage(by(ec).canvas,0,0,ed.width,ed.height,ea.x,ea.y,ea.w,ea.h)}}};bB.prototype.image=function(ec,ea,ee,eb,ed){if(ec.width>0){ea=q.round(ea);ee=q.round(ee);eb=eb||ec.width;ed=ed||ec.height;cW.beginShape(cW.QUADS);cW.texture(ec);cW.vertex(ea,ee,0,0,0);cW.vertex(ea,ee+ed,0,0,ed);cW.vertex(ea+eb,ee+ed,0,eb,ed);cW.vertex(ea+eb,ee,0,eb,0);cW.endShape()}};cW.tint=function(ed,ec,ea,ei){var ef=cW.color(ed,ec,ea,ei);var eb=cW.red(ef)/bJ;var ee=cW.green(ef)/bI;var eg=cW.blue(ef)/bG;var eh=cW.alpha(ef)/bU;bf=function(em){var el=em.data,ek=4*em.width*em.height;for(var ej=0;ej<ek;){el[ej++]*=eb;el[ej++]*=ee;el[ej++]*=eg;el[ej++]*=eh}};bw=function(ek){for(var ej=0;ej<ek.length;){ek[ej++]=eb;ek[ej++]=ee;ek[ej++]=eg;ek[ej++]=eh}}};cW.noTint=function(){bf=null;bw=null};cW.copy=function(ea,ef,ee,eg,ec,ei,eh,eb,ed){if(ed===t){ed=eb;eb=eh;eh=ei;ei=ec;ec=eg;eg=ee;ee=ef;ef=ea;ea=cW}cW.blend(ea,ef,ee,eg,ec,ei,eh,eb,ed,0)};cW.blend=function(ea,ek,ej,en,ef,ep,eo,eb,eh,eg,ed){if(ea.isRemote){throw\"Image is loaded remotely. Cannot blend image.\"}if(eg===t){eg=eh;eh=eb;eb=eo;eo=ep;ep=ef;ef=en;en=ej;ej=ek;ek=ea;ea=cW}var ec=ek+en,ei=ej+ef,em=ep+eb,ee=eo+eh,el=ed||cW;if(ed===t||eg===t){cW.loadPixels()}ea.loadPixels();if(ea===cW&&cW.intersect(ek,ej,ec,ei,ep,eo,em,ee)){cW.blit_resize(cW.get(ek,ej,ec-ek,ei-ej),0,0,ec-ek-1,ei-ej-1,el.imageData.data,el.width,el.height,ep,eo,em,ee,eg)}else{cW.blit_resize(ea,ek,ej,ec,ei,el.imageData.data,el.width,el.height,ep,eo,em,ee,eg)}if(ed===t){cW.updatePixels()}};var bp=function(ee){var ea=cW.floor(ee*3.5),ec,eb;ea=ea<1?1:ea<248?ea:248;if(cW.shared.blurRadius!==ea){cW.shared.blurRadius=ea;cW.shared.blurKernelSize=1+(cW.shared.blurRadius<<1);cW.shared.blurKernel=new e(cW.shared.blurKernelSize);var eg=cW.shared.blurKernel;var ef=cW.shared.blurKernelSize;var ed=cW.shared.blurRadius;for(ec=0;ec<ef;ec++){eg[ec]=0}var eh=(ea-1)*(ea-1);for(ec=1;ec<ea;ec++){eg[ea+ec]=eg[eb]=eh}eg[ea]=ea*ea}};var b7=function(eo,et){var ec,ef,el,eq,er,eA,es;var ev,en,ez,ey,ep;var ei=et.pixels.getLength();var eu=new e(ei);var eD=new e(ei);var eh=new e(ei);var eC=new e(ei);var eB=0;var ek,ej,ex,ee;bp(eo);var eb=et.height;var ea=et.width;var ew=cW.shared.blurKernelSize;var em=cW.shared.blurRadius;var eg=cW.shared.blurKernel;var ed=et.imageData.data;for(ej=0;ej<eb;ej++){for(ek=0;ek<ea;ek++){eq=el=ef=er=ec=0;ev=ek-em;if(ev<0){ep=-ev;ev=0}else{if(ev>=ea){break}ep=0}for(ex=ep;ex<ew;ex++){if(ev>=ea){break}ee=(ev+eB)*4;es=eg[ex];er+=es*ed[ee+3];ef+=es*ed[ee];el+=es*ed[ee+1];eq+=es*ed[ee+2];ec+=es;ev++}en=eB+ek;eC[en]=er/ec;eu[en]=ef/ec;eD[en]=el/ec;eh[en]=eq/ec}eB+=ea}eB=0;ez=-em;ey=ez*ea;for(ej=0;ej<eb;ej++){for(ek=0;ek<ea;ek++){eq=el=ef=er=ec=0;if(ez<0){ep=en=-ez;ev=ek}else{if(ez>=eb){break}ep=0;en=ez;ev=ek+ey}for(ex=ep;ex<ew;ex++){if(en>=eb){break}es=eg[ex];er+=es*eC[ev];ef+=es*eu[ev];el+=es*eD[ev];eq+=es*eh[ev];ec+=es;en++;ev+=ea}ee=(ek+eB)*4;ed[ee]=ef/ec;ed[ee+1]=el/ec;ed[ee+2]=eq/ec;ed[ee+3]=er/ec}eB+=ea;ey+=ea;ez++}};var cf=function(er,el){var eh=0;var ev=el.pixels.getLength();var em=new K(ev);var ep,eb,ek,ej,ed;var eq,ee,eg,ei,ec,en,eu,ea,es,ef,et,eo;if(!er){while(eh<ev){ep=eh;eb=eh+el.width;while(eh<eb){ek=ej=el.pixels.getPixel(eh);ee=eh-1;eq=eh+1;eg=eh-el.width;ei=eh+el.width;if(ee<ep){ee=eh}if(eq>=eb){eq=eh}if(eg<0){eg=0}if(ei>=ev){ei=eh}eu=el.pixels.getPixel(eg);en=el.pixels.getPixel(ee);ea=el.pixels.getPixel(ei);ec=el.pixels.getPixel(eq);ed=77*(ek>>16&255)+151*(ek>>8&255)+28*(ek&255);ef=77*(en>>16&255)+151*(en>>8&255)+28*(en&255);es=77*(ec>>16&255)+151*(ec>>8&255)+28*(ec&255);et=77*(eu>>16&255)+151*(eu>>8&255)+28*(eu&255);eo=77*(ea>>16&255)+151*(ea>>8&255)+28*(ea&255);if(ef>ed){ej=en;ed=ef}if(es>ed){ej=ec;ed=es}if(et>ed){ej=eu;ed=et}if(eo>ed){ej=ea;ed=eo}em[eh++]=ej}}}else{while(eh<ev){ep=eh;eb=eh+el.width;while(eh<eb){ek=ej=el.pixels.getPixel(eh);ee=eh-1;eq=eh+1;eg=eh-el.width;ei=eh+el.width;if(ee<ep){ee=eh}if(eq>=eb){eq=eh}if(eg<0){eg=0}if(ei>=ev){ei=eh}eu=el.pixels.getPixel(eg);en=el.pixels.getPixel(ee);ea=el.pixels.getPixel(ei);ec=el.pixels.getPixel(eq);ed=77*(ek>>16&255)+151*(ek>>8&255)+28*(ek&255);ef=77*(en>>16&255)+151*(en>>8&255)+28*(en&255);es=77*(ec>>16&255)+151*(ec>>8&255)+28*(ec&255);et=77*(eu>>16&255)+151*(eu>>8&255)+28*(eu&255);eo=77*(ea>>16&255)+151*(ea>>8&255)+28*(ea&255);if(ef<ed){ej=en;ed=ef}if(es<ed){ej=ec;ed=es}if(et<ed){ej=eu;ed=et}if(eo<ed){ej=ea;ed=eo}em[eh++]=ej}}}el.pixels.set(em)};cW.filter=function(eh,eg,ed){var ek,ef,eb,ej;if(arguments.length===3){ed.loadPixels();ek=ed}else{cW.loadPixels();ek=cW}if(eg===t){eg=null}if(ek.isRemote){throw\"Image is loaded remotely. Cannot filter image.\"}var el=ek.pixels.getLength();switch(eh){case 11:var em=eg||1;b7(em,ek);break;case 12:if(ek.format===4){for(ej=0;ej<el;ej++){ef=255-ek.pixels.getPixel(ej);ek.pixels.setPixel(ej,4278190080|ef<<16|ef<<8|ef)}ek.format=1}else{for(ej=0;ej<el;ej++){ef=ek.pixels.getPixel(ej);eb=77*(ef>>16&255)+151*(ef>>8&255)+28*(ef&255)>>8;ek.pixels.setPixel(ej,ef&4278190080|eb<<16|eb<<8|eb)}}break;case 13:for(ej=0;ej<el;ej++){ek.pixels.setPixel(ej,ek.pixels.getPixel(ej)^16777215)}break;case 15:if(eg===null){throw\"Use filter(POSTERIZE, int levels) instead of filter(POSTERIZE)\"}var ep=cW.floor(eg);if(ep<2||ep>255){throw\"Levels must be between 2 and 255 for filter(POSTERIZE, levels)\"}var ei=ep-1;for(ej=0;ej<el;ej++){var ea=ek.pixels.getPixel(ej)>>16&255;var en=ek.pixels.getPixel(ej)>>8&255;var ec=ek.pixels.getPixel(ej)&255;ea=(ea*ep>>8)*255/ei;en=(en*ep>>8)*255/ei;ec=(ec*ep>>8)*255/ei;ek.pixels.setPixel(ej,4278190080&ek.pixels.getPixel(ej)|ea<<16|en<<8|ec)}break;case 14:for(ej=0;ej<el;ej++){ek.pixels.setPixel(ej,ek.pixels.getPixel(ej)|4278190080)}ek.format=1;break;case 16:if(eg===null){eg=0.5}if(eg<0||eg>1){throw\"Level must be between 0 and 1 for filter(THRESHOLD, level)\"}var ee=cW.floor(eg*255);for(ej=0;ej<el;ej++){var eo=cW.max((ek.pixels.getPixel(ej)&16711680)>>16,cW.max((ek.pixels.getPixel(ej)&65280)>>8,ek.pixels.getPixel(ej)&255));ek.pixels.setPixel(ej,ek.pixels.getPixel(ej)&4278190080|(eo<ee?0:16777215))}break;case 17:cf(true,ek);break;case 18:cf(false,ek);break}ek.updatePixels()};cW.shared={fracU:0,ifU:0,fracV:0,ifV:0,u1:0,u2:0,v1:0,v2:0,sX:0,sY:0,iw:0,iw1:0,ih1:0,ul:0,ll:0,ur:0,lr:0,cUL:0,cLL:0,cUR:0,cLR:0,srcXOffset:0,srcYOffset:0,r:0,g:0,b:0,a:0,srcBuffer:null,blurRadius:0,blurKernelSize:0,blurKernel:null};cW.intersect=function(ec,ej,eb,ei,en,eg,em,ef){var el=eb-ec+1;var ee=ei-ej+1;var ea=em-en+1;var eh=ef-eg+1;if(en<ec){ea+=en-ec;if(ea>el){ea=el}}else{var ek=el+ec-en;if(ea>ek){ea=ek}}if(eg<ej){eh+=eg-ej;if(eh>ee){eh=ee}}else{var ed=ee+ej-eg;if(eh>ed){eh=ed}}return !(ea<=0||eh<=0)};var dS={};dS[1]=cW.modes.blend;dS[2]=cW.modes.add;dS[4]=cW.modes.subtract;dS[8]=cW.modes.lightest;dS[16]=cW.modes.darkest;dS[0]=cW.modes.replace;dS[32]=cW.modes.difference;dS[64]=cW.modes.exclusion;dS[128]=cW.modes.multiply;dS[256]=cW.modes.screen;dS[512]=cW.modes.overlay;dS[1024]=cW.modes.hard_light;dS[2048]=cW.modes.soft_light;dS[4096]=cW.modes.dodge;dS[8192]=cW.modes.burn;cW.blit_resize=function(en,ez,et,ey,es,eE,ej,er,ex,eo,ew,em,ep){var eC,eB;if(ez<0){ez=0}if(et<0){et=0}if(ey>=en.width){ey=en.width-1}if(es>=en.height){es=en.height-1}var eI=ey-ez;var eN=es-et;var ea=ew-ex;var ek=em-eo;if(ea<=0||ek<=0||eI<=0||eN<=0||ex>=ej||eo>=er||ez>=en.width||et>=en.height){return}var eh=q.floor(eI/ea*32768);var ee=q.floor(eN/ek*32768);var eG=cW.shared;eG.srcXOffset=q.floor(ex<0?-ex*eh:ez*32768);eG.srcYOffset=q.floor(eo<0?-eo*ee:et*32768);if(ex<0){ea+=ex;ex=0}if(eo<0){ek+=eo;eo=0}ea=q.min(ea,ej-ex);ek=q.min(ek,er-eo);var eu=eo*ej+ex;var eQ;eG.srcBuffer=en.imageData.data;eG.iw=en.width;eG.iw1=en.width-1;eG.ih1=en.height-1;var ev=cW.filter_bilinear,eK=cW.filter_new_scanline,ei=dS[ep],eH,eM,eF,eJ,ec,ed,eb=4278190080,eL=16711680,eA=65280,eg=255,eP=32767,eD=15,el=1,eq=9,ef=eG.srcBuffer,eO=q.min;for(eB=0;eB<ek;eB++){eG.sX=eG.srcXOffset;eG.fracV=eG.srcYOffset&eP;eG.ifV=eP-eG.fracV;eG.v1=(eG.srcYOffset>>eD)*eG.iw;eG.v2=eO((eG.srcYOffset>>eD)+1,eG.ih1)*eG.iw;for(eC=0;eC<ea;eC++){eM=(eu+eC)*4;eQ=eE[eM+3]<<24&eb|eE[eM]<<16&eL|eE[eM+1]<<8&eA|eE[eM+2]&eg;eG.fracU=eG.sX&eP;eG.ifU=eP-eG.fracU;eG.ul=eG.ifU*eG.ifV>>eD;eG.ll=eG.ifU*eG.fracV>>eD;eG.ur=eG.fracU*eG.ifV>>eD;eG.lr=eG.fracU*eG.fracV>>eD;eG.u1=eG.sX>>eD;eG.u2=eO(eG.u1+1,eG.iw1);eF=(eG.v1+eG.u1)*4;eJ=(eG.v1+eG.u2)*4;ec=(eG.v2+eG.u1)*4;ed=(eG.v2+eG.u2)*4;eG.cUL=ef[eF+3]<<24&eb|ef[eF]<<16&eL|ef[eF+1]<<8&eA|ef[eF+2]&eg;eG.cUR=ef[eJ+3]<<24&eb|ef[eJ]<<16&eL|ef[eJ+1]<<8&eA|ef[eJ+2]&eg;eG.cLL=ef[ec+3]<<24&eb|ef[ec]<<16&eL|ef[ec+1]<<8&eA|ef[ec+2]&eg;eG.cLR=ef[ed+3]<<24&eb|ef[ed]<<16&eL|ef[ed+1]<<8&eA|ef[ed+2]&eg;eG.r=eG.ul*((eG.cUL&eL)>>16)+eG.ll*((eG.cLL&eL)>>16)+eG.ur*((eG.cUR&eL)>>16)+eG.lr*((eG.cLR&eL)>>16)<<el&eL;eG.g=eG.ul*(eG.cUL&eA)+eG.ll*(eG.cLL&eA)+eG.ur*(eG.cUR&eA)+eG.lr*(eG.cLR&eA)>>>eD&eA;eG.b=eG.ul*(eG.cUL&eg)+eG.ll*(eG.cLL&eg)+eG.ur*(eG.cUR&eg)+eG.lr*(eG.cLR&eg)>>>eD;eG.a=eG.ul*((eG.cUL&eb)>>>24)+eG.ll*((eG.cLL&eb)>>>24)+eG.ur*((eG.cUR&eb)>>>24)+eG.lr*((eG.cLR&eb)>>>24)<<eq&eb;eH=ei(eQ,eG.a|eG.r|eG.g|eG.b);eE[eM]=(eH&eL)>>>16;eE[eM+1]=(eH&eA)>>>8;eE[eM+2]=eH&eg;eE[eM+3]=(eH&eb)>>>24;eG.sX+=eh}eu+=ej;eG.srcYOffset+=ee}};cW.loadFont=function(eb,ec){if(eb===t){throw\"font name required in loadFont.\"}if(eb.indexOf(\".svg\")===-1){if(ec===t){ec=W.size}return H.get(eb,ec)}var ea=cW.loadGlyphs(eb);return{name:eb,css:\"12px sans-serif\",glyph:true,units_per_em:ea.units_per_em,horiz_adv_x:1/ea.units_per_em*ea.horiz_adv_x,ascent:ea.ascent,descent:ea.descent,width:function(eh){var ef=0;var ed=eh.length;for(var ee=0;ee<ed;ee++){try{ef+=parseFloat(cW.glyphLook(cW.glyphTable[eb],eh[ee]).horiz_adv_x)}catch(eg){F.debug(eg)}}return ef/cW.glyphTable[eb].units_per_em}}};cW.createFont=function(ea,eb){return cW.loadFont(ea,eb)};cW.textFont=function(ea,ec){if(ec!==t){if(!ea.glyph){ea=H.get(ea.name,ec)}d0=ec}W=ea;Y=W.name;a3=W.ascent;dA=W.descent;d7=W.leading;var eb=dY.$ensureContext();eb.font=W.css};cW.textSize=function(eb){W=H.get(Y,eb);d0=eb;a3=W.ascent;dA=W.descent;d7=W.leading;var ea=dY.$ensureContext();ea.font=W.css};cW.textAscent=function(){return a3};cW.textDescent=function(){return dA};cW.textLeading=function(ea){d7=ea};cW.textAlign=function(eb,ea){N=eb;c1=ea||0};function bu(ea){if(ea instanceof String){return ea}if(typeof ea===\"number\"){if(ea===(0|ea)){return ea.toString()}return cW.nf(ea,0,3)}if(ea===null||ea===t){return\"\"}return ea.toString()}bR.prototype.textWidth=function(ee){var ea=bu(ee).split(/\\r?\\n/g),ec=0;var eb,ed=ea.length;d8.font=W.css;for(eb=0;eb<ed;++eb){ec=q.max(ec,W.measureTextWidth(ea[eb]))}return ec|0};bB.prototype.textWidth=function(ef){var ea=bu(ef).split(/\\r?\\n/g),ed=0;var ec,ee=ea.length;if(cE===t){cE=d.createElement(\"canvas\")}var eb=cE.getContext(\"2d\");eb.font=W.css;for(ec=0;ec<ee;++ec){ed=q.max(ed,eb.measureText(ea[ec]).width)}return ed|0};cW.glyphLook=function(ea,eb){try{switch(eb){case\"1\":return ea.one;case\"2\":return ea.two;case\"3\":return ea.three;case\"4\":return ea.four;case\"5\":return ea.five;case\"6\":return ea.six;case\"7\":return ea.seven;case\"8\":return ea.eight;case\"9\":return ea.nine;case\"0\":return ea.zero;case\" \":return ea.space;case\"$\":return ea.dollar;case\"!\":return ea.exclam;case'\"':return ea.quotedbl;case\"#\":return ea.numbersign;case\"%\":return ea.percent;case\"&\":return ea.ampersand;case\"'\":return ea.quotesingle;case\"(\":return ea.parenleft;case\")\":return ea.parenright;case\"*\":return ea.asterisk;case\"+\":return ea.plus;case\",\":return ea.comma;case\"-\":return ea.hyphen;case\".\":return ea.period;case\"/\":return ea.slash;case\"_\":return ea.underscore;case\":\":return ea.colon;case\";\":return ea.semicolon;case\"<\":return ea.less;case\"=\":return ea.equal;case\">\":return ea.greater;case\"?\":return ea.question;case\"@\":return ea.at;case\"[\":return ea.bracketleft;case\"\\\\\":return ea.backslash;case\"]\":return ea.bracketright;case\"^\":return ea.asciicircum;case\"`\":return ea.grave;case\"{\":return ea.braceleft;case\"|\":return ea.bar;case\"}\":return ea.braceright;case\"~\":return ea.asciitilde;default:return ea[eb]}}catch(ec){F.debug(ec)}};bR.prototype.text$line=function(ei,el,ek,ej,ef){var eh=0,eg=0;if(!W.glyph){if(ei&&\"fillText\" in d8){if(aq){d8.fillStyle=cW.color.toString(a1);aq=false}if(ef===39||ef===3){eh=W.measureTextWidth(ei);if(ef===39){eg=-eh}else{eg=-eh/2}}d8.fillText(ei,el+eg,ek)}}else{var ea=cW.glyphTable[Y];aD();d8.translate(el,ek+d0);if(ef===39||ef===3){eh=ea.width(ei);if(ef===39){eg=-eh}else{eg=-eh/2}}var em=ea.units_per_em,ee=1/em*d0;d8.scale(ee,ee);for(var eb=0,ec=ei.length;eb<ec;eb++){try{cW.glyphLook(ea,ei[eb]).draw()}catch(ed){F.debug(ed)}}cP()}};bB.prototype.text$line=function(eh,el,ek,ei,ef){if(cE===t){cE=d.createElement(\"canvas\")}var eb=d8;d8=cE.getContext(\"2d\");d8.font=W.css;var eg=W.measureTextWidth(eh);cE.width=eg;cE.height=d0;d8=cE.getContext(\"2d\");d8.font=W.css;d8.textBaseline=\"top\";bR.prototype.text$line(eh,0,0,0,37);var ea=cE.width/cE.height;d8=eb;d8.bindTexture(d8.TEXTURE_2D,bS);d8.texImage2D(d8.TEXTURE_2D,0,d8.RGBA,d8.RGBA,d8.UNSIGNED_BYTE,cE);d8.texParameteri(d8.TEXTURE_2D,d8.TEXTURE_MAG_FILTER,d8.LINEAR);d8.texParameteri(d8.TEXTURE_2D,d8.TEXTURE_MIN_FILTER,d8.LINEAR);d8.texParameteri(d8.TEXTURE_2D,d8.TEXTURE_WRAP_T,d8.CLAMP_TO_EDGE);d8.texParameteri(d8.TEXTURE_2D,d8.TEXTURE_WRAP_S,d8.CLAMP_TO_EDGE);var ee=0;if(ef===39){ee=-eg}else{if(ef===3){ee=-eg/2}}var ec=new aP;var ed=d0*0.5;ec.translate(el+ee-ed/2,ek-ed,ei);ec.scale(-ea*ed,-ed,ed);ec.translate(-1,-1,-1);ec.transpose();var ej=new aP;ej.scale(1,-1,1);ej.apply(dJ.array());ej.transpose();d8.useProgram(dQ);dc(\"aVertex2d\",dQ,\"aVertex\",3,cH);dc(\"aTextureCoord2d\",dQ,\"aTextureCoord\",2,ac);dZ(\"uSampler2d\",dQ,\"uSampler\",[0]);dZ(\"uIsDrawingText2d\",dQ,\"uIsDrawingText\",true);a9(\"uModel2d\",dQ,\"uModel\",false,ec.array());a9(\"uView2d\",dQ,\"uView\",false,ej.array());d2(\"uColor2d\",dQ,\"uColor\",bo);d8.bindBuffer(d8.ELEMENT_ARRAY_BUFFER,R);d8.drawElements(d8.TRIANGLES,6,d8.UNSIGNED_SHORT,0)};function bi(ed,eg,ef,ee){var ei,ec;if(ed.indexOf(\"\\n\")<0){ei=[ed];ec=1}else{ei=ed.split(/\\r?\\n/g);ec=ei.length}var ea=0;if(c1===101){ea=a3+dA}else{if(c1===3){ea=a3/2-(ec-1)*d7/2}else{if(c1===102){ea=-(dA+(ec-1)*d7)}}}for(var eb=0;eb<ec;++eb){var eh=ei[eb];dY.text$line(eh,eg,ef+ea,ee,N);ea+=d7}}function bd(eq,el,ek,ep,en,ej){if(eq.length===0||ep===0||en===0){return}if(d0>en){return}var em=-1;var ee=0;var ea=0;var eg=[];for(var ef=0,es=eq.length;ef<es;ef++){var eh=eq[ef];var ev=eh===\" \";var eo=W.measureTextWidth(eh);if(eh!==\"\\n\"&&ea+eo<=ep){if(ev){em=ef}ea+=eo}else{if(em+1===ee){if(ef>0){em=ef}else{return}}if(eh===\"\\n\"){eg.push({text:eq.substring(ee,ef),width:ea});ee=ef+1}else{eg.push({text:eq.substring(ee,em+1),width:ea});ee=em+1}ea=0;ef=ee-1}}if(ee<es){eg.push({text:eq.substring(ee),width:ea})}var eu=1,ei=a3;if(N===3){eu=ep/2}else{if(N===39){eu=ep}}var er=eg.length,eb=q.min(er,q.floor(en/d7));if(c1===101){ei=a3+dA}else{if(c1===3){ei=en/2-d7*(eb/2-1)}else{if(c1===102){ei=dA+d7}}}var ec,ed,et;for(ec=0;ec<er;ec++){et=ec*d7;if(ei+et>en-dA){break}ed=eg[ec];dY.text$line(ed.text,el+eu,ek+ei+et,ej,N)}}cW.text=function(){if(cI===5){return}if(arguments.length===3){bi(bu(arguments[0]),arguments[1],arguments[2],0)}else{if(arguments.length===4){bi(bu(arguments[0]),arguments[1],arguments[2],arguments[3])}else{if(arguments.length===5){bd(bu(arguments[0]),arguments[1],arguments[2],arguments[3],arguments[4],0)}else{if(arguments.length===6){bd(bu(arguments[0]),arguments[1],arguments[2],arguments[3],arguments[4],arguments[5])}}}}};cW.textMode=function(ea){cI=ea};cW.loadGlyphs=function(eg){var ei,eh,ee,ec,ep,eo,en,eq,ek,er,el,em=\"[0-9\\\\-]+\",ej;var ef=function(ex,ew){var eu=0,et=[],es,ev=new RegExp(ex,\"g\");es=et[eu]=ev.exec(ew);while(es){eu++;es=et[eu]=ev.exec(ew)}return et};var eb=function(ex){var ey=ef(\"[A-Za-z][0-9\\\\- ]+|Z\",ex);var ew=function(){aD();return dY.$ensureContext()};var eu=function(){bn();dd();cP()};ej=\"return {draw:function(){var curContext=beforePathDraw();curContext.beginPath();\";ei=0;eh=0;ee=0;ec=0;ep=0;eo=0;ex=0;eq=0;ek=\"\";er=ey.length-1;for(var et=0;et<er;et++){var es=ey[et][0],ev=ef(em,es);switch(es[0]){case\"M\":ei=parseFloat(ev[0][0]);eh=parseFloat(ev[1][0]);ej+=\"curContext.moveTo(\"+ei+\",\"+-eh+\");\";break;case\"L\":ei=parseFloat(ev[0][0]);eh=parseFloat(ev[1][0]);ej+=\"curContext.lineTo(\"+ei+\",\"+-eh+\");\";break;case\"H\":ei=parseFloat(ev[0][0]);ej+=\"curContext.lineTo(\"+ei+\",\"+-eh+\");\";break;case\"V\":eh=parseFloat(ev[0][0]);ej+=\"curContext.lineTo(\"+ei+\",\"+-eh+\");\";break;case\"T\":ep=parseFloat(ev[0][0]);eo=parseFloat(ev[1][0]);if(ek===\"Q\"||ek===\"T\"){ex=q.sqrt(q.pow(ei-ee,2)+q.pow(ec-eh,2));eq=q.PI+q.atan2(ee-ei,ec-eh);ee=ei+q.sin(eq)*ex;ec=eh+q.cos(eq)*ex}else{ee=ei;ec=eh}ej+=\"curContext.quadraticCurveTo(\"+ee+\",\"+-ec+\",\"+ep+\",\"+-eo+\");\";ei=ep;eh=eo;break;case\"Q\":ee=parseFloat(ev[0][0]);ec=parseFloat(ev[1][0]);ep=parseFloat(ev[2][0]);eo=parseFloat(ev[3][0]);ej+=\"curContext.quadraticCurveTo(\"+ee+\",\"+-ec+\",\"+ep+\",\"+-eo+\");\";ei=ep;eh=eo;break;case\"Z\":ej+=\"curContext.closePath();\";break}ek=es[0]}ej+=\"afterPathDraw();\";ej+=\"curContext.translate(\"+el+\",0);\";ej+=\"}}\";return(new Function(\"beforePathDraw\",\"afterPathDraw\",ej))(ew,eu)};var ea=function(ev){var eu=ev.getElementsByTagName(\"font\");cW.glyphTable[eg].horiz_adv_x=eu[0].getAttribute(\"horiz-adv-x\");var ex=ev.getElementsByTagName(\"font-face\")[0];cW.glyphTable[eg].units_per_em=parseFloat(ex.getAttribute(\"units-per-em\"));cW.glyphTable[eg].ascent=parseFloat(ex.getAttribute(\"ascent\"));cW.glyphTable[eg].descent=parseFloat(ex.getAttribute(\"descent\"));var ez=ev.getElementsByTagName(\"glyph\"),et=ez.length;for(var ey=0;ey<et;ey++){var es=ez[ey].getAttribute(\"unicode\");var ew=ez[ey].getAttribute(\"glyph-name\");el=ez[ey].getAttribute(\"horiz-adv-x\");if(el===null){el=cW.glyphTable[eg].horiz_adv_x}en=ez[ey].getAttribute(\"d\");if(en!==t){ej=eb(en);cW.glyphTable[eg][ew]={name:ew,unicode:es,horiz_adv_x:el,draw:ej.draw}}}};var ed=function(){var eu;try{eu=d.implementation.createDocument(\"\",\"\",null)}catch(ew){F.debug(ew.message);return}try{eu.async=false;eu.load(eg);ea(eu.getElementsByTagName(\"svg\")[0])}catch(et){F.debug(et);try{var es=new D.XMLHttpRequest;es.open(\"GET\",eg,false);es.send(null);ea(es.responseXML.documentElement)}catch(ev){F.debug(et)}}};cW.glyphTable[eg]={};ed(eg);return cW.glyphTable[eg]};cW.param=function(ec){var eb=\"data-processing-\"+ec;if(ae.hasAttribute(eb)){return ae.getAttribute(eb)}for(var ed=0,ea=ae.childNodes.length;ed<ea;++ed){var ee=ae.childNodes.item(ed);if(ee.nodeType!==1||ee.tagName.toLowerCase()!==\"param\"){continue}if(ee.getAttribute(\"name\")===ec){return ee.getAttribute(\"value\")}}if(cQ.params.hasOwnProperty(ec)){return cQ.params[ec]}return null};function cL(eb){if(eb===\"3D\"){dY=new bB}else{if(eb===\"2D\"){dY=new bR}else{dY=new ca}}for(var ea in ca.prototype){if(ca.prototype.hasOwnProperty(ea)&&ea.indexOf(\"$\")<0){cW[ea]=dY[ea]}}dY.$init()}function cU(ea){return function(){cL(\"2D\");return dY[ea].apply(this,arguments)}}ca.prototype.translate=cU(\"translate\");ca.prototype.transform=cU(\"transform\");ca.prototype.scale=cU(\"scale\");ca.prototype.pushMatrix=cU(\"pushMatrix\");ca.prototype.popMatrix=cU(\"popMatrix\");ca.prototype.resetMatrix=cU(\"resetMatrix\");ca.prototype.applyMatrix=cU(\"applyMatrix\");ca.prototype.rotate=cU(\"rotate\");ca.prototype.rotateZ=cU(\"rotateZ\");ca.prototype.shearX=cU(\"shearX\");ca.prototype.shearY=cU(\"shearY\");ca.prototype.redraw=cU(\"redraw\");ca.prototype.toImageData=cU(\"toImageData\");ca.prototype.ambientLight=cU(\"ambientLight\");ca.prototype.directionalLight=cU(\"directionalLight\");ca.prototype.lightFalloff=cU(\"lightFalloff\");ca.prototype.lightSpecular=cU(\"lightSpecular\");ca.prototype.pointLight=cU(\"pointLight\");ca.prototype.noLights=cU(\"noLights\");ca.prototype.spotLight=cU(\"spotLight\");ca.prototype.beginCamera=cU(\"beginCamera\");ca.prototype.endCamera=cU(\"endCamera\");ca.prototype.frustum=cU(\"frustum\");ca.prototype.box=cU(\"box\");ca.prototype.sphere=cU(\"sphere\");ca.prototype.ambient=cU(\"ambient\");ca.prototype.emissive=cU(\"emissive\");ca.prototype.shininess=cU(\"shininess\");ca.prototype.specular=cU(\"specular\");ca.prototype.fill=cU(\"fill\");ca.prototype.stroke=cU(\"stroke\");ca.prototype.strokeWeight=cU(\"strokeWeight\");ca.prototype.smooth=cU(\"smooth\");ca.prototype.noSmooth=cU(\"noSmooth\");ca.prototype.point=cU(\"point\");ca.prototype.vertex=cU(\"vertex\");ca.prototype.endShape=cU(\"endShape\");ca.prototype.bezierVertex=cU(\"bezierVertex\");ca.prototype.curveVertex=cU(\"curveVertex\");ca.prototype.curve=cU(\"curve\");ca.prototype.line=cU(\"line\");ca.prototype.bezier=cU(\"bezier\");ca.prototype.rect=cU(\"rect\");ca.prototype.ellipse=cU(\"ellipse\");ca.prototype.background=cU(\"background\");ca.prototype.image=cU(\"image\");ca.prototype.textWidth=cU(\"textWidth\");ca.prototype.text$line=cU(\"text$line\");ca.prototype.$ensureContext=cU(\"$ensureContext\");ca.prototype.$newPMatrix=cU(\"$newPMatrix\");ca.prototype.size=function(ea,ec,eb){cL(eb===2?\"3D\":\"2D\");cW.size(ea,ec,eb)};ca.prototype.$init=G;bR.prototype.$init=function(){cW.size(cW.width,cW.height);d8.lineCap=\"round\";cW.noSmooth();cW.disableContextMenu()};bB.prototype.$init=function(){cW.use3DContext=true;cW.disableContextMenu()};ds.prototype.$ensureContext=function(){return d8};function dy(eb,ed){var ec=eb,ea=0,ee=0;cW.pmouseX=cW.mouseX;cW.pmouseY=cW.mouseY;if(ec.offsetParent){do{ea+=ec.offsetLeft;ee+=ec.offsetTop}while(!!(ec=ec.offsetParent))}ec=eb;do{ea-=ec.scrollLeft||0;ee-=ec.scrollTop||0}while(!!(ec=ec.parentNode));ea+=ad;ee+=dp;ea+=aU;ee+=bX;ea+=D.pageXOffset;ee+=D.pageYOffset;return{X:ea,Y:ee}}function aI(ea,eb){var ec=dy(ea,eb);cW.mouseX=eb.pageX-ec.X;cW.mouseY=eb.pageY-ec.Y}function cu(eb){var ed=dy(eb.changedTouches[0].target,eb.changedTouches[0]),ea;for(ea=0;ea<eb.touches.length;ea++){var ef=eb.touches[ea];ef.offsetX=ef.pageX-ed.X;ef.offsetY=ef.pageY-ed.Y}for(ea=0;ea<eb.targetTouches.length;ea++){var ec=eb.targetTouches[ea];ec.offsetX=ec.pageX-ed.X;ec.offsetY=ec.pageY-ed.Y}for(ea=0;ea<eb.changedTouches.length;ea++){var ee=eb.changedTouches[ea];ee.offsetX=ee.pageX-ed.X;ee.offsetY=ee.pageY-ed.Y}return eb}bO(ae,\"touchstart\",function(ec){ae.setAttribute(\"style\",\"-webkit-user-select: none\");ae.setAttribute(\"onclick\",\"void(0)\");ae.setAttribute(\"style\",\"-webkit-tap-highlight-color:rgba(0,0,0,0)\");for(var eb=0,ea=au.length;eb<ea;eb++){var ed=au[eb].type;if(ed===\"mouseout\"||ed===\"mousemove\"||ed===\"mousedown\"||ed===\"mouseup\"||ed===\"DOMMouseScroll\"||ed===\"mousewheel\"||ed===\"touchstart\"){de(au[eb])}}if(cW.touchStart!==t||cW.touchMove!==t||cW.touchEnd!==t||cW.touchCancel!==t){bO(ae,\"touchstart\",function(ee){if(cW.touchStart!==t){ee=cu(ee);cW.touchStart(ee)}});bO(ae,\"touchmove\",function(ee){if(cW.touchMove!==t){ee.preventDefault();ee=cu(ee);cW.touchMove(ee)}});bO(ae,\"touchend\",function(ee){if(cW.touchEnd!==t){ee=cu(ee);cW.touchEnd(ee)}});bO(ae,\"touchcancel\",function(ee){if(cW.touchCancel!==t){ee=cu(ee);cW.touchCancel(ee)}})}else{bO(ae,\"touchstart\",function(ee){aI(ae,ee.touches[0]);cW.__mousePressed=true;cW.mouseDragging=false;cW.mouseButton=37;if(typeof cW.mousePressed===\"function\"){cW.mousePressed()}});bO(ae,\"touchmove\",function(ee){ee.preventDefault();aI(ae,ee.touches[0]);if(typeof cW.mouseMoved===\"function\"&&!cW.__mousePressed){cW.mouseMoved()}if(typeof cW.mouseDragged===\"function\"&&cW.__mousePressed){cW.mouseDragged();cW.mouseDragging=true}});bO(ae,\"touchend\",function(ee){cW.__mousePressed=false;if(typeof cW.mouseClicked===\"function\"&&!cW.mouseDragging){cW.mouseClicked()}if(typeof cW.mouseReleased===\"function\"){cW.mouseReleased()}})}ae.dispatchEvent(ec)});(function(){var ea=true,eb=function(ec){ec.preventDefault();ec.stopPropagation()};cW.disableContextMenu=function(){if(!ea){return}bO(ae,\"contextmenu\",eb);ea=false};cW.enableContextMenu=function(){if(ea){return}de({elem:ae,type:\"contextmenu\",fn:eb});ea=true}})();bO(ae,\"mousemove\",function(ea){aI(ae,ea);if(typeof cW.mouseMoved===\"function\"&&!cW.__mousePressed){cW.mouseMoved()}if(typeof cW.mouseDragged===\"function\"&&cW.__mousePressed){cW.mouseDragged();cW.mouseDragging=true}});bO(ae,\"mouseout\",function(ea){if(typeof cW.mouseOut===\"function\"){cW.mouseOut()}});bO(ae,\"mouseover\",function(ea){aI(ae,ea);if(typeof cW.mouseOver===\"function\"){cW.mouseOver()}});ae.onmousedown=function(){ae.focus();return false};bO(ae,\"mousedown\",function(ea){cW.__mousePressed=true;cW.mouseDragging=false;switch(ea.which){case 1:cW.mouseButton=37;break;case 2:cW.mouseButton=3;break;case 3:cW.mouseButton=39;break}if(typeof cW.mousePressed===\"function\"){cW.mousePressed()}});bO(ae,\"mouseup\",function(ea){cW.__mousePressed=false;if(typeof cW.mouseClicked===\"function\"&&!cW.mouseDragging){cW.mouseClicked()}if(typeof cW.mouseReleased===\"function\"){cW.mouseReleased()}});var an=function(ea){var eb=0;if(ea.wheelDelta){eb=ea.wheelDelta/120;if(D.opera){eb=-eb}}else{if(ea.detail){eb=-ea.detail/3}}cW.mouseScroll=eb;if(eb&&typeof cW.mouseScrolled===\"function\"){cW.mouseScrolled()}};bO(d,\"DOMMouseScroll\",an);bO(d,\"mousewheel\",an);if(!ae.getAttribute(\"tabindex\")){ae.setAttribute(\"tabindex\",0)}function dD(eb){var ea=eb.which||eb.keyCode;switch(ea){case 13:return 10;case 91:case 93:case 224:return 157;case 57392:return 17;case 46:return 127;case 45:return 155}return ea}function cB(eb){var ec=eb.which||eb.keyCode;var ea=eb.shiftKey||eb.ctrlKey||eb.altKey||eb.metaKey;switch(ec){case 13:ec=ea?13:10;break;case 8:ec=ea?127:8;break}return new bP(ec)}function cR(ea){if(typeof ea.preventDefault===\"function\"){ea.preventDefault()}else{if(typeof ea.stopPropagation===\"function\"){ea.stopPropagation()}}return false}function dG(){var ea;for(ea in ag){if(ag.hasOwnProperty(ea)){cW.__keyPressed=true;return}}cW.__keyPressed=false}function cx(){cW.__keyPressed=false;ag=[];dI=null}function bq(ea,eb){ag[ea]=eb;dI=null;cW.key=eb;cW.keyCode=ea;cW.keyPressed();cW.keyCode=0;cW.keyTyped();dG()}function cz(eb){var ea=dD(eb);if(ea===127){bq(ea,new bP(127));return}if(dX.indexOf(ea)<0){dI=ea;return}var ec=new bP(65535);cW.key=ec;cW.keyCode=ea;ag[ea]=ec;cW.keyPressed();dI=null;dG();return cR(eb)}function dv(eb){if(dI===null){return}var ea=dI,ec=cB(eb);bq(ea,ec);return cR(eb)}function cp(eb){var ea=dD(eb),ec=ag[ea];if(ec===t){return}cW.key=ec;cW.keyCode=ea;cW.keyReleased();delete ag[ea];dG()}if(!cV){if(ba instanceof F.Sketch){cQ=ba}else{if(typeof ba===\"function\"){cQ=new F.Sketch(ba)}else{if(!ba){cQ=new F.Sketch(function(){})}else{cQ=F.compile(ba)}}}cW.externals.sketch=cQ;cL();ae.onfocus=function(){cW.focused=true};ae.onblur=function(){cW.focused=false;if(!cQ.options.globalKeyEvents){cx()}};if(cQ.options.pauseOnBlur){bO(D,\"focus\",function(){if(aC){cW.loop()}});bO(D,\"blur\",function(){if(aC&&ax){cW.noLoop();aC=true}cx()})}var aV=cQ.options.globalKeyEvents?D:ae;bO(aV,\"keydown\",cz);bO(aV,\"keypress\",dv);bO(aV,\"keyup\",cp);for(var c4 in F.lib){if(F.lib.hasOwnProperty(c4)){if(F.lib[c4].hasOwnProperty(\"attach\")){F.lib[c4].attach(cW)}else{if(F.lib[c4] instanceof Function){F.lib[c4].call(this)}}}}var dB=100;var b6=function(ed){if(!(cQ.imageCache.pending||H.preloading.pending(dB))){if(D.opera){var ec,eb,ea=cQ.imageCache.operaCache;for(ec in ea){if(ea.hasOwnProperty(ec)){eb=ea[ec];if(eb!==null){d.body.removeChild(eb)}delete ea[ec]}}}cQ.attach(ed,g);cQ.onLoad(ed);if(ed.setup){ed.setup();ed.resetMatrix();cQ.onSetup()}T();if(ed.draw){if(!aC){ed.redraw()}else{ed.loop()}}}else{D.setTimeout(function(){b6(ed)},dB)}};a(this);b6(cW)}else{cQ=new F.Sketch;cL();cW.size=function(ea,ec,eb){if(eb&&eb===2){cL(\"3D\")}else{cL(\"2D\")}cW.size(ea,ec,eb)}}};F.debug=s;F.prototype=g;function u(){var R=[\"abs\",\"acos\",\"alpha\",\"ambient\",\"ambientLight\",\"append\",\"applyMatrix\",\"arc\",\"arrayCopy\",\"asin\",\"atan\",\"atan2\",\"background\",\"beginCamera\",\"beginDraw\",\"beginShape\",\"bezier\",\"bezierDetail\",\"bezierPoint\",\"bezierTangent\",\"bezierVertex\",\"binary\",\"blend\",\"blendColor\",\"blit_resize\",\"blue\",\"box\",\"breakShape\",\"brightness\",\"camera\",\"ceil\",\"Character\",\"color\",\"colorMode\",\"concat\",\"constrain\",\"copy\",\"cos\",\"createFont\",\"createGraphics\",\"createImage\",\"cursor\",\"curve\",\"curveDetail\",\"curvePoint\",\"curveTangent\",\"curveTightness\",\"curveVertex\",\"day\",\"degrees\",\"directionalLight\",\"disableContextMenu\",\"dist\",\"draw\",\"ellipse\",\"ellipseMode\",\"emissive\",\"enableContextMenu\",\"endCamera\",\"endDraw\",\"endShape\",\"exit\",\"exp\",\"expand\",\"externals\",\"fill\",\"filter\",\"floor\",\"focused\",\"frameCount\",\"frameRate\",\"frustum\",\"get\",\"glyphLook\",\"glyphTable\",\"green\",\"height\",\"hex\",\"hint\",\"hour\",\"hue\",\"image\",\"imageMode\",\"intersect\",\"join\",\"key\",\"keyCode\",\"keyPressed\",\"keyReleased\",\"keyTyped\",\"lerp\",\"lerpColor\",\"lightFalloff\",\"lights\",\"lightSpecular\",\"line\",\"link\",\"loadBytes\",\"loadFont\",\"loadGlyphs\",\"loadImage\",\"loadPixels\",\"loadShape\",\"loadXML\",\"loadStrings\",\"log\",\"loop\",\"mag\",\"map\",\"match\",\"matchAll\",\"max\",\"millis\",\"min\",\"minute\",\"mix\",\"modelX\",\"modelY\",\"modelZ\",\"modes\",\"month\",\"mouseButton\",\"mouseClicked\",\"mouseDragged\",\"mouseMoved\",\"mouseOut\",\"mouseOver\",\"mousePressed\",\"mouseReleased\",\"mouseScroll\",\"mouseScrolled\",\"mouseX\",\"mouseY\",\"name\",\"nf\",\"nfc\",\"nfp\",\"nfs\",\"noCursor\",\"noFill\",\"noise\",\"noiseDetail\",\"noiseSeed\",\"noLights\",\"noLoop\",\"norm\",\"normal\",\"noSmooth\",\"noStroke\",\"noTint\",\"ortho\",\"param\",\"parseBoolean\",\"parseByte\",\"parseChar\",\"parseFloat\",\"parseInt\",\"peg\",\"perspective\",\"PImage\",\"pixels\",\"PMatrix2D\",\"PMatrix3D\",\"PMatrixStack\",\"pmouseX\",\"pmouseY\",\"point\",\"pointLight\",\"popMatrix\",\"popStyle\",\"pow\",\"print\",\"printCamera\",\"println\",\"printMatrix\",\"printProjection\",\"PShape\",\"PShapeSVG\",\"pushMatrix\",\"pushStyle\",\"quad\",\"radians\",\"random\",\"Random\",\"randomSeed\",\"rect\",\"rectMode\",\"red\",\"redraw\",\"requestImage\",\"resetMatrix\",\"reverse\",\"rotate\",\"rotateX\",\"rotateY\",\"rotateZ\",\"round\",\"saturation\",\"save\",\"saveFrame\",\"saveStrings\",\"scale\",\"screenX\",\"screenY\",\"screenZ\",\"second\",\"set\",\"setup\",\"shape\",\"shapeMode\",\"shared\",\"shearX\",\"shearY\",\"shininess\",\"shorten\",\"sin\",\"size\",\"smooth\",\"sort\",\"specular\",\"sphere\",\"sphereDetail\",\"splice\",\"split\",\"splitTokens\",\"spotLight\",\"sq\",\"sqrt\",\"status\",\"str\",\"stroke\",\"strokeCap\",\"strokeJoin\",\"strokeWeight\",\"subset\",\"tan\",\"text\",\"textAlign\",\"textAscent\",\"textDescent\",\"textFont\",\"textLeading\",\"textMode\",\"textSize\",\"texture\",\"textureMode\",\"textWidth\",\"tint\",\"toImageData\",\"touchCancel\",\"touchEnd\",\"touchMove\",\"touchStart\",\"translate\",\"transform\",\"triangle\",\"trim\",\"unbinary\",\"unhex\",\"updatePixels\",\"use3DContext\",\"vertex\",\"width\",\"XMLElement\",\"XML\",\"year\",\"__contains\",\"__equals\",\"__equalsIgnoreCase\",\"__frameRate\",\"__hashCode\",\"__int_cast\",\"__instanceof\",\"__keyPressed\",\"__mousePressed\",\"__printStackTrace\",\"__replace\",\"__replaceAll\",\"__replaceFirst\",\"__toCharArray\",\"__split\",\"__codePointAt\",\"__startsWith\",\"__endsWith\",\"__matches\"];var P={};var Q,O;for(Q=0,O=R.length;Q<O;++Q){P[R[Q]]=null}for(var S in F.lib){if(F.lib.hasOwnProperty(S)){if(F.lib[S].exports){var N=F.lib[S].exports;for(Q=0,O=N.length;Q<O;++Q){P[N[Q]]=null}}}}return P}function c(ar){var aX=u();function aE(bq){var bt=[];var bv=bq.split(/([\\{\\[\\(\\)\\]\\}])/);var by=bv[0];var bw=[];for(var bs=1;bs<bv.length;bs+=2){var bx=bv[bs];if(bx===\"[\"||bx===\"{\"||bx===\"(\"){bw.push(by);by=bx}else{if(bx===\"]\"||bx===\"}\"||bx===\")\"){var br=bx===\"}\"?\"A\":bx===\")\"?\"B\":\"C\";var bu=bt.length;bt.push(by+bx);by=bw.pop()+'\"'+br+(bu+1)+'\"'}}by+=bv[bs+1]}bt.unshift(by);return bt}function aj(br,bq){return br.replace(/'(\\d+)'/g,function(bt,bs){var bu=bq[bs];if(bu.charAt(0)===\"/\"){return bu}return/^'((?:[^'\\\\\\n])|(?:\\\\.[0-9A-Fa-f]*))'$/.test(bu)?\"(new $p.Character(\"+bu+\"))\":bu})}function aP(bt){var bs=/^\\s*/.exec(bt),bq;if(bs[0].length===bt.length){bq={left:bs[0],middle:\"\",right:\"\"}}else{var br=/\\s*$/.exec(bt);bq={left:bs[0],middle:bt.substring(bs[0].length,br.index),right:br[0]}}bq.untrim=function(bu){return this.left+bu+this.right};return bq}function a6(bq){return bq.replace(/^\\s+/,\"\").replace(/\\s+$/,\"\")}function av(bs,bt){for(var br=0,bq=bt.length;br<bq;++br){bs[bt[br]]=null}return bs}function ba(br){for(var bq in br){if(br.hasOwnProperty(bq)){return false}}return true}function aQ(bq){return bq.substring(2,bq.length-1)}var bg=ar.replace(/\\r\\n?|\\n\\r/g,\"\\n\");var N=[];var a3=bg.replace(/(\"(?:[^\"\\\\\\n]|\\\\.)*\")|('(?:[^'\\\\\\n]|\\\\.)*')|(([\\[\\(=|&!\\^:?]\\s*)(\\/(?![*\\/])(?:[^\\/\\\\\\n]|\\\\.)*\\/[gim]*)\\b)|(\\/\\/[^\\n]*\\n)|(\\/\\*(?:(?!\\*\\/)(?:.|\\n))*\\*\\/)/g,function(by,br,bv,bw,bt,bx,bq,bs){var bu;if(br||bv){bu=N.length;N.push(by);return\"'\"+bu+\"'\"}if(bw){bu=N.length;N.push(bx);return bt+\"'\"+bu+\"'\"}return bs!==\"\"?\" \":\"\\n\"});a3=a3.replace(/__x([0-9A-F]{4})/g,function(br,bq){return\"__x005F_x\"+bq});a3=a3.replace(/\\$/g,\"__x0024\");var Z;var aA=a3;var aa=function(br,bs,bq,bt){if(!!bs||!!bt){return br}Z=true;return\"\"};do{Z=false;aA=aA.replace(/([<]?)<\\s*((?:\\?|[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\[\\])*(?:\\s+(?:extends|super)\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)?(?:\\s*,\\s*(?:\\?|[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\[\\])*(?:\\s+(?:extends|super)\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)?)*)\\s*>([=]?)/g,aa)}while(Z);var bk=aE(aA);var al;var aJ={},a9,az=0;function bc(br,bq){var bs=bk.length;bk.push(br);return'\"'+bq+bs+'\"'}function a7(){return\"class\"+ ++az}function bl(br,bs,bq){br.classId=bs;br.scopeId=bq;aJ[bs]=br}var V,S,ap,aV,bi,aZ;var O=/\\b((?:(?:public|private|final|protected|static|abstract)\\s+)*)(class|interface)\\s+([A-Za-z_$][\\w$]*\\b)(\\s+extends\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\b)*)?(\\s+implements\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\b)*)?\\s*(\"A\\d+\")/g;var bb=/\\b((?:(?:public|private|final|protected|static|abstract|synchronized)\\s+)*)((?!(?:else|new|return|throw|function|public|private|protected)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*([A-Za-z_$][\\w$]*\\b)\\s*(\"B\\d+\")(\\s*throws\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)*)?\\s*(\"A\\d+\"|;)/g;var aM=/^((?:(?:public|private|final|protected|static)\\s+)*)((?!(?:else|new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*([A-Za-z_$][\\w$]*\\b)\\s*(?:\"C\\d+\"\\s*)*([=,]|$)/;var bm=/\\b((?:(?:public|private|final|protected|static|abstract)\\s+)*)((?!(?:new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b)\\s*(\"B\\d+\")(\\s*throws\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)*)?\\s*(\"A\\d+\")/g;var W=/^((?:(?:public|private|final|protected|static)\\s+)*)((?!(?:new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*/;var au=/\\bfunction(?:\\s+([A-Za-z_$][\\w$]*))?\\s*(\"B\\d+\")\\s*(\"A\\d+\")/g;function ae(br){var bq=br;bq=bq.replace(O,function(bs){return bc(bs,\"E\")});bq=bq.replace(bb,function(bs){return bc(bs,\"D\")});bq=bq.replace(au,function(bs){return bc(bs,\"H\")});return bq}function bd(bs,br){var bq=bs.replace(bm,function(bx,bu,bv,by,bw,bt){if(bv!==br){return bx}return bc(bx,\"G\")});return bq}function aH(bq){this.name=bq}aH.prototype.toString=function(){return this.name};function ao(br,bq){this.params=br;this.methodArgsParam=bq}ao.prototype.getNames=function(){var bs=[];for(var br=0,bq=this.params.length;br<bq;++br){bs.push(this.params[br].name)}return bs};ao.prototype.prependMethodArgs=function(bq){if(!this.methodArgsParam){return bq}return\"{\\nvar \"+this.methodArgsParam.name+\" = Array.prototype.slice.call(arguments, \"+this.params.length+\");\\n\"+bq.substring(1)};ao.prototype.toString=function(){if(this.params.length===0){return\"()\"}var bq=\"(\";for(var bs=0,br=this.params.length;bs<br;++bs){bq+=this.params[bs]+\", \"}return bq.substring(0,bq.length-2)+\")\"};function aD(bw){var bt=a6(bw.substring(1,bw.length-1));var bq=[],bu=null;if(bt!==\"\"){var br=bt.split(\",\");for(var bs=0;bs<br.length;++bs){var bv=/\\b([A-Za-z_$][\\w$]*\\b)(\\s*\"[ABC][\\d]*\")*\\s*$/.exec(br[bs]);if(bs===br.length-1&&br[bs].indexOf(\"...\")>=0){bu=new aH(bv[1]);break}bq.push(new aH(bv[1]))}}return new ao(bq,bu)}function aq(bu){var bt=bu;bt=bt.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\s*\"C\\d+\")+\\s*(\"A\\d+\")/g,function(bw,bv,bx){return bx});bt=bt.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\s*\"B\\d+\")\\s*(\"A\\d+\")/g,function(bw,bv,bx){return bc(bw,\"F\")});bt=bt.replace(au,function(bv){return bc(bv,\"H\")});bt=bt.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)\\s*(\"C\\d+\"(?:\\s*\"C\\d+\")*)/g,function(bA,bz,bx){var bw=bx.replace(/\"C(\\d+)\"/g,function(bC,bB){return bk[bB]}).replace(/\\[\\s*\\]/g,\"[null]\").replace(/\\s*\\]\\s*\\[\\s*/g,\", \");var by=\"{\"+bw.substring(1,bw.length-1)+\"}\";var bv=\"('\"+bz+\"', \"+bc(by,\"A\")+\")\";return\"$p.createJavaArray\"+bc(bv,\"B\")});bt=bt.replace(/(\\.\\s*length)\\s*\"B\\d+\"/g,\"$1\");bt=bt.replace(/#([0-9A-Fa-f]{6})\\b/g,function(bv,bw){return\"0xFF\"+bw});bt=bt.replace(/\"B(\\d+)\"(\\s*(?:[\\w$']|\"B))/g,function(by,bw,bx){var bz=bk[bw];if(!/^\\(\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\s*(?:\"C\\d+\"\\s*)*\\)$/.test(bz)){return by}if(/^\\(\\s*int\\s*\\)$/.test(bz)){return\"(int)\"+bx}var bv=bz.split(/\"C(\\d+)\"/g);if(bv.length>1){if(!/^\\[\\s*\\]$/.test(bk[bv[1]])){return by}}return\"\"+bx});bt=bt.replace(/\\(int\\)([^,\\]\\)\\}\\?\\:\\*\\+\\-\\/\\^\\|\\%\\&\\~<\\>\\=]+)/g,function(bw,bv){var bx=aP(bv);return bx.untrim(\"__int_cast(\"+bx.middle+\")\")});bt=bt.replace(/\\bsuper(\\s*\"B\\d+\")/g,\"$$superCstr$1\").replace(/\\bsuper(\\s*\\.)/g,\"$$super$1\");bt=bt.replace(/\\b0+((\\d*)(?:\\.[\\d*])?(?:[eE][\\-\\+]?\\d+)?[fF]?)\\b/,function(bx,bw,bv){if(bw===bv){return bx}return bv===\"\"?\"0\"+bw:bw});bt=bt.replace(/\\b(\\.?\\d+\\.?)[fF]\\b/g,\"$1\");bt=bt.replace(/([^\\s])%([^=\\s])/g,\"$1 % $2\");bt=bt.replace(/\\b(frameRate|keyPressed|mousePressed)\\b(?!\\s*\"B)/g,\"__$1\");bt=bt.replace(/\\b(boolean|byte|char|float|int)\\s*\"B/g,function(bw,bv){return\"parse\"+bv.substring(0,1).toUpperCase()+bv.substring(1)+'\"B'});bt=bt.replace(/\\bpixels\\b\\s*((\"C(\\d+)\")|\\.length)?(\\s*=(?!=)([^,\\]\\)\\}]+))?/g,function(bw,bA,bv,bz,by,bB){if(bv){var bx=bk[bz];if(by){return\"pixels.setPixel\"+bc(\"(\"+bx.substring(1,bx.length-1)+\",\"+bB+\")\",\"B\")}return\"pixels.getPixel\"+bc(\"(\"+bx.substring(1,bx.length-1)+\")\",\"B\")}if(bA){return\"pixels.getLength\"+bc(\"()\",\"B\")}if(by){return\"pixels.set\"+bc(\"(\"+bB+\")\",\"B\")}return\"pixels.toArray\"+bc(\"()\",\"B\")});var bs;function br(bw,bv,bA,by){var bx=bk[by];bs=true;var bz=aP(bx.substring(1,bx.length-1));return\"__\"+bA+(bz.middle===\"\"?bc(\"(\"+bv.replace(/\\.\\s*$/,\"\")+\")\",\"B\"):bc(\"(\"+bv.replace(/\\.\\s*$/,\"\")+\",\"+bz.middle+\")\",\"B\"))}do{bs=false;bt=bt.replace(/((?:'\\d+'|\\b[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\")*)\\s*\\.\\s*(?:[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\"\\s*)*\\.\\s*)*)(replace|replaceAll|replaceFirst|contains|equals|equalsIgnoreCase|hashCode|toCharArray|printStackTrace|split|startsWith|endsWith|codePointAt|matches)\\s*\"B(\\d+)\"/g,br)}while(bs);function bq(bx,bv,bw){bs=true;return\"__instanceof\"+bc(\"(\"+bv+\", \"+bw+\")\",\"B\")}do{bs=false;bt=bt.replace(/((?:'\\d+'|\\b[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\")*)\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\"\\s*)*)*)instanceof\\s+([A-Za-z_$][\\w$]*\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*)*)/g,bq)}while(bs);bt=bt.replace(/\\bthis(\\s*\"B\\d+\")/g,\"$$constr$1\");return bt}function aC(br,bq){this.baseInterfaceName=br;this.body=bq;bq.owner=this}aC.prototype.toString=function(){return\"new (\"+this.body+\")\"};function ai(bs){var br=(new RegExp(/\\bnew\\s*([A-Za-z_$][\\w$]*\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*)*)\\s*\"B\\d+\"\\s*\"A(\\d+)\"/)).exec(bs);var bv=a9,bu=a7();a9=bu;var bq=br[1]+\"$\"+bu;var bt=new aC(bq,V(bk[br[2]],bq,\"\",\"implements \"+br[1]));bl(bt,bu,bv);a9=bv;return bt}function af(br,bs,bq){this.name=br;this.params=bs;this.body=bq}af.prototype.toString=function(){var bs=al;var bt=av({\"this\":null},this.params.getNames());al=function(bu){return bt.hasOwnProperty(bu.name)?bu.name:bs(bu)};var br=\"function\";if(this.name){br+=\" \"+this.name}var bq=this.params.prependMethodArgs(this.body.toString());br+=this.params+\" \"+bq;al=bs;return br};function aK(br){var bq=(new RegExp(/\\b([A-Za-z_$][\\w$]*)\\s*\"B(\\d+)\"\\s*\"A(\\d+)\"/)).exec(br);return new af(bq[1]!==\"function\"?bq[1]:null,aD(bk[bq[2]]),ap(bk[bq[3]]))}function ad(bq){this.members=bq}ad.prototype.toString=function(){var bs=al;al=function(bu){return bu.name===\"this\"?\"this\":bs(bu)};var bq=\"\";for(var bt=0,br=this.members.length;bt<br;++bt){if(this.members[bt].label){bq+=this.members[bt].label+\": \"}bq+=this.members[bt].value.toString()+\", \"}al=bs;return bq.substring(0,bq.length-2)};function aF(bt){var bq=bt.split(\",\");for(var bs=0;bs<bq.length;++bs){var br=bq[bs].indexOf(\":\");if(br<0){bq[bs]={value:aZ(bq[bs])}}else{bq[bs]={label:a6(bq[bs].substring(0,br)),value:aZ(a6(bq[bs].substring(br+1)))}}}return new ad(bq)}function ay(bs){if(bs.charAt(0)===\"(\"||bs.charAt(0)===\"[\"){return bs.charAt(0)+ay(bs.substring(1,bs.length-1))+bs.charAt(bs.length-1)}if(bs.charAt(0)===\"{\"){if(/^\\{\\s*(?:[A-Za-z_$][\\w$]*|'\\d+')\\s*:/.test(bs)){return\"{\"+bc(bs.substring(1,bs.length-1),\"I\")+\"}\"}return\"[\"+ay(bs.substring(1,bs.length-1))+\"]\"}var br=aP(bs);var bq=aq(br.middle);bq=bq.replace(/\"[ABC](\\d+)\"/g,function(bu,bt){return ay(bk[bt])});return br.untrim(bq)}function R(bq){return bq.replace(/(\\.\\s*)?((?:\\b[A-Za-z_]|\\$)[\\w$]*)(\\s*\\.\\s*([A-Za-z_$][\\w$]*)(\\s*\\()?)?/g,function(bt,bv,br,bx,bw,bu){if(bv){return bt}var bs={name:br,member:bw,callSign:!!bu};return al(bs)+(bx===t?\"\":bx)})}function bp(br,bq){this.expr=br;this.transforms=bq}bp.prototype.toString=function(){var bq=this.transforms;var br=R(this.expr);return br.replace(/\"!(\\d+)\"/g,function(bt,bs){return bq[bs].toString()})};aZ=function(bs){var br=[];var bq=ay(bs);bq=bq.replace(/\"H(\\d+)\"/g,function(bu,bt){br.push(aK(bk[bt]));return'\"!'+(br.length-1)+'\"'});bq=bq.replace(/\"F(\\d+)\"/g,function(bu,bt){br.push(ai(bk[bt]));return'\"!'+(br.length-1)+'\"'});bq=bq.replace(/\"I(\\d+)\"/g,function(bu,bt){br.push(aF(bk[bt]));return'\"!'+(br.length-1)+'\"'});return new bp(bq,br)};function a4(bq,bs,br){this.name=bq;this.value=bs;this.isDefault=br}a4.prototype.toString=function(){return this.name+\" = \"+this.value};function ak(bu,br){var bv=bu.indexOf(\"=\");var bq,bt,bs;if(bv<0){bq=bu;bt=br;bs=true}else{bq=bu.substring(0,bv);bt=aZ(bu.substring(bv+1));bs=false}return new a4(a6(bq.replace(/(\\s*\"C\\d+\")+/g,\"\")),bt,bs)}function aT(bq){if(bq===\"int\"||bq===\"float\"){return\"0\"}if(bq===\"boolean\"){return\"false\"}if(bq===\"color\"){return\"0x00000000\"}return\"null\"}function aI(br,bq){this.definitions=br;this.varType=bq}aI.prototype.getNames=function(){var bs=[];for(var br=0,bq=this.definitions.length;br<bq;++br){bs.push(this.definitions[br].name)}return bs};aI.prototype.toString=function(){return\"var \"+this.definitions.join(\",\")};function ah(bq){this.expression=bq}ah.prototype.toString=function(){return this.expression.toString()};function bn(bu){if(aM.test(bu)){var bt=W.exec(bu);var bs=bu.substring(bt[0].length).split(\",\");var bq=aT(bt[2]);for(var br=0;br<bs.length;++br){bs[br]=ak(bs[br],bq)}return new aI(bs,bt[2])}return new ah(aZ(bu))}function a1(bq,bs,br){this.initStatement=bq;this.condition=bs;this.step=br}a1.prototype.toString=function(){return\"(\"+this.initStatement+\"; \"+this.condition+\"; \"+this.step+\")\"};function aS(br,bq){this.initStatement=br;this.container=bq}aS.prototype.toString=function(){var bq=this.initStatement.toString();if(bq.indexOf(\"=\")>=0){bq=bq.substring(0,bq.indexOf(\"=\"))}return\"(\"+bq+\" in \"+this.container+\")\"};function aY(br,bq){this.initStatement=br;this.container=bq}aY.iteratorId=0;aY.prototype.toString=function(){var bu=this.initStatement.toString();var br=\"$it\"+aY.iteratorId++;var bt=bu.replace(/^\\s*var\\s*/,\"\").split(\"=\")[0];var bs=\"var \"+br+\" = new $p.ObjectIterator(\"+this.container+\"), \"+bt+\" = void(0)\";var bq=br+\".hasNext() && ((\"+bt+\" = \"+br+\".next()) || true)\";return\"(\"+bs+\"; \"+bq+\";)\"};function Y(br){var bq;if(/\\bin\\b/.test(br)){bq=br.substring(1,br.length-1).split(/\\bin\\b/g);return new aS(bn(a6(bq[0])),aZ(bq[1]))}if(br.indexOf(\":\")>=0&&br.indexOf(\";\")<0){bq=br.substring(1,br.length-1).split(\":\");return new aY(bn(a6(bq[0])),aZ(bq[1]))}bq=br.substring(1,br.length-1).split(\";\");return new a1(bn(a6(bq[0])),aZ(bq[1]),aZ(bq[2]))}function a2(bq){bq.sort(function(bs,br){return br.weight-bs.weight})}function ab(bs,bq,br){this.name=bs;this.body=bq;this.isStatic=br;bq.owner=this}ab.prototype.toString=function(){return\"\"+this.body};function an(bs,bq,br){this.name=bs;this.body=bq;this.isStatic=br;bq.owner=this}an.prototype.toString=function(){return\"\"+this.body};function T(bs){var br=O.exec(bs);O.lastIndex=0;var bt=br[1].indexOf(\"static\")>=0;var bq=bk[aQ(br[6])],bv;var bw=a9,bu=a7();a9=bu;if(br[2]===\"interface\"){bv=new ab(br[3],S(bq,br[3],br[4]),bt)}else{bv=new an(br[3],V(bq,br[3],br[4],br[5]),bt)}bl(bv,bu,bw);a9=bw;return bv}function ac(bs,bt,bq,br){this.name=bs;this.params=bt;this.body=bq;this.isStatic=br}ac.prototype.toString=function(){var bt=av({},this.params.getNames());var bs=al;al=function(bu){return bt.hasOwnProperty(bu.name)?bu.name:bs(bu)};var br=this.params.prependMethodArgs(this.body.toString());var bq=\"function \"+this.methodId+this.params+\" \"+br+\"\\n\";al=bs;return bq};function P(bt){var br=bb.exec(bt);bb.lastIndex=0;var bs=br[1].indexOf(\"static\")>=0;var bq=br[6]!==\";\"?bk[aQ(br[6])]:\"{}\";return new ac(br[3],aD(bk[aQ(br[4])]),ap(bq),bs)}function am(bs,br,bq){this.definitions=bs;this.fieldType=br;this.isStatic=bq}am.prototype.getNames=function(){var bs=[];for(var br=0,bq=this.definitions.length;br<bq;++br){bs.push(this.definitions[br].name)}return bs};am.prototype.toString=function(){var bx=al({name:\"[this]\"});if(this.isStatic){var bw=this.owner.name;var bu=[];for(var bv=0,bt=this.definitions.length;bv<bt;++bv){var bs=this.definitions[bv];var bq=bs.name,by=bw+\".\"+bq;var br=\"if(\"+by+\" === void(0)) {\\n \"+by+\" = \"+bs.value+\"; }\\n$p.defineProperty(\"+bx+\", '\"+bq+\"', { get: function(){return \"+by+\";}, set: function(val){\"+by+\" = val;} });\\n\";bu.push(br)}return bu.join(\"\")}return bx+\".\"+this.definitions.join(\"; \"+bx+\".\")};function bf(bv){var bu=W.exec(bv);var bq=bu[1].indexOf(\"static\")>=0;var bt=bv.substring(bu[0].length).split(/,\\s*/g);var br=aT(bu[2]);for(var bs=0;bs<bt.length;++bs){bt[bs]=ak(bt[bs],br)}return new am(bt,bu[2],bq)}function aN(br,bq){this.params=br;this.body=bq}aN.prototype.toString=function(){var bt=av({},this.params.getNames());var br=al;al=function(bu){return bt.hasOwnProperty(bu.name)?bu.name:br(bu)};var bs=\"function $constr_\"+this.params.params.length+this.params.toString();var bq=this.params.prependMethodArgs(this.body.toString());if(!/\\$(superCstr|constr)\\b/.test(bq)){bq=\"{\\n$superCstr();\\n\"+bq.substring(1)}al=br;return bs+bq+\"\\n\"};function at(bs){var bq=(new RegExp(/\"B(\\d+)\"\\s*\"A(\\d+)\"/)).exec(bs);var br=aD(bk[bq[1]]);return new aN(br,ap(bk[bq[2]]))}function aO(bs,bv,bu,bq,bw,bx){var bt,br;this.name=bs;this.interfacesNames=bv;this.methodsNames=bu;this.fields=bq;this.innerClasses=bw;this.misc=bx;for(bt=0,br=bq.length;bt<br;++bt){bq[bt].owner=this}}aO.prototype.getMembers=function(bx,bq,bv){if(this.owner.base){this.owner.base.body.getMembers(bx,bq,bv)}var bu,bt,bs,br;for(bu=0,bs=this.fields.length;bu<bs;++bu){var bz=this.fields[bu].getNames();for(bt=0,br=bz.length;bt<br;++bt){bx[bz[bt]]=this.fields[bu]}}for(bu=0,bs=this.methodsNames.length;bu<bs;++bu){var bw=this.methodsNames[bu];bq[bw]=true}for(bu=0,bs=this.innerClasses.length;bu<bs;++bu){var by=this.innerClasses[bu];bv[by.name]=by}};aO.prototype.toString=function(){function br(bH){var bG=0;while(bH){++bG;bH=bH.scope}return bG}var bA=br(this.owner);var bB=this.name;var bx=\"\";var bC=\"\";var bE={},bz={},by={};this.getMembers(bE,bz,by);var bw,bu,bv,bt;if(this.owner.interfaces){var bq=[],bs;for(bw=0,bu=this.interfacesNames.length;bw<bu;++bw){if(!this.owner.interfaces[bw]){continue}bs=al({name:this.interfacesNames[bw]});bq.push(bs);bx+=\"$p.extendInterfaceMembers(\"+bB+\", \"+bs+\");\\n\"}bC+=bB+\".$interfaces = [\"+bq.join(\", \")+\"];\\n\"}bC+=bB+\".$isInterface = true;\\n\";bC+=bB+\".$methods = ['\"+this.methodsNames.join(\"', '\")+\"'];\\n\";a2(this.innerClasses);for(bw=0,bu=this.innerClasses.length;bw<bu;++bw){var bF=this.innerClasses[bw];if(bF.isStatic){bx+=bB+\".\"+bF.name+\" = \"+bF+\";\\n\"}}for(bw=0,bu=this.fields.length;bw<bu;++bw){var bD=this.fields[bw];if(bD.isStatic){bx+=bB+\".\"+bD.definitions.join(\";\\n\"+bB+\".\")+\";\\n\"}}return\"(function() {\\nfunction \"+bB+\"() { throw 'Unable to create the interface'; }\\n\"+bx+bC+\"return \"+bB+\";\\n})()\"};S=function(bw,br,bB){var bC=bw.substring(1,bw.length-1);bC=ae(bC);bC=bd(bC,br);var bz=[],bt=[];bC=bC.replace(/\"([DE])(\\d+)\"/g,function(bF,bE,bD){if(bE===\"D\"){bz.push(bD)}else{if(bE===\"E\"){bt.push(bD)}}return\"\"});var bx=bC.split(/;(?:\\s*;)*/g);var bu;var bv,bs;if(bB!==t){bu=bB.replace(/^\\s*extends\\s+(.+?)\\s*$/g,\"$1\").split(/\\s*,\\s*/g)}for(bv=0,bs=bz.length;bv<bs;++bv){var bq=P(bk[bz[bv]]);bz[bv]=bq.name}for(bv=0,bs=bx.length-1;bv<bs;++bv){var bA=aP(bx[bv]);bx[bv]=bf(bA.middle)}var by=bx.pop();for(bv=0,bs=bt.length;bv<bs;++bv){bt[bv]=T(bk[bt[bv]])}return new aO(br,bu,bz,bx,bt,{tail:by})};function aB(br,by,bx,bw,bs,bz,bA,bu,bq){var bv,bt;this.name=br;this.baseClassName=by;this.interfacesNames=bx;this.functions=bw;this.methods=bs;this.fields=bz;this.cstrs=bA;this.innerClasses=bu;this.misc=bq;for(bv=0,bt=bz.length;bv<bt;++bv){bz[bv].owner=this}}aB.prototype.getMembers=function(bx,br,bw){if(this.owner.base){this.owner.base.body.getMembers(bx,br,bw)}var bv,bu,bt,bs;for(bv=0,bt=this.fields.length;bv<bt;++bv){var bz=this.fields[bv].getNames();for(bu=0,bs=bz.length;bu<bs;++bu){bx[bz[bu]]=this.fields[bv]}}for(bv=0,bt=this.methods.length;bv<bt;++bv){var bq=this.methods[bv];br[bq.name]=bq}for(bv=0,bt=this.innerClasses.length;bv<bt;++bv){var by=this.innerClasses[bv];bw[by.name]=by}};aB.prototype.toString=function(){function bN(bV){var bU=0;while(bV){++bU;bV=bV.scope}return bU}var bB=bN(this.owner);var bG=\"$this_\"+bB;var bs=this.name;var bx=\"var \"+bG+\" = this;\\n\";var bH=\"\";var bz=\"\";var bS={},bT={},bJ={};this.getMembers(bS,bT,bJ);var bR=al;al=function(bV){var bU=bV.name;if(bU===\"this\"){return bV.callSign||!bV.member?bG+\".$self\":bG}if(bS.hasOwnProperty(bU)){return bS[bU].isStatic?bs+\".\"+bU:bG+\".\"+bU}if(bJ.hasOwnProperty(bU)){return bG+\".\"+bU}if(bT.hasOwnProperty(bU)){return bT[bU].isStatic?bs+\".\"+bU:bG+\".$self.\"+bU}return bR(bV)};var bA;if(this.baseClassName){bA=bR({name:this.baseClassName});bx+=\"var $super = { $upcast: \"+bG+\" };\\n\";bx+=\"function $superCstr(){\"+bA+\".apply($super,arguments);if(!('$self' in $super)) $p.extendClassChain($super)}\\n\";bz+=bs+\".$base = \"+bA+\";\\n\"}else{bx+=\"function $superCstr(){$p.extendClassChain(\"+bG+\")}\\n\"}if(this.owner.base){bH+=\"$p.extendStaticMembers(\"+bs+\", \"+bA+\");\\n\"}var bM,bK,bL,bI;if(this.owner.interfaces){var bw=[],bq;for(bM=0,bK=this.interfacesNames.length;bM<bK;++bM){if(!this.owner.interfaces[bM]){continue}bq=bR({name:this.interfacesNames[bM]});bw.push(bq);bH+=\"$p.extendInterfaceMembers(\"+bs+\", \"+bq+\");\\n\"}bz+=bs+\".$interfaces = [\"+bw.join(\", \")+\"];\\n\"}if(this.functions.length>0){bx+=this.functions.join(\"\\n\")+\"\\n\"}a2(this.innerClasses);for(bM=0,bK=this.innerClasses.length;bM<bK;++bM){var bD=this.innerClasses[bM];if(bD.isStatic){bH+=bs+\".\"+bD.name+\" = \"+bD+\";\\n\";bx+=bG+\".\"+bD.name+\" = \"+bs+\".\"+bD.name+\";\\n\"}else{bx+=bG+\".\"+bD.name+\" = \"+bD+\";\\n\"}}for(bM=0,bK=this.fields.length;bM<bK;++bM){var br=this.fields[bM];if(br.isStatic){bH+=bs+\".\"+br.definitions.join(\";\\n\"+bs+\".\")+\";\\n\";for(bL=0,bI=br.definitions.length;bL<bI;++bL){var bu=br.definitions[bL].name,by=bs+\".\"+bu;bx+=\"$p.defineProperty(\"+bG+\", '\"+bu+\"', {get: function(){return \"+by+\"}, set: function(val){\"+by+\" = val}});\\n\"}}else{bx+=bG+\".\"+br.definitions.join(\";\\n\"+bG+\".\")+\";\\n\"}}var bC={};for(bM=0,bK=this.methods.length;bM<bK;++bM){var bt=this.methods[bM];var bP=bC[bt.name];var bv=bt.name+\"$\"+bt.params.params.length;var bF=!!bt.params.methodArgsParam;if(bP){++bP;bv+=\"_\"+bP}else{bP=1}bt.methodId=bv;bC[bt.name]=bP;if(bt.isStatic){bH+=bt;bH+=\"$p.addMethod(\"+bs+\", '\"+bt.name+\"', \"+bv+\", \"+bF+\");\\n\";bx+=\"$p.addMethod(\"+bG+\", '\"+bt.name+\"', \"+bv+\", \"+bF+\");\\n\"}else{bx+=bt;bx+=\"$p.addMethod(\"+bG+\", '\"+bt.name+\"', \"+bv+\", \"+bF+\");\\n\"}}bx+=a6(this.misc.tail);if(this.cstrs.length>0){bx+=this.cstrs.join(\"\\n\")+\"\\n\"}bx+=\"function $constr() {\\n\";var bQ=[];for(bM=0,bK=this.cstrs.length;bM<bK;++bM){var bO=this.cstrs[bM].params.params.length;var bE=!!this.cstrs[bM].params.methodArgsParam;bQ.push(\"if(arguments.length \"+(bE?\">=\":\"===\")+\" \"+bO+\") { $constr_\"+bO+\".apply(\"+bG+\", arguments); }\")}if(bQ.length>0){bx+=bQ.join(\" else \")+\" else \"}bx+=\"$superCstr();\\n}\\n\";bx+=\"$constr.apply(null, arguments);\\n\";al=bR;return\"(function() {\\nfunction \"+bs+\"() {\\n\"+bx+\"}\\n\"+bH+bz+\"return \"+bs+\";\\n})()\"};V=function(bz,br,bq,bC){var bE=bz.substring(1,bz.length-1);bE=ae(bE);bE=bd(bE,br);var bs=[],bt=[],bD=[],bw=[];bE=bE.replace(/\"([DEGH])(\\d+)\"/g,function(bH,bG,bF){if(bG===\"D\"){bs.push(bF)}else{if(bG===\"E\"){bt.push(bF)}else{if(bG===\"H\"){bw.push(bF)}else{bD.push(bF)}}}return\"\"});var by=bE.replace(/^(?:\\s*;)+/,\"\").split(/;(?:\\s*;)*/g);var bx,bv;var bu;if(bq!==t){bx=bq.replace(/^\\s*extends\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)\\s*$/g,\"$1\")}if(bC!==t){bv=bC.replace(/^\\s*implements\\s+(.+?)\\s*$/g,\"$1\").split(/\\s*,\\s*/g)}for(bu=0;bu<bw.length;++bu){bw[bu]=aK(bk[bw[bu]])}for(bu=0;bu<bs.length;++bu){bs[bu]=P(bk[bs[bu]])}for(bu=0;bu<by.length-1;++bu){var bB=aP(by[bu]);by[bu]=bf(bB.middle)}var bA=by.pop();for(bu=0;bu<bD.length;++bu){bD[bu]=at(bk[bD[bu]])}for(bu=0;bu<bt.length;++bu){bt[bu]=T(bk[bt[bu]])}return new aB(br,bx,bv,bw,bs,by,bD,bt,{tail:bA})};function aw(br,bq){this.name=br;this.body=bq;bq.owner=this}aw.prototype.toString=function(){return\"var \"+this.name+\" = \"+this.body+\";\\n$p.\"+this.name+\" = \"+this.name+\";\\n\"};function a5(br,bq){this.name=br;this.body=bq;bq.owner=this}a5.prototype.toString=function(){return\"var \"+this.name+\" = \"+this.body+\";\\n$p.\"+this.name+\" = \"+this.name+\";\\n\"};function bo(bs){var br=O.exec(bs);O.lastIndex=0;var bq=bk[aQ(br[6])];var bv=a9,bt=a7();a9=bt;var bu;if(br[2]===\"interface\"){bu=new aw(br[3],S(bq,br[3],br[4]))}else{bu=new a5(br[3],V(bq,br[3],br[4],br[5]))}bl(bu,bt,bv);a9=bv;return bu}function aR(br,bs,bq){this.name=br;this.params=bs;this.body=bq}aR.prototype.toString=function(){var bt=av({},this.params.getNames());var bs=al;al=function(bu){return bt.hasOwnProperty(bu.name)?bu.name:bs(bu)};var br=this.params.prependMethodArgs(this.body.toString());var bq=\"function \"+this.name+this.params+\" \"+br+\"\\n$p.\"+this.name+\" = \"+this.name+\";\";al=bs;return bq};function aW(bs){var br=bb.exec(bs);var bq=bb.lastIndex=0;return new aR(br[3],aD(bk[aQ(br[4])]),ap(bk[aQ(br[6])]))}function ag(bq){var br=bq;br=br.replace(/\\b(catch\\s*\"B\\d+\"\\s*\"A\\d+\")(\\s*catch\\s*\"B\\d+\"\\s*\"A\\d+\")+/g,\"$1\");return br}function aU(bq,br){this.argument=bq;this.misc=br}aU.prototype.toString=function(){return this.misc.prefix+this.argument.toString()};function Q(bq,br){this.argument=bq;this.misc=br}Q.prototype.toString=function(){return this.misc.prefix+this.argument.toString()};function ax(bq,br,bs){this.name=bq;this.argument=br;this.misc=bs}ax.prototype.toString=function(){var bq=this.misc.prefix;if(this.argument!==t){bq+=this.argument.toString()}return bq};function aL(bq){this.expr=bq}aL.prototype.toString=function(){return\"case \"+this.expr+\":\"};function X(bq){this.label=bq}X.prototype.toString=function(){return this.label};aV=function(by,bz,bs){var bD=new RegExp(/\\b(catch|for|if|switch|while|with)\\s*\"B(\\d+)\"|\\b(do|else|finally|return|throw|try|break|continue)\\b|(\"[ADEH](\\d+)\")|\\b(case)\\s+([^:]+):|\\b([A-Za-z_$][\\w$]*\\s*:)|(;)/g);var bA=[];by=ag(by);var bx=0,bt,br;while((bt=bD.exec(by))!==null){if(bt[1]!==t){var bw=by.lastIndexOf('\"B',bD.lastIndex);var bC=by.substring(bx,bw);if(bt[1]===\"for\"){bA.push(new aU(Y(bk[bt[2]]),{prefix:bC}))}else{if(bt[1]===\"catch\"){bA.push(new Q(aD(bk[bt[2]]),{prefix:bC}))}else{bA.push(new ax(bt[1],aZ(bk[bt[2]]),{prefix:bC}))}}}else{if(bt[3]!==t){bA.push(new ax(bt[3],t,{prefix:by.substring(bx,bD.lastIndex)}))}else{if(bt[4]!==t){br=by.substring(bx,bD.lastIndex-bt[4].length);if(a6(br).length!==0){continue}bA.push(br);var bu=bt[4].charAt(1),bq=bt[5];if(bu===\"D\"){bA.push(bz(bk[bq]))}else{if(bu===\"E\"){bA.push(bs(bk[bq]))}else{if(bu===\"H\"){bA.push(aK(bk[bq]))}else{bA.push(ap(bk[bq]))}}}}else{if(bt[6]!==t){bA.push(new aL(aZ(a6(bt[7]))))}else{if(bt[8]!==t){br=by.substring(bx,bD.lastIndex-bt[8].length);if(a6(br).length!==0){continue}bA.push(new X(by.substring(bx,bD.lastIndex)))}else{var bB=aP(by.substring(bx,bD.lastIndex-1));bA.push(bB.left);bA.push(bn(bB.middle));bA.push(bB.right+\";\")}}}}}bx=bD.lastIndex}var bv=aP(by.substring(bx));bA.push(bv.left);if(bv.middle!==\"\"){bA.push(bn(bv.middle));bA.push(\";\"+bv.right)}return bA};function be(br){var bs=[];for(var bt=0,bq=br.length;bt<bq;++bt){var bu=br[bt];if(bu instanceof aI){bs=bs.concat(bu.getNames())}else{if(bu instanceof aU&&bu.argument.initStatement instanceof aI){bs=bs.concat(bu.argument.initStatement.getNames())}else{if(bu instanceof ab||bu instanceof an||bu instanceof aw||bu instanceof a5||bu instanceof aR||bu instanceof af){bs.push(bu.name)}}}}return av({},bs)}function U(bq){this.statements=bq}U.prototype.toString=function(){var bs=be(this.statements);var br=al;if(!ba(bs)){al=function(bt){return bs.hasOwnProperty(bt.name)?bt.name:br(bt)}}var bq=\"{\\n\"+this.statements.join(\"\")+\"\\n}\";al=br;return bq};ap=function(br){var bq=aP(br.substring(1,br.length-1));return new U(aV(bq.middle))};function aG(bq){this.statements=bq}aG.prototype.toString=function(){var bu=[],bv=[],bw;for(var bt=0,br=this.statements.length;bt<br;++bt){bw=this.statements[bt];if(bw instanceof a5||bw instanceof aw){bu.push(bw)}else{bv.push(bw)}}a2(bu);var bs=be(this.statements);al=function(by){var bx=by.name;if(bs.hasOwnProperty(bx)){return bx}if(aX.hasOwnProperty(bx)||B.hasOwnProperty(bx)||g.hasOwnProperty(bx)){return\"$p.\"+bx}return bx};var bq=\"// this code was autogenerated from PJS\\n(function($p) {\\n\"+bu.join(\"\")+\"\\n\"+bv.join(\"\")+\"\\n})\";al=null;return bq};bi=function(){var bq=ae(bk[0]);bq=bq.replace(/\\bimport\\s+[^;]+;/g,\"\");return new aG(aV(bq,aW,bo))};function bj(bq){var bu={};var bs,by;for(bs in aJ){if(aJ.hasOwnProperty(bs)){by=aJ[bs];var bE=by.scopeId,br=by.name;if(bE){var bD=aJ[bE];by.scope=bD;if(bD.inScope===t){bD.inScope={}}bD.inScope[br]=by}else{bu[br]=by}}}function bB(bF,bI){var bL=bI.split(\".\");var bH=bF.scope,bK;while(bH){if(bH.hasOwnProperty(bL[0])){bK=bH[bL[0]];break}bH=bH.scope}if(bK===t){bK=bu[bL[0]]}for(var bJ=1,bG=bL.length;bJ<bG&&bK;++bJ){bK=bK.inScope[bL[bJ]]}return bK}for(bs in aJ){if(aJ.hasOwnProperty(bs)){by=aJ[bs];var bx=by.body.baseClassName;if(bx){var bA=bB(by,bx);if(bA){by.base=bA;if(!bA.derived){bA.derived=[]}bA.derived.push(by)}}var bw=by.body.interfacesNames,bC=[],bv,bt;if(bw&&bw.length>0){for(bv=0,bt=bw.length;bv<bt;++bv){var bz=bB(by,bw[bv]);bC.push(bz);if(!bz){continue}if(!bz.derived){bz.derived=[]}bz.derived.push(by)}if(bC.length>0){by.interfaces=bC}}}}}function a8(bq){var bv=[],bs={};var br,by,bw;for(br in aJ){if(aJ.hasOwnProperty(br)){bw=aJ[br];if(!bw.inScope&&!bw.derived){bv.push(br);bw.weight=0}else{var bx=[];if(bw.inScope){for(by in bw.inScope){if(bw.inScope.hasOwnProperty(by)){bx.push(bw.inScope[by])}}}if(bw.derived){bx=bx.concat(bw.derived)}bs[br]=bx}}}function bz(bB,bD){var bA=bs[bB];if(!bA){return false}var bC=bA.indexOf(bD);if(bC<0){return false}bA.splice(bC,1);if(bA.length>0){return false}delete bs[bB];return true}while(bv.length>0){br=bv.shift();bw=aJ[br];if(bw.scopeId&&bz(bw.scopeId,bw)){bv.push(bw.scopeId);aJ[bw.scopeId].weight=bw.weight+1}if(bw.base&&bz(bw.base.classId,bw)){bv.push(bw.base.classId);bw.base.weight=bw.weight+1}if(bw.interfaces){var bu,bt;for(bu=0,bt=bw.interfaces.length;bu<bt;++bu){if(!bw.interfaces[bu]||!bz(bw.interfaces[bu].classId,bw)){continue}bv.push(bw.interfaces[bu].classId);bw.interfaces[bu].weight=bw.weight+1}}}}var bh=bi();bj(bh);a8(bh);var a0=bh.toString();a0=a0.replace(/\\s*\\n(?:[\\t ]*\\n)+/g,\"\\n\\n\");a0=a0.replace(/__x([0-9A-F]{4})/g,function(br,bq){return String.fromCharCode(parseInt(bq,16))});return aj(a0,N)}function z(O,ad){var X=(new RegExp(/\\/\\*\\s*@pjs\\s+((?:[^\\*]|\\*+[^\\*\\/])*)\\*\\//g)).exec(O);if(X&&X.length===2){var N=[],Q=X.splice(1,2)[0].replace(/\\{([\\s\\S]*?)\\}/g,function(){return function(ag,ah){N.push(ah);return\"{\"+(N.length-1)+\"}\"}}()).replace(\"\\n\",\"\").replace(\"\\r\",\"\").split(\";\");var W=function(ag){return ag.replace(/^\\s*[\"']?/,\"\").replace(/[\"']?\\s*$/,\"\")};for(var aa=0,Y=Q.length;aa<Y;aa++){var U=Q[aa].split(\"=\");if(U&&U.length===2){var af=W(U[0]),V=W(U[1]),ae=[];if(af===\"preload\"){ae=V.split(\",\");for(var Z=0,ab=ae.length;Z<ab;Z++){var ac=W(ae[Z]);ad.imageCache.add(ac)}}else{if(af===\"font\"){ae=V.split(\",\");for(var R=0,T=ae.length;R<T;R++){var S=W(ae[R]),P=/^\\{(\\d*?)\\}$/.exec(S);H.preloading.add(P?JSON.parse(\"{\"+N[P[1]]+\"}\"):S)}}else{if(af===\"pauseOnBlur\"){ad.options.pauseOnBlur=V===\"true\"}else{if(af===\"globalKeyEvents\"){ad.options.globalKeyEvents=V===\"true\"}else{if(af.substring(0,6)===\"param-\"){ad.params[af.substring(6)]=V}else{ad.options[af]=V}}}}}}}}return O}F.compile=function(N){var Q=new F.Sketch;var O=z(N,Q);var P=c(O);Q.sourceCode=P;return Q};var j=function(){var T={},Q=\"undefined\",R=\"function\",N=!1,S=!0,O=512,P=\"log\";if(typeof tinylog!==Q&&typeof tinylog[P]===R){T[P]=tinylog[P]}else{if(typeof d!==Q&&!d.fake){(function(){var ao=d,am=\"div\",ac=\"style\",ag=\"title\",ab={zIndex:10000,position:\"fixed\",bottom:\"0px\",width:\"100%\",height:\"15%\",fontFamily:\"sans-serif\",color:\"#ccc\",backgroundColor:\"black\"},ae={position:\"relative\",fontFamily:\"monospace\",overflow:\"auto\",height:\"100%\",paddingTop:\"5px\"},ai={height:\"5px\",marginTop:\"-5px\",cursor:\"n-resize\",backgroundColor:\"darkgrey\"},an={position:\"absolute\",top:\"5px\",right:\"20px\",color:\"#111\",MozBorderRadius:\"4px\",webkitBorderRadius:\"4px\",borderRadius:\"4px\",cursor:\"pointer\",fontWeight:\"normal\",textAlign:\"center\",padding:\"3px 5px\",backgroundColor:\"#333\",fontSize:\"12px\"},Y={minHeight:\"16px\"},af={fontSize:\"12px\",margin:\"0 8px 0 8px\",maxWidth:\"100%\",whiteSpace:\"pre-wrap\",overflow:\"auto\"},ad=ao.defaultView,al=ao.documentElement,U=al[ac],W=function(){var aq=arguments.length,ap,at,ar;while(aq--){at=arguments[aq--];ap=arguments[aq][ac];for(ar in at){if(at.hasOwnProperty(ar)){ap[ar]=at[ar]}}}},aj=function(ar,aq,ap){if(ar.addEventListener){ar.addEventListener(aq,ap,N)}else{if(ar.attachEvent){ar.attachEvent(\"on\"+aq,ap)}}return[ar,aq,ap]},V=function(ar,aq,ap){if(ar.removeEventListener){ar.removeEventListener(aq,ap,N)}else{if(ar.detachEvent){ar.detachEvent(\"on\"+aq,ap)}}},aa=function(aq){var ap=aq.childNodes,ar=ap.length;while(ar--){aq.removeChild(ap.item(0))}},ak=function(aq,ap){return aq.appendChild(ap)},ah=function(ap){return ao.createElement(ap)},Z=function(ap){return ao.createTextNode(ap)},X=T[P]=function(aE){var aw,ax=U.paddingBottom,ar=ah(am),aB=ar[ac],aC=ak(ar,ah(am)),au=ak(ar,ah(am)),at=ak(ar,ah(am)),aD=N,av=N,aq=N,ay=0,ap=function(){U.paddingBottom=ar.clientHeight+\"px\"},aA=function(aF){var aG=ad.innerHeight,aH=aC.clientHeight;if(aF<0){aF=0}else{if(aF+aH>aG){aF=aG-aH}}aB.height=aF/aG*100+\"%\";ap()},az=[aj(ao,\"mousemove\",function(aF){if(aD){aA(ad.innerHeight-aF.clientY);au.scrollTop=aq}}),aj(ao,\"mouseup\",function(){if(aD){aD=aq=N}}),aj(aC,\"dblclick\",function(aF){aF.preventDefault();if(av){aA(av);av=N}else{av=ar.clientHeight;aB.height=\"0px\"}}),aj(aC,\"mousedown\",function(aF){aF.preventDefault();aD=S;aq=au.scrollTop}),aj(aC,\"contextmenu\",function(){aD=N}),aj(at,\"click\",function(){aw()})];aw=function(){var aF=az.length;while(aF--){V.apply(T,az[aF])}al.removeChild(ar);U.paddingBottom=ax;aa(au);aa(ar);T[P]=X};W(ar,ab,au,ae,aC,ai,at,an);at[ag]=\"Close Log\";ak(at,Z(\"\\u2716\"));aC[ag]=\"Double-click to toggle log minimization\";al.insertBefore(ar,al.firstChild);T[P]=function(aH){if(ay===O){au.removeChild(au.firstChild)}else{ay++}var aG=ak(au,ah(am)),aF=ak(aG,ah(am));aG[ag]=(new Date).toLocaleTimeString();W(aG,Y,aF,af);ak(aF,Z(aH));au.scrollTop=au.scrollHeight};T[P](aE);ap()}})()}else{if(typeof print===R){T[P]=print}}}return T}();F.logger=j;F.version=\"1.4.1\";F.lib={};F.registerLibrary=function(N,O){F.lib[N]=O;if(O.hasOwnProperty(\"init\")){O.init(g)}};F.instances=k;F.getInstanceById=function(N){return k[J[N]]};F.Sketch=function(N){this.attachFunction=N;this.options={pauseOnBlur:false,globalKeyEvents:false};this.onLoad=G;this.onSetup=G;this.onPause=G;this.onLoop=G;this.onFrameStart=G;this.onFrameEnd=G;this.onExit=G;this.params={};this.imageCache={pending:0,images:{},operaCache:{},add:function(P,O){if(this.images[P]){return}if(!n){this.images[P]=null}if(!O){O=new Image;O.onload=function(R){return function(){R.pending--}}(this);this.pending++;O.src=P}this.images[P]=O;if(D.opera){var Q=d.createElement(\"div\");Q.appendChild(O);Q.style.position=\"absolute\";Q.style.opacity=0;Q.style.width=\"1px\";Q.style.height=\"1px\";if(!this.operaCache[P]){d.body.appendChild(Q);this.operaCache[P]=Q}}}};this.sourceCode=undefined;this.attach=function(P){if(typeof this.attachFunction===\"function\"){this.attachFunction(P)}else{if(this.sourceCode){var O=(new Function(\"return (\"+this.sourceCode+\");\"))();O(P);this.attachFunction=O}else{throw\"Unable to attach sketch to the processing instance\"}}};this.toString=function(){var O;var P=\"((function(Sketch) {\\n\";P+=\"var sketch = new Sketch(\\n\"+this.sourceCode+\");\\n\";for(O in this.options){if(this.options.hasOwnProperty(O)){var Q=this.options[O];P+=\"sketch.options.\"+O+\" = \"+(typeof Q===\"string\"?'\"'+Q+'\"':\"\"+Q)+\";\\n\"}}for(O in this.imageCache){if(this.options.hasOwnProperty(O)){P+='sketch.imageCache.add(\"'+O+'\");\\n'}}P+=\"return sketch;\\n})(Processing.Sketch))\";return P}};var v=function(Q,N){var O=[],U=[],V=N.length,S=0;function T(W,Y){var X=new XMLHttpRequest;X.onreadystatechange=function(){if(X.readyState===4){var Z;if(X.status!==200&&X.status!==0){Z=\"Invalid XHR status \"+X.status}else{if(X.responseText===\"\"){if(\"withCredentials\" in new XMLHttpRequest&&(new XMLHttpRequest).withCredentials===false&&D.location.protocol===\"file:\"){Z=\"XMLHttpRequest failure, possibly due to a same-origin policy violation. You can try loading this page in another browser, or load it from http://localhost using a local webserver. See the Processing.js README for a more detailed explanation of this problem and solutions.\"}else{Z=\"File is empty.\"}}}Y(X.responseText,Z)}};X.open(\"GET\",W,true);if(X.overrideMimeType){X.overrideMimeType(\"application/json\")}X.setRequestHeader(\"If-Modified-Since\",\"Fri, 01 Jan 1960 00:00:00 GMT\");X.send(null)}function P(X,W){function Z(ac,aa){O[X]=ac;++S;if(aa){U.push(W+\" ==> \"+aa)}if(S===V){if(U.length===0){try{return new F(Q,O.join(\"\\n\"))}catch(ab){throw\"Processing.js: Unable to execute pjs sketch: \"+ab}}else{throw\"Processing.js: Unable to load pjs sketch files: \"+U.join(\"\\n\")}}}if(W.charAt(0)===\"#\"){var Y=d.getElementById(W.substring(1));if(Y){Z(Y.text||Y.textContent)}else{Z(\"\",\"Unable to load pjs sketch: element with id '\"+W.substring(1)+\"' was not found\")}return}T(W,Z)}for(var R=0;R<V;++R){P(R,N[R])}};var I=function(){d.removeEventListener(\"DOMContentLoaded\",I,false);k=[];var O=d.getElementsByTagName(\"canvas\"),U;for(var T=0,P=O.length;T<P;T++){var W=O[T].getAttribute(\"data-processing-sources\");if(W===null){W=O[T].getAttribute(\"data-src\");if(W===null){W=O[T].getAttribute(\"datasrc\")}}if(W){U=W.split(/\\s+/g);for(var S=0;S<U.length;){if(U[S]){S++}else{U.splice(S,1)}}v(O[T],U)}}var ac,aa,N,Z,ab=d.getElementsByTagName(\"script\"),Q=[];for(ac=ab.length-1;ac>=0;ac--){Q.push(ab[ac])}for(ac=0,aa=Q.length;ac<aa;ac++){var Y=Q[ac];if(!Y.getAttribute){continue}var X=Y.getAttribute(\"type\");if(X&&(X.toLowerCase()===\"text/processing\"||X.toLowerCase()===\"application/processing\")){var V=Y.getAttribute(\"data-processing-target\");O=t;if(V){O=d.getElementById(V)}else{var R=Y.nextSibling;while(R&&R.nodeType!==1){R=R.nextSibling}if(R&&R.nodeName.toLowerCase()===\"canvas\"){O=R}}if(O){if(Y.getAttribute(\"src\")){U=Y.getAttribute(\"src\").split(/\\s+/);v(O,U);continue}N=Y.textContent||Y.text;Z=new F(O,N)}}}};F.reload=function(){if(k.length>0){for(var N=k.length-1;N>=0;N--){if(k[N]){k[N].exit()}}}I()};F.loadSketchFromSources=v;F.disableInit=function(){if(n){d.removeEventListener(\"DOMContentLoaded\",I,false)}};if(n){D.Processing=F;d.addEventListener(\"DOMContentLoaded\",I,false)}else{this.Processing=F}})(window,window.document,Math);\n",
      "content": "/***\n\n    P R O C E S S I N G . J S - 1.4.1\n    a port of the Processing visualization language\n\n    Processing.js is licensed under the MIT License, see LICENSE.\n    For a list of copyright holders, please refer to AUTHORS.\n\n    http://processingjs.org\n\n***/\n\n(function(D,d,q,t){var G=function(){};var s=function(){if(\"console\" in D){return function(N){D.console.log(\"Processing.js: \"+N)}}return G}();var w=function(N){var O=new XMLHttpRequest;O.open(\"GET\",N,false);if(O.overrideMimeType){O.overrideMimeType(\"text/plain\")}O.setRequestHeader(\"If-Modified-Since\",\"Fri, 01 Jan 1960 00:00:00 GMT\");O.send(null);if(O.status!==200&&O.status!==0){throw\"XMLHttpRequest failed, status code \"+O.status}return O.responseText};var n=\"document\" in this&&!(\"fake\" in this.document);d.head=d.head||d.getElementsByTagName(\"head\")[0];function C(N,O){if(N in D){return D[N]}if(typeof D[O]===\"function\"){return D[O]}return function(Q){if(Q instanceof Array){return Q}if(typeof Q===\"number\"){var P=[];P.length=Q;return P}}}if(d.documentMode>=9&&!d.doctype){throw\"The doctype directive is missing. The recommended doctype in Internet Explorer is the HTML5 doctype: <!DOCTYPE html>\"}var e=C(\"Float32Array\",\"WebGLFloatArray\"),K=C(\"Int32Array\",\"WebGLIntArray\"),y=C(\"Uint16Array\",\"WebGLUnsignedShortArray\"),b=C(\"Uint8Array\",\"WebGLUnsignedByteArray\");var B={X:0,Y:1,Z:2,R:3,G:4,B:5,A:6,U:7,V:8,NX:9,NY:10,NZ:11,EDGE:12,SR:13,SG:14,SB:15,SA:16,SW:17,TX:18,TY:19,TZ:20,VX:21,VY:22,VZ:23,VW:24,AR:25,AG:26,AB:27,DR:3,DG:4,DB:5,DA:6,SPR:28,SPG:29,SPB:30,SHINE:31,ER:32,EG:33,EB:34,BEEN_LIT:35,VERTEX_FIELD_COUNT:36,P2D:1,JAVA2D:1,WEBGL:2,P3D:2,OPENGL:2,PDF:0,DXF:0,OTHER:0,WINDOWS:1,MAXOSX:2,LINUX:3,EPSILON:0.0001,MAX_FLOAT:3.4028235e+38,MIN_FLOAT:-3.4028235e+38,MAX_INT:2147483647,MIN_INT:-2147483648,PI:q.PI,TWO_PI:2*q.PI,HALF_PI:q.PI/2,THIRD_PI:q.PI/3,QUARTER_PI:q.PI/4,DEG_TO_RAD:q.PI/180,RAD_TO_DEG:180/q.PI,WHITESPACE:\" \\t\\n\\r\\u000c\\u00a0\",RGB:1,ARGB:2,HSB:3,ALPHA:4,CMYK:5,TIFF:0,TARGA:1,JPEG:2,GIF:3,BLUR:11,GRAY:12,INVERT:13,OPAQUE:14,POSTERIZE:15,THRESHOLD:16,ERODE:17,DILATE:18,REPLACE:0,BLEND:1<<0,ADD:1<<1,SUBTRACT:1<<2,LIGHTEST:1<<3,DARKEST:1<<4,DIFFERENCE:1<<5,EXCLUSION:1<<6,MULTIPLY:1<<7,SCREEN:1<<8,OVERLAY:1<<9,HARD_LIGHT:1<<10,SOFT_LIGHT:1<<11,DODGE:1<<12,BURN:1<<13,ALPHA_MASK:4278190080,RED_MASK:16711680,GREEN_MASK:65280,BLUE_MASK:255,CUSTOM:0,ORTHOGRAPHIC:2,PERSPECTIVE:3,POINT:2,POINTS:2,LINE:4,LINES:4,TRIANGLE:8,TRIANGLES:9,TRIANGLE_STRIP:10,TRIANGLE_FAN:11,QUAD:16,QUADS:16,QUAD_STRIP:17,POLYGON:20,PATH:21,RECT:30,ELLIPSE:31,ARC:32,SPHERE:40,BOX:41,GROUP:0,PRIMITIVE:1,GEOMETRY:3,VERTEX:0,BEZIER_VERTEX:1,CURVE_VERTEX:2,BREAK:3,CLOSESHAPE:4,OPEN:1,CLOSE:2,CORNER:0,CORNERS:1,RADIUS:2,CENTER_RADIUS:2,CENTER:3,DIAMETER:3,CENTER_DIAMETER:3,BASELINE:0,TOP:101,BOTTOM:102,NORMAL:1,NORMALIZED:1,IMAGE:2,MODEL:4,SHAPE:5,SQUARE:\"butt\",ROUND:\"round\",PROJECT:\"square\",MITER:\"miter\",BEVEL:\"bevel\",AMBIENT:0,DIRECTIONAL:1,SPOT:3,BACKSPACE:8,TAB:9,ENTER:10,RETURN:13,ESC:27,DELETE:127,CODED:65535,SHIFT:16,CONTROL:17,ALT:18,CAPSLK:20,PGUP:33,PGDN:34,END:35,HOME:36,LEFT:37,UP:38,RIGHT:39,DOWN:40,F1:112,F2:113,F3:114,F4:115,F5:116,F6:117,F7:118,F8:119,F9:120,F10:121,F11:122,F12:123,NUMLK:144,META:157,INSERT:155,ARROW:\"default\",CROSS:\"crosshair\",HAND:\"pointer\",MOVE:\"move\",TEXT:\"text\",WAIT:\"wait\",NOCURSOR:\"url('data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw=='), auto\",DISABLE_OPENGL_2X_SMOOTH:1,ENABLE_OPENGL_2X_SMOOTH:-1,ENABLE_OPENGL_4X_SMOOTH:2,ENABLE_NATIVE_FONTS:3,DISABLE_DEPTH_TEST:4,ENABLE_DEPTH_TEST:-4,ENABLE_DEPTH_SORT:5,DISABLE_DEPTH_SORT:-5,DISABLE_OPENGL_ERROR_REPORT:6,ENABLE_OPENGL_ERROR_REPORT:-6,ENABLE_ACCURATE_TEXTURES:7,DISABLE_ACCURATE_TEXTURES:-7,HINT_COUNT:10,SINCOS_LENGTH:720,PRECISIONB:15,PRECISIONF:1<<15,PREC_MAXVAL:(1<<15)-1,PREC_ALPHA_SHIFT:24-15,PREC_RED_SHIFT:16-15,NORMAL_MODE_AUTO:0,NORMAL_MODE_SHAPE:1,NORMAL_MODE_VERTEX:2,MAX_LIGHTS:8};function h(P){if(typeof P===\"string\"){var O=0;for(var N=0;N<P.length;++N){O=O*31+P.charCodeAt(N)&4294967295}return O}if(typeof P!==\"object\"){return P&4294967295}if(P.hashCode instanceof Function){return P.hashCode()}if(P.$id===t){P.$id=q.floor(q.random()*65536)-32768<<16|q.floor(q.random()*65536)}return P.$id}function r(O,N){if(O===null||N===null){return O===null&&N===null}if(typeof O===\"string\"){return O===N}if(typeof O!==\"object\"){return O===N}if(O.equals instanceof Function){return O.equals(N)}return O===N}var o=function(O){if(O.iterator instanceof Function){return O.iterator()}if(O instanceof Array){var N=-1;this.hasNext=function(){return ++N<O.length};this.next=function(){return O[N]}}else{throw\"Unable to iterate: \"+O}};var f=function(){function O(Q){var P=0;this.hasNext=function(){return P<Q.length};this.next=function(){return Q[P++]};this.remove=function(){Q.splice(P,1)}}function N(P){var Q;if(P instanceof N){Q=P.toArray()}else{Q=[];if(typeof P===\"number\"){Q.length=P>0?P:0}}this.get=function(R){return Q[R]};this.contains=function(R){return this.indexOf(R)>-1};this.indexOf=function(T){for(var S=0,R=Q.length;S<R;++S){if(r(T,Q[S])){return S}}return -1};this.lastIndexOf=function(S){for(var R=Q.length-1;R>=0;--R){if(r(S,Q[R])){return R}}return -1};this.add=function(){if(arguments.length===1){Q.push(arguments[0])}else{if(arguments.length===2){var R=arguments[0];if(typeof R===\"number\"){if(R>=0&&R<=Q.length){Q.splice(R,0,arguments[1])}else{throw R+\" is not a valid index\"}}else{throw typeof R+\" is not a number\"}}else{throw\"Please use the proper number of parameters.\"}}};this.addAll=function(S,R){var T;if(typeof S===\"number\"){if(S<0||S>Q.length){throw\"Index out of bounds for addAll: \"+S+\" greater or equal than \"+Q.length}T=new o(R);while(T.hasNext()){Q.splice(S++,0,T.next())}}else{T=new o(S);while(T.hasNext()){Q.push(T.next())}}};this.set=function(){if(arguments.length===2){var R=arguments[0];if(typeof R===\"number\"){if(R>=0&&R<Q.length){Q.splice(R,1,arguments[1])}else{throw R+\" is not a valid index.\"}}else{throw typeof R+\" is not a number\"}}else{throw\"Please use the proper number of parameters.\"}};this.size=function(){return Q.length};this.clear=function(){Q.length=0};this.remove=function(R){if(typeof R===\"number\"){return Q.splice(R,1)[0]}R=this.indexOf(R);if(R>-1){Q.splice(R,1);return true}return false};this.removeAll=function(V){var S,R,U,T=new N;T.addAll(this);this.clear();for(S=0,R=0;S<T.size();S++){U=T.get(S);if(!V.contains(U)){this.add(R++,U)}}if(this.size()<T.size()){return true}return false};this.isEmpty=function(){return !Q.length};this.clone=function(){return new N(this)};this.toArray=function(){return Q.slice(0)};this.iterator=function(){return new O(Q)}}return N}();var x=function(){function N(){if(arguments.length===1&&arguments[0] instanceof N){return arguments[0].clone()}var W=arguments.length>0?arguments[0]:16;var X=arguments.length>1?arguments[1]:0.75;var Q=[];Q.length=W;var S=0;var O=this;function U(Z){var Y=h(Z)%Q.length;return Y<0?Q.length+Y:Y}function R(){if(S<=X*Q.length){return}var ab=[];for(var aa=0;aa<Q.length;++aa){if(Q[aa]!==t){ab=ab.concat(Q[aa])}}var ac=Q.length*2;Q=[];Q.length=ac;for(var Z=0;Z<ab.length;++Z){var Y=U(ab[Z].key);var ad=Q[Y];if(ad===t){Q[Y]=ad=[]}ad.push(ab[Z])}}function P(ad,ae){var Y=0;var ac=-1;var ab=false;var aa;function Z(){while(!ab){++ac;if(Y>=Q.length){ab=true}else{if(Q[Y]===t||ac>=Q[Y].length){ac=-1;++Y}else{return}}}}this.hasNext=function(){return !ab};this.next=function(){aa=ad(Q[Y][ac]);Z();return aa};this.remove=function(){if(aa!==t){ae(aa);--ac;Z()}};Z()}function V(Y,Z,aa){this.clear=function(){O.clear()};this.contains=function(ab){return Z(ab)};this.containsAll=function(ac){var ab=ac.iterator();while(ab.hasNext()){if(!this.contains(ab.next())){return false}}return true};this.isEmpty=function(){return O.isEmpty()};this.iterator=function(){return new P(Y,aa)};this.remove=function(ab){if(this.contains(ab)){aa(ab);return true}return false};this.removeAll=function(ae){var ab=ae.iterator();var ad=false;while(ab.hasNext()){var ac=ab.next();if(this.contains(ac)){aa(ac);ad=true}}return true};this.retainAll=function(af){var ad=this.iterator();var ac=[];while(ad.hasNext()){var ae=ad.next();if(!af.contains(ae)){ac.push(ae)}}for(var ab=0;ab<ac.length;++ab){aa(ac[ab])}return ac.length>0};this.size=function(){return O.size()};this.toArray=function(){var ab=[];var ac=this.iterator();while(ac.hasNext()){ab.push(ac.next())}return ab}}function T(Y){this._isIn=function(Z){return Z===O&&Y.removed===t};this.equals=function(Z){return r(Y.key,Z.getKey())};this.getKey=function(){return Y.key};this.getValue=function(){return Y.value};this.hashCode=function(Z){return h(Y.key)};this.setValue=function(aa){var Z=Y.value;Y.value=aa;return Z}}this.clear=function(){S=0;Q=[];Q.length=W};this.clone=function(){var Y=new N;Y.putAll(this);return Y};this.containsKey=function(aa){var Y=U(aa);var ab=Q[Y];if(ab===t){return false}for(var Z=0;Z<ab.length;++Z){if(r(ab[Z].key,aa)){return true}}return false};this.containsValue=function(aa){for(var Z=0;Z<Q.length;++Z){var ab=Q[Z];if(ab===t){continue}for(var Y=0;Y<ab.length;++Y){if(r(ab[Y].value,aa)){return true}}}return false};this.entrySet=function(){return new V(function(Y){return new T(Y)},function(Y){return Y instanceof T&&Y._isIn(O)},function(Y){return O.remove(Y.getKey())})};this.get=function(aa){var Y=U(aa);var ab=Q[Y];if(ab===t){return null}for(var Z=0;Z<ab.length;++Z){if(r(ab[Z].key,aa)){return ab[Z].value}}return null};this.isEmpty=function(){return S===0};this.keySet=function(){return new V(function(Y){return Y.key},function(Y){return O.containsKey(Y)},function(Y){return O.remove(Y)})};this.values=function(){return new V(function(Y){return Y.value},function(Y){return O.containsValue(Y)},function(Y){return O.removeByValue(Y)})};this.put=function(aa,ac){var Y=U(aa);var ad=Q[Y];if(ad===t){++S;Q[Y]=[{key:aa,value:ac}];R();return null}for(var Z=0;Z<ad.length;++Z){if(r(ad[Z].key,aa)){var ab=ad[Z].value;ad[Z].value=ac;return ab}}++S;ad.push({key:aa,value:ac});R();return null};this.putAll=function(Y){var Z=Y.entrySet().iterator();while(Z.hasNext()){var aa=Z.next();this.put(aa.getKey(),aa.getValue())}};this.remove=function(aa){var Y=U(aa);var ac=Q[Y];if(ac===t){return null}for(var Z=0;Z<ac.length;++Z){if(r(ac[Z].key,aa)){--S;var ab=ac[Z].value;ac[Z].removed=true;if(ac.length>1){ac.splice(Z,1)}else{Q[Y]=t}return ab}}return null};this.removeByValue=function(aa){var ac,Z,Y,ab;for(ac in Q){if(Q.hasOwnProperty(ac)){for(Z=0,Y=Q[ac].length;Z<Y;Z++){ab=Q[ac][Z];if(ab.value===aa){Q[ac].splice(Z,1);return true}}}}return false};this.size=function(){return S}}return N}();var A=function(){function N(Q,S,R){this.x=Q||0;this.y=S||0;this.z=R||0}N.dist=function(R,Q){return R.dist(Q)};N.dot=function(R,Q){return R.dot(Q)};N.cross=function(R,Q){return R.cross(Q)};N.angleBetween=function(R,Q){return q.acos(R.dot(Q)/(R.mag()*Q.mag()))};N.prototype={set:function(Q,S,R){if(arguments.length===1){this.set(Q.x||Q[0]||0,Q.y||Q[1]||0,Q.z||Q[2]||0)}else{this.x=Q;this.y=S;this.z=R}},get:function(){return new N(this.x,this.y,this.z)},mag:function(){var Q=this.x,S=this.y,R=this.z;return q.sqrt(Q*Q+S*S+R*R)},add:function(Q,S,R){if(arguments.length===1){this.x+=Q.x;this.y+=Q.y;this.z+=Q.z}else{this.x+=Q;this.y+=S;this.z+=R}},sub:function(Q,S,R){if(arguments.length===1){this.x-=Q.x;this.y-=Q.y;this.z-=Q.z}else{this.x-=Q;this.y-=S;this.z-=R}},mult:function(Q){if(typeof Q===\"number\"){this.x*=Q;this.y*=Q;this.z*=Q}else{this.x*=Q.x;this.y*=Q.y;this.z*=Q.z}},div:function(Q){if(typeof Q===\"number\"){this.x/=Q;this.y/=Q;this.z/=Q}else{this.x/=Q.x;this.y/=Q.y;this.z/=Q.z}},dist:function(T){var S=this.x-T.x,R=this.y-T.y,Q=this.z-T.z;return q.sqrt(S*S+R*R+Q*Q)},dot:function(Q,S,R){if(arguments.length===1){return this.x*Q.x+this.y*Q.y+this.z*Q.z}return this.x*Q+this.y*S+this.z*R},cross:function(R){var Q=this.x,T=this.y,S=this.z;return new N(T*R.z-R.y*S,S*R.x-R.z*Q,Q*R.y-R.x*T)},normalize:function(){var Q=this.mag();if(Q>0){this.div(Q)}},limit:function(Q){if(this.mag()>Q){this.normalize();this.mult(Q)}},heading2D:function(){return -q.atan2(-this.y,this.x)},toString:function(){return\"[\"+this.x+\", \"+this.y+\", \"+this.z+\"]\"},array:function(){return[this.x,this.y,this.z]}};function O(Q){return function(T,S){var R=T.get();R[Q](S);return R}}for(var P in N.prototype){if(N.prototype.hasOwnProperty(P)&&!N.hasOwnProperty(P)){N[P]=O(P)}}return N}();function M(){}M.prototype=B;var g=new M;g.ArrayList=f;g.HashMap=x;g.PVector=A;g.ObjectIterator=o;g.PConstants=B;g.defineProperty=function(O,N,P){if(\"defineProperty\" in Object){Object.defineProperty(O,N,P)}else{if(P.hasOwnProperty(\"get\")){O.__defineGetter__(N,P.get)}if(P.hasOwnProperty(\"set\")){O.__defineSetter__(N,P.set)}}};function m(O,N,R){if(!O.hasOwnProperty(N)||typeof O[N]!==\"function\"){O[N]=R;return}var Q=O[N];if(\"$overloads\" in Q){Q.$defaultOverload=R;return}if(!(\"$overloads\" in R)&&Q.length===R.length){return}var T,P;if(\"$overloads\" in R){T=R.$overloads.slice(0);T[Q.length]=Q;P=R.$defaultOverload}else{T=[];T[R.length]=R;T[Q.length]=Q;P=Q}var S=function(){var U=S.$overloads[arguments.length]||(\"$methodArgsIndex\" in S&&arguments.length>S.$methodArgsIndex?S.$overloads[S.$methodArgsIndex]:null)||S.$defaultOverload;return U.apply(this,arguments)};S.$overloads=T;if(\"$methodArgsIndex\" in R){S.$methodArgsIndex=R.$methodArgsIndex}S.$defaultOverload=P;S.name=N;O[N]=S}function i(Q,P){function R(S){g.defineProperty(Q,S,{get:function(){return P[S]},set:function(T){P[S]=T},enumerable:true})}var O=[];for(var N in P){if(typeof P[N]===\"function\"){m(Q,N,P[N])}else{if(N.charAt(0)!==\"$\"&&!(N in Q)){O.push(N)}}}while(O.length>0){R(O.shift())}Q.$super=P}g.extendClassChain=function(O){var P=[O];for(var N=O.$upcast;N;N=N.$upcast){i(N,O);P.push(N);O=N}while(P.length>0){P.pop().$self=O}};g.extendStaticMembers=function(N,O){i(N,O)};g.extendInterfaceMembers=function(N,O){i(N,O)};g.addMethod=function(Q,P,S,R){var N=Q[P];if(N||R){var O=S.length;if(\"$overloads\" in N){N.$overloads[O]=S}else{var T=function(){var V=T.$overloads[arguments.length]||(\"$methodArgsIndex\" in T&&arguments.length>T.$methodArgsIndex?T.$overloads[T.$methodArgsIndex]:null)||T.$defaultOverload;return V.apply(this,arguments)};var U=[];if(N){U[N.length]=N}U[O]=S;T.$overloads=U;T.$defaultOverload=N||S;if(R){T.$methodArgsIndex=O}T.name=P;Q[P]=T}}else{Q[P]=S}};function l(N){if(typeof N!==\"string\"){return false}return[\"byte\",\"int\",\"char\",\"color\",\"float\",\"long\",\"double\"].indexOf(N)!==-1}g.createJavaArray=function(S,T){var O=null,P=null;if(typeof S===\"string\"){if(S===\"boolean\"){P=false}else{if(l(S)){P=0}}}if(typeof T[0]===\"number\"){var N=0|T[0];if(T.length<=1){O=[];O.length=N;for(var R=0;R<N;++R){O[R]=P}}else{O=[];var U=T.slice(1);for(var Q=0;Q<N;++Q){O.push(g.createJavaArray(S,U))}}}return O};var E={aliceblue:\"#f0f8ff\",antiquewhite:\"#faebd7\",aqua:\"#00ffff\",aquamarine:\"#7fffd4\",azure:\"#f0ffff\",beige:\"#f5f5dc\",bisque:\"#ffe4c4\",black:\"#000000\",blanchedalmond:\"#ffebcd\",blue:\"#0000ff\",blueviolet:\"#8a2be2\",brown:\"#a52a2a\",burlywood:\"#deb887\",cadetblue:\"#5f9ea0\",chartreuse:\"#7fff00\",chocolate:\"#d2691e\",coral:\"#ff7f50\",cornflowerblue:\"#6495ed\",cornsilk:\"#fff8dc\",crimson:\"#dc143c\",cyan:\"#00ffff\",darkblue:\"#00008b\",darkcyan:\"#008b8b\",darkgoldenrod:\"#b8860b\",darkgray:\"#a9a9a9\",darkgreen:\"#006400\",darkkhaki:\"#bdb76b\",darkmagenta:\"#8b008b\",darkolivegreen:\"#556b2f\",darkorange:\"#ff8c00\",darkorchid:\"#9932cc\",darkred:\"#8b0000\",darksalmon:\"#e9967a\",darkseagreen:\"#8fbc8f\",darkslateblue:\"#483d8b\",darkslategray:\"#2f4f4f\",darkturquoise:\"#00ced1\",darkviolet:\"#9400d3\",deeppink:\"#ff1493\",deepskyblue:\"#00bfff\",dimgray:\"#696969\",dodgerblue:\"#1e90ff\",firebrick:\"#b22222\",floralwhite:\"#fffaf0\",forestgreen:\"#228b22\",fuchsia:\"#ff00ff\",gainsboro:\"#dcdcdc\",ghostwhite:\"#f8f8ff\",gold:\"#ffd700\",goldenrod:\"#daa520\",gray:\"#808080\",green:\"#008000\",greenyellow:\"#adff2f\",honeydew:\"#f0fff0\",hotpink:\"#ff69b4\",indianred:\"#cd5c5c\",indigo:\"#4b0082\",ivory:\"#fffff0\",khaki:\"#f0e68c\",lavender:\"#e6e6fa\",lavenderblush:\"#fff0f5\",lawngreen:\"#7cfc00\",lemonchiffon:\"#fffacd\",lightblue:\"#add8e6\",lightcoral:\"#f08080\",lightcyan:\"#e0ffff\",lightgoldenrodyellow:\"#fafad2\",lightgrey:\"#d3d3d3\",lightgreen:\"#90ee90\",lightpink:\"#ffb6c1\",lightsalmon:\"#ffa07a\",lightseagreen:\"#20b2aa\",lightskyblue:\"#87cefa\",lightslategray:\"#778899\",lightsteelblue:\"#b0c4de\",lightyellow:\"#ffffe0\",lime:\"#00ff00\",limegreen:\"#32cd32\",linen:\"#faf0e6\",magenta:\"#ff00ff\",maroon:\"#800000\",mediumaquamarine:\"#66cdaa\",mediumblue:\"#0000cd\",mediumorchid:\"#ba55d3\",mediumpurple:\"#9370d8\",mediumseagreen:\"#3cb371\",mediumslateblue:\"#7b68ee\",mediumspringgreen:\"#00fa9a\",mediumturquoise:\"#48d1cc\",mediumvioletred:\"#c71585\",midnightblue:\"#191970\",mintcream:\"#f5fffa\",mistyrose:\"#ffe4e1\",moccasin:\"#ffe4b5\",navajowhite:\"#ffdead\",navy:\"#000080\",oldlace:\"#fdf5e6\",olive:\"#808000\",olivedrab:\"#6b8e23\",orange:\"#ffa500\",orangered:\"#ff4500\",orchid:\"#da70d6\",palegoldenrod:\"#eee8aa\",palegreen:\"#98fb98\",paleturquoise:\"#afeeee\",palevioletred:\"#d87093\",papayawhip:\"#ffefd5\",peachpuff:\"#ffdab9\",peru:\"#cd853f\",pink:\"#ffc0cb\",plum:\"#dda0dd\",powderblue:\"#b0e0e6\",purple:\"#800080\",red:\"#ff0000\",rosybrown:\"#bc8f8f\",royalblue:\"#4169e1\",saddlebrown:\"#8b4513\",salmon:\"#fa8072\",sandybrown:\"#f4a460\",seagreen:\"#2e8b57\",seashell:\"#fff5ee\",sienna:\"#a0522d\",silver:\"#c0c0c0\",skyblue:\"#87ceeb\",slateblue:\"#6a5acd\",slategray:\"#708090\",snow:\"#fffafa\",springgreen:\"#00ff7f\",steelblue:\"#4682b4\",tan:\"#d2b48c\",teal:\"#008080\",thistle:\"#d8bfd8\",tomato:\"#ff6347\",turquoise:\"#40e0d0\",violet:\"#ee82ee\",wheat:\"#f5deb3\",white:\"#ffffff\",whitesmoke:\"#f5f5f5\",yellow:\"#ffff00\",yellowgreen:\"#9acd32\"};(function(O){var R=(\"open() createOutput() createInput() BufferedReader selectFolder() dataPath() createWriter() selectOutput() beginRecord() saveStream() endRecord() selectInput() saveBytes() createReader() beginRaw() endRaw() PrintWriter delay()\").split(\" \"),Q=R.length,N,S;function P(T){return function(){throw\"Processing.js does not support \"+T+\".\"}}while(Q--){N=R[Q];S=N.replace(\"()\",\"\");O[S]=P(N)}})(g);g.defineProperty(g,\"screenWidth\",{get:function(){return D.innerWidth}});g.defineProperty(g,\"screenHeight\",{get:function(){return D.innerHeight}});g.defineProperty(g,\"online\",{get:function(){return true}});var k=[];var J={};var L=function(N){k.splice(J[N],1);delete J[N]};var a=function(N){if(N.externals.canvas.id===t||!N.externals.canvas.id.length){N.externals.canvas.id=\"__processing\"+k.length}J[N.externals.canvas.id]=k.length;k.push(N)};function p(X){var Q=250,ae=X.size/Q,N=d.createElement(\"canvas\");N.width=2*Q;N.height=2*Q;N.style.opacity=0;var W=X.getCSSDefinition(Q+\"px\",\"normal\"),Y=N.getContext(\"2d\");Y.font=W;var ac=\"dbflkhyjqpg\";N.width=Y.measureText(ac).width;Y.font=W;var T=d.createElement(\"div\");T.style.position=\"absolute\";T.style.opacity=0;T.style.fontFamily='\"'+X.name+'\"';T.style.fontSize=Q+\"px\";T.innerHTML=ac+\"<br/>\"+ac;d.body.appendChild(T);var U=N.width,ab=N.height,V=ab/2;Y.fillStyle=\"white\";Y.fillRect(0,0,U,ab);Y.fillStyle=\"black\";Y.fillText(ac,0,V);var P=Y.getImageData(0,0,U,ab).data;var Z=0,S=U*4,aa=P.length;while(++Z<aa&&P[Z]===255){G()}var R=q.round(Z/S);Z=aa-1;while(--Z>0&&P[Z]===255){G()}var ad=q.round(Z/S);X.ascent=ae*(V-R);X.descent=ae*(ad-V);if(d.defaultView.getComputedStyle){var O=d.defaultView.getComputedStyle(T,null).getPropertyValue(\"height\");O=ae*O.replace(\"px\",\"\");if(O>=X.size*2){X.leading=q.round(O/2)}}d.body.removeChild(T);if(X.caching){return Y}}function H(N,O){if(N===t){N=\"\"}this.name=N;if(O===t){O=0}this.size=O;this.glyph=false;this.ascent=0;this.descent=0;this.leading=1.2*O;var R=N.indexOf(\" Italic Bold\");if(R!==-1){N=N.substring(0,R)}this.style=\"normal\";var Q=N.indexOf(\" Italic\");if(Q!==-1){N=N.substring(0,Q);this.style=\"italic\"}this.weight=\"normal\";var P=N.indexOf(\" Bold\");if(P!==-1){N=N.substring(0,P);this.weight=\"bold\"}this.family=\"sans-serif\";if(N!==t){switch(N){case\"sans-serif\":case\"serif\":case\"monospace\":case\"fantasy\":case\"cursive\":this.family=N;break;default:this.family='\"'+N+'\", sans-serif';break}}this.context2d=p(this);this.css=this.getCSSDefinition();if(this.context2d){this.context2d.font=this.css}}H.prototype.caching=true;H.prototype.getCSSDefinition=function(P,N){if(P===t){P=this.size+\"px\"}if(N===t){N=this.leading+\"px\"}var O=[this.style,\"normal\",this.weight,P+\"/\"+N,this.family];return O.join(\" \")};H.prototype.measureTextWidth=function(N){return this.context2d.measureText(N).width};H.prototype.measureTextWidthFallback=function(P){var O=d.createElement(\"canvas\"),N=O.getContext(\"2d\");N.font=this.css;return N.measureText(P).width};H.PFontCache={length:0};H.get=function(Q,R){R=(R*10+0.5|0)/10;var O=H.PFontCache,N=Q+\"/\"+R;if(!O[N]){O[N]=new H(Q,R);O.length++;if(O.length===50){H.prototype.measureTextWidth=H.prototype.measureTextWidthFallback;H.prototype.caching=false;var P;for(P in O){if(P!==\"length\"){O[P].context2d=null}}return new H(Q,R)}if(O.length===400){H.PFontCache={};H.get=H.getFallback;return new H(Q,R)}}return O[N]};H.getFallback=function(N,O){return new H(N,O)};H.list=function(){return[\"sans-serif\",\"serif\",\"monospace\",\"fantasy\",\"cursive\"]};H.preloading={template:{},initialized:false,initialize:function(){var P=function(){var R=\"#E3KAI2wAgT1MvMg7Eo3VmNtYX7ABi3CxnbHlm7Abw3kaGVhZ7ACs3OGhoZWE7A53CRobXR47AY3AGbG9jYQ7G03Bm1heH7ABC3CBuYW1l7Ae3AgcG9zd7AI3AE#B3AQ2kgTY18PPPUACwAg3ALSRoo3#yld0xg32QAB77#E777773B#E3C#I#Q77773E#Q7777777772CMAIw7AB77732B#M#Q3wAB#g3B#E#E2BB//82BB////w#B7#gAEg3E77x2B32B#E#Q#MTcBAQ32gAe#M#QQJ#E32M#QQJ#I#g32Q77#\";var Q=function(S){return\"AAAAAAAA\".substr(~~S?7-S:6)};return R.replace(/[#237]/g,Q)};var N=d.createElement(\"style\");N.setAttribute(\"type\",\"text/css\");N.innerHTML='@font-face {\\n  font-family: \"PjsEmptyFont\";\\n  src: url(\\'data:application/x-font-ttf;base64,'+P()+\"')\\n       format('truetype');\\n}\";d.head.appendChild(N);var O=d.createElement(\"span\");O.style.cssText='position: absolute; top: 0; left: 0; opacity: 0; font-family: \"PjsEmptyFont\", fantasy;';O.innerHTML=\"AAAAAAAA\";d.body.appendChild(O);this.template=O;this.initialized=true},getElementWidth:function(N){return d.defaultView.getComputedStyle(N,\"\").getPropertyValue(\"width\")},timeAttempted:0,pending:function(R){if(!this.initialized){this.initialize()}var P,N,Q=this.getElementWidth(this.template);for(var O=0;O<this.fontList.length;O++){P=this.fontList[O];N=this.getElementWidth(P);if(this.timeAttempted<4000&&N===Q){this.timeAttempted+=R;return true}else{d.body.removeChild(P);this.fontList.splice(O--,1);this.timeAttempted=0}}if(this.fontList.length===0){return false}return true},fontList:[],addedList:{},add:function(N){if(!this.initialized){this.initialize()}var R=typeof N===\"object\"?N.fontFace:N,Q=typeof N===\"object\"?N.url:N;if(this.addedList[R]){return}var P=d.createElement(\"style\");P.setAttribute(\"type\",\"text/css\");P.innerHTML=\"@font-face{\\n  font-family: '\"+R+\"';\\n  src:  url('\"+Q+\"');\\n}\\n\";d.head.appendChild(P);this.addedList[R]=true;var O=d.createElement(\"span\");O.style.cssText=\"position: absolute; top: 0; left: 0; opacity: 0;\";O.style.fontFamily='\"'+R+'\", \"PjsEmptyFont\", fantasy';O.innerHTML=\"AAAAAAAA\";d.body.appendChild(O);this.fontList.push(O)}};g.PFont=H;var F=this.Processing=function(be,ba){if(!(this instanceof F)){throw\"called Processing constructor as if it were a function: missing 'new'.\"}var ae,cV=be===t&&ba===t;if(cV){ae=d.createElement(\"canvas\")}else{ae=typeof be===\"string\"?d.getElementById(be):be}if(!(ae instanceof HTMLCanvasElement)){throw\"called Processing constructor without passing canvas element reference or id.\"}function dw(ea){F.debug(\"Unimplemented - \"+ea)}var cW=this;cW.externals={canvas:ae,context:t,sketch:t};cW.name=\"Processing.js Instance\";cW.use3DContext=false;cW.focused=false;cW.breakShape=false;cW.glyphTable={};cW.pmouseX=0;cW.pmouseY=0;cW.mouseX=0;cW.mouseY=0;cW.mouseButton=0;cW.mouseScroll=0;cW.mouseClicked=t;cW.mouseDragged=t;cW.mouseMoved=t;cW.mousePressed=t;cW.mouseReleased=t;cW.mouseScrolled=t;cW.mouseOver=t;cW.mouseOut=t;cW.touchStart=t;cW.touchEnd=t;cW.touchMove=t;cW.touchCancel=t;cW.key=t;cW.keyCode=t;cW.keyPressed=G;cW.keyReleased=G;cW.keyTyped=G;cW.draw=t;cW.setup=t;cW.__mousePressed=false;cW.__keyPressed=false;cW.__frameRate=60;cW.frameCount=0;cW.width=100;cW.height=100;var d8,cQ,dY,bD=true,aH=true,bo=[1,1,1,1],a1=4294967295,aq=true,ce=true,c0=[0,0,0,1],cv=4278190080,b3=true,dW=1,ax=false,dO=false,aC=true,b4=0,bK=0,cN=3,a8=0,a7=0,a6=0,a2=0,dU=60,az=1000/dU,Z=\"default\",ck=ae.style.cursor,dR=20,cj=0,d6=[],aJ=0,Q=20,cM=false,a4=-3355444,cy=20,bU=255,bJ=255,bI=255,bG=255,cZ=false,aK=false,dN=0,d5=0,cY=1,bf=null,bw=null,a5=false,dq=Date.now(),dt=dq,P=0,cE,c3,aQ,aL,bz,cd,U,dC={attributes:{},locations:{}},dx,dQ,bT,bh,cJ,dk,aB,b2,bg,b8,at,aG,bC,aw,af,c7,bS,cs={width:0,height:0},d4=2,dT=false,cH,ac,R,N=37,c1=0,cI=4,Y=\"Arial\",d0=12,a3=9,dA=2,d7=14,W=H.get(Y,d0),aj,cn=null,dV=false,d3,bZ=1000,ag=[],dI=null,dX=[16,17,18,20,33,34,35,36,37,38,39,40,144,155,112,113,114,115,116,117,118,119,120,121,122,123,157];var ad,dp,aU,bX;if(d.defaultView&&d.defaultView.getComputedStyle){ad=parseInt(d.defaultView.getComputedStyle(ae,null)[\"paddingLeft\"],10)||0;dp=parseInt(d.defaultView.getComputedStyle(ae,null)[\"paddingTop\"],10)||0;aU=parseInt(d.defaultView.getComputedStyle(ae,null)[\"borderLeftWidth\"],10)||0;bX=parseInt(d.defaultView.getComputedStyle(ae,null)[\"borderTopWidth\"],10)||0}var dL=0;var bL=0,bM=0,bt=[],bs=[],br=[],ah=new e(720),bl=new e(720),cF,cA;var bV,ch,dJ,aT,am,da,ab,db,ap=false,ci=false,cK=60*(q.PI/180),dl=cW.width/2,dj=cW.height/2,di=dj/q.tan(cK/2),a0=di/10,av=di*10,b5=cW.width/cW.height;var bb=[],cb=[],c2=0,dP=false,aa=false,du=true;var S=0;var bm=[];var dh=new e([0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,-0.5,0.5,0.5,-0.5,0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,0.5,-0.5,0.5,0.5,0.5,0.5,0.5,0.5,-0.5,0.5,0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5,0.5,-0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,-0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,0.5,0.5,0.5,0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,0.5,0.5,0.5,0.5]);var bH=new e([0.5,0.5,0.5,0.5,-0.5,0.5,0.5,0.5,-0.5,0.5,-0.5,-0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,0.5,-0.5,-0.5,0.5,0.5,0.5,0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,0.5,-0.5,0.5,0.5,0.5,0.5,0.5,0.5,-0.5,0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,0.5,-0.5,0.5]);var df=new e([0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0]);var ak=new e([0,0,0,0,1,0,1,1,0,1,0,0]);var ai=new e([0,0,1,0,0,1,0,0,1,0,0,1]);var aO=\"varying vec4 vFrontColor;attribute vec3 aVertex;attribute vec4 aColor;uniform mat4 uView;uniform mat4 uProjection;uniform float uPointSize;void main(void) {  vFrontColor = aColor;  gl_PointSize = uPointSize;  gl_Position = uProjection * uView * vec4(aVertex, 1.0);}\";var bQ=\"#ifdef GL_ES\\nprecision highp float;\\n#endif\\nvarying vec4 vFrontColor;uniform bool uSmooth;void main(void){  if(uSmooth == true){    float dist = distance(gl_PointCoord, vec2(0.5));    if(dist > 0.5){      discard;    }  }  gl_FragColor = vFrontColor;}\";var dE=\"varying vec4 vFrontColor;attribute vec3 aVertex;attribute vec2 aTextureCoord;uniform vec4 uColor;uniform mat4 uModel;uniform mat4 uView;uniform mat4 uProjection;uniform float uPointSize;varying vec2 vTextureCoord;void main(void) {  gl_PointSize = uPointSize;  vFrontColor = uColor;  gl_Position = uProjection * uView * uModel * vec4(aVertex, 1.0);  vTextureCoord = aTextureCoord;}\";var aW=\"#ifdef GL_ES\\nprecision highp float;\\n#endif\\nvarying vec4 vFrontColor;varying vec2 vTextureCoord;uniform sampler2D uSampler;uniform int uIsDrawingText;uniform bool uSmooth;void main(void){  if(uSmooth == true){    float dist = distance(gl_PointCoord, vec2(0.5));    if(dist > 0.5){      discard;    }  }  if(uIsDrawingText == 1){    float alpha = texture2D(uSampler, vTextureCoord).a;    gl_FragColor = vec4(vFrontColor.rgb * alpha, alpha);  }  else{    gl_FragColor = vFrontColor;  }}\";var bA=/Windows/.test(navigator.userAgent);var dn=\"varying vec4 vFrontColor;attribute vec3 aVertex;attribute vec3 aNormal;attribute vec4 aColor;attribute vec2 aTexture;varying   vec2 vTexture;uniform vec4 uColor;uniform bool uUsingMat;uniform vec3 uSpecular;uniform vec3 uMaterialEmissive;uniform vec3 uMaterialAmbient;uniform vec3 uMaterialSpecular;uniform float uShininess;uniform mat4 uModel;uniform mat4 uView;uniform mat4 uProjection;uniform mat4 uNormalTransform;uniform int uLightCount;uniform vec3 uFalloff;struct Light {  int type;  vec3 color;  vec3 position;  vec3 direction;  float angle;  vec3 halfVector;  float concentration;};uniform Light uLights0;uniform Light uLights1;uniform Light uLights2;uniform Light uLights3;uniform Light uLights4;uniform Light uLights5;uniform Light uLights6;uniform Light uLights7;Light getLight(int index){  if(index == 0) return uLights0;  if(index == 1) return uLights1;  if(index == 2) return uLights2;  if(index == 3) return uLights3;  if(index == 4) return uLights4;  if(index == 5) return uLights5;  if(index == 6) return uLights6;  return uLights7;}void AmbientLight( inout vec3 totalAmbient, in vec3 ecPos, in Light light ) {  float d = length( light.position - ecPos );  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ));  totalAmbient += light.color * attenuation;}void DirectionalLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {  float powerFactor = 0.0;  float nDotVP = max(0.0, dot( vertNormal, normalize(-light.position) ));  float nDotVH = max(0.0, dot( vertNormal, normalize(-light.position-normalize(ecPos) )));  if( nDotVP != 0.0 ){    powerFactor = pow( nDotVH, uShininess );  }  col += light.color * nDotVP;  spec += uSpecular * powerFactor;}void PointLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {  float powerFactor;   vec3 VP = light.position - ecPos;  float d = length( VP );   VP = normalize( VP );  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ));  float nDotVP = max( 0.0, dot( vertNormal, VP ));  vec3 halfVector = normalize( VP - normalize(ecPos) );  float nDotHV = max( 0.0, dot( vertNormal, halfVector ));  if( nDotVP == 0.0 ) {    powerFactor = 0.0;  }  else {    powerFactor = pow( nDotHV, uShininess );  }  spec += uSpecular * powerFactor * attenuation;  col += light.color * nDotVP * attenuation;}void SpotLight( inout vec3 col, inout vec3 spec, in vec3 vertNormal, in vec3 ecPos, in Light light ) {  float spotAttenuation;  float powerFactor = 0.0;  vec3 VP = light.position - ecPos;  vec3 ldir = normalize( -light.direction );  float d = length( VP );  VP = normalize( VP );  float attenuation = 1.0 / ( uFalloff[0] + ( uFalloff[1] * d ) + ( uFalloff[2] * d * d ) );  float spotDot = dot( VP, ldir );\"+(bA?\"  spotAttenuation = 1.0; \":\"  if( spotDot > cos( light.angle ) ) {    spotAttenuation = pow( spotDot, light.concentration );  }  else{    spotAttenuation = 0.0;  }  attenuation *= spotAttenuation;\")+\"  float nDotVP = max( 0.0, dot( vertNormal, VP ) );  vec3 halfVector = normalize( VP - normalize(ecPos) );  float nDotHV = max( 0.0, dot( vertNormal, halfVector ) );  if( nDotVP != 0.0 ) {    powerFactor = pow( nDotHV, uShininess );  }  spec += uSpecular * powerFactor * attenuation;  col += light.color * nDotVP * attenuation;}void main(void) {  vec3 finalAmbient = vec3( 0.0 );  vec3 finalDiffuse = vec3( 0.0 );  vec3 finalSpecular = vec3( 0.0 );  vec4 col = uColor;  if ( uColor[0] == -1.0 ){    col = aColor;  }  vec3 norm = normalize(vec3( uNormalTransform * vec4( aNormal, 0.0 ) ));  vec4 ecPos4 = uView * uModel * vec4(aVertex, 1.0);  vec3 ecPos = (vec3(ecPos4))/ecPos4.w;  if( uLightCount == 0 ) {    vFrontColor = col + vec4(uMaterialSpecular, 1.0);  }  else {    for( int i = 0; i < 8; i++ ) {      Light l = getLight(i);      if( i >= uLightCount ){        break;      }      if( l.type == 0 ) {        AmbientLight( finalAmbient, ecPos, l );      }      else if( l.type == 1 ) {        DirectionalLight( finalDiffuse, finalSpecular, norm, ecPos, l );      }      else if( l.type == 2 ) {        PointLight( finalDiffuse, finalSpecular, norm, ecPos, l );      }      else {        SpotLight( finalDiffuse, finalSpecular, norm, ecPos, l );      }    }   if( uUsingMat == false ) {     vFrontColor = vec4(       vec3( col ) * finalAmbient +       vec3( col ) * finalDiffuse +       vec3( col ) * finalSpecular,       col[3] );   }   else{     vFrontColor = vec4(        uMaterialEmissive +        (vec3(col) * uMaterialAmbient * finalAmbient ) +        (vec3(col) * finalDiffuse) +        (uMaterialSpecular * finalSpecular),        col[3] );    }  }  vTexture.xy = aTexture.xy;  gl_Position = uProjection * uView * uModel * vec4( aVertex, 1.0 );}\";var aF=\"#ifdef GL_ES\\nprecision highp float;\\n#endif\\nvarying vec4 vFrontColor;uniform sampler2D uSampler;uniform bool uUsingTexture;varying vec2 vTexture;void main(void){  if( uUsingTexture ){    gl_FragColor = vec4(texture2D(uSampler, vTexture.xy)) * vFrontColor;  }  else{    gl_FragColor = vFrontColor;  }}\";function d2(ec,eb,ee,ed){var ea=dC.locations[ec];if(ea===t){ea=d8.getUniformLocation(eb,ee);dC.locations[ec]=ea}if(ea!==null){if(ed.length===4){d8.uniform4fv(ea,ed)}else{if(ed.length===3){d8.uniform3fv(ea,ed)}else{if(ed.length===2){d8.uniform2fv(ea,ed)}else{d8.uniform1f(ea,ed)}}}}}function dZ(ec,eb,ee,ed){var ea=dC.locations[ec];if(ea===t){ea=d8.getUniformLocation(eb,ee);dC.locations[ec]=ea}if(ea!==null){if(ed.length===4){d8.uniform4iv(ea,ed)}else{if(ed.length===3){d8.uniform3iv(ea,ed)}else{if(ed.length===2){d8.uniform2iv(ea,ed)}else{d8.uniform1i(ea,ed)}}}}}function a9(ee,ec,ef,ed,eb){var ea=dC.locations[ee];if(ea===t){ea=d8.getUniformLocation(ec,ef);dC.locations[ee]=ea}if(ea!==-1){if(eb.length===16){d8.uniformMatrix4fv(ea,ed,eb)}else{if(eb.length===9){d8.uniformMatrix3fv(ea,ed,eb)}else{d8.uniformMatrix2fv(ea,ed,eb)}}}}function dc(ee,ec,ef,eb,ed){var ea=dC.attributes[ee];if(ea===t){ea=d8.getAttribLocation(ec,ef);dC.attributes[ee]=ea}if(ea!==-1){d8.bindBuffer(d8.ARRAY_BUFFER,ed);d8.vertexAttribPointer(ea,eb,d8.FLOAT,false,0,0);d8.enableVertexAttribArray(ea)}}function cg(ec,eb,ed){var ea=dC.attributes[ec];if(ea===t){ea=d8.getAttribLocation(eb,ed);dC.attributes[ec]=ea}if(ea!==-1){d8.disableVertexAttribArray(ea)}}var bF=function(ec,ee,eb){var ef=ec.createShader(ec.VERTEX_SHADER);ec.shaderSource(ef,ee);ec.compileShader(ef);if(!ec.getShaderParameter(ef,ec.COMPILE_STATUS)){throw ec.getShaderInfoLog(ef)}var ed=ec.createShader(ec.FRAGMENT_SHADER);ec.shaderSource(ed,eb);ec.compileShader(ed);if(!ec.getShaderParameter(ed,ec.COMPILE_STATUS)){throw ec.getShaderInfoLog(ed)}var ea=ec.createProgram();ec.attachShader(ea,ef);ec.attachShader(ea,ed);ec.linkProgram(ea);if(!ec.getProgramParameter(ea,ec.LINK_STATUS)){throw\"Error linking shaders.\"}return ea};var aZ=function(ea,ee,eb,ed,ec){return{x:ea,y:ee,w:eb,h:ed}};var bk=aZ;var b1=function(ea,ee,eb,ed,ec){return{x:ea,y:ee,w:ec?eb:eb-ea,h:ec?ed:ed-ee}};var aN=function(ea,ee,eb,ed,ec){return{x:ea-eb/2,y:ee-ed/2,w:eb,h:ed}};var ds=function(){};var bR=function(){};var bB=function(){};var ca=function(){};bR.prototype=new ds;bR.prototype.constructor=bR;bB.prototype=new ds;bB.prototype.constructor=bB;ca.prototype=new ds;ca.prototype.constructor=ca;ds.prototype.a3DOnlyFunction=G;var cl={};var bP=cW.Character=function(ea){if(typeof ea===\"string\"&&ea.length===1){this.code=ea.charCodeAt(0)}else{if(typeof ea===\"number\"){this.code=ea}else{if(ea instanceof bP){this.code=ea}else{this.code=NaN}}}return cl[this.code]===t?cl[this.code]=this:cl[this.code]};bP.prototype.toString=function(){return String.fromCharCode(this.code)};bP.prototype.valueOf=function(){return this.code};var O=cW.PShape=function(ea){this.family=ea||0;this.visible=true;this.style=true;this.children=[];this.nameTable=[];this.params=[];this.name=\"\";this.image=null;this.matrix=null;this.kind=null;this.close=null;this.width=null;this.height=null;this.parent=null};O.prototype={isVisible:function(){return this.visible},setVisible:function(ea){this.visible=ea},disableStyle:function(){this.style=false;for(var eb=0,ea=this.children.length;eb<ea;eb++){this.children[eb].disableStyle()}},enableStyle:function(){this.style=true;for(var eb=0,ea=this.children.length;eb<ea;eb++){this.children[eb].enableStyle()}},getFamily:function(){return this.family},getWidth:function(){return this.width},getHeight:function(){return this.height},setName:function(ea){this.name=ea},getName:function(){return this.name},draw:function(ea){ea=ea||cW;if(this.visible){this.pre(ea);this.drawImpl(ea);this.post(ea)}},drawImpl:function(ea){if(this.family===0){this.drawGroup(ea)}else{if(this.family===1){this.drawPrimitive(ea)}else{if(this.family===3){this.drawGeometry(ea)}else{if(this.family===21){this.drawPath(ea)}}}}},drawPath:function(ec){var ed,eb;if(this.vertices.length===0){return}ec.beginShape();if(this.vertexCodes.length===0){if(this.vertices[0].length===2){for(ed=0,eb=this.vertices.length;ed<eb;ed++){ec.vertex(this.vertices[ed][0],this.vertices[ed][1])}}else{for(ed=0,eb=this.vertices.length;ed<eb;ed++){ec.vertex(this.vertices[ed][0],this.vertices[ed][1],this.vertices[ed][2])}}}else{var ea=0;if(this.vertices[0].length===2){for(ed=0,eb=this.vertexCodes.length;ed<eb;ed++){if(this.vertexCodes[ed]===0){ec.vertex(this.vertices[ea][0],this.vertices[ea][1],this.vertices[ea][\"moveTo\"]);ec.breakShape=false;ea++}else{if(this.vertexCodes[ed]===1){ec.bezierVertex(this.vertices[ea+0][0],this.vertices[ea+0][1],this.vertices[ea+1][0],this.vertices[ea+1][1],this.vertices[ea+2][0],this.vertices[ea+2][1]);ea+=3}else{if(this.vertexCodes[ed]===2){ec.curveVertex(this.vertices[ea][0],this.vertices[ea][1]);ea++}else{if(this.vertexCodes[ed]===3){ec.breakShape=true}}}}}}else{for(ed=0,eb=this.vertexCodes.length;ed<eb;ed++){if(this.vertexCodes[ed]===0){ec.vertex(this.vertices[ea][0],this.vertices[ea][1],this.vertices[ea][2]);if(this.vertices[ea][\"moveTo\"]===true){bb[bb.length-1][\"moveTo\"]=true}else{if(this.vertices[ea][\"moveTo\"]===false){bb[bb.length-1][\"moveTo\"]=false}}ec.breakShape=false}else{if(this.vertexCodes[ed]===1){ec.bezierVertex(this.vertices[ea+0][0],this.vertices[ea+0][1],this.vertices[ea+0][2],this.vertices[ea+1][0],this.vertices[ea+1][1],this.vertices[ea+1][2],this.vertices[ea+2][0],this.vertices[ea+2][1],this.vertices[ea+2][2]);ea+=3}else{if(this.vertexCodes[ed]===2){ec.curveVertex(this.vertices[ea][0],this.vertices[ea][1],this.vertices[ea][2]);ea++}else{if(this.vertexCodes[ed]===3){ec.breakShape=true}}}}}}}ec.endShape(this.close?2:1)},drawGeometry:function(ec){var ed,eb;ec.beginShape(this.kind);if(this.style){for(ed=0,eb=this.vertices.length;ed<eb;ed++){ec.vertex(this.vertices[ed])}}else{for(ed=0,eb=this.vertices.length;ed<eb;ed++){var ea=this.vertices[ed];if(ea[2]===0){ec.vertex(ea[0],ea[1])}else{ec.vertex(ea[0],ea[1],ea[2])}}}ec.endShape()},drawGroup:function(eb){for(var ec=0,ea=this.children.length;ec<ea;ec++){this.children[ec].draw(eb)}},drawPrimitive:function(ea){if(this.kind===2){ea.point(this.params[0],this.params[1])}else{if(this.kind===4){if(this.params.length===4){ea.line(this.params[0],this.params[1],this.params[2],this.params[3])}else{ea.line(this.params[0],this.params[1],this.params[2],this.params[3],this.params[4],this.params[5])}}else{if(this.kind===8){ea.triangle(this.params[0],this.params[1],this.params[2],this.params[3],this.params[4],this.params[5])}else{if(this.kind===16){ea.quad(this.params[0],this.params[1],this.params[2],this.params[3],this.params[4],this.params[5],this.params[6],this.params[7])}else{if(this.kind===30){if(this.image!==null){var ee=bk;ea.imageMode(0);ea.image(this.image,this.params[0],this.params[1],this.params[2],this.params[3]);bk=ee}else{var eb=bK;ea.rectMode(0);ea.rect(this.params[0],this.params[1],this.params[2],this.params[3]);bK=eb}}else{if(this.kind===31){var ec=cN;ea.ellipseMode(0);ea.ellipse(this.params[0],this.params[1],this.params[2],this.params[3]);cN=ec}else{if(this.kind===32){var ed=cN;ea.ellipseMode(0);ea.arc(this.params[0],this.params[1],this.params[2],this.params[3],this.params[4],this.params[5]);cN=ed}else{if(this.kind===41){if(this.params.length===1){ea.box(this.params[0])}else{ea.box(this.params[0],this.params[1],this.params[2])}}else{if(this.kind===40){ea.sphere(this.params[0])}}}}}}}}}},pre:function(ea){if(this.matrix){ea.pushMatrix();ea.transform(this.matrix)}if(this.style){ea.pushStyle();this.styles(ea)}},post:function(ea){if(this.matrix){ea.popMatrix()}if(this.style){ea.popStyle()}},styles:function(ea){if(this.stroke){ea.stroke(this.strokeColor);ea.strokeWeight(this.strokeWeight);ea.strokeCap(this.strokeCap);ea.strokeJoin(this.strokeJoin)}else{ea.noStroke()}if(this.fill){ea.fill(this.fillColor)}else{ea.noFill()}},getChild:function(ed){var eb,ea;if(typeof ed===\"number\"){return this.children[ed]}var ec;if(ed===\"\"||this.name===ed){return this}if(this.nameTable.length>0){for(eb=0,ea=this.nameTable.length;eb<ea||ec;eb++){if(this.nameTable[eb].getName===ed){ec=this.nameTable[eb];break}}if(ec){return ec}}for(eb=0,ea=this.children.length;eb<ea;eb++){ec=this.children[eb].getChild(ed);if(ec){return ec}}return null},getChildCount:function(){return this.children.length},addChild:function(ea){this.children.push(ea);ea.parent=this;if(ea.getName()!==null){this.addName(ea.getName(),ea)}},addName:function(eb,ea){if(this.parent!==null){this.parent.addName(eb,ea)}else{this.nameTable.push([eb,ea])}},translate:function(){if(arguments.length===2){this.checkMatrix(2);this.matrix.translate(arguments[0],arguments[1])}else{this.checkMatrix(3);this.matrix.translate(arguments[0],arguments[1],0)}},checkMatrix:function(ea){if(this.matrix===null){if(ea===2){this.matrix=new cW.PMatrix2D}else{this.matrix=new cW.PMatrix3D}}else{if(ea===3&&this.matrix instanceof cW.PMatrix2D){this.matrix=new cW.PMatrix3D}}},rotateX:function(ea){this.rotate(ea,1,0,0)},rotateY:function(ea){this.rotate(ea,0,1,0)},rotateZ:function(ea){this.rotate(ea,0,0,1)},rotate:function(){if(arguments.length===1){this.checkMatrix(2);this.matrix.rotate(arguments[0])}else{this.checkMatrix(3);this.matrix.rotate(arguments[0],arguments[1],arguments[2],arguments[3])}},scale:function(){if(arguments.length===2){this.checkMatrix(2);this.matrix.scale(arguments[0],arguments[1])}else{if(arguments.length===3){this.checkMatrix(2);this.matrix.scale(arguments[0],arguments[1],arguments[2])}else{this.checkMatrix(2);this.matrix.scale(arguments[0])}}},resetMatrix:function(){this.checkMatrix(2);this.matrix.reset()},applyMatrix:function(ea){if(arguments.length===1){this.applyMatrix(ea.elements[0],ea.elements[1],0,ea.elements[2],ea.elements[3],ea.elements[4],0,ea.elements[5],0,0,1,0,0,0,0,1)}else{if(arguments.length===6){this.checkMatrix(2);this.matrix.apply(arguments[0],arguments[1],arguments[2],0,arguments[3],arguments[4],arguments[5],0,0,0,1,0,0,0,0,1)}else{if(arguments.length===16){this.checkMatrix(3);this.matrix.apply(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11],arguments[12],arguments[13],arguments[14],arguments[15])}}}}};var cr=cW.PShapeSVG=function(){cW.PShape.call(this);if(arguments.length===1){this.element=arguments[0];this.vertexCodes=[];this.vertices=[];this.opacity=1;this.stroke=false;this.strokeColor=4278190080;this.strokeWeight=1;this.strokeCap=\"butt\";this.strokeJoin=\"miter\";this.strokeGradient=null;this.strokeGradientPaint=null;this.strokeName=null;this.strokeOpacity=1;this.fill=true;this.fillColor=4278190080;this.fillGradient=null;this.fillGradientPaint=null;this.fillName=null;this.fillOpacity=1;if(this.element.getName()!==\"svg\"){throw\"root is not <svg>, it's <\"+this.element.getName()+\">\"}}else{if(arguments.length===2){if(typeof arguments[1]===\"string\"){if(arguments[1].indexOf(\".svg\")>-1){this.element=new cW.XMLElement(cW,arguments[1]);this.vertexCodes=[];this.vertices=[];this.opacity=1;this.stroke=false;this.strokeColor=4278190080;this.strokeWeight=1;this.strokeCap=\"butt\";this.strokeJoin=\"miter\";this.strokeGradient=\"\";this.strokeGradientPaint=\"\";this.strokeName=\"\";this.strokeOpacity=1;this.fill=true;this.fillColor=4278190080;this.fillGradient=null;this.fillGradientPaint=null;this.fillOpacity=1}}else{if(arguments[0]){this.element=arguments[1];this.vertexCodes=arguments[0].vertexCodes.slice();this.vertices=arguments[0].vertices.slice();this.stroke=arguments[0].stroke;this.strokeColor=arguments[0].strokeColor;this.strokeWeight=arguments[0].strokeWeight;this.strokeCap=arguments[0].strokeCap;this.strokeJoin=arguments[0].strokeJoin;this.strokeGradient=arguments[0].strokeGradient;this.strokeGradientPaint=arguments[0].strokeGradientPaint;this.strokeName=arguments[0].strokeName;this.fill=arguments[0].fill;this.fillColor=arguments[0].fillColor;this.fillGradient=arguments[0].fillGradient;this.fillGradientPaint=arguments[0].fillGradientPaint;this.fillName=arguments[0].fillName;this.strokeOpacity=arguments[0].strokeOpacity;this.fillOpacity=arguments[0].fillOpacity;this.opacity=arguments[0].opacity}}}}this.name=this.element.getStringAttribute(\"id\");var ea=this.element.getStringAttribute(\"display\",\"inline\");this.visible=ea!==\"none\";var ef=this.element.getAttribute(\"transform\");if(ef){this.matrix=this.parseMatrix(ef)}var ec=this.element.getStringAttribute(\"viewBox\");if(ec!==null){var ee=ec.split(\" \");this.width=ee[2];this.height=ee[3]}var eb=this.element.getStringAttribute(\"width\");var ed=this.element.getStringAttribute(\"height\");if(eb!==null){this.width=this.parseUnitSize(eb);this.height=this.parseUnitSize(ed)}else{if(this.width===0||this.height===0){this.width=1;this.height=1;throw\"The width and/or height is not readable in the <svg> tag of this file.\"}}this.parseColors(this.element);this.parseChildren(this.element)};cr.prototype=new O;cr.prototype.parseMatrix=function(){function ea(ec){var eb=[];ec.replace(/\\((.*?)\\)/,function(){return function(ed,ee){eb=ee.replace(/,+/g,\" \").split(/\\s+/)}}());return eb}return function(ei){this.checkMatrix(2);var eb=[];ei.replace(/\\s*(\\w+)\\((.*?)\\)/g,function(el){eb.push(cW.trim(el))});if(eb.length===0){return null}for(var eg=0,ee=eb.length;eg<ee;eg++){var ec=ea(eb[eg]);if(eb[eg].indexOf(\"matrix\")!==-1){this.matrix.set(ec[0],ec[2],ec[4],ec[1],ec[3],ec[5])}else{if(eb[eg].indexOf(\"translate\")!==-1){var eh=ec[0];var ef=ec.length===2?ec[1]:0;this.matrix.translate(eh,ef)}else{if(eb[eg].indexOf(\"scale\")!==-1){var ek=ec[0];var ej=ec.length===2?ec[1]:ec[0];this.matrix.scale(ek,ej)}else{if(eb[eg].indexOf(\"rotate\")!==-1){var ed=ec[0];if(ec.length===1){this.matrix.rotate(cW.radians(ed))}else{if(ec.length===3){this.matrix.translate(ec[1],ec[2]);this.matrix.rotate(cW.radians(ec[0]));this.matrix.translate(-ec[1],-ec[2])}}}else{if(eb[eg].indexOf(\"skewX\")!==-1){this.matrix.skewX(parseFloat(ec[0]))}else{if(eb[eg].indexOf(\"skewY\")!==-1){this.matrix.skewY(ec[0])}else{if(eb[eg].indexOf(\"shearX\")!==-1){this.matrix.shearX(ec[0])}else{if(eb[eg].indexOf(\"shearY\")!==-1){this.matrix.shearY(ec[0])}}}}}}}}}return this.matrix}}();cr.prototype.parseChildren=function(ef){var eb=ef.getChildren();var ee=new cW.PShape;for(var ed=0,ec=eb.length;ed<ec;ed++){var ea=this.parseChild(eb[ed]);if(ea){ee.addChild(ea)}}this.children.push(ee)};cr.prototype.getName=function(){return this.name};cr.prototype.parseChild=function(ec){var eb=ec.getName();var ea;if(eb===\"g\"){ea=new cr(this,ec)}else{if(eb===\"defs\"){ea=new cr(this,ec)}else{if(eb===\"line\"){ea=new cr(this,ec);ea.parseLine()}else{if(eb===\"circle\"){ea=new cr(this,ec);ea.parseEllipse(true)}else{if(eb===\"ellipse\"){ea=new cr(this,ec);ea.parseEllipse(false)}else{if(eb===\"rect\"){ea=new cr(this,ec);ea.parseRect()}else{if(eb===\"polygon\"){ea=new cr(this,ec);ea.parsePoly(true)}else{if(eb===\"polyline\"){ea=new cr(this,ec);ea.parsePoly(false)}else{if(eb===\"path\"){ea=new cr(this,ec);ea.parsePath()}else{if(eb===\"radialGradient\"){dw(\"PShapeSVG.prototype.parseChild, name = radialGradient\")}else{if(eb===\"linearGradient\"){dw(\"PShapeSVG.prototype.parseChild, name = linearGradient\")}else{if(eb===\"text\"){dw(\"PShapeSVG.prototype.parseChild, name = text\")}else{if(eb===\"filter\"){dw(\"PShapeSVG.prototype.parseChild, name = filter\")}else{if(eb===\"mask\"){dw(\"PShapeSVG.prototype.parseChild, name = mask\")}else{G()}}}}}}}}}}}}}}return ea};cr.prototype.parsePath=function(){this.family=21;this.kind=0;var ef=[];var ez;var ey=cW.trim(this.element.getStringAttribute(\"d\").replace(/[\\s,]+/g,\" \"));if(ey===null){return}ey=cW.__toCharArray(ey);var ed=0,ec=0,ek=0,ei=0,ej=0,eh=0,eq=0,ep=0,eb=0,ea=0,em=0,el=0,eo=0,en=0,ex=0,et=0;var er=\"\";var ev=[];var ew=false;var eg;var ee;var eu,es;while(ex<ey.length){et=ey[ex].valueOf();if(et>=65&&et<=90||et>=97&&et<=122){eu=ex;ex++;if(ex<ey.length){ev=[];et=ey[ex].valueOf();while(!(et>=65&&et<=90||et>=97&&et<=100||et>=102&&et<=122)&&ew===false){if(et===32){if(er!==\"\"){ev.push(parseFloat(er));er=\"\"}ex++}else{if(et===45){if(ey[ex-1].valueOf()===101){er+=ey[ex].toString();ex++}else{if(er!==\"\"){ev.push(parseFloat(er))}er=ey[ex].toString();ex++}}else{er+=ey[ex].toString();ex++}}if(ex===ey.length){ew=true}else{et=ey[ex].valueOf()}}}if(er!==\"\"){ev.push(parseFloat(er));er=\"\"}ee=ey[eu];et=ee.valueOf();if(et===77){if(ev.length>=2&&ev.length%2===0){ed=ev[0];ec=ev[1];this.parsePathMoveto(ed,ec);if(ev.length>2){for(eu=2,es=ev.length;eu<es;eu+=2){ed=ev[eu];ec=ev[eu+1];this.parsePathLineto(ed,ec)}}}}else{if(et===109){if(ev.length>=2&&ev.length%2===0){ed+=ev[0];ec+=ev[1];this.parsePathMoveto(ed,ec);if(ev.length>2){for(eu=2,es=ev.length;eu<es;eu+=2){ed+=ev[eu];ec+=ev[eu+1];this.parsePathLineto(ed,ec)}}}}else{if(et===76){if(ev.length>=2&&ev.length%2===0){for(eu=0,es=ev.length;eu<es;eu+=2){ed=ev[eu];ec=ev[eu+1];this.parsePathLineto(ed,ec)}}}else{if(et===108){if(ev.length>=2&&ev.length%2===0){for(eu=0,es=ev.length;eu<es;eu+=2){ed+=ev[eu];ec+=ev[eu+1];this.parsePathLineto(ed,ec)}}}else{if(et===72){for(eu=0,es=ev.length;eu<es;eu++){ed=ev[eu];this.parsePathLineto(ed,ec)}}else{if(et===104){for(eu=0,es=ev.length;eu<es;eu++){ed+=ev[eu];this.parsePathLineto(ed,ec)}}else{if(et===86){for(eu=0,es=ev.length;eu<es;eu++){ec=ev[eu];this.parsePathLineto(ed,ec)}}else{if(et===118){for(eu=0,es=ev.length;eu<es;eu++){ec+=ev[eu];this.parsePathLineto(ed,ec)}}else{if(et===67){if(ev.length>=6&&ev.length%6===0){for(eu=0,es=ev.length;eu<es;eu+=6){ej=ev[eu];eq=ev[eu+1];eh=ev[eu+2];ep=ev[eu+3];eb=ev[eu+4];ea=ev[eu+5];this.parsePathCurveto(ej,eq,eh,ep,eb,ea);ed=eb;ec=ea}}}else{if(et===99){if(ev.length>=6&&ev.length%6===0){for(eu=0,es=ev.length;eu<es;eu+=6){ej=ed+ev[eu];eq=ec+ev[eu+1];eh=ed+ev[eu+2];ep=ec+ev[eu+3];eb=ed+ev[eu+4];ea=ec+ev[eu+5];this.parsePathCurveto(ej,eq,eh,ep,eb,ea);ed=eb;ec=ea}}}else{if(et===83){if(ev.length>=4&&ev.length%4===0){for(eu=0,es=ev.length;eu<es;eu+=4){if(eg.toLowerCase()===\"c\"||eg.toLowerCase()===\"s\"){em=this.vertices[this.vertices.length-2][0];el=this.vertices[this.vertices.length-2][1];eo=this.vertices[this.vertices.length-1][0];en=this.vertices[this.vertices.length-1][1];ej=eo+(eo-em);eq=en+(en-el)}else{ej=this.vertices[this.vertices.length-1][0];eq=this.vertices[this.vertices.length-1][1]}eh=ev[eu];ep=ev[eu+1];eb=ev[eu+2];ea=ev[eu+3];this.parsePathCurveto(ej,eq,eh,ep,eb,ea);ed=eb;ec=ea}}}else{if(et===115){if(ev.length>=4&&ev.length%4===0){for(eu=0,es=ev.length;eu<es;eu+=4){if(eg.toLowerCase()===\"c\"||eg.toLowerCase()===\"s\"){em=this.vertices[this.vertices.length-2][0];el=this.vertices[this.vertices.length-2][1];eo=this.vertices[this.vertices.length-1][0];en=this.vertices[this.vertices.length-1][1];ej=eo+(eo-em);eq=en+(en-el)}else{ej=this.vertices[this.vertices.length-1][0];eq=this.vertices[this.vertices.length-1][1]}eh=ed+ev[eu];ep=ec+ev[eu+1];eb=ed+ev[eu+2];ea=ec+ev[eu+3];this.parsePathCurveto(ej,eq,eh,ep,eb,ea);ed=eb;ec=ea}}}else{if(et===81){if(ev.length>=4&&ev.length%4===0){for(eu=0,es=ev.length;eu<es;eu+=4){ek=ev[eu];ei=ev[eu+1];eb=ev[eu+2];ea=ev[eu+3];this.parsePathQuadto(ed,ec,ek,ei,eb,ea);ed=eb;ec=ea}}}else{if(et===113){if(ev.length>=4&&ev.length%4===0){for(eu=0,es=ev.length;eu<es;eu+=4){ek=ed+ev[eu];ei=ec+ev[eu+1];eb=ed+ev[eu+2];ea=ec+ev[eu+3];this.parsePathQuadto(ed,ec,ek,ei,eb,ea);ed=eb;ec=ea}}}else{if(et===84){if(ev.length>=2&&ev.length%2===0){for(eu=0,es=ev.length;eu<es;eu+=2){if(eg.toLowerCase()===\"q\"||eg.toLowerCase()===\"t\"){em=this.vertices[this.vertices.length-2][0];el=this.vertices[this.vertices.length-2][1];eo=this.vertices[this.vertices.length-1][0];en=this.vertices[this.vertices.length-1][1];ek=eo+(eo-em);ei=en+(en-el)}else{ek=ed;ei=ec}eb=ev[eu];ea=ev[eu+1];this.parsePathQuadto(ed,ec,ek,ei,eb,ea);ed=eb;ec=ea}}}else{if(et===116){if(ev.length>=2&&ev.length%2===0){for(eu=0,es=ev.length;eu<es;eu+=2){if(eg.toLowerCase()===\"q\"||eg.toLowerCase()===\"t\"){em=this.vertices[this.vertices.length-2][0];el=this.vertices[this.vertices.length-2][1];eo=this.vertices[this.vertices.length-1][0];en=this.vertices[this.vertices.length-1][1];ek=eo+(eo-em);ei=en+(en-el)}else{ek=ed;ei=ec}eb=ed+ev[eu];ea=ec+ev[eu+1];this.parsePathQuadto(ed,ec,ek,ei,eb,ea);ed=eb;ec=ea}}}else{if(et===90||et===122){this.close=true}}}}}}}}}}}}}}}}}eg=ee.toString()}else{ex++}}};cr.prototype.parsePathQuadto=function(ec,ee,ea,ef,eb,ed){if(this.vertices.length>0){this.parsePathCode(1);this.parsePathVertex(ec+(ea-ec)*2/3,ee+(ef-ee)*2/3);this.parsePathVertex(eb+(ea-eb)*2/3,ed+(ef-ed)*2/3);this.parsePathVertex(eb,ed)}else{throw\"Path must start with M/m\"}};cr.prototype.parsePathCurveto=function(ed,ef,eb,ee,ea,ec){if(this.vertices.length>0){this.parsePathCode(1);this.parsePathVertex(ed,ef);this.parsePathVertex(eb,ee);this.parsePathVertex(ea,ec)}else{throw\"Path must start with M/m\"}};cr.prototype.parsePathLineto=function(eb,ea){if(this.vertices.length>0){this.parsePathCode(0);this.parsePathVertex(eb,ea);this.vertices[this.vertices.length-1][\"moveTo\"]=false}else{throw\"Path must start with M/m\"}};cr.prototype.parsePathMoveto=function(eb,ea){if(this.vertices.length>0){this.parsePathCode(3)}this.parsePathCode(0);this.parsePathVertex(eb,ea);this.vertices[this.vertices.length-1][\"moveTo\"]=true};cr.prototype.parsePathVertex=function(ea,ec){var eb=[];eb[0]=ea;eb[1]=ec;this.vertices.push(eb)};cr.prototype.parsePathCode=function(ea){this.vertexCodes.push(ea)};cr.prototype.parsePoly=function(ee){this.family=21;this.close=ee;var eb=cW.trim(this.element.getStringAttribute(\"points\").replace(/[,\\s]+/g,\" \"));if(eb!==null){var ea=eb.split(\" \");if(ea.length%2===0){for(var ed=0,ec=ea.length;ed<ec;ed++){var ef=[];ef[0]=ea[ed];ef[1]=ea[++ed];this.vertices.push(ef)}}else{throw\"Error parsing polygon points: odd number of coordinates provided\"}}};cr.prototype.parseRect=function(){this.kind=30;this.family=1;this.params=[];this.params[0]=this.element.getFloatAttribute(\"x\");this.params[1]=this.element.getFloatAttribute(\"y\");this.params[2]=this.element.getFloatAttribute(\"width\");this.params[3]=this.element.getFloatAttribute(\"height\");if(this.params[2]<0||this.params[3]<0){throw\"svg error: negative width or height found while parsing <rect>\"}};cr.prototype.parseEllipse=function(ec){this.kind=31;this.family=1;this.params=[];this.params[0]=this.element.getFloatAttribute(\"cx\")|0;this.params[1]=this.element.getFloatAttribute(\"cy\")|0;var eb,ea;if(ec){eb=ea=this.element.getFloatAttribute(\"r\");if(eb<0){throw\"svg error: negative radius found while parsing <circle>\"}}else{eb=this.element.getFloatAttribute(\"rx\");ea=this.element.getFloatAttribute(\"ry\");if(eb<0||ea<0){throw\"svg error: negative x-axis radius or y-axis radius found while parsing <ellipse>\"}}this.params[0]-=eb;this.params[1]-=ea;this.params[2]=eb*2;this.params[3]=ea*2};cr.prototype.parseLine=function(){this.kind=4;this.family=1;this.params=[];this.params[0]=this.element.getFloatAttribute(\"x1\");this.params[1]=this.element.getFloatAttribute(\"y1\");this.params[2]=this.element.getFloatAttribute(\"x2\");this.params[3]=this.element.getFloatAttribute(\"y2\")};cr.prototype.parseColors=function(ec){if(ec.hasAttribute(\"opacity\")){this.setOpacity(ec.getAttribute(\"opacity\"))}if(ec.hasAttribute(\"stroke\")){this.setStroke(ec.getAttribute(\"stroke\"))}if(ec.hasAttribute(\"stroke-width\")){this.setStrokeWeight(ec.getAttribute(\"stroke-width\"))}if(ec.hasAttribute(\"stroke-linejoin\")){this.setStrokeJoin(ec.getAttribute(\"stroke-linejoin\"))}if(ec.hasAttribute(\"stroke-linecap\")){this.setStrokeCap(ec.getStringAttribute(\"stroke-linecap\"))}if(ec.hasAttribute(\"fill\")){this.setFill(ec.getStringAttribute(\"fill\"))}if(ec.hasAttribute(\"style\")){var ef=ec.getStringAttribute(\"style\");var ed=ef.toString().split(\";\");for(var eb=0,ea=ed.length;eb<ea;eb++){var ee=cW.trim(ed[eb].split(\":\"));if(ee[0]===\"fill\"){this.setFill(ee[1])}else{if(ee[0]===\"fill-opacity\"){this.setFillOpacity(ee[1])}else{if(ee[0]===\"stroke\"){this.setStroke(ee[1])}else{if(ee[0]===\"stroke-width\"){this.setStrokeWeight(ee[1])}else{if(ee[0]===\"stroke-linecap\"){this.setStrokeCap(ee[1])}else{if(ee[0]===\"stroke-linejoin\"){this.setStrokeJoin(ee[1])}else{if(ee[0]===\"stroke-opacity\"){this.setStrokeOpacity(ee[1])}else{if(ee[0]===\"opacity\"){this.setOpacity(ee[1])}}}}}}}}}}};cr.prototype.setFillOpacity=function(ea){this.fillOpacity=parseFloat(ea);this.fillColor=this.fillOpacity*255<<24|this.fillColor&16777215};cr.prototype.setFill=function(ea){var eb=this.fillColor&4278190080;if(ea===\"none\"){this.fill=false}else{if(ea.indexOf(\"#\")===0){this.fill=true;if(ea.length===4){ea=ea.replace(/#(.)(.)(.)/,\"#$1$1$2$2$3$3\")}this.fillColor=eb|parseInt(ea.substring(1),16)&16777215}else{if(ea.indexOf(\"rgb\")===0){this.fill=true;this.fillColor=eb|this.parseRGB(ea)}else{if(ea.indexOf(\"url(#\")===0){this.fillName=ea.substring(5,ea.length-1)}else{if(E[ea]){this.fill=true;this.fillColor=eb|parseInt(E[ea].substring(1),16)&16777215}}}}}};cr.prototype.setOpacity=function(ea){this.strokeColor=parseFloat(ea)*255<<24|this.strokeColor&16777215;this.fillColor=parseFloat(ea)*255<<24|this.fillColor&16777215};cr.prototype.setStroke=function(ea){var eb=this.strokeColor&4278190080;if(ea===\"none\"){this.stroke=false}else{if(ea.charAt(0)===\"#\"){this.stroke=true;if(ea.length===4){ea=ea.replace(/#(.)(.)(.)/,\"#$1$1$2$2$3$3\")}this.strokeColor=eb|parseInt(ea.substring(1),16)&16777215}else{if(ea.indexOf(\"rgb\")===0){this.stroke=true;this.strokeColor=eb|this.parseRGB(ea)}else{if(ea.indexOf(\"url(#\")===0){this.strokeName=ea.substring(5,ea.length-1)}else{if(E[ea]){this.stroke=true;this.strokeColor=eb|parseInt(E[ea].substring(1),16)&16777215}}}}}};cr.prototype.setStrokeWeight=function(ea){this.strokeWeight=this.parseUnitSize(ea)};cr.prototype.setStrokeJoin=function(ea){if(ea===\"miter\"){this.strokeJoin=\"miter\"}else{if(ea===\"round\"){this.strokeJoin=\"round\"}else{if(ea===\"bevel\"){this.strokeJoin=\"bevel\"}}}};cr.prototype.setStrokeCap=function(ea){if(ea===\"butt\"){this.strokeCap=\"butt\"}else{if(ea===\"round\"){this.strokeCap=\"round\"}else{if(ea===\"square\"){this.strokeCap=\"square\"}}}};cr.prototype.setStrokeOpacity=function(ea){this.strokeOpacity=parseFloat(ea);this.strokeColor=this.strokeOpacity*255<<24|this.strokeColor&16777215};cr.prototype.parseRGB=function(eb){var ec=eb.substring(eb.indexOf(\"(\")+1,eb.indexOf(\")\"));var ea=ec.split(\", \");return ea[0]<<16|ea[1]<<8|ea[2]};cr.prototype.parseUnitSize=function(eb){var ea=eb.length-2;if(ea<0){return eb}if(eb.indexOf(\"pt\")===ea){return parseFloat(eb.substring(0,ea))*1.25}if(eb.indexOf(\"pc\")===ea){return parseFloat(eb.substring(0,ea))*15}if(eb.indexOf(\"mm\")===ea){return parseFloat(eb.substring(0,ea))*3.543307}if(eb.indexOf(\"cm\")===ea){return parseFloat(eb.substring(0,ea))*35.43307}if(eb.indexOf(\"in\")===ea){return parseFloat(eb.substring(0,ea))*90}if(eb.indexOf(\"px\")===ea){return parseFloat(eb.substring(0,ea))}return parseFloat(eb)};cW.shape=function(ec,eb,ee,ed,ea){if(arguments.length>=1&&arguments[0]!==null){if(ec.isVisible()){cW.pushMatrix();if(S===3){if(arguments.length===5){cW.translate(eb-ed/2,ee-ea/2);cW.scale(ed/ec.getWidth(),ea/ec.getHeight())}else{if(arguments.length===3){cW.translate(eb-ec.getWidth()/2,-ec.getHeight()/2)}else{cW.translate(-ec.getWidth()/2,-ec.getHeight()/2)}}}else{if(S===0){if(arguments.length===5){cW.translate(eb,ee);cW.scale(ed/ec.getWidth(),ea/ec.getHeight())}else{if(arguments.length===3){cW.translate(eb,ee)}}}else{if(S===1){if(arguments.length===5){ed-=eb;ea-=ee;cW.translate(eb,ee);cW.scale(ed/ec.getWidth(),ea/ec.getHeight())}else{if(arguments.length===3){cW.translate(eb,ee)}}}}}ec.draw(cW);if(arguments.length===1&&S===3||arguments.length>1){cW.popMatrix()}}}};cW.shapeMode=function(ea){S=ea};cW.loadShape=function(ea){if(arguments.length===1){if(ea.indexOf(\".svg\")>-1){return new cr(null,ea)}}return null};var cT=function(ee,ed,ea,eb,ec){this.fullName=ee||\"\";this.name=ed||\"\";this.namespace=ea||\"\";this.value=eb;this.type=ec};cT.prototype={getName:function(){return this.name},getFullName:function(){return this.fullName},getNamespace:function(){return this.namespace},getValue:function(){return this.value},getType:function(){return this.type},setValue:function(ea){this.value=ea}};var b9=cW.XMLElement=function(ea,ec,ed,eb){this.attributes=[];this.children=[];this.fullName=null;this.name=null;this.namespace=\"\";this.content=null;this.parent=null;this.lineNr=\"\";this.systemID=\"\";this.type=\"ELEMENT\";if(ea){if(typeof ea===\"string\"){if(ec===t&&ea.indexOf(\"<\")>-1){this.parse(ea)}else{this.fullName=ea;this.namespace=ec;this.systemId=ed;this.lineNr=eb}}else{this.parse(ec)}}};b9.prototype={parse:function(ea){var ec;try{var ee=ea.substring(ea.length-4);if(ee===\".xml\"||ee===\".svg\"){ea=w(ea)}ec=(new DOMParser).parseFromString(ea,\"text/xml\");var eb=ec.documentElement;if(eb){this.parseChildrenRecursive(null,eb)}else{throw\"Error loading document\"}return this}catch(ed){throw ed}},parseChildrenRecursive:function(ei,eg){var ef,eb,eh,ee,ed,ea;if(!ei){this.fullName=eg.localName;this.name=eg.nodeName;ef=this}else{ef=new b9(eg.nodeName);ef.parent=ei}if(eg.nodeType===3&&eg.textContent!==\"\"){return this.createPCDataElement(eg.textContent)}if(eg.nodeType===4){return this.createCDataElement(eg.textContent)}if(eg.attributes){for(ee=0,ed=eg.attributes.length;ee<ed;ee++){eh=eg.attributes[ee];eb=new cT(eh.getname,eh.nodeName,eh.namespaceURI,eh.nodeValue,eh.nodeType);ef.attributes.push(eb)}}if(eg.childNodes){for(ee=0,ed=eg.childNodes.length;ee<ed;ee++){var ec=eg.childNodes[ee];ea=ef.parseChildrenRecursive(ef,ec);if(ea!==null){ef.children.push(ea)}}}return ef},createElement:function(eb,ec,ed,ea){if(ed===t){return new b9(eb,ec)}return new b9(eb,ec,ed,ea)},createPCDataElement:function(eb,ea){if(eb.replace(/^\\s+$/g,\"\")===\"\"){return null}var ec=new b9;ec.type=\"TEXT\";ec.content=eb;return ec},createCDataElement:function(ec){var ed=this.createPCDataElement(ec);if(ed===null){return null}ed.type=\"CDATA\";var eb={\"<\":\"&lt;\",\">\":\"&gt;\",\"'\":\"&apos;\",'\"':\"&quot;\"},ea;for(ea in eb){if(!Object.hasOwnProperty(eb,ea)){ec=ec.replace(new RegExp(ea,\"g\"),eb[ea])}}ed.cdata=ec;return ed},hasAttribute:function(){if(arguments.length===1){return this.getAttribute(arguments[0])!==null}if(arguments.length===2){return this.getAttribute(arguments[0],arguments[1])!==null}},equals:function(ef){if(!(ef instanceof b9)){return false}var ec,eb;if(this.fullName!==ef.fullName){return false}if(this.attributes.length!==ef.getAttributeCount()){return false}if(this.attributes.length!==ef.attributes.length){return false}var ej,eh,ea,eg,ei;for(ec=0,eb=this.attributes.length;ec<eb;ec++){ej=this.attributes[ec].getName();eh=this.attributes[ec].getNamespace();ei=ef.findAttribute(ej,eh);if(ei===null){return false}if(this.attributes[ec].getValue()!==ei.getValue()){return false}if(this.attributes[ec].getType()!==ei.getType()){return false}}if(this.children.length!==ef.getChildCount()){return false}if(this.children.length>0){var ee,ed;for(ec=0,eb=this.children.length;ec<eb;ec++){ee=this.getChild(ec);ed=ef.getChild(ec);if(!ee.equals(ed)){return false}}return true}return this.content===ef.content},getContent:function(){if(this.type===\"TEXT\"||this.type===\"CDATA\"){return this.content}var ea=this.children;if(ea.length===1&&(ea[0].type===\"TEXT\"||ea[0].type===\"CDATA\")){return ea[0].content}return null},getAttribute:function(){var ea;if(arguments.length===2){ea=this.findAttribute(arguments[0]);if(ea){return ea.getValue()}return arguments[1]}else{if(arguments.length===1){ea=this.findAttribute(arguments[0]);if(ea){return ea.getValue()}return null}else{if(arguments.length===3){ea=this.findAttribute(arguments[0],arguments[1]);if(ea){return ea.getValue()}return arguments[2]}}}},getStringAttribute:function(){if(arguments.length===1){return this.getAttribute(arguments[0])}if(arguments.length===2){return this.getAttribute(arguments[0],arguments[1])}return this.getAttribute(arguments[0],arguments[1],arguments[2])},getString:function(ea){return this.getStringAttribute(ea)},getFloatAttribute:function(){if(arguments.length===1){return parseFloat(this.getAttribute(arguments[0],0))}if(arguments.length===2){return this.getAttribute(arguments[0],arguments[1])}return this.getAttribute(arguments[0],arguments[1],arguments[2])},getFloat:function(ea){return this.getFloatAttribute(ea)},getIntAttribute:function(){if(arguments.length===1){return this.getAttribute(arguments[0],0)}if(arguments.length===2){return this.getAttribute(arguments[0],arguments[1])}return this.getAttribute(arguments[0],arguments[1],arguments[2])},getInt:function(ea){return this.getIntAttribute(ea)},hasChildren:function(){return this.children.length>0},addChild:function(ea){if(ea!==null){ea.parent=this;this.children.push(ea)}},insertChild:function(ec,ea){if(ec){if(ec.getLocalName()===null&&!this.hasChildren()){var eb=this.children[this.children.length-1];if(eb.getLocalName()===null){eb.setContent(eb.getContent()+ec.getContent());return}}ec.parent=this;this.children.splice(ea,0,ec)}},getChild:function(eb){if(typeof eb===\"number\"){return this.children[eb]}if(eb.indexOf(\"/\")!==-1){return this.getChildRecursive(eb.split(\"/\"),0)}var ea,ee;for(var ed=0,ec=this.getChildCount();ed<ec;ed++){ea=this.getChild(ed);ee=ea.getName();if(ee!==null&&ee===eb){return ea}}return null},getChildren:function(){if(arguments.length===1){if(typeof arguments[0]===\"number\"){return this.getChild(arguments[0])}if(arguments[0].indexOf(\"/\")!==-1){return this.getChildrenRecursive(arguments[0].split(\"/\"),0)}var ee=[];var ea,ed;for(var ec=0,eb=this.getChildCount();ec<eb;ec++){ea=this.getChild(ec);ed=ea.getName();if(ed!==null&&ed===arguments[0]){ee.push(ea)}}return ee}return this.children},getChildCount:function(){return this.children.length},getChildRecursive:function(eb,eg){if(eg===eb.length){return this}var ea,ef,ee=eb[eg];for(var ed=0,ec=this.getChildCount();ed<ec;ed++){ea=this.getChild(ed);ef=ea.getName();if(ef!==null&&ef===ee){return ea.getChildRecursive(eb,eg+1)}}return null},getChildrenRecursive:function(ea,ee){if(ee===ea.length-1){return this.getChildren(ea[ee])}var ed=this.getChildren(ea[ee]);var ec=[];for(var eb=0;eb<ed.length;eb++){ec=ec.concat(ed[eb].getChildrenRecursive(ea,ee+1))}return ec},isLeaf:function(){return !this.hasChildren()},listChildren:function(){var ea=[];for(var ec=0,eb=this.children.length;ec<eb;ec++){ea.push(this.getChild(ec).getName())}return ea},removeAttribute:function(eb,ed){this.namespace=ed||\"\";for(var ec=0,ea=this.attributes.length;ec<ea;ec++){if(this.attributes[ec].getName()===eb&&this.attributes[ec].getNamespace()===this.namespace){this.attributes.splice(ec,1);break}}},removeChild:function(ec){if(ec){for(var eb=0,ea=this.children.length;eb<ea;eb++){if(this.children[eb].equals(ec)){this.children.splice(eb,1);break}}}},removeChildAtIndex:function(ea){if(this.children.length>ea){this.children.splice(ea,1)}},findAttribute:function(eb,ed){this.namespace=ed||\"\";for(var ec=0,ea=this.attributes.length;ec<ea;ec++){if(this.attributes[ec].getName()===eb&&this.attributes[ec].getNamespace()===this.namespace){return this.attributes[ec]}}return null},setAttribute:function(){var ea;if(arguments.length===3){var ec=arguments[0].indexOf(\":\");var eb=arguments[0].substring(ec+1);ea=this.findAttribute(eb,arguments[1]);if(ea){ea.setValue(arguments[2])}else{ea=new cT(arguments[0],eb,arguments[1],arguments[2],\"CDATA\");this.attributes.push(ea)}}else{ea=this.findAttribute(arguments[0]);if(ea){ea.setValue(arguments[1])}else{ea=new cT(arguments[0],arguments[0],null,arguments[1],\"CDATA\");this.attributes.push(ea)}}},setString:function(ea,eb){this.setAttribute(ea,eb)},setInt:function(ea,eb){this.setAttribute(ea,eb)},setFloat:function(ea,eb){this.setAttribute(ea,eb)},setContent:function(ea){if(this.children.length>0){F.debug(\"Tried to set content for XMLElement with children\")}this.content=ea},setName:function(){if(arguments.length===1){this.name=arguments[0];this.fullName=arguments[0];this.namespace=null}else{var ea=arguments[0].indexOf(\":\");if(arguments[1]===null||ea<0){this.name=arguments[0]}else{this.name=arguments[0].substring(ea+1)}this.fullName=arguments[0];this.namespace=arguments[1]}},getName:function(){return this.fullName},getLocalName:function(){return this.name},getAttributeCount:function(){return this.attributes.length},toString:function(){if(this.type===\"TEXT\"){return this.content}if(this.type===\"CDATA\"){return this.cdata}var ec=this.fullName;var ed=\"<\"+ec;var eb,ee;for(eb=0;eb<this.attributes.length;eb++){var ea=this.attributes[eb];ed+=\" \"+ea.getName()+'=\"'+ea.getValue()+'\"'}if(this.children.length===0){if(this.content===\"\"){ed+=\"/>\"}else{ed+=\">\"+this.content+\"</\"+ec+\">\"}}else{ed+=\">\";for(ee=0;ee<this.children.length;ee++){ed+=this.children[ee].toString()}ed+=\"</\"+ec+\">\"}return ed}};b9.parse=function(eb){var ea=new b9;ea.parse(eb);return ea};var dg=cW.XML=cW.XMLElement;cW.loadXML=function(ea){return new dg(cW,ea)};var cm=function(ed){var ea=0;for(var eb=0;eb<ed.length;eb++){if(eb!==0){ea=q.max(ea,q.abs(ed[eb]))}else{ea=q.abs(ed[eb])}}var ec=(ea+\"\").indexOf(\".\");if(ec===0){ec=1}else{if(ec===-1){ec=(ea+\"\").length}}return ec};var aX=cW.PMatrix2D=function(){if(arguments.length===0){this.reset()}else{if(arguments.length===1&&arguments[0] instanceof aX){this.set(arguments[0].array())}else{if(arguments.length===6){this.set(arguments[0],arguments[1],arguments[2],arguments[3],arguments[4],arguments[5])}}}};aX.prototype={set:function(){if(arguments.length===6){var ea=arguments;this.set([ea[0],ea[1],ea[2],ea[3],ea[4],ea[5]])}else{if(arguments.length===1&&arguments[0] instanceof aX){this.elements=arguments[0].array()}else{if(arguments.length===1&&arguments[0] instanceof Array){this.elements=arguments[0].slice()}}}},get:function(){var ea=new aX;ea.set(this.elements);return ea},reset:function(){this.set([1,0,0,0,1,0])},array:function aE(){return this.elements.slice()},translate:function(eb,ea){this.elements[2]=eb*this.elements[0]+ea*this.elements[1]+this.elements[2];this.elements[5]=eb*this.elements[3]+ea*this.elements[4]+this.elements[5]},invTranslate:function(eb,ea){this.translate(-eb,-ea)},transpose:function(){},mult:function(eb,ec){var ea,ed;if(eb instanceof A){ea=eb.x;ed=eb.y;if(!ec){ec=new A}}else{if(eb instanceof Array){ea=eb[0];ed=eb[1];if(!ec){ec=[]}}}if(ec instanceof Array){ec[0]=this.elements[0]*ea+this.elements[1]*ed+this.elements[2];ec[1]=this.elements[3]*ea+this.elements[4]*ed+this.elements[5]}else{if(ec instanceof A){ec.x=this.elements[0]*ea+this.elements[1]*ed+this.elements[2];ec.y=this.elements[3]*ea+this.elements[4]*ed+this.elements[5];ec.z=0}}return ec},multX:function(ea,eb){return ea*this.elements[0]+eb*this.elements[1]+this.elements[2]},multY:function(ea,eb){return ea*this.elements[3]+eb*this.elements[4]+this.elements[5]},skewX:function(ea){this.apply(1,0,1,ea,0,0)},skewY:function(ea){this.apply(1,0,1,0,ea,0)},shearX:function(ea){this.apply(1,0,1,q.tan(ea),0,0)},shearY:function(ea){this.apply(1,0,1,0,q.tan(ea),0)},determinant:function(){return this.elements[0]*this.elements[4]-this.elements[1]*this.elements[3]},invert:function(){var ef=this.determinant();if(q.abs(ef)>-2147483648){var eb=this.elements[0];var eg=this.elements[1];var ee=this.elements[2];var ed=this.elements[3];var ec=this.elements[4];var ea=this.elements[5];this.elements[0]=ec/ef;this.elements[3]=-ed/ef;this.elements[1]=-eg/ef;this.elements[4]=eb/ef;this.elements[2]=(eg*ea-ec*ee)/ef;this.elements[5]=(ed*ee-eb*ea)/ef;return true}return false},scale:function(eb,ea){if(eb&&!ea){ea=eb}if(eb&&ea){this.elements[0]*=eb;this.elements[1]*=ea;this.elements[3]*=eb;this.elements[4]*=ea}},invScale:function(eb,ea){if(eb&&!ea){ea=eb}this.scale(1/eb,1/ea)},apply:function(){var ec;if(arguments.length===1&&arguments[0] instanceof aX){ec=arguments[0].array()}else{if(arguments.length===6){ec=Array.prototype.slice.call(arguments)}else{if(arguments.length===1&&arguments[0] instanceof Array){ec=arguments[0]}}}var ea=[0,0,this.elements[2],0,0,this.elements[5]];var ed=0;for(var ee=0;ee<2;ee++){for(var eb=0;eb<3;eb++,ed++){ea[ed]+=this.elements[ee*3+0]*ec[eb+0]+this.elements[ee*3+1]*ec[eb+3]}}this.elements=ea.slice()},preApply:function(){var eb;if(arguments.length===1&&arguments[0] instanceof aX){eb=arguments[0].array()}else{if(arguments.length===6){eb=Array.prototype.slice.call(arguments)}else{if(arguments.length===1&&arguments[0] instanceof Array){eb=arguments[0]}}}var ea=[0,0,eb[2],0,0,eb[5]];ea[2]=eb[2]+this.elements[2]*eb[0]+this.elements[5]*eb[1];ea[5]=eb[5]+this.elements[2]*eb[3]+this.elements[5]*eb[4];ea[0]=this.elements[0]*eb[0]+this.elements[3]*eb[1];ea[3]=this.elements[0]*eb[3]+this.elements[3]*eb[4];ea[1]=this.elements[1]*eb[0]+this.elements[4]*eb[1];ea[4]=this.elements[1]*eb[3]+this.elements[4]*eb[4];this.elements=ea.slice()},rotate:function(ec){var ee=q.cos(ec);var ea=q.sin(ec);var ed=this.elements[0];var eb=this.elements[1];this.elements[0]=ee*ed+ea*eb;this.elements[1]=-ea*ed+ee*eb;ed=this.elements[3];eb=this.elements[4];this.elements[3]=ee*ed+ea*eb;this.elements[4]=-ea*ed+ee*eb},rotateZ:function(ea){this.rotate(ea)},invRotateZ:function(ea){this.rotateZ(ea-q.PI)},print:function(){var eb=cm(this.elements);var ea=\"\"+cW.nfs(this.elements[0],eb,4)+\" \"+cW.nfs(this.elements[1],eb,4)+\" \"+cW.nfs(this.elements[2],eb,4)+\"\\n\"+cW.nfs(this.elements[3],eb,4)+\" \"+cW.nfs(this.elements[4],eb,4)+\" \"+cW.nfs(this.elements[5],eb,4)+\"\\n\\n\";cW.println(ea)}};var aP=cW.PMatrix3D=function(){this.reset()};aP.prototype={set:function(){if(arguments.length===16){this.elements=Array.prototype.slice.call(arguments)}else{if(arguments.length===1&&arguments[0] instanceof aP){this.elements=arguments[0].array()}else{if(arguments.length===1&&arguments[0] instanceof Array){this.elements=arguments[0].slice()}}}},get:function(){var ea=new aP;ea.set(this.elements);return ea},reset:function(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},array:function aE(){return this.elements.slice()},translate:function(eb,ea,ec){if(ec===t){ec=0}this.elements[3]+=eb*this.elements[0]+ea*this.elements[1]+ec*this.elements[2];this.elements[7]+=eb*this.elements[4]+ea*this.elements[5]+ec*this.elements[6];this.elements[11]+=eb*this.elements[8]+ea*this.elements[9]+ec*this.elements[10];this.elements[15]+=eb*this.elements[12]+ea*this.elements[13]+ec*this.elements[14]},transpose:function(){var ea=this.elements[4];this.elements[4]=this.elements[1];this.elements[1]=ea;ea=this.elements[8];this.elements[8]=this.elements[2];this.elements[2]=ea;ea=this.elements[6];this.elements[6]=this.elements[9];this.elements[9]=ea;ea=this.elements[3];this.elements[3]=this.elements[12];this.elements[12]=ea;ea=this.elements[7];this.elements[7]=this.elements[13];this.elements[13]=ea;ea=this.elements[11];this.elements[11]=this.elements[14];this.elements[14]=ea},mult:function(ec,ed){var ea,ef,ee,eb;if(ec instanceof A){ea=ec.x;ef=ec.y;ee=ec.z;eb=1;if(!ed){ed=new A}}else{if(ec instanceof Array){ea=ec[0];ef=ec[1];ee=ec[2];eb=ec[3]||1;if(!ed||ed.length!==3&&ed.length!==4){ed=[0,0,0]}}}if(ed instanceof Array){if(ed.length===3){ed[0]=this.elements[0]*ea+this.elements[1]*ef+this.elements[2]*ee+this.elements[3];ed[1]=this.elements[4]*ea+this.elements[5]*ef+this.elements[6]*ee+this.elements[7];ed[2]=this.elements[8]*ea+this.elements[9]*ef+this.elements[10]*ee+this.elements[11]}else{if(ed.length===4){ed[0]=this.elements[0]*ea+this.elements[1]*ef+this.elements[2]*ee+this.elements[3]*eb;ed[1]=this.elements[4]*ea+this.elements[5]*ef+this.elements[6]*ee+this.elements[7]*eb;ed[2]=this.elements[8]*ea+this.elements[9]*ef+this.elements[10]*ee+this.elements[11]*eb;ed[3]=this.elements[12]*ea+this.elements[13]*ef+this.elements[14]*ee+this.elements[15]*eb}}}if(ed instanceof A){ed.x=this.elements[0]*ea+this.elements[1]*ef+this.elements[2]*ee+this.elements[3];ed.y=this.elements[4]*ea+this.elements[5]*ef+this.elements[6]*ee+this.elements[7];ed.z=this.elements[8]*ea+this.elements[9]*ef+this.elements[10]*ee+this.elements[11]}return ed},preApply:function(){var ec;if(arguments.length===1&&arguments[0] instanceof aP){ec=arguments[0].array()}else{if(arguments.length===16){ec=Array.prototype.slice.call(arguments)}else{if(arguments.length===1&&arguments[0] instanceof Array){ec=arguments[0]}}}var ea=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];var ed=0;for(var ee=0;ee<4;ee++){for(var eb=0;eb<4;eb++,ed++){ea[ed]+=this.elements[eb+0]*ec[ee*4+0]+this.elements[eb+4]*ec[ee*4+1]+this.elements[eb+8]*ec[ee*4+2]+this.elements[eb+12]*ec[ee*4+3]}}this.elements=ea.slice()},apply:function(){var ec;if(arguments.length===1&&arguments[0] instanceof aP){ec=arguments[0].array()}else{if(arguments.length===16){ec=Array.prototype.slice.call(arguments)}else{if(arguments.length===1&&arguments[0] instanceof Array){ec=arguments[0]}}}var ea=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];var ed=0;for(var ee=0;ee<4;ee++){for(var eb=0;eb<4;eb++,ed++){ea[ed]+=this.elements[ee*4+0]*ec[eb+0]+this.elements[ee*4+1]*ec[eb+4]+this.elements[ee*4+2]*ec[eb+8]+this.elements[ee*4+3]*ec[eb+12]}}this.elements=ea.slice()},rotate:function(ee,ea,eg,ed){if(!eg){this.rotateZ(ee)}else{var ef=cW.cos(ee);var ec=cW.sin(ee);var eb=1-ef;this.apply(eb*ea*ea+ef,eb*ea*eg-ec*ed,eb*ea*ed+ec*eg,0,eb*ea*eg+ec*ed,eb*eg*eg+ef,eb*eg*ed-ec*ea,0,eb*ea*ed-ec*eg,eb*eg*ed+ec*ea,eb*ed*ed+ef,0,0,0,0,1)}},invApply:function(){if(ab===t){ab=new aP}var ea=arguments;ab.set(ea[0],ea[1],ea[2],ea[3],ea[4],ea[5],ea[6],ea[7],ea[8],ea[9],ea[10],ea[11],ea[12],ea[13],ea[14],ea[15]);if(!ab.invert()){return false}this.preApply(ab);return true},rotateX:function(eb){var ec=cW.cos(eb);var ea=cW.sin(eb);this.apply([1,0,0,0,0,ec,-ea,0,0,ea,ec,0,0,0,0,1])},rotateY:function(eb){var ec=cW.cos(eb);var ea=cW.sin(eb);this.apply([ec,0,ea,0,0,1,0,0,-ea,0,ec,0,0,0,0,1])},rotateZ:function(eb){var ec=q.cos(eb);var ea=q.sin(eb);this.apply([ec,-ea,0,0,ea,ec,0,0,0,0,1,0,0,0,0,1])},scale:function(ec,eb,ea){if(ec&&!eb&&!ea){eb=ea=ec}else{if(ec&&eb&&!ea){ea=1}}if(ec&&eb&&ea){this.elements[0]*=ec;this.elements[1]*=eb;this.elements[2]*=ea;this.elements[4]*=ec;this.elements[5]*=eb;this.elements[6]*=ea;this.elements[8]*=ec;this.elements[9]*=eb;this.elements[10]*=ea;this.elements[12]*=ec;this.elements[13]*=eb;this.elements[14]*=ea}},skewX:function(eb){var ea=q.tan(eb);this.apply(1,ea,0,0,0,1,0,0,0,0,1,0,0,0,0,1)},skewY:function(eb){var ea=q.tan(eb);this.apply(1,0,0,0,ea,1,0,0,0,0,1,0,0,0,0,1)},shearX:function(eb){var ea=q.tan(eb);this.apply(1,ea,0,0,0,1,0,0,0,0,1,0,0,0,0,1)},shearY:function(eb){var ea=q.tan(eb);this.apply(1,0,0,0,ea,1,0,0,0,0,1,0,0,0,0,1)},multX:function(ea,ed,ec,eb){if(!ec){return this.elements[0]*ea+this.elements[1]*ed+this.elements[3]}if(!eb){return this.elements[0]*ea+this.elements[1]*ed+this.elements[2]*ec+this.elements[3]}return this.elements[0]*ea+this.elements[1]*ed+this.elements[2]*ec+this.elements[3]*eb},multY:function(ea,ed,ec,eb){if(!ec){return this.elements[4]*ea+this.elements[5]*ed+this.elements[7]}if(!eb){return this.elements[4]*ea+this.elements[5]*ed+this.elements[6]*ec+this.elements[7]}return this.elements[4]*ea+this.elements[5]*ed+this.elements[6]*ec+this.elements[7]*eb},multZ:function(ea,ed,ec,eb){if(!eb){return this.elements[8]*ea+this.elements[9]*ed+this.elements[10]*ec+this.elements[11]}return this.elements[8]*ea+this.elements[9]*ed+this.elements[10]*ec+this.elements[11]*eb},multW:function(ea,ed,ec,eb){if(!eb){return this.elements[12]*ea+this.elements[13]*ed+this.elements[14]*ec+this.elements[15]}return this.elements[12]*ea+this.elements[13]*ed+this.elements[14]*ec+this.elements[15]*eb},invert:function(){var ej=this.elements[0]*this.elements[5]-this.elements[1]*this.elements[4];var ei=this.elements[0]*this.elements[6]-this.elements[2]*this.elements[4];var eh=this.elements[0]*this.elements[7]-this.elements[3]*this.elements[4];var eg=this.elements[1]*this.elements[6]-this.elements[2]*this.elements[5];var ef=this.elements[1]*this.elements[7]-this.elements[3]*this.elements[5];var ee=this.elements[2]*this.elements[7]-this.elements[3]*this.elements[6];var ed=this.elements[8]*this.elements[13]-this.elements[9]*this.elements[12];var ec=this.elements[8]*this.elements[14]-this.elements[10]*this.elements[12];var eb=this.elements[8]*this.elements[15]-this.elements[11]*this.elements[12];var eo=this.elements[9]*this.elements[14]-this.elements[10]*this.elements[13];var em=this.elements[9]*this.elements[15]-this.elements[11]*this.elements[13];var el=this.elements[10]*this.elements[15]-this.elements[11]*this.elements[14];var en=ej*el-ei*em+eh*eo+eg*eb-ef*ec+ee*ed;if(q.abs(en)<=1e-9){return false}var ek=[];ek[0]=+this.elements[5]*el-this.elements[6]*em+this.elements[7]*eo;ek[4]=-this.elements[4]*el+this.elements[6]*eb-this.elements[7]*ec;ek[8]=+this.elements[4]*em-this.elements[5]*eb+this.elements[7]*ed;ek[12]=-this.elements[4]*eo+this.elements[5]*ec-this.elements[6]*ed;ek[1]=-this.elements[1]*el+this.elements[2]*em-this.elements[3]*eo;ek[5]=+this.elements[0]*el-this.elements[2]*eb+this.elements[3]*ec;ek[9]=-this.elements[0]*em+this.elements[1]*eb-this.elements[3]*ed;ek[13]=+this.elements[0]*eo-this.elements[1]*ec+this.elements[2]*ed;ek[2]=+this.elements[13]*ee-this.elements[14]*ef+this.elements[15]*eg;ek[6]=-this.elements[12]*ee+this.elements[14]*eh-this.elements[15]*ei;ek[10]=+this.elements[12]*ef-this.elements[13]*eh+this.elements[15]*ej;ek[14]=-this.elements[12]*eg+this.elements[13]*ei-this.elements[14]*ej;ek[3]=-this.elements[9]*ee+this.elements[10]*ef-this.elements[11]*eg;ek[7]=+this.elements[8]*ee-this.elements[10]*eh+this.elements[11]*ei;ek[11]=-this.elements[8]*ef+this.elements[9]*eh-this.elements[11]*ej;ek[15]=+this.elements[8]*eg-this.elements[9]*ei+this.elements[10]*ej;var ea=1/en;ek[0]*=ea;ek[1]*=ea;ek[2]*=ea;ek[3]*=ea;ek[4]*=ea;ek[5]*=ea;ek[6]*=ea;ek[7]*=ea;ek[8]*=ea;ek[9]*=ea;ek[10]*=ea;ek[11]*=ea;ek[12]*=ea;ek[13]*=ea;ek[14]*=ea;ek[15]*=ea;this.elements=ek.slice();return true},toString:function(){var eb=\"\";for(var ea=0;ea<15;ea++){eb+=this.elements[ea]+\", \"}eb+=this.elements[15];return eb},print:function(){var eb=cm(this.elements);var ea=\"\"+cW.nfs(this.elements[0],eb,4)+\" \"+cW.nfs(this.elements[1],eb,4)+\" \"+cW.nfs(this.elements[2],eb,4)+\" \"+cW.nfs(this.elements[3],eb,4)+\"\\n\"+cW.nfs(this.elements[4],eb,4)+\" \"+cW.nfs(this.elements[5],eb,4)+\" \"+cW.nfs(this.elements[6],eb,4)+\" \"+cW.nfs(this.elements[7],eb,4)+\"\\n\"+cW.nfs(this.elements[8],eb,4)+\" \"+cW.nfs(this.elements[9],eb,4)+\" \"+cW.nfs(this.elements[10],eb,4)+\" \"+cW.nfs(this.elements[11],eb,4)+\"\\n\"+cW.nfs(this.elements[12],eb,4)+\" \"+cW.nfs(this.elements[13],eb,4)+\" \"+cW.nfs(this.elements[14],eb,4)+\" \"+cW.nfs(this.elements[15],eb,4)+\"\\n\\n\";cW.println(ea)},invTranslate:function(eb,ea,ec){this.preApply(1,0,0,-eb,0,1,0,-ea,0,0,1,-ec,0,0,0,1)},invRotateX:function(eb){var ec=q.cos(-eb);var ea=q.sin(-eb);this.preApply([1,0,0,0,0,ec,-ea,0,0,ea,ec,0,0,0,0,1])},invRotateY:function(eb){var ec=q.cos(-eb);var ea=q.sin(-eb);this.preApply([ec,0,ea,0,0,1,0,0,-ea,0,ec,0,0,0,0,1])},invRotateZ:function(eb){var ec=q.cos(-eb);var ea=q.sin(-eb);this.preApply([ec,-ea,0,0,ea,ec,0,0,0,0,1,0,0,0,0,1])},invScale:function(ea,ec,eb){this.preApply([1/ea,0,0,0,0,1/ec,0,0,0,0,1/eb,0,0,0,0,1])}};var V=cW.PMatrixStack=function(){this.matrixStack=[]};V.prototype.load=function(){var ea=dY.$newPMatrix();if(arguments.length===1){ea.set(arguments[0])}else{ea.set(arguments)}this.matrixStack.push(ea)};bR.prototype.$newPMatrix=function(){return new aX};bB.prototype.$newPMatrix=function(){return new aP};V.prototype.push=function(){this.matrixStack.push(this.peek())};V.prototype.pop=function(){return this.matrixStack.pop()};V.prototype.peek=function(){var ea=dY.$newPMatrix();ea.set(this.matrixStack[this.matrixStack.length-1]);return ea};V.prototype.mult=function(ea){this.matrixStack[this.matrixStack.length-1].apply(ea)};cW.split=function(eb,ea){return eb.split(ea)};cW.splitTokens=function(eg,ef){if(ef===t){return eg.split(/\\s+/g)}var ed=ef.split(/()/g),eb=\"\",ea=eg.length,ec,eh,ee=[];for(ec=0;ec<ea;ec++){eh=eg[ec];if(ed.indexOf(eh)>-1){if(eb!==\"\"){ee.push(eb)}eb=\"\"}else{eb+=eh}}if(eb!==\"\"){ee.push(eb)}return ee};cW.append=function(eb,ea){eb[eb.length]=ea;return eb};cW.concat=function(eb,ea){return eb.concat(ea)};cW.sort=function(ef,ed){var eb=[];if(ef.length>0){var ee=ed>0?ed:ef.length;for(var ec=0;ec<ee;ec++){eb.push(ef[ec])}if(typeof ef[0]===\"string\"){eb.sort()}else{eb.sort(function(eh,eg){return eh-eg})}if(ed>0){for(var ea=eb.length;ea<ef.length;ea++){eb.push(ef[ea])}}}return eb};cW.splice=function(ee,ed,eb){if(ed.length===0){return ee}if(ed instanceof Array){for(var ec=0,ea=eb;ec<ed.length;ea++,ec++){ee.splice(ea,0,ed[ec])}}else{ee.splice(eb,0,ed)}return ee};cW.subset=function(ed,ec,eb){var ea=eb!==t?ec+eb:ed.length;return ed.slice(ec,ea)};cW.join=function(eb,ea){return eb.join(ea)};cW.shorten=function(ed){var eb=[];var ea=ed.length;for(var ec=0;ec<ea;ec++){eb[ec]=ed[ec]}eb.pop();return eb};cW.expand=function(ec,ed){var eb=ec.slice(0),ea=ed||ec.length*2;eb.length=ea;return eb};cW.arrayCopy=function(){var eg,ee=0,ec,eb=0,ef;if(arguments.length===2){eg=arguments[0];ec=arguments[1];ef=eg.length}else{if(arguments.length===3){eg=arguments[0];ec=arguments[1];ef=arguments[2]}else{if(arguments.length===5){eg=arguments[0];ee=arguments[1];ec=arguments[2];eb=arguments[3];ef=arguments[4]}}}for(var ed=ee,ea=eb;ed<ef+ee;ed++,ea++){if(ec[ea]!==t){ec[ea]=eg[ed]}else{throw\"array index out of bounds exception\"}}};cW.reverse=function(ea){return ea.reverse()};cW.mix=function(eb,ea,ec){return eb+((ea-eb)*ec>>8)};cW.peg=function(ea){return ea<0?0:ea>255?255:ea};cW.modes=function(){var ef=4278190080,ec=16711680,eb=65280,ee=255,ed=q.min,ea=q.max;function eg(el,eo,ek,et,ev,eu,em,eq,ep,ei,ej){var es=ed(((el&4278190080)>>>24)+eo,255)<<24;var eh=ek+((ep-ek)*eo>>8);eh=(eh<0?0:eh>255?255:eh)<<16;var en=et+((ei-et)*eo>>8);en=(en<0?0:en>255?255:en)<<8;var er=ev+((ej-ev)*eo>>8);er=er<0?0:er>255?255:er;return es|eh|en|er}return{replace:function(ei,eh){return eh},blend:function(ej,ei){var el=(ei&ef)>>>24,eh=ej&ec,en=ej&eb,ep=ej&ee,eo=ei&ec,ek=ei&eb,em=ei&ee;return ed(((ej&ef)>>>24)+el,255)<<24|eh+((eo-eh)*el>>8)&ec|en+((ek-en)*el>>8)&eb|ep+((em-ep)*el>>8)&ee},add:function(ei,eh){var ej=(eh&ef)>>>24;return ed(((ei&ef)>>>24)+ej,255)<<24|ed((ei&ec)+((eh&ec)>>8)*ej,ec)&ec|ed((ei&eb)+((eh&eb)>>8)*ej,eb)&eb|ed((ei&ee)+((eh&ee)*ej>>8),ee)},subtract:function(ei,eh){var ej=(eh&ef)>>>24;return ed(((ei&ef)>>>24)+ej,255)<<24|ea((ei&ec)-((eh&ec)>>8)*ej,eb)&ec|ea((ei&eb)-((eh&eb)>>8)*ej,ee)&eb|ea((ei&ee)-((eh&ee)*ej>>8),0)},lightest:function(ei,eh){var ej=(eh&ef)>>>24;return ed(((ei&ef)>>>24)+ej,255)<<24|ea(ei&ec,((eh&ec)>>8)*ej)&ec|ea(ei&eb,((eh&eb)>>8)*ej)&eb|ea(ei&ee,(eh&ee)*ej>>8)},darkest:function(ej,ei){var el=(ei&ef)>>>24,eh=ej&ec,en=ej&eb,ep=ej&ee,eo=ed(ej&ec,((ei&ec)>>8)*el),ek=ed(ej&eb,((ei&eb)>>8)*el),em=ed(ej&ee,(ei&ee)*el>>8);return ed(((ej&ef)>>>24)+el,255)<<24|eh+((eo-eh)*el>>8)&ec|en+((ek-en)*el>>8)&eb|ep+((em-ep)*el>>8)&ee},difference:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee,eo=ej>er?ej-er:er-ej,eh=eq>em?eq-em:em-eq,ei=es>ep?es-ep:ep-es;return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)},exclusion:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee,eo=ej+er-(ej*er>>7),eh=eq+em-(eq*em>>7),ei=es+ep-(es*ep>>7);return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)},multiply:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee,eo=ej*er>>8,eh=eq*em>>8,ei=es*ep>>8;return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)},screen:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee,eo=255-((255-ej)*(255-er)>>8),eh=255-((255-eq)*(255-em)>>8),ei=255-((255-es)*(255-ep)>>8);return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)},hard_light:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee,eo=er<128?ej*er>>7:255-((255-ej)*(255-er)>>7),eh=em<128?eq*em>>7:255-((255-eq)*(255-em)>>7),ei=ep<128?es*ep>>7:255-((255-es)*(255-ep)>>7);return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)},soft_light:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee,eo=(ej*er>>7)+(ej*ej>>8)-(ej*ej*er>>15),eh=(eq*em>>7)+(eq*eq>>8)-(eq*eq*em>>15),ei=(es*ep>>7)+(es*es>>8)-(es*es*ep>>15);return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)},overlay:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee,eo=ej<128?ej*er>>7:255-((255-ej)*(255-er)>>7),eh=eq<128?eq*em>>7:255-((255-eq)*(255-em)>>7),ei=es<128?es*ep>>7:255-((255-es)*(255-ep)>>7);return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)},dodge:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee;var eo=255;if(er!==255){eo=(ej<<8)/(255-er);eo=eo<0?0:eo>255?255:eo}var eh=255;if(em!==255){eh=(eq<<8)/(255-em);eh=eh<0?0:eh>255?255:eh}var ei=255;if(ep!==255){ei=(es<<8)/(255-ep);ei=ei<0?0:ei>255?255:ei}return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)},burn:function(el,ek){var en=(ek&ef)>>>24,ej=(el&ec)>>16,eq=(el&eb)>>8,es=el&ee,er=(ek&ec)>>16,em=(ek&eb)>>8,ep=ek&ee;var eo=0;if(er!==0){eo=(255-ej<<8)/er;eo=255-(eo<0?0:eo>255?255:eo)}var eh=0;if(em!==0){eh=(255-eq<<8)/em;eh=255-(eh<0?0:eh>255?255:eh)}var ei=0;if(ep!==0){ei=(255-es<<8)/ep;ei=255-(ei<0?0:ei>255?255:ei)}return eg(el,en,ej,eq,es,er,em,ep,eo,eh,ei)}}}();function dH(ef,ee,ec,eb){var ea,ed,eh,ei;if(cY===3){var eg=cW.color.toRGB(ef,ee,ec);ea=eg[0];ed=eg[1];eh=eg[2]}else{ea=q.round(255*(ef/bJ));ed=q.round(255*(ee/bI));eh=q.round(255*(ec/bG))}ei=q.round(255*(eb/bU));ea=ea<0?0:ea;ed=ed<0?0:ed;eh=eh<0?0:eh;ei=ei<0?0:ei;ea=ea>255?255:ea;ed=ed>255?255:ed;eh=eh>255?255:eh;ei=ei>255?255:ei;return ei<<24&4278190080|ea<<16&16711680|ed<<8&65280|eh&255}function dK(ea,ec){var eb;if(ea&4278190080){eb=q.round(255*(ec/bU));eb=eb>255?255:eb;eb=eb<0?0:eb;return ea-(ea&4278190080)+(eb<<24&4278190080)}if(cY===1){return dH(ea,ea,ea,ec)}if(cY===3){return dH(0,0,ea/bJ*bG,ec)}}function dM(ea){if(ea<=bJ&&ea>=0){if(cY===1){return dH(ea,ea,ea,bU)}if(cY===3){return dH(0,0,ea/bJ*bG,bU)}}if(ea){if(ea>2147483647){ea-=4294967296}return ea}}cW.color=function(ea,ed,ec,eb){if(ea!==t&&ed!==t&&ec!==t&&eb!==t){return dH(ea,ed,ec,eb)}if(ea!==t&&ed!==t&&ec!==t){return dH(ea,ed,ec,bU)}if(ea!==t&&ed!==t){return dK(ea,ed)}if(typeof ea===\"number\"){return dM(ea)}return dH(bJ,bI,bG,bU)};cW.color.toString=function(ea){return\"rgba(\"+((ea>>16)&255)+\",\"+((ea>>8)&255)+\",\"+(ea&255)+\",\"+((ea>>24)&255)/255+\")\"};cW.color.toInt=function(ed,ec,ea,eb){return eb<<24&4278190080|ed<<16&16711680|ec<<8&65280|ea&255};cW.color.toArray=function(ea){return[(ea>>16)&255,(ea>>8)&255,ea&255,(ea>>24)&255]};cW.color.toGLArray=function(ea){return[((ea&16711680)>>>16)/255,((ea>>8)&255)/255,(ea&255)/255,((ea>>24)&255)/255]};cW.color.toRGB=function(ec,ei,ef){ec=ec>bJ?bJ:ec;ei=ei>bI?bI:ei;ef=ef>bG?bG:ef;ec=ec/bJ*360;ei=ei/bI*100;ef=ef/bG*100;var eh=q.round(ef/100*255);if(ei===0){return[eh,eh,eh]}var ed=ec%360;var ee=ed%60;var eb=q.round(ef*(100-ei)/10000*255);var ea=q.round(ef*(6000-ei*ee)/600000*255);var eg=q.round(ef*(6000-ei*(60-ee))/600000*255);switch(q.floor(ed/60)){case 0:return[eh,eg,eb];case 1:return[ea,eh,eb];case 2:return[eb,eh,eg];case 3:return[eb,ea,eh];case 4:return[eg,eb,eh];case 5:return[eh,eb,ea]}};function aS(eh){var eg,ef,eb;eg=((eh>>16)&255)/255;ef=((eh>>8)&255)/255;eb=(eh&255)/255;var ea=cW.max(cW.max(eg,ef),eb),ed=cW.min(cW.min(eg,ef),eb),ec,ee;if(ed===ea){return[0,0,ea*bG]}ee=(ea-ed)/ea;if(eg===ea){ec=(ef-eb)/(ea-ed)}else{if(ef===ea){ec=2+(eb-eg)/(ea-ed)}else{ec=4+(eg-ef)/(ea-ed)}}ec/=6;if(ec<0){ec+=1}else{if(ec>1){ec-=1}}return[ec*bJ,ee*bI,ea*bG]}cW.brightness=function(ea){return aS(ea)[2]};cW.saturation=function(ea){return aS(ea)[1]};cW.hue=function(ea){return aS(ea)[0]};cW.red=function(ea){return((ea>>16)&255)/255*bJ};cW.green=function(ea){return((ea&65280)>>>8)/255*bI};cW.blue=function(ea){return(ea&255)/255*bG};cW.alpha=function(ea){return((ea>>24)&255)/255*bU};cW.lerpColor=function(em,el,ef){var ek,eq,er,es,eo,ea,eg,eu,en,ev,ee,et;var ei,eh,eb,ep,ej;var ed=cW.color(em);var ec=cW.color(el);if(cY===3){ei=aS(ed);eu=((ed>>24)&255)/bU;eh=aS(ec);et=((ec&4278190080)>>>24)/bU;ep=cW.lerp(ei[0],eh[0],ef);ej=cW.lerp(ei[1],eh[1],ef);er=cW.lerp(ei[2],eh[2],ef);eb=cW.color.toRGB(ep,ej,er);es=cW.lerp(eu,et,ef)*bU;return es<<24&4278190080|(eb[0]&255)<<16|(eb[1]&255)<<8|eb[2]&255}eo=(ed>>16)&255;ea=(ed>>8)&255;eg=ed&255;eu=((ed>>24)&255)/bU;en=(ec&16711680)>>>16;ev=(ec>>8)&255;ee=ec&255;et=((ec>>24)&255)/bU;ek=cW.lerp(eo,en,ef)|0;eq=cW.lerp(ea,ev,ef)|0;er=cW.lerp(eg,ee,ef)|0;es=cW.lerp(eu,et,ef)*bU;return es<<24&4278190080|ek<<16&16711680|eq<<8&65280|er&255};cW.colorMode=function(){cY=arguments[0];if(arguments.length>1){bJ=arguments[1];bI=arguments[2]||arguments[1];bG=arguments[3]||arguments[1];bU=arguments[4]||arguments[1]}};cW.blendColor=function(eb,ea,ec){if(ec===0){return cW.modes.replace(eb,ea)}else{if(ec===1){return cW.modes.blend(eb,ea)}else{if(ec===2){return cW.modes.add(eb,ea)}else{if(ec===4){return cW.modes.subtract(eb,ea)}else{if(ec===8){return cW.modes.lightest(eb,ea)}else{if(ec===16){return cW.modes.darkest(eb,ea)}else{if(ec===32){return cW.modes.difference(eb,ea)}else{if(ec===64){return cW.modes.exclusion(eb,ea)}else{if(ec===128){return cW.modes.multiply(eb,ea)}else{if(ec===256){return cW.modes.screen(eb,ea)}else{if(ec===1024){return cW.modes.hard_light(eb,ea)}else{if(ec===2048){return cW.modes.soft_light(eb,ea)}else{if(ec===512){return cW.modes.overlay(eb,ea)}else{if(ec===4096){return cW.modes.dodge(eb,ea)}else{if(ec===8192){return cW.modes.burn(eb,ea)}}}}}}}}}}}}}}}};function aD(){d8.save()}function cP(){d8.restore();b3=true;aq=true}cW.printMatrix=function(){dJ.print()};bR.prototype.translate=function(ea,eb){dJ.translate(ea,eb);aT.invTranslate(ea,eb);d8.translate(ea,eb)};bB.prototype.translate=function(ea,ec,eb){dJ.translate(ea,ec,eb);aT.invTranslate(ea,ec,eb)};bR.prototype.scale=function(ea,eb){dJ.scale(ea,eb);aT.invScale(ea,eb);d8.scale(ea,eb||ea)};bB.prototype.scale=function(ea,ec,eb){dJ.scale(ea,ec,eb);aT.invScale(ea,ec,eb)};bR.prototype.transform=function(eb){var ea=eb.array();d8.transform(ea[0],ea[3],ea[1],ea[4],ea[2],ea[5])};bB.prototype.transformm=function(ea){throw\"p.transform is currently not supported in 3D mode\"};bR.prototype.pushMatrix=function(){am.load(dJ);da.load(aT);aD()};bB.prototype.pushMatrix=function(){am.load(dJ);da.load(aT)};bR.prototype.popMatrix=function(){dJ.set(am.pop());aT.set(da.pop());cP()};bB.prototype.popMatrix=function(){dJ.set(am.pop());aT.set(da.pop())};bR.prototype.resetMatrix=function(){dJ.reset();aT.reset();d8.setTransform(1,0,0,1,0,0)};bB.prototype.resetMatrix=function(){dJ.reset();aT.reset()};ds.prototype.applyMatrix=function(){var ea=arguments;dJ.apply(ea[0],ea[1],ea[2],ea[3],ea[4],ea[5],ea[6],ea[7],ea[8],ea[9],ea[10],ea[11],ea[12],ea[13],ea[14],ea[15]);aT.invApply(ea[0],ea[1],ea[2],ea[3],ea[4],ea[5],ea[6],ea[7],ea[8],ea[9],ea[10],ea[11],ea[12],ea[13],ea[14],ea[15])};bR.prototype.applyMatrix=function(){var ea=arguments;for(var eb=ea.length;eb<16;eb++){ea[eb]=0}ea[10]=ea[15]=1;ds.prototype.applyMatrix.apply(this,ea)};cW.rotateX=function(ea){dJ.rotateX(ea);aT.invRotateX(ea)};bR.prototype.rotateZ=function(){throw\"rotateZ() is not supported in 2D mode. Use rotate(float) instead.\"};bB.prototype.rotateZ=function(ea){dJ.rotateZ(ea);aT.invRotateZ(ea)};cW.rotateY=function(ea){dJ.rotateY(ea);aT.invRotateY(ea)};bR.prototype.rotate=function(ea){dJ.rotateZ(ea);aT.invRotateZ(ea);d8.rotate(ea)};bB.prototype.rotate=function(ea){cW.rotateZ(ea)};bR.prototype.shearX=function(ea){dJ.shearX(ea);d8.transform(1,0,ea,1,0,0)};bB.prototype.shearX=function(ea){dJ.shearX(ea)};bR.prototype.shearY=function(ea){dJ.shearY(ea);d8.transform(1,ea,0,1,0,0)};bB.prototype.shearY=function(ea){dJ.shearY(ea)};cW.pushStyle=function(){aD();cW.pushMatrix();var ea={doFill:aH,currentFillColor:a1,doStroke:ce,currentStrokeColor:cv,curTint:bf,curRectMode:bK,curColorMode:cY,colorModeX:bJ,colorModeZ:bG,colorModeY:bI,colorModeA:bU,curTextFont:W,horizontalTextAlignment:N,verticalTextAlignment:c1,textMode:cI,curFontName:Y,curTextSize:d0,curTextAscent:a3,curTextDescent:dA,curTextLeading:d7};bm.push(ea)};cW.popStyle=function(){var ea=bm.pop();if(ea){cP();cW.popMatrix();aH=ea.doFill;a1=ea.currentFillColor;ce=ea.doStroke;cv=ea.currentStrokeColor;bf=ea.curTint;bK=ea.curRectMode;cY=ea.curColorMode;bJ=ea.colorModeX;bG=ea.colorModeZ;bI=ea.colorModeY;bU=ea.colorModeA;W=ea.curTextFont;Y=ea.curFontName;d0=ea.curTextSize;N=ea.horizontalTextAlignment;c1=ea.verticalTextAlignment;cI=ea.textMode;a3=ea.curTextAscent;dA=ea.curTextDescent;d7=ea.curTextLeading}else{throw\"Too many popStyle() without enough pushStyle()\"}};cW.year=function(){return(new Date).getFullYear()};cW.month=function(){return(new Date).getMonth()+1};cW.day=function(){return(new Date).getDate()};cW.hour=function(){return(new Date).getHours()};cW.minute=function(){return(new Date).getMinutes()};cW.second=function(){return(new Date).getSeconds()};cW.millis=function(){return Date.now()-dq};function ct(){var ea=(Date.now()-dt)/1000;P++;var eb=P/ea;if(ea>0.5){dt=Date.now();P=0;cW.__frameRate=eb}cW.frameCount++}bR.prototype.redraw=function(){ct();d8.lineWidth=dW;var ea=cW.pmouseX,eb=cW.pmouseY;cW.pmouseX=dN;cW.pmouseY=d5;aD();cW.draw();cP();dN=cW.mouseX;d5=cW.mouseY;cW.pmouseX=ea;cW.pmouseY=eb};bB.prototype.redraw=function(){ct();var ea=cW.pmouseX,eb=cW.pmouseY;cW.pmouseX=dN;cW.pmouseY=d5;d8.clear(d8.DEPTH_BUFFER_BIT);dC={attributes:{},locations:{}};cW.noLights();cW.lightFalloff(1,0,0);cW.shininess(1);cW.ambient(255,255,255);cW.specular(0,0,0);cW.emissive(0,0,0);cW.camera();cW.draw();dN=cW.mouseX;d5=cW.mouseY;cW.pmouseX=ea;cW.pmouseY=eb};cW.noLoop=function(){aC=false;ax=false;clearInterval(b4);cQ.onPause()};cW.loop=function(){if(ax){return}dt=Date.now();P=0;b4=D.setInterval(function(){try{cQ.onFrameStart();cW.redraw();cQ.onFrameEnd()}catch(ea){D.clearInterval(b4);throw ea}},az);aC=true;ax=true;cQ.onLoop()};cW.frameRate=function(ea){dU=ea;az=1000/dU;if(aC){cW.noLoop();cW.loop()}};var au=[];function bO(ec,eb,ea){if(ec.addEventListener){ec.addEventListener(eb,ea,false)}else{ec.attachEvent(\"on\"+eb,ea)}au.push({elem:ec,type:eb,fn:ea})}function de(ea){var ed=ea.elem,ec=ea.type,eb=ea.fn;if(ed.removeEventListener){ed.removeEventListener(ec,eb,false)}else{if(ed.detachEvent){ed.detachEvent(\"on\"+ec,eb)}}}cW.exit=function(){D.clearInterval(b4);L(cW.externals.canvas.id);delete ae.onmousedown;for(var eb in F.lib){if(F.lib.hasOwnProperty(eb)){if(F.lib[eb].hasOwnProperty(\"detach\")){F.lib[eb].detach(cW)}}}var ea=au.length;while(ea--){de(au[ea])}cQ.onExit()};cW.cursor=function(){if(arguments.length>1||arguments.length===1&&arguments[0] instanceof cW.PImage){var ed=arguments[0],ea,ef;if(arguments.length>=3){ea=arguments[1];ef=arguments[2];if(ea<0||ef<0||ef>=ed.height||ea>=ed.width){throw\"x and y must be non-negative and less than the dimensions of the image\"}}else{ea=ed.width>>>1;ef=ed.height>>>1}var eb=ed.toDataURL();var ec='url(\"'+eb+'\") '+ea+\" \"+ef+\", default\";Z=ae.style.cursor=ec}else{if(arguments.length===1){var ee=arguments[0];Z=ae.style.cursor=ee}else{Z=ae.style.cursor=ck}}};cW.noCursor=function(){Z=ae.style.cursor=B.NOCURSOR};cW.link=function(ea,eb){if(eb!==t){D.open(ea,eb)}else{D.location=ea}};cW.beginDraw=G;cW.endDraw=G;bR.prototype.toImageData=function(ea,ed,eb,ec){ea=ea!==t?ea:0;ed=ed!==t?ed:0;eb=eb!==t?eb:cW.width;ec=ec!==t?ec:cW.height;return d8.getImageData(ea,ed,eb,ec)};bB.prototype.toImageData=function(ei,eh,ej,ee){ei=ei!==t?ei:0;eh=eh!==t?eh:0;ej=ej!==t?ej:cW.width;ee=ee!==t?ee:cW.height;var eg=d.createElement(\"canvas\"),ek=eg.getContext(\"2d\"),ed=ek.createImageData(ej,ee),eb=new b(ej*ee*4);d8.readPixels(ei,eh,ej,ee,d8.RGBA,d8.UNSIGNED_BYTE,eb);for(var ec=0,ef=eb.length,ea=ed.data;ec<ef;ec++){ea[ec]=eb[(ee-1-q.floor(ec/4/ej))*ej*4+ec%(ej*4)]}return ed};cW.status=function(ea){D.status=ea};cW.binary=function(eb,ec){var ed;if(ec>0){ed=ec}else{if(eb instanceof bP){ed=16;eb|=0}else{ed=32;while(ed>1&&!(eb>>>ed-1&1)){ed--}}}var ea=\"\";while(ed>0){ea+=eb>>>--ed&1?\"1\":\"0\"}return ea};cW.unbinary=function(eb){var ed=eb.length-1,ec=1,ea=0;while(ed>=0){var ee=eb[ed--];if(ee!==\"0\"&&ee!==\"1\"){throw\"the value passed into unbinary was not an 8 bit binary number\"}if(ee===\"1\"){ea+=ec}ec<<=1}return ea};function cX(em,ek,ee,ep,eg,en){var ec=em<0?ee:ek;var eb=eg===0;var el=eg===t||eg<0?0:eg;var ej=q.abs(em);if(eb){el=1;ej*=10;while(q.abs(q.round(ej)-ej)>0.000001&&el<7){++el;ej*=10}}else{if(el!==0){ej*=q.pow(10,el)}}var ed,ei=ej*2;if(q.floor(ej)===ej){ed=ej}else{if(q.floor(ei)===ei){var ea=q.floor(ej);ed=ea+ea%2}else{ed=q.round(ej)}}var ef=\"\";var eo=ep+el;while(eo>0||ed>0){eo--;ef=\"\"+ed%10+ef;ed=q.floor(ed/10)}if(en!==t){var eh=ef.length-3-el;while(eh>0){ef=ef.substring(0,eh)+en+ef.substring(eh);eh-=3}}if(el>0){return ec+ef.substring(0,ef.length-el)+\".\"+ef.substring(ef.length-el,ef.length)}return ec+ef}function ao(eg,ef,ea,ei,eb,eh){if(eg instanceof Array){var ed=[];for(var ec=0,ee=eg.length;ec<ee;ec++){ed.push(cX(eg[ec],ef,ea,ei,eb,eh))}return ed}return cX(eg,ef,ea,ei,eb,eh)}cW.nf=function(ec,ea,eb){return ao(ec,\"\",\"-\",ea,eb)};cW.nfs=function(ec,ea,eb){return ao(ec,\" \",\"-\",ea,eb)};cW.nfp=function(ec,ea,eb){return ao(ec,\"+\",\"-\",ea,eb)};cW.nfc=function(ec,ea,eb){return ao(ec,\"\",\"-\",ea,eb,\",\")};var aM=function(ec,eb){eb=eb===t||eb===null?eb=8:eb;if(ec<0){ec=4294967295+ec+1}var ea=Number(ec).toString(16).toUpperCase();while(ea.length<eb){ea=\"0\"+ea}if(ea.length>=eb){ea=ea.substring(ea.length-eb,ea.length)}return ea};cW.hex=function(eb,ea){if(arguments.length===1){if(eb instanceof bP){ea=4}else{ea=8}}return aM(eb,ea)};function dF(ea){var eb=parseInt(\"0x\"+ea,16);if(eb>2147483647){eb-=4294967296}return eb}cW.unhex=function(ec){if(ec instanceof Array){var ea=[];for(var eb=0;eb<ec.length;eb++){ea.push(dF(ec[eb]))}return ea}return dF(ec)};cW.loadStrings=function(eb){if(localStorage[eb]){return localStorage[eb].split(\"\\n\")}var ea=w(eb);if(typeof ea!==\"string\"||ea===\"\"){return[]}ea=ea.replace(/(\\r\\n?)/g,\"\\n\").replace(/\\n$/,\"\");return ea.split(\"\\n\")};cW.saveStrings=function(eb,ea){localStorage[eb]=ea.join(\"\\n\")};cW.loadBytes=function(ec){var eb=w(ec);var ea=[];for(var ed=0;ed<eb.length;ed++){ea.push(eb.charCodeAt(ed))}return ea};function bc(ea){return Array.prototype.slice.call(ea,1)}cW.matchAll=function(eb,ea){var ed=[],ec;var ee=new RegExp(ea,\"g\");while((ec=ee.exec(eb))!==null){ed.push(ec);if(ec[0].length===0){++ee.lastIndex}}return ed.length>0?ed:null};cW.__contains=function(eb,ea){if(typeof eb!==\"string\"){return eb.contains.apply(eb,bc(arguments))}return eb!==null&&ea!==null&&typeof ea===\"string\"&&eb.indexOf(ea)>-1};cW.__replaceAll=function(ea,ec,eb){if(typeof ea!==\"string\"){return ea.replaceAll.apply(ea,bc(arguments))}return ea.replace(new RegExp(ec,\"g\"),eb)};cW.__replaceFirst=function(ea,ec,eb){if(typeof ea!==\"string\"){return ea.replaceFirst.apply(ea,bc(arguments))}return ea.replace(new RegExp(ec,\"\"),eb)};cW.__replace=function(ed,ef,ee){if(typeof ed!==\"string\"){return ed.replace.apply(ed,bc(arguments))}if(ef instanceof RegExp){return ed.replace(ef,ee)}if(typeof ef!==\"string\"){ef=ef.toString()}if(ef===\"\"){return ed}var ec=ed.indexOf(ef);if(ec<0){return ed}var eb=0,ea=\"\";do{ea+=ed.substring(eb,ec)+ee;eb=ec+ef.length}while((ec=ed.indexOf(ef,eb))>=0);return ea+ed.substring(eb)};cW.__equals=function(eb,ea){if(eb.equals instanceof Function){return eb.equals.apply(eb,bc(arguments))}return eb.valueOf()===ea.valueOf()};cW.__equalsIgnoreCase=function(eb,ea){if(typeof eb!==\"string\"){return eb.equalsIgnoreCase.apply(eb,bc(arguments))}return eb.toLowerCase()===ea.toLowerCase()};cW.__toCharArray=function(ec){if(typeof ec!==\"string\"){return ec.toCharArray.apply(ec,bc(arguments))}var ed=[];for(var eb=0,ea=ec.length;eb<ea;++eb){ed[eb]=new bP(ec.charAt(eb))}return ed};cW.__split=function(ed,ee,eb){if(typeof ed!==\"string\"){return ed.split.apply(ed,bc(arguments))}var eg=new RegExp(ee);if(eb===t||eb<1){return ed.split(eg)}var ea=[],ef=ed,eh;while((eh=ef.search(eg))!==-1&&ea.length<eb-1){var ec=eg.exec(ef).toString();ea.push(ef.substring(0,eh));ef=ef.substring(eh+ec.length)}if(eh!==-1||ef!==\"\"){ea.push(ef)}return ea};cW.__codePointAt=function(ed,eb){var ee=ed.charCodeAt(eb),ec,ea;if(55296<=ee&&ee<=56319){ec=ee;ea=ed.charCodeAt(eb+1);return(ec-55296)*1024+(ea-56320)+65536}return ee};cW.match=function(eb,ea){return eb.match(ea)};cW.__matches=function(eb,ea){return(new RegExp(ea)).test(eb)};cW.__startsWith=function(ea,ec,eb){if(typeof ea!==\"string\"){return ea.startsWith.apply(ea,bc(arguments))}eb=eb||0;if(eb<0||eb>ea.length){return false}return ec===\"\"||ec===ea?true:ea.indexOf(ec)===eb};cW.__endsWith=function(eb,ec){if(typeof eb!==\"string\"){return eb.endsWith.apply(eb,bc(arguments))}var ea=ec?ec.length:0;return ec===\"\"||ec===eb?true:eb.indexOf(ec)===eb.length-ea};cW.__hashCode=function(ea){if(ea.hashCode instanceof Function){return ea.hashCode.apply(ea,bc(arguments))}return h(ea)};cW.__printStackTrace=function(ea){cW.println(\"Exception: \"+ea.toString())};var d9=[];cW.println=function(ea){var eb=d9.length;if(eb){F.logger.log(d9.join(\"\"));d9.length=0}if(arguments.length===0&&eb===0){F.logger.log(\"\")}else{if(arguments.length!==0){F.logger.log(ea)}}};cW.print=function(ea){d9.push(ea)};cW.str=function(ec){if(ec instanceof Array){var ea=[];for(var eb=0;eb<ec.length;eb++){ea.push(ec[eb].toString()+\"\")}return ea}return ec.toString()+\"\"};cW.trim=function(ec){if(ec instanceof Array){var ea=[];for(var eb=0;eb<ec.length;eb++){ea.push(ec[eb].replace(/^\\s*/,\"\").replace(/\\s*$/,\"\").replace(/\\r*$/,\"\"))}return ea}return ec.replace(/^\\s*/,\"\").replace(/\\s*$/,\"\").replace(/\\r*$/,\"\")};function aR(ea){if(typeof ea===\"number\"){return ea!==0}if(typeof ea===\"boolean\"){return ea}if(typeof ea===\"string\"){return ea.toLowerCase()===\"true\"}if(ea instanceof bP){return ea.code===49||ea.code===84||ea.code===116}}cW.parseBoolean=function(ec){if(ec instanceof Array){var ea=[];for(var eb=0;eb<ec.length;eb++){ea.push(aR(ec[eb]))}return ea}return aR(ec)};cW.parseByte=function(ec){if(ec instanceof Array){var ea=[];for(var eb=0;eb<ec.length;eb++){ea.push(0-(ec[eb]&128)|ec[eb]&127)}return ea}return 0-(ec&128)|ec&127};cW.parseChar=function(ec){if(typeof ec===\"number\"){return new bP(String.fromCharCode(ec&65535))}if(ec instanceof Array){var ea=[];for(var eb=0;eb<ec.length;eb++){ea.push(new bP(String.fromCharCode(ec[eb]&65535)))}return ea}throw\"char() may receive only one argument of type int, byte, int[], or byte[].\"};function cO(ea){if(typeof ea===\"number\"){return ea}if(typeof ea===\"boolean\"){return ea?1:0}if(typeof ea===\"string\"){return parseFloat(ea)}if(ea instanceof bP){return ea.code}}cW.parseFloat=function(ec){if(ec instanceof Array){var ea=[];for(var eb=0;eb<ec.length;eb++){ea.push(cO(ec[eb]))}return ea}return cO(ec)};function al(ec,ea){if(typeof ec===\"number\"){return ec&4294967295}if(typeof ec===\"boolean\"){return ec?1:0}if(typeof ec===\"string\"){var eb=parseInt(ec,ea||10);return eb&4294967295}if(ec instanceof bP){return ec.code}}cW.parseInt=function(ed,ec){if(ed instanceof Array){var ea=[];for(var eb=0;eb<ed.length;eb++){if(typeof ed[eb]===\"string\"&&!/^\\s*[+\\-]?\\d+\\s*$/.test(ed[eb])){ea.push(0)}else{ea.push(al(ed[eb],ec))}}return ea}return al(ed,ec)};cW.__int_cast=function(ea){return 0|ea};cW.__instanceof=function(ec,eb){if(typeof eb!==\"function\"){throw\"Function is expected as type argument for instanceof operator\"}if(typeof ec===\"string\"){return eb===Object||eb===String}if(ec instanceof eb){return true}if(typeof ec!==\"object\"||ec===null){return false}var ee=ec.constructor;if(eb.$isInterface){var ed=[];while(ee){if(ee.$interfaces){ed=ed.concat(ee.$interfaces)}ee=ee.$base}while(ed.length>0){var ea=ed.shift();if(ea===eb){return true}if(ea.$interfaces){ed=ed.concat(ea.$interfaces)}}return false}while(ee.hasOwnProperty(\"$base\")){ee=ee.$base;if(ee===eb){return true}}return false};cW.abs=q.abs;cW.ceil=q.ceil;cW.constrain=function(eb,ec,ea){return eb>ea?ea:eb<ec?ec:eb};cW.dist=function(){var ec,eb,ea;if(arguments.length===4){ec=arguments[0]-arguments[2];eb=arguments[1]-arguments[3];return q.sqrt(ec*ec+eb*eb)}if(arguments.length===6){ec=arguments[0]-arguments[3];eb=arguments[1]-arguments[4];ea=arguments[2]-arguments[5];return q.sqrt(ec*ec+eb*eb+ea*ea)}};cW.exp=q.exp;cW.floor=q.floor;cW.lerp=function(eb,ea,ec){return(ea-eb)*ec+eb};cW.log=q.log;cW.mag=function(eb,ea,ec){if(ec){return q.sqrt(eb*eb+ea*ea+ec*ec)}return q.sqrt(eb*eb+ea*ea)};cW.map=function(ed,eb,ec,ea,ee){return ea+(ee-ea)*((ed-eb)/(ec-eb))};cW.max=function(){if(arguments.length===2){return arguments[0]<arguments[1]?arguments[1]:arguments[0]}var eb=arguments.length===1?arguments[0]:arguments;if(!(\"length\" in eb&&eb.length>0)){throw\"Non-empty array is expected\"}var ea=eb[0],ed=eb.length;for(var ec=1;ec<ed;++ec){if(ea<eb[ec]){ea=eb[ec]}}return ea};cW.min=function(){if(arguments.length===2){return arguments[0]<arguments[1]?arguments[0]:arguments[1]}var ea=arguments.length===1?arguments[0]:arguments;if(!(\"length\" in ea&&ea.length>0)){throw\"Non-empty array is expected\"}var ec=ea[0],ed=ea.length;for(var eb=1;eb<ed;++eb){if(ec>ea[eb]){ec=ea[eb]}}return ec};cW.norm=function(eb,ea,ec){return(eb-ea)/(ec-ea)};cW.pow=q.pow;cW.round=q.round;cW.sq=function(ea){return ea*ea};cW.sqrt=q.sqrt;cW.acos=q.acos;cW.asin=q.asin;cW.atan=q.atan;cW.atan2=q.atan2;cW.cos=q.cos;cW.degrees=function(ea){return ea*180/q.PI};cW.radians=function(ea){return ea/180*q.PI};cW.sin=q.sin;cW.tan=q.tan;var bY=q.random;cW.random=function(){if(arguments.length===0){return bY()}if(arguments.length===1){return bY()*arguments[0]}var eb=arguments[0],ea=arguments[1];return bY()*(ea-eb)+eb};function co(ec,eb){var ee=ec||362436069,ea=eb||521288629;var ed=function(){ee=36969*(ee&65535)+(ee>>>16)&4294967295;ea=18000*(ea&65535)+(ea>>>16)&4294967295;return((ee&65535)<<16|ea&65535)&4294967295};this.nextDouble=function(){var ef=ed()/4294967296;return ef<0?1+ef:ef};this.nextInt=ed}co.createRandomized=function(){var ea=new Date;return new co(ea/60000&4294967295,ea&4294967295)};cW.randomSeed=function(ea){bY=(new co(ea)).nextDouble};cW.Random=function(ea){var ed=false,eb,ec;this.nextGaussian=function(){if(ed){ed=false;return eb}var eh,ef,ee;do{eh=2*ec()-1;ef=2*ec()-1;ee=eh*eh+ef*ef}while(ee>=1||ee===0);var eg=q.sqrt(-2*q.log(ee)/ee);eb=ef*eg;ed=true;return eh*eg};ec=ea===t?q.random:(new co(ea)).nextDouble};function dz(eh){var eb=eh!==t?new co(eh):co.createRandomized();var eg,ee;var ed=new b(512);for(eg=0;eg<256;++eg){ed[eg]=eg}for(eg=0;eg<256;++eg){var ej=ed[ee=eb.nextInt()&255];ed[ee]=ed[eg];ed[eg]=ej}for(eg=0;eg<256;++eg){ed[eg+256]=ed[eg]}function ea(en,ek,eq,ep){var eo=en&15;var em=eo<8?ek:eq,el=eo<4?eq:eo===12||eo===14?ek:ep;return((eo&1)===0?em:-em)+((eo&2)===0?el:-el)}function ef(em,ek,en){var el=(em&1)===0?ek:en;return(em&2)===0?-el:el}function ei(el,ek){return(el&1)===0?-ek:ek}function ec(em,el,ek){return el+em*(ek-el)}this.noise3d=function(ew,ev,eu){var en=q.floor(ew)&255,el=q.floor(ev)&255,ek=q.floor(eu)&255;ew-=q.floor(ew);ev-=q.floor(ev);eu-=q.floor(eu);var er=(3-2*ew)*ew*ew,eq=(3-2*ev)*ev*ev,ep=(3-2*eu)*eu*eu;var ey=ed[en]+el,et=ed[ey]+ek,es=ed[ey+1]+ek,ex=ed[en+1]+el,eo=ed[ex]+ek,em=ed[ex+1]+ek;return ec(ep,ec(eq,ec(er,ea(ed[et],ew,ev,eu),ea(ed[eo],ew-1,ev,eu)),ec(er,ea(ed[es],ew,ev-1,eu),ea(ed[em],ew-1,ev-1,eu))),ec(eq,ec(er,ea(ed[et+1],ew,ev,eu-1),ea(ed[eo+1],ew-1,ev,eu-1)),ec(er,ea(ed[es+1],ew,ev-1,eu-1),ea(ed[em+1],ew-1,ev-1,eu-1))))};this.noise2d=function(ek,er){var eq=q.floor(ek)&255,eo=q.floor(er)&255;ek-=q.floor(ek);er-=q.floor(er);var em=(3-2*ek)*ek*ek,el=(3-2*er)*er*er;var ep=ed[eq]+eo,en=ed[eq+1]+eo;return ec(el,ec(em,ef(ed[ep],ek,er),ef(ed[en],ek-1,er)),ec(em,ef(ed[ep+1],ek,er-1),ef(ed[en+1],ek-1,er-1)))};this.noise1d=function(ek){var em=q.floor(ek)&255;ek-=q.floor(ek);var el=(3-2*ek)*ek*ek;return ec(el,ei(ed[em],ek),ei(ed[em+1],ek-1))}}var bW={generator:t,octaves:4,fallout:0.5,seed:t};cW.noise=function(ea,eh,eg){if(bW.generator===t){bW.generator=new dz(bW.seed)}var ef=bW.generator;var ee=1,eb=1,ed=0;for(var ec=0;ec<bW.octaves;++ec){ee*=bW.fallout;switch(arguments.length){case 1:ed+=ee*(1+ef.noise1d(eb*ea))/2;break;case 2:ed+=ee*(1+ef.noise2d(eb*ea,eb*eh))/2;break;case 3:ed+=ee*(1+ef.noise3d(eb*ea,eb*eh,eb*eg))/2;break}eb*=2}return ed};cW.noiseDetail=function(eb,ea){bW.octaves=eb;if(ea!==t){bW.fallout=ea}};cW.noiseSeed=function(ea){bW.seed=ea;bW.generator=t};ds.prototype.size=function(eb,ee,ed){if(ce){cW.stroke(0)}if(aH){cW.fill(255)}var ec={fillStyle:d8.fillStyle,strokeStyle:d8.strokeStyle,lineCap:d8.lineCap,lineJoin:d8.lineJoin};if(ae.style.length>0){ae.style.removeProperty(\"width\");ae.style.removeProperty(\"height\")}ae.width=cW.width=eb||100;ae.height=cW.height=ee||100;for(var ef in ec){if(ec.hasOwnProperty(ef)){d8[ef]=ec[ef]}}cW.textFont(W);cW.background();bZ=q.max(1000,eb*ee*0.05);cW.externals.context=d8;for(var ea=0;ea<720;ea++){ah[ea]=cW.sin(ea*(q.PI/180)*0.5);bl[ea]=cW.cos(ea*(q.PI/180)*0.5)}};bR.prototype.size=function(ea,ec,eb){if(d8===t){d8=ae.getContext(\"2d\");am=new V;da=new V;dJ=new aX;aT=new aX}ds.prototype.size.apply(this,arguments)};bB.prototype.size=function(){var eb=false;return function ea(ed,ef,ee){if(eb){throw\"Multiple calls to size() for 3D renders are not allowed.\"}eb=true;function eg(ei){var el=[\"experimental-webgl\",\"webgl\",\"webkit-3d\"],ek;for(var ej=0,eh=el.length;ej<eh;ej++){ek=ei.getContext(el[ej],{antialias:false,preserveDrawingBuffer:true});if(ek){break}}return ek}try{ae.width=cW.width=ed||100;ae.height=cW.height=ef||100;d8=eg(ae);c7=d8.createTexture();bS=d8.createTexture()}catch(ec){F.debug(ec)}if(!d8){throw\"WebGL context is not supported on this browser.\"}d8.viewport(0,0,ae.width,ae.height);d8.enable(d8.DEPTH_TEST);d8.enable(d8.BLEND);d8.blendFunc(d8.SRC_ALPHA,d8.ONE_MINUS_SRC_ALPHA);dQ=bF(d8,dE,aW);bT=bF(d8,aO,bQ);cW.strokeWeight(1);dx=bF(d8,dn,aF);d8.useProgram(dx);dZ(\"usingTexture3d\",dx,\"usingTexture\",dT);cW.lightFalloff(1,0,0);cW.shininess(1);cW.ambient(255,255,255);cW.specular(0,0,0);cW.emissive(0,0,0);bh=d8.createBuffer();d8.bindBuffer(d8.ARRAY_BUFFER,bh);d8.bufferData(d8.ARRAY_BUFFER,dh,d8.STATIC_DRAW);cJ=d8.createBuffer();d8.bindBuffer(d8.ARRAY_BUFFER,cJ);d8.bufferData(d8.ARRAY_BUFFER,df,d8.STATIC_DRAW);dk=d8.createBuffer();d8.bindBuffer(d8.ARRAY_BUFFER,dk);d8.bufferData(d8.ARRAY_BUFFER,bH,d8.STATIC_DRAW);aB=d8.createBuffer();d8.bindBuffer(d8.ARRAY_BUFFER,aB);d8.bufferData(d8.ARRAY_BUFFER,ak,d8.STATIC_DRAW);b2=d8.createBuffer();d8.bindBuffer(d8.ARRAY_BUFFER,b2);d8.bufferData(d8.ARRAY_BUFFER,ai,d8.STATIC_DRAW);bg=d8.createBuffer();b8=d8.createBuffer();at=d8.createBuffer();aG=d8.createBuffer();bC=d8.createBuffer();af=d8.createBuffer();aw=d8.createBuffer();d8.bindBuffer(d8.ARRAY_BUFFER,aw);d8.bufferData(d8.ARRAY_BUFFER,new e([0,0,0]),d8.STATIC_DRAW);cH=d8.createBuffer();d8.bindBuffer(d8.ARRAY_BUFFER,cH);d8.bufferData(d8.ARRAY_BUFFER,new e([1,1,0,-1,1,0,-1,-1,0,1,-1,0]),d8.STATIC_DRAW);ac=d8.createBuffer();d8.bindBuffer(d8.ARRAY_BUFFER,ac);d8.bufferData(d8.ARRAY_BUFFER,new e([0,0,1,0,1,1,0,1]),d8.STATIC_DRAW);R=d8.createBuffer();d8.bindBuffer(d8.ELEMENT_ARRAY_BUFFER,R);d8.bufferData(d8.ELEMENT_ARRAY_BUFFER,new y([0,1,2,2,3,0]),d8.STATIC_DRAW);bV=new aP;ch=new aP;dJ=new aP;aT=new aP;db=new aP;cW.camera();cW.perspective();am=new V;da=new V;c3=new aP;aQ=new aP;aL=new aP;bz=new aP;cd=new aP;U=new aP;U.set(-1,3,-3,1,3,-6,3,0,-3,3,0,0,1,0,0,0);ds.prototype.size.apply(this,arguments)}}();bR.prototype.ambientLight=ds.prototype.a3DOnlyFunction;bB.prototype.ambientLight=function(ea,ed,ei,ej,ef,ee){if(dL===8){throw\"can only create \"+8+\" lights\"}var eg=new A(ej,ef,ee);var eh=new aP;eh.scale(1,-1,1);eh.apply(dJ.array());eh.mult(eg,eg);var eb=dH(ea,ed,ei,0);var ec=[((eb>>16)&255)/255,((eb>>8)&255)/255,(eb&255)/255];d8.useProgram(dx);d2(\"uLights.color.3d.\"+dL,dx,\"uLights\"+dL+\".color\",ec);d2(\"uLights.position.3d.\"+dL,dx,\"uLights\"+dL+\".position\",eg.array());dZ(\"uLights.type.3d.\"+dL,dx,\"uLights\"+dL+\".type\",0);dZ(\"uLightCount3d\",dx,\"uLightCount\",++dL)};bR.prototype.directionalLight=ds.prototype.a3DOnlyFunction;bB.prototype.directionalLight=function(ea,eg,ei,eh,ef,ee){if(dL===8){throw\"can only create \"+8+\" lights\"}d8.useProgram(dx);var ej=new aP;ej.scale(1,-1,1);ej.apply(dJ.array());ej=ej.array();var ec=[ej[0]*eh+ej[4]*ef+ej[8]*ee,ej[1]*eh+ej[5]*ef+ej[9]*ee,ej[2]*eh+ej[6]*ef+ej[10]*ee];var eb=dH(ea,eg,ei,0);var ed=[((eb>>16)&255)/255,((eb>>8)&255)/255,(eb&255)/255];d2(\"uLights.color.3d.\"+dL,dx,\"uLights\"+dL+\".color\",ed);d2(\"uLights.position.3d.\"+dL,dx,\"uLights\"+dL+\".position\",ec);dZ(\"uLights.type.3d.\"+dL,dx,\"uLights\"+dL+\".type\",1);dZ(\"uLightCount3d\",dx,\"uLightCount\",++dL)};bR.prototype.lightFalloff=ds.prototype.a3DOnlyFunction;bB.prototype.lightFalloff=function(eb,ea,ec){d8.useProgram(dx);d2(\"uFalloff3d\",dx,\"uFalloff\",[eb,ea,ec])};bR.prototype.lightSpecular=ds.prototype.a3DOnlyFunction;bB.prototype.lightSpecular=function(ee,ed,ea){var eb=dH(ee,ed,ea,0);var ec=[((eb>>16)&255)/255,((eb>>8)&255)/255,(eb&255)/255];d8.useProgram(dx);d2(\"uSpecular3d\",dx,\"uSpecular\",ec)};cW.lights=function(){cW.ambientLight(128,128,128);cW.directionalLight(128,128,128,0,0,-1);cW.lightFalloff(1,0,0);cW.lightSpecular(0,0,0)};bR.prototype.pointLight=ds.prototype.a3DOnlyFunction;bB.prototype.pointLight=function(ea,ed,ei,ej,ef,ee){if(dL===8){throw\"can only create \"+8+\" lights\"}var eg=new A(ej,ef,ee);var eh=new aP;eh.scale(1,-1,1);eh.apply(dJ.array());eh.mult(eg,eg);var eb=dH(ea,ed,ei,0);var ec=[((eb>>16)&255)/255,((eb>>8)&255)/255,(eb&255)/255];d8.useProgram(dx);d2(\"uLights.color.3d.\"+dL,dx,\"uLights\"+dL+\".color\",ec);d2(\"uLights.position.3d.\"+dL,dx,\"uLights\"+dL+\".position\",eg.array());dZ(\"uLights.type.3d.\"+dL,dx,\"uLights\"+dL+\".type\",2);dZ(\"uLightCount3d\",dx,\"uLightCount\",++dL)};bR.prototype.noLights=ds.prototype.a3DOnlyFunction;bB.prototype.noLights=function(){dL=0;d8.useProgram(dx);dZ(\"uLightCount3d\",dx,\"uLightCount\",dL)};bR.prototype.spotLight=ds.prototype.a3DOnlyFunction;bB.prototype.spotLight=function(ea,ei,en,eo,em,ek,ej,eh,ef,ee,eg){if(dL===8){throw\"can only create \"+8+\" lights\"}d8.useProgram(dx);var el=new A(eo,em,ek);var ep=new aP;ep.scale(1,-1,1);ep.apply(dJ.array());ep.mult(el,el);ep=ep.array();var ec=[ep[0]*ej+ep[4]*eh+ep[8]*ef,ep[1]*ej+ep[5]*eh+ep[9]*ef,ep[2]*ej+ep[6]*eh+ep[10]*ef];var eb=dH(ea,ei,en,0);var ed=[((eb>>16)&255)/255,((eb>>8)&255)/255,(eb&255)/255];d2(\"uLights.color.3d.\"+dL,dx,\"uLights\"+dL+\".color\",ed);d2(\"uLights.position.3d.\"+dL,dx,\"uLights\"+dL+\".position\",el.array());d2(\"uLights.direction.3d.\"+dL,dx,\"uLights\"+dL+\".direction\",ec);d2(\"uLights.concentration.3d.\"+dL,dx,\"uLights\"+dL+\".concentration\",eg);d2(\"uLights.angle.3d.\"+dL,dx,\"uLights\"+dL+\".angle\",ee);dZ(\"uLights.type.3d.\"+dL,dx,\"uLights\"+dL+\".type\",3);dZ(\"uLightCount3d\",dx,\"uLightCount\",++dL)};bR.prototype.beginCamera=function(){throw\"beginCamera() is not available in 2D mode\"};bB.prototype.beginCamera=function(){if(ap){throw\"You cannot call beginCamera() again before calling endCamera()\"}ap=true;dJ=ch;aT=bV};bR.prototype.endCamera=function(){throw\"endCamera() is not available in 2D mode\"};bB.prototype.endCamera=function(){if(!ap){throw\"You cannot call endCamera() before calling beginCamera()\"}dJ.set(bV);aT.set(ch);ap=false};cW.camera=function(el,ek,ei,eg,ee,ed,et,er,ep){if(el===t){dl=cW.width/2;dj=cW.height/2;di=dj/q.tan(cK/2);el=dl;ek=dj;ei=di;eg=dl;ee=dj;ed=0;et=0;er=1;ep=0}var ef=new A(el-eg,ek-ee,ei-ed);var eh=new A(et,er,ep);ef.normalize();var ej=A.cross(eh,ef);eh=A.cross(ef,ej);ej.normalize();eh.normalize();var eu=ej.x,es=ej.y,eq=ej.z;var ec=eh.x,eb=eh.y,ea=eh.z;var eo=ef.x,en=ef.y,em=ef.z;bV.set(eu,es,eq,0,ec,eb,ea,0,eo,en,em,0,0,0,0,1);bV.translate(-el,-ek,-ei);ch.reset();ch.invApply(eu,es,eq,0,ec,eb,ea,0,eo,en,em,0,0,0,0,1);ch.translate(el,ek,ei);dJ.set(bV);aT.set(ch)};cW.perspective=function(ee,ec,ef,eb){if(arguments.length===0){dj=ae.height/2;di=dj/q.tan(cK/2);a0=di/10;av=di*10;b5=cW.width/cW.height;ee=cK;ec=b5;ef=a0;eb=av}var eg,ea,eh,ed;eg=ef*q.tan(ee/2);ea=-eg;eh=eg*ec;ed=ea*ec;cW.frustum(ed,eh,ea,eg,ef,eb)};bR.prototype.frustum=function(){throw\"Processing.js: frustum() is not supported in 2D mode\"};bB.prototype.frustum=function(eg,ec,eb,ef,ee,ea){ci=true;db=new aP;db.set(2*ee/(ec-eg),0,(ec+eg)/(ec-eg),0,0,2*ee/(ef-eb),(ef+eb)/(ef-eb),0,0,0,-(ea+ee)/(ea-ee),-(2*ea*ee)/(ea-ee),0,0,-1,0);var ed=new aP;ed.set(db);ed.transpose();d8.useProgram(dQ);a9(\"projection2d\",dQ,\"uProjection\",false,ed.array());d8.useProgram(dx);a9(\"projection3d\",dx,\"uProjection\",false,ed.array());d8.useProgram(bT);a9(\"uProjectionUS\",bT,\"uProjection\",false,ed.array())};cW.ortho=function(eb,em,ea,ek,eh,eg){if(arguments.length===0){eb=0;em=cW.width;ea=0;ek=cW.height;eh=-10;eg=10}var el=2/(em-eb);var ej=2/(ek-ea);var ei=-2/(eg-eh);var ef=-(em+eb)/(em-eb);var ee=-(ek+ea)/(ek-ea);var ed=-(eg+eh)/(eg-eh);db=new aP;db.set(el,0,0,ef,0,ej,0,ee,0,0,ei,ed,0,0,0,1);var ec=new aP;ec.set(db);ec.transpose();d8.useProgram(dQ);a9(\"projection2d\",dQ,\"uProjection\",false,ec.array());d8.useProgram(dx);a9(\"projection3d\",dx,\"uProjection\",false,ec.array());d8.useProgram(bT);a9(\"uProjectionUS\",bT,\"uProjection\",false,ec.array());ci=false};cW.printProjection=function(){db.print()};cW.printCamera=function(){bV.print()};bR.prototype.box=ds.prototype.a3DOnlyFunction;bB.prototype.box=function(ec,ef,eh){if(!ef||!eh){ef=eh=ec}var ee=new aP;ee.scale(ec,ef,eh);var eb=new aP;eb.scale(1,-1,1);eb.apply(dJ.array());eb.transpose();if(aH){d8.useProgram(dx);a9(\"model3d\",dx,\"uModel\",false,ee.array());a9(\"view3d\",dx,\"uView\",false,eb.array());d8.enable(d8.POLYGON_OFFSET_FILL);d8.polygonOffset(1,1);d2(\"color3d\",dx,\"uColor\",bo);if(dL>0){var ed=new aP;ed.set(eb);var ea=new aP;ea.set(ee);ed.mult(ea);var eg=new aP;eg.set(ed);eg.invert();eg.transpose();a9(\"uNormalTransform3d\",dx,\"uNormalTransform\",false,eg.array());dc(\"aNormal3d\",dx,\"aNormal\",3,cJ)}else{cg(\"aNormal3d\",dx,\"aNormal\")}dc(\"aVertex3d\",dx,\"aVertex\",3,bh);cg(\"aColor3d\",dx,\"aColor\");cg(\"aTexture3d\",dx,\"aTexture\");d8.drawArrays(d8.TRIANGLES,0,dh.length/3);d8.disable(d8.POLYGON_OFFSET_FILL)}if(dW>0&&ce){d8.useProgram(dQ);a9(\"uModel2d\",dQ,\"uModel\",false,ee.array());a9(\"uView2d\",dQ,\"uView\",false,eb.array());d2(\"uColor2d\",dQ,\"uColor\",c0);dZ(\"uIsDrawingText2d\",dQ,\"uIsDrawingText\",false);dc(\"vertex2d\",dQ,\"aVertex\",3,dk);cg(\"aTextureCoord2d\",dQ,\"aTextureCoord\");d8.drawArrays(d8.LINES,0,bH.length/3)}};var cD=function(){var eb;cF=[];for(eb=0;eb<bM;eb++){cF.push(0);cF.push(-1);cF.push(0);cF.push(bt[eb]);cF.push(bs[eb]);cF.push(br[eb])}cF.push(0);cF.push(-1);cF.push(0);cF.push(bt[0]);cF.push(bs[0]);cF.push(br[0]);var ef,ec,ee;var ed=0;for(eb=2;eb<bL;eb++){ef=ec=ed;ed+=bM;ee=ed;for(var ea=0;ea<bM;ea++){cF.push(bt[ef]);cF.push(bs[ef]);cF.push(br[ef++]);cF.push(bt[ee]);cF.push(bs[ee]);cF.push(br[ee++])}ef=ec;ee=ed;cF.push(bt[ef]);cF.push(bs[ef]);cF.push(br[ef]);cF.push(bt[ee]);cF.push(bs[ee]);cF.push(br[ee])}for(eb=0;eb<bM;eb++){ee=ed+eb;cF.push(bt[ee]);cF.push(bs[ee]);cF.push(br[ee]);cF.push(0);cF.push(1);cF.push(0)}cF.push(bt[ed]);cF.push(bs[ed]);cF.push(br[ed]);cF.push(0);cF.push(1);cF.push(0);d8.bindBuffer(d8.ARRAY_BUFFER,bg);d8.bufferData(d8.ARRAY_BUFFER,new e(cF),d8.STATIC_DRAW)};cW.sphereDetail=function(eb,em){var eh;if(arguments.length===1){eb=em=arguments[0]}if(eb<3){eb=3}if(em<2){em=2}if(eb===bM&&em===bL){return}var el=720/eb;var ef=new e(eb);var ec=new e(eb);for(eh=0;eh<eb;eh++){ef[eh]=bl[eh*el%720|0];ec[eh]=ah[eh*el%720|0]}var ek=eb*(em-1)+2;var ej=0;bt=new e(ek);bs=new e(ek);br=new e(ek);var ei=720*0.5/em;var ee=ei;for(eh=1;eh<em;eh++){var ed=ah[ee%720|0];var ea=-bl[ee%720|0];for(var eg=0;eg<eb;eg++){bt[ej]=ef[eg]*ed;bs[ej]=ea;br[ej++]=ec[eg]*ed}ee+=ei}bM=eb;bL=em;cD()};bR.prototype.sphere=ds.prototype.a3DOnlyFunction;bB.prototype.sphere=function(){var ee=arguments[0];if(bM<3||bL<2){cW.sphereDetail(30)}var ed=new aP;ed.scale(ee,ee,ee);var eb=new aP;eb.scale(1,-1,1);eb.apply(dJ.array());eb.transpose();if(aH){if(dL>0){var ec=new aP;ec.set(eb);var ea=new aP;ea.set(ed);ec.mult(ea);var ef=new aP;ef.set(ec);ef.invert();ef.transpose();a9(\"uNormalTransform3d\",dx,\"uNormalTransform\",false,ef.array());dc(\"aNormal3d\",dx,\"aNormal\",3,bg)}else{cg(\"aNormal3d\",dx,\"aNormal\")}d8.useProgram(dx);cg(\"aTexture3d\",dx,\"aTexture\");a9(\"uModel3d\",dx,\"uModel\",false,ed.array());a9(\"uView3d\",dx,\"uView\",false,eb.array());dc(\"aVertex3d\",dx,\"aVertex\",3,bg);cg(\"aColor3d\",dx,\"aColor\");d8.enable(d8.POLYGON_OFFSET_FILL);d8.polygonOffset(1,1);d2(\"uColor3d\",dx,\"uColor\",bo);d8.drawArrays(d8.TRIANGLE_STRIP,0,cF.length/3);d8.disable(d8.POLYGON_OFFSET_FILL)}if(dW>0&&ce){d8.useProgram(dQ);a9(\"uModel2d\",dQ,\"uModel\",false,ed.array());a9(\"uView2d\",dQ,\"uView\",false,eb.array());dc(\"aVertex2d\",dQ,\"aVertex\",3,bg);cg(\"aTextureCoord2d\",dQ,\"aTextureCoord\");d2(\"uColor2d\",dQ,\"uColor\",c0);dZ(\"uIsDrawingText\",dQ,\"uIsDrawingText\",false);d8.drawArrays(d8.LINE_STRIP,0,cF.length/3)}};cW.modelX=function(eg,ef,ee){var ei=dJ.array();var ek=ch.array();var ea=ei[0]*eg+ei[1]*ef+ei[2]*ee+ei[3];var ej=ei[4]*eg+ei[5]*ef+ei[6]*ee+ei[7];var eh=ei[8]*eg+ei[9]*ef+ei[10]*ee+ei[11];var eb=ei[12]*eg+ei[13]*ef+ei[14]*ee+ei[15];var ec=ek[0]*ea+ek[1]*ej+ek[2]*eh+ek[3]*eb;var ed=ek[12]*ea+ek[13]*ej+ek[14]*eh+ek[15]*eb;return ed!==0?ec/ed:ec};cW.modelY=function(eg,ef,ee){var ei=dJ.array();var ek=ch.array();var ea=ei[0]*eg+ei[1]*ef+ei[2]*ee+ei[3];var ej=ei[4]*eg+ei[5]*ef+ei[6]*ee+ei[7];var eh=ei[8]*eg+ei[9]*ef+ei[10]*ee+ei[11];var eb=ei[12]*eg+ei[13]*ef+ei[14]*ee+ei[15];var ec=ek[4]*ea+ek[5]*ej+ek[6]*eh+ek[7]*eb;var ed=ek[12]*ea+ek[13]*ej+ek[14]*eh+ek[15]*eb;return ed!==0?ec/ed:ec};cW.modelZ=function(eg,ef,ee){var ei=dJ.array();var ek=ch.array();var ea=ei[0]*eg+ei[1]*ef+ei[2]*ee+ei[3];var ej=ei[4]*eg+ei[5]*ef+ei[6]*ee+ei[7];var eh=ei[8]*eg+ei[9]*ef+ei[10]*ee+ei[11];var ec=ei[12]*eg+ei[13]*ef+ei[14]*ee+ei[15];var eb=ek[8]*ea+ek[9]*ej+ek[10]*eh+ek[11]*ec;var ed=ek[12]*ea+ek[13]*ej+ek[14]*eh+ek[15]*ec;return ed!==0?eb/ed:eb};bR.prototype.ambient=ds.prototype.a3DOnlyFunction;bB.prototype.ambient=function(ed,ec,eb){d8.useProgram(dx);dZ(\"uUsingMat3d\",dx,\"uUsingMat\",true);var ea=cW.color(ed,ec,eb);d2(\"uMaterialAmbient3d\",dx,\"uMaterialAmbient\",cW.color.toGLArray(ea).slice(0,3))};bR.prototype.emissive=ds.prototype.a3DOnlyFunction;bB.prototype.emissive=function(ed,ec,eb){d8.useProgram(dx);dZ(\"uUsingMat3d\",dx,\"uUsingMat\",true);var ea=cW.color(ed,ec,eb);d2(\"uMaterialEmissive3d\",dx,\"uMaterialEmissive\",cW.color.toGLArray(ea).slice(0,3))};bR.prototype.shininess=ds.prototype.a3DOnlyFunction;bB.prototype.shininess=function(ea){d8.useProgram(dx);dZ(\"uUsingMat3d\",dx,\"uUsingMat\",true);d2(\"uShininess3d\",dx,\"uShininess\",ea)};bR.prototype.specular=ds.prototype.a3DOnlyFunction;bB.prototype.specular=function(ed,ec,eb){d8.useProgram(dx);dZ(\"uUsingMat3d\",dx,\"uUsingMat\",true);var ea=cW.color(ed,ec,eb);d2(\"uMaterialSpecular3d\",dx,\"uMaterialSpecular\",cW.color.toGLArray(ea).slice(0,3))};cW.screenX=function(eh,eg,ef){var ej=dJ.array();if(ej.length===16){var ea=ej[0]*eh+ej[1]*eg+ej[2]*ef+ej[3];var ek=ej[4]*eh+ej[5]*eg+ej[6]*ef+ej[7];var ei=ej[8]*eh+ej[9]*eg+ej[10]*ef+ej[11];var eb=ej[12]*eh+ej[13]*eg+ej[14]*ef+ej[15];var ee=db.array();var ec=ee[0]*ea+ee[1]*ek+ee[2]*ei+ee[3]*eb;var ed=ee[12]*ea+ee[13]*ek+ee[14]*ei+ee[15]*eb;if(ed!==0){ec/=ed}return cW.width*(1+ec)/2}return dJ.multX(eh,eg)};cW.screenY=function aA(eh,eg,ef){var ej=dJ.array();if(ej.length===16){var ea=ej[0]*eh+ej[1]*eg+ej[2]*ef+ej[3];var ek=ej[4]*eh+ej[5]*eg+ej[6]*ef+ej[7];var ei=ej[8]*eh+ej[9]*eg+ej[10]*ef+ej[11];var eb=ej[12]*eh+ej[13]*eg+ej[14]*ef+ej[15];var ee=db.array();var ec=ee[4]*ea+ee[5]*ek+ee[6]*ei+ee[7]*eb;var ed=ee[12]*ea+ee[13]*ek+ee[14]*ei+ee[15]*eb;if(ed!==0){ec/=ed}return cW.height*(1+ec)/2}return dJ.multY(eh,eg)};cW.screenZ=function ay(eh,eg,ef){var ej=dJ.array();if(ej.length!==16){return 0}var ee=db.array();var ea=ej[0]*eh+ej[1]*eg+ej[2]*ef+ej[3];var ek=ej[4]*eh+ej[5]*eg+ej[6]*ef+ej[7];var ei=ej[8]*eh+ej[9]*eg+ej[10]*ef+ej[11];var ec=ej[12]*eh+ej[13]*eg+ej[14]*ef+ej[15];var eb=ee[8]*ea+ee[9]*ek+ee[10]*ei+ee[11]*ec;var ed=ee[12]*ea+ee[13]*ek+ee[14]*ei+ee[15]*ec;if(ed!==0){eb/=ed}return(eb+1)/2};ds.prototype.fill=function(){var ea=cW.color(arguments[0],arguments[1],arguments[2],arguments[3]);if(ea===a1&&aH){return}aH=true;a1=ea};bR.prototype.fill=function(){ds.prototype.fill.apply(this,arguments);aq=true};bB.prototype.fill=function(){ds.prototype.fill.apply(this,arguments);bo=cW.color.toGLArray(a1)};function bn(){if(aH){if(aq){d8.fillStyle=cW.color.toString(a1);aq=false}d8.fill()}}cW.noFill=function(){aH=false};ds.prototype.stroke=function(){var ea=cW.color(arguments[0],arguments[1],arguments[2],arguments[3]);if(ea===cv&&ce){return}ce=true;cv=ea};bR.prototype.stroke=function(){ds.prototype.stroke.apply(this,arguments);b3=true};bB.prototype.stroke=function(){ds.prototype.stroke.apply(this,arguments);c0=cW.color.toGLArray(cv)};function dd(){if(ce){if(b3){d8.strokeStyle=cW.color.toString(cv);b3=false}d8.stroke()}}cW.noStroke=function(){ce=false};ds.prototype.strokeWeight=function(ea){dW=ea};bR.prototype.strokeWeight=function(ea){ds.prototype.strokeWeight.apply(this,arguments);d8.lineWidth=ea};bB.prototype.strokeWeight=function(ea){ds.prototype.strokeWeight.apply(this,arguments);d8.useProgram(dQ);d2(\"pointSize2d\",dQ,\"uPointSize\",ea);d8.useProgram(bT);d2(\"pointSizeUnlitShape\",bT,\"uPointSize\",ea);d8.lineWidth(ea)};cW.strokeCap=function(ea){dY.$ensureContext().lineCap=ea};cW.strokeJoin=function(ea){dY.$ensureContext().lineJoin=ea};bR.prototype.smooth=function(){dO=true;var ea=ae.style;ea.setProperty(\"image-rendering\",\"optimizeQuality\",\"important\");ea.setProperty(\"-ms-interpolation-mode\",\"bicubic\",\"important\");if(d8.hasOwnProperty(\"mozImageSmoothingEnabled\")){d8.mozImageSmoothingEnabled=true}};bB.prototype.smooth=function(){dO=true};bR.prototype.noSmooth=function(){dO=false;var ea=ae.style;ea.setProperty(\"image-rendering\",\"optimizeSpeed\",\"important\");ea.setProperty(\"image-rendering\",\"-moz-crisp-edges\",\"important\");ea.setProperty(\"image-rendering\",\"-webkit-optimize-contrast\",\"important\");ea.setProperty(\"image-rendering\",\"optimize-contrast\",\"important\");ea.setProperty(\"-ms-interpolation-mode\",\"nearest-neighbor\",\"important\");if(d8.hasOwnProperty(\"mozImageSmoothingEnabled\")){d8.mozImageSmoothingEnabled=false}};bB.prototype.noSmooth=function(){dO=false};bR.prototype.point=function(ea,eb){if(!ce){return}ea=q.round(ea);eb=q.round(eb);d8.fillStyle=cW.color.toString(cv);aq=true;if(dW>1){d8.beginPath();d8.arc(ea,eb,dW/2,0,6.283185307179586,false);d8.fill()}else{d8.fillRect(ea,eb,1,1)}};bB.prototype.point=function(ea,ee,ed){var ec=new aP;ec.translate(ea,ee,ed||0);ec.transpose();var eb=new aP;eb.scale(1,-1,1);eb.apply(dJ.array());eb.transpose();d8.useProgram(dQ);a9(\"uModel2d\",dQ,\"uModel\",false,ec.array());a9(\"uView2d\",dQ,\"uView\",false,eb.array());if(dW>0&&ce){d2(\"uColor2d\",dQ,\"uColor\",c0);dZ(\"uIsDrawingText2d\",dQ,\"uIsDrawingText\",false);dZ(\"uSmooth2d\",dQ,\"uSmooth\",dO);dc(\"aVertex2d\",dQ,\"aVertex\",3,aw);cg(\"aTextureCoord2d\",dQ,\"aTextureCoord\");d8.drawArrays(d8.POINTS,0,1)}};cW.beginShape=function(ea){dR=ea;d6=[];bb=[]};bR.prototype.vertex=function(eb,ed,ea){var ec=[];if(du){du=false}ec.isVert=true;ec[0]=eb;ec[1]=ed;ec[2]=0;ec[3]=0;ec[4]=0;ec[5]=a1;ec[6]=cv;bb.push(ec);if(ea){bb[bb.length-1][\"moveTo\"]=ea}};bB.prototype.vertex=function(ea,ef,ee,ed,ec){var eb=[];if(du){du=false}eb.isVert=true;if(ec===t&&dT){ec=ed;ed=ee;ee=0}if(ed!==t&&ec!==t){if(d4===2){ed/=cs.width;ec/=cs.height}ed=ed>1?1:ed;ed=ed<0?0:ed;ec=ec>1?1:ec;ec=ec<0?0:ec}eb[0]=ea;eb[1]=ef;eb[2]=ee||0;eb[3]=ed||0;eb[4]=ec||0;eb[5]=bo[0];eb[6]=bo[1];eb[7]=bo[2];eb[8]=bo[3];eb[9]=c0[0];eb[10]=c0[1];eb[11]=c0[2];eb[12]=c0[3];eb[13]=a8;eb[14]=a7;eb[15]=a6;bb.push(eb)};var d1=function(ec,eb){var ea=new aP;ea.scale(1,-1,1);ea.apply(dJ.array());ea.transpose();d8.useProgram(bT);a9(\"uViewUS\",bT,\"uView\",false,ea.array());dZ(\"uSmoothUS\",bT,\"uSmooth\",dO);dc(\"aVertexUS\",bT,\"aVertex\",3,aw);d8.bufferData(d8.ARRAY_BUFFER,new e(ec),d8.STREAM_DRAW);dc(\"aColorUS\",bT,\"aColor\",4,aG);d8.bufferData(d8.ARRAY_BUFFER,new e(eb),d8.STREAM_DRAW);d8.drawArrays(d8.POINTS,0,ec.length/3)};var bj=function(ee,ed,ec){var eb;if(ed===\"LINES\"){eb=d8.LINES}else{if(ed===\"LINE_LOOP\"){eb=d8.LINE_LOOP}else{eb=d8.LINE_STRIP}}var ea=new aP;ea.scale(1,-1,1);ea.apply(dJ.array());ea.transpose();d8.useProgram(bT);a9(\"uViewUS\",bT,\"uView\",false,ea.array());dc(\"aVertexUS\",bT,\"aVertex\",3,b8);d8.bufferData(d8.ARRAY_BUFFER,new e(ee),d8.STREAM_DRAW);dc(\"aColorUS\",bT,\"aColor\",4,bC);d8.bufferData(d8.ARRAY_BUFFER,new e(ec),d8.STREAM_DRAW);d8.drawArrays(eb,0,ee.length/3)};var dm=function(ef,ee,ed,ec){var eb;if(ee===\"TRIANGLES\"){eb=d8.TRIANGLES}else{if(ee===\"TRIANGLE_FAN\"){eb=d8.TRIANGLE_FAN}else{eb=d8.TRIANGLE_STRIP}}var ea=new aP;ea.scale(1,-1,1);ea.apply(dJ.array());ea.transpose();d8.useProgram(dx);a9(\"model3d\",dx,\"uModel\",false,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);a9(\"view3d\",dx,\"uView\",false,ea.array());d8.enable(d8.POLYGON_OFFSET_FILL);d8.polygonOffset(1,1);d2(\"color3d\",dx,\"uColor\",[-1,0,0,0]);dc(\"vertex3d\",dx,\"aVertex\",3,at);d8.bufferData(d8.ARRAY_BUFFER,new e(ef),d8.STREAM_DRAW);if(dT&&bf!==null){bw(ed)}dc(\"aColor3d\",dx,\"aColor\",4,aG);d8.bufferData(d8.ARRAY_BUFFER,new e(ed),d8.STREAM_DRAW);cg(\"aNormal3d\",dx,\"aNormal\");if(dT){dZ(\"uUsingTexture3d\",dx,\"uUsingTexture\",dT);dc(\"aTexture3d\",dx,\"aTexture\",2,af);d8.bufferData(d8.ARRAY_BUFFER,new e(ec),d8.STREAM_DRAW)}d8.drawArrays(eb,0,ef.length/3);d8.disable(d8.POLYGON_OFFSET_FILL)};function cS(){bn();dd();d8.closePath()}bR.prototype.endShape=function(eh){if(bb.length===0){return}var ed=eh===2;if(ed){bb.push(bb[0])}var ec=[];var ea=[];var ej=[];var em=[];var ef=[];var ei;du=true;var eg,ee,eb;var el=bb.length;for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=0;ee<3;ee++){ea.push(ei[ee])}}for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=5;ee<9;ee++){ej.push(ei[ee])}}for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=9;ee<13;ee++){em.push(ei[ee])}}for(eg=0;eg<el;eg++){ei=bb[eg];ef.push(ei[3]);ef.push(ei[4])}if(dP&&(dR===20||dR===t)){if(el>3){var ek=[],en=1-aJ;d8.beginPath();d8.moveTo(bb[1][0],bb[1][1]);for(eg=1;eg+2<el;eg++){ei=bb[eg];ek[0]=[ei[0],ei[1]];ek[1]=[ei[0]+(en*bb[eg+1][0]-en*bb[eg-1][0])/6,ei[1]+(en*bb[eg+1][1]-en*bb[eg-1][1])/6];ek[2]=[bb[eg+1][0]+(en*bb[eg][0]-en*bb[eg+2][0])/6,bb[eg+1][1]+(en*bb[eg][1]-en*bb[eg+2][1])/6];ek[3]=[bb[eg+1][0],bb[eg+1][1]];d8.bezierCurveTo(ek[1][0],ek[1][1],ek[2][0],ek[2][1],ek[3][0],ek[3][1])}cS()}}else{if(aa&&(dR===20||dR===t)){d8.beginPath();for(eg=0;eg<el;eg++){ei=bb[eg];if(bb[eg][\"isVert\"]){if(bb[eg][\"moveTo\"]){d8.moveTo(ei[0],ei[1])}else{d8.lineTo(ei[0],ei[1])}}else{d8.bezierCurveTo(bb[eg][0],bb[eg][1],bb[eg][2],bb[eg][3],bb[eg][4],bb[eg][5])}}cS()}else{if(dR===2){for(eg=0;eg<el;eg++){ei=bb[eg];if(ce){cW.stroke(ei[6])}cW.point(ei[0],ei[1])}}else{if(dR===4){for(eg=0;eg+1<el;eg+=2){ei=bb[eg];if(ce){cW.stroke(bb[eg+1][6])}cW.line(ei[0],ei[1],bb[eg+1][0],bb[eg+1][1])}}else{if(dR===9){for(eg=0;eg+2<el;eg+=3){ei=bb[eg];d8.beginPath();d8.moveTo(ei[0],ei[1]);d8.lineTo(bb[eg+1][0],bb[eg+1][1]);d8.lineTo(bb[eg+2][0],bb[eg+2][1]);d8.lineTo(ei[0],ei[1]);if(aH){cW.fill(bb[eg+2][5]);bn()}if(ce){cW.stroke(bb[eg+2][6]);dd()}d8.closePath()}}else{if(dR===10){for(eg=0;eg+1<el;eg++){ei=bb[eg];d8.beginPath();d8.moveTo(bb[eg+1][0],bb[eg+1][1]);d8.lineTo(ei[0],ei[1]);if(ce){cW.stroke(bb[eg+1][6])}if(aH){cW.fill(bb[eg+1][5])}if(eg+2<el){d8.lineTo(bb[eg+2][0],bb[eg+2][1]);if(ce){cW.stroke(bb[eg+2][6])}if(aH){cW.fill(bb[eg+2][5])}}cS()}}else{if(dR===11){if(el>2){d8.beginPath();d8.moveTo(bb[0][0],bb[0][1]);d8.lineTo(bb[1][0],bb[1][1]);d8.lineTo(bb[2][0],bb[2][1]);if(aH){cW.fill(bb[2][5]);bn()}if(ce){cW.stroke(bb[2][6]);dd()}d8.closePath();for(eg=3;eg<el;eg++){ei=bb[eg];d8.beginPath();d8.moveTo(bb[0][0],bb[0][1]);d8.lineTo(bb[eg-1][0],bb[eg-1][1]);d8.lineTo(ei[0],ei[1]);if(aH){cW.fill(ei[5]);bn()}if(ce){cW.stroke(ei[6]);dd()}d8.closePath()}}}else{if(dR===16){for(eg=0;eg+3<el;eg+=4){ei=bb[eg];d8.beginPath();d8.moveTo(ei[0],ei[1]);for(ee=1;ee<4;ee++){d8.lineTo(bb[eg+ee][0],bb[eg+ee][1])}d8.lineTo(ei[0],ei[1]);if(aH){cW.fill(bb[eg+3][5]);bn()}if(ce){cW.stroke(bb[eg+3][6]);dd()}d8.closePath()}}else{if(dR===17){if(el>3){for(eg=0;eg+1<el;eg+=2){ei=bb[eg];d8.beginPath();if(eg+3<el){d8.moveTo(bb[eg+2][0],bb[eg+2][1]);d8.lineTo(ei[0],ei[1]);d8.lineTo(bb[eg+1][0],bb[eg+1][1]);d8.lineTo(bb[eg+3][0],bb[eg+3][1]);if(aH){cW.fill(bb[eg+3][5])}if(ce){cW.stroke(bb[eg+3][6])}}else{d8.moveTo(ei[0],ei[1]);d8.lineTo(bb[eg+1][0],bb[eg+1][1])}cS()}}}else{d8.beginPath();d8.moveTo(bb[0][0],bb[0][1]);for(eg=1;eg<el;eg++){ei=bb[eg];if(ei.isVert){if(ei.moveTo){d8.moveTo(ei[0],ei[1])}else{d8.lineTo(ei[0],ei[1])}}}cS()}}}}}}}}}dP=false;aa=false;cb=[];c2=0;if(ed){bb.pop()}};bB.prototype.endShape=function(eh){if(bb.length===0){return}var ed=eh===2;var ec=[];var ea=[];var ej=[];var em=[];var ef=[];var ei;du=true;var eg,ee,eb;var el=bb.length;for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=0;ee<3;ee++){ea.push(ei[ee])}}for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=5;ee<9;ee++){ej.push(ei[ee])}}for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=9;ee<13;ee++){em.push(ei[ee])}}for(eg=0;eg<el;eg++){ei=bb[eg];ef.push(ei[3]);ef.push(ei[4])}if(ed){ea.push(bb[0][0]);ea.push(bb[0][1]);ea.push(bb[0][2]);for(eg=5;eg<9;eg++){ej.push(bb[0][eg])}for(eg=9;eg<13;eg++){em.push(bb[0][eg])}ef.push(bb[0][3]);ef.push(bb[0][4])}if(dP&&(dR===20||dR===t)){ec=ea;if(ce){bj(ec,null,em)}if(aH){dm(ea,null,ej)}}else{if(aa&&(dR===20||dR===t)){ec=ea;ec.splice(ec.length-3);em.splice(em.length-4);if(ce){bj(ec,null,em)}if(aH){dm(ea,\"TRIANGLES\",ej)}}else{if(dR===2){for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=0;ee<3;ee++){ec.push(ei[ee])}}d1(ec,em)}else{if(dR===4){for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=0;ee<3;ee++){ec.push(ei[ee])}}for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=5;ee<9;ee++){ej.push(ei[ee])}}bj(ec,\"LINES\",em)}else{if(dR===9){if(el>2){for(eg=0;eg+2<el;eg+=3){ea=[];ef=[];ec=[];ej=[];em=[];for(ee=0;ee<3;ee++){for(eb=0;eb<3;eb++){ec.push(bb[eg+ee][eb]);ea.push(bb[eg+ee][eb])}}for(ee=0;ee<3;ee++){for(eb=3;eb<5;eb++){ef.push(bb[eg+ee][eb])}}for(ee=0;ee<3;ee++){for(eb=5;eb<9;eb++){ej.push(bb[eg+ee][eb]);em.push(bb[eg+ee][eb+4])}}if(ce){bj(ec,\"LINE_LOOP\",em)}if(aH||dT){dm(ea,\"TRIANGLES\",ej,ef)}}}}else{if(dR===10){if(el>2){for(eg=0;eg+2<el;eg++){ec=[];ea=[];em=[];ej=[];ef=[];for(ee=0;ee<3;ee++){for(eb=0;eb<3;eb++){ec.push(bb[eg+ee][eb]);ea.push(bb[eg+ee][eb])}}for(ee=0;ee<3;ee++){for(eb=3;eb<5;eb++){ef.push(bb[eg+ee][eb])}}for(ee=0;ee<3;ee++){for(eb=5;eb<9;eb++){em.push(bb[eg+ee][eb+4]);ej.push(bb[eg+ee][eb])}}if(aH||dT){dm(ea,\"TRIANGLE_STRIP\",ej,ef)}if(ce){bj(ec,\"LINE_LOOP\",em)}}}}else{if(dR===11){if(el>2){for(eg=0;eg<3;eg++){ei=bb[eg];for(ee=0;ee<3;ee++){ec.push(ei[ee])}}for(eg=0;eg<3;eg++){ei=bb[eg];for(ee=9;ee<13;ee++){em.push(ei[ee])}}if(ce){bj(ec,\"LINE_LOOP\",em)}for(eg=2;eg+1<el;eg++){ec=[];em=[];ec.push(bb[0][0]);ec.push(bb[0][1]);ec.push(bb[0][2]);em.push(bb[0][9]);em.push(bb[0][10]);em.push(bb[0][11]);em.push(bb[0][12]);for(ee=0;ee<2;ee++){for(eb=0;eb<3;eb++){ec.push(bb[eg+ee][eb])}}for(ee=0;ee<2;ee++){for(eb=9;eb<13;eb++){em.push(bb[eg+ee][eb])}}if(ce){bj(ec,\"LINE_STRIP\",em)}}if(aH||dT){dm(ea,\"TRIANGLE_FAN\",ej,ef)}}}else{if(dR===16){for(eg=0;eg+3<el;eg+=4){ec=[];for(ee=0;ee<4;ee++){ei=bb[eg+ee];for(eb=0;eb<3;eb++){ec.push(ei[eb])}}if(ce){bj(ec,\"LINE_LOOP\",em)}if(aH){ea=[];ej=[];ef=[];for(ee=0;ee<3;ee++){ea.push(bb[eg][ee])}for(ee=5;ee<9;ee++){ej.push(bb[eg][ee])}for(ee=0;ee<3;ee++){ea.push(bb[eg+1][ee])}for(ee=5;ee<9;ee++){ej.push(bb[eg+1][ee])}for(ee=0;ee<3;ee++){ea.push(bb[eg+3][ee])}for(ee=5;ee<9;ee++){ej.push(bb[eg+3][ee])}for(ee=0;ee<3;ee++){ea.push(bb[eg+2][ee])}for(ee=5;ee<9;ee++){ej.push(bb[eg+2][ee])}if(dT){ef.push(bb[eg+0][3]);ef.push(bb[eg+0][4]);ef.push(bb[eg+1][3]);ef.push(bb[eg+1][4]);ef.push(bb[eg+3][3]);ef.push(bb[eg+3][4]);ef.push(bb[eg+2][3]);ef.push(bb[eg+2][4])}dm(ea,\"TRIANGLE_STRIP\",ej,ef)}}}else{if(dR===17){var ek=[];if(el>3){for(eg=0;eg<2;eg++){ei=bb[eg];for(ee=0;ee<3;ee++){ec.push(ei[ee])}}for(eg=0;eg<2;eg++){ei=bb[eg];for(ee=9;ee<13;ee++){em.push(ei[ee])}}bj(ec,\"LINE_STRIP\",em);if(el>4&&el%2>0){ek=ea.splice(ea.length-3);bb.pop()}for(eg=0;eg+3<el;eg+=2){ec=[];em=[];for(ee=0;ee<3;ee++){ec.push(bb[eg+1][ee])}for(ee=0;ee<3;ee++){ec.push(bb[eg+3][ee])}for(ee=0;ee<3;ee++){ec.push(bb[eg+2][ee])}for(ee=0;ee<3;ee++){ec.push(bb[eg+0][ee])}for(ee=9;ee<13;ee++){em.push(bb[eg+1][ee])}for(ee=9;ee<13;ee++){em.push(bb[eg+3][ee])}for(ee=9;ee<13;ee++){em.push(bb[eg+2][ee])}for(ee=9;ee<13;ee++){em.push(bb[eg+0][ee])}if(ce){bj(ec,\"LINE_STRIP\",em)}}if(aH||dT){dm(ea,\"TRIANGLE_LIST\",ej,ef)}}}else{if(el===1){for(ee=0;ee<3;ee++){ec.push(bb[0][ee])}for(ee=9;ee<13;ee++){em.push(bb[0][ee])}d1(ec,em)}else{for(eg=0;eg<el;eg++){ei=bb[eg];for(ee=0;ee<3;ee++){ec.push(ei[ee])}for(ee=5;ee<9;ee++){em.push(ei[ee])}}if(ce&&ed){bj(ec,\"LINE_LOOP\",em)}else{if(ce&&!ed){bj(ec,\"LINE_STRIP\",em)}}if(aH||dT){dm(ea,\"TRIANGLE_FAN\",ej,ef)}}}}}}}}}dT=false;d8.useProgram(dx);dZ(\"usingTexture3d\",dx,\"uUsingTexture\",dT)}}dP=false;aa=false;cb=[];c2=0};var aY=function(ed,ec){var ee=1/ed;var eb=ee*ee;var ea=eb*ee;ec.set(0,0,0,1,ea,eb,ee,0,6*ea,2*eb,0,0,6*ea,0,0,0)};var dr=function(){if(!aL){c3=new aP;aL=new aP;cM=true}var ea=aJ;c3.set((ea-1)/2,(ea+3)/2,(-3-ea)/2,(1-ea)/2,1-ea,(-5-ea)/2,ea+2,(ea-1)/2,(ea-1)/2,0,(1-ea)/2,0,0,1,0,0);aY(Q,aL);if(!cd){aQ=new aP}aQ.set(c3);aQ.preApply(cd);aL.apply(c3)};bR.prototype.bezierVertex=function(){aa=true;var ea=[];if(du){throw\"vertex() must be used at least once before calling bezierVertex()\"}for(var eb=0;eb<arguments.length;eb++){ea[eb]=arguments[eb]}bb.push(ea);bb[bb.length-1][\"isVert\"]=false};bB.prototype.bezierVertex=function(){aa=true;var eh=[];if(du){throw\"vertex() must be used at least once before calling bezierVertex()\"}if(arguments.length===9){if(bz===t){bz=new aP}var em=bb.length-1;aY(cy,bz);bz.apply(U);var eo=bz.array();var ed=bb[em][0],en=bb[em][1],eg=bb[em][2];var ej=eo[4]*ed+eo[5]*arguments[0]+eo[6]*arguments[3]+eo[7]*arguments[6];var ei=eo[8]*ed+eo[9]*arguments[0]+eo[10]*arguments[3]+eo[11]*arguments[6];var ef=eo[12]*ed+eo[13]*arguments[0]+eo[14]*arguments[3]+eo[15]*arguments[6];var ep=eo[4]*en+eo[5]*arguments[1]+eo[6]*arguments[4]+eo[7]*arguments[7];var el=eo[8]*en+eo[9]*arguments[1]+eo[10]*arguments[4]+eo[11]*arguments[7];var ek=eo[12]*en+eo[13]*arguments[1]+eo[14]*arguments[4]+eo[15]*arguments[7];var ec=eo[4]*eg+eo[5]*arguments[2]+eo[6]*arguments[5]+eo[7]*arguments[8];var eb=eo[8]*eg+eo[9]*arguments[2]+eo[10]*arguments[5]+eo[11]*arguments[8];var ea=eo[12]*eg+eo[13]*arguments[2]+eo[14]*arguments[5]+eo[15]*arguments[8];for(var ee=0;ee<cy;ee++){ed+=ej;ej+=ei;ei+=ef;en+=ep;ep+=el;el+=ek;eg+=ec;ec+=eb;eb+=ea;cW.vertex(ed,en,eg)}cW.vertex(arguments[6],arguments[7],arguments[8])}};cW.texture=function(ed){var eb=dY.$ensureContext();if(ed.__texture){eb.bindTexture(eb.TEXTURE_2D,ed.__texture)}else{if(ed.localName===\"canvas\"){eb.bindTexture(eb.TEXTURE_2D,c7);eb.texImage2D(eb.TEXTURE_2D,0,eb.RGBA,eb.RGBA,eb.UNSIGNED_BYTE,ed);eb.texParameteri(eb.TEXTURE_2D,eb.TEXTURE_MAG_FILTER,eb.LINEAR);eb.texParameteri(eb.TEXTURE_2D,eb.TEXTURE_MIN_FILTER,eb.LINEAR);eb.generateMipmap(eb.TEXTURE_2D);cs.width=ed.width;cs.height=ed.height}else{var ec=eb.createTexture(),ef=d.createElement(\"canvas\"),ea=ef.getContext(\"2d\"),ee;if(ed.width&ed.width-1===0){ef.width=ed.width}else{ee=1;while(ee<ed.width){ee*=2}ef.width=ee}if(ed.height&ed.height-1===0){ef.height=ed.height}else{ee=1;while(ee<ed.height){ee*=2}ef.height=ee}ea.drawImage(ed.sourceImg,0,0,ed.width,ed.height,0,0,ef.width,ef.height);eb.bindTexture(eb.TEXTURE_2D,ec);eb.texParameteri(eb.TEXTURE_2D,eb.TEXTURE_MIN_FILTER,eb.LINEAR_MIPMAP_LINEAR);eb.texParameteri(eb.TEXTURE_2D,eb.TEXTURE_MAG_FILTER,eb.LINEAR);eb.texParameteri(eb.TEXTURE_2D,eb.TEXTURE_WRAP_T,eb.CLAMP_TO_EDGE);eb.texParameteri(eb.TEXTURE_2D,eb.TEXTURE_WRAP_S,eb.CLAMP_TO_EDGE);eb.texImage2D(eb.TEXTURE_2D,0,eb.RGBA,eb.RGBA,eb.UNSIGNED_BYTE,ef);eb.generateMipmap(eb.TEXTURE_2D);ed.__texture=ec;cs.width=ed.width;cs.height=ed.height}}dT=true;eb.useProgram(dx);dZ(\"usingTexture3d\",dx,\"uUsingTexture\",dT)};cW.textureMode=function(ea){d4=ea};var ar=function(ev,eg,em,et,ef,el,er,ee,ek,ep,ed,ei){var ew=et;var eh=ef;var en=el;var ej=aL.array();var eu=ej[4]*ev+ej[5]*et+ej[6]*er+ej[7]*ep;var es=ej[8]*ev+ej[9]*et+ej[10]*er+ej[11]*ep;var eq=ej[12]*ev+ej[13]*et+ej[14]*er+ej[15]*ep;var ez=ej[4]*eg+ej[5]*ef+ej[6]*ee+ej[7]*ed;var ey=ej[8]*eg+ej[9]*ef+ej[10]*ee+ej[11]*ed;var ex=ej[12]*eg+ej[13]*ef+ej[14]*ee+ej[15]*ed;var ec=ej[4]*em+ej[5]*el+ej[6]*ek+ej[7]*ei;var eb=ej[8]*em+ej[9]*el+ej[10]*ek+ej[11]*ei;var ea=ej[12]*em+ej[13]*el+ej[14]*ek+ej[15]*ei;cW.vertex(ew,eh,en);for(var eo=0;eo<Q;eo++){ew+=eu;eu+=es;es+=eq;eh+=ez;ez+=ey;ey+=ex;en+=ec;ec+=eb;eb+=ea;cW.vertex(ew,eh,en)}};bR.prototype.curveVertex=function(ea,eb){dP=true;cW.vertex(ea,eb)};bB.prototype.curveVertex=function(ea,ed,ec){dP=true;if(!cM){dr()}var eb=[];eb[0]=ea;eb[1]=ed;eb[2]=ec;cb.push(eb);c2++;if(c2>3){ar(cb[c2-4][0],cb[c2-4][1],cb[c2-4][2],cb[c2-3][0],cb[c2-3][1],cb[c2-3][2],cb[c2-2][0],cb[c2-2][1],cb[c2-2][2],cb[c2-1][0],cb[c2-1][1],cb[c2-1][2])}};bR.prototype.curve=function(ef,eh,ed,eg,eb,ee,ea,ec){cW.beginShape();cW.curveVertex(ef,eh);cW.curveVertex(ed,eg);cW.curveVertex(eb,ee);cW.curveVertex(ea,ec);cW.endShape()};bB.prototype.curve=function(ec,ek,eg,eb,ej,ef,ea,ei,ee,el,eh,ed){if(ed!==t){cW.beginShape();cW.curveVertex(ec,ek,eg);cW.curveVertex(eb,ej,ef);cW.curveVertex(ea,ei,ee);cW.curveVertex(el,eh,ed);cW.endShape();return}cW.beginShape();cW.curveVertex(ec,ek);cW.curveVertex(eg,eb);cW.curveVertex(ej,ef);cW.curveVertex(ea,ei);cW.endShape()};cW.curveTightness=function(ea){aJ=ea};cW.curveDetail=function(ea){Q=ea;dr()};cW.rectMode=function(ea){bK=ea};cW.imageMode=function(ea){switch(ea){case 0:bk=aZ;break;case 1:bk=b1;break;case 3:bk=aN;break;default:throw\"Invalid imageMode\"}};cW.ellipseMode=function(ea){cN=ea};cW.arc=function(em,ek,ed,eo,ec,el){if(ed<=0||el<ec){return}if(cN===1){ed=ed-em;eo=eo-ek}else{if(cN===2){em=em-ed;ek=ek-eo;ed=ed*2;eo=eo*2}else{if(cN===3){em=em-ed/2;ek=ek-eo/2}}}while(ec<0){ec+=6.283185307179586;el+=6.283185307179586}if(el-ec>6.283185307179586){ec=0;el=6.283185307179586}var en=ed/2,ep=eo/2,eh=em+en,ef=ek+ep,eb=0|0.5+ec*cW.RAD_TO_DEG*2,ej=0|0.5+el*cW.RAD_TO_DEG*2,ei,eg;if(aH){var ee=ce;ce=false;cW.beginShape();cW.vertex(eh,ef);for(ei=eb;ei<=ej;ei++){eg=ei%720;cW.vertex(eh+bl[eg]*en,ef+ah[eg]*ep)}cW.endShape(2);ce=ee}if(ce){var ea=aH;aH=false;cW.beginShape();for(ei=eb;ei<=ej;ei++){eg=ei%720;cW.vertex(eh+bl[eg]*en,ef+ah[eg]*ep)}cW.endShape();aH=ea}};bR.prototype.line=function(eb,ei,ea,eg){if(!ce){return}eb=q.round(eb);ea=q.round(ea);ei=q.round(ei);eg=q.round(eg);if(eb===ea&&ei===eg){cW.point(eb,ei);return}var ec=t,ej=t,ef=true,eh=dJ.array(),ed=[1,0,0,0,1,0];for(var ee=0;ee<6&&ef;ee++){ef=eh[ee]===ed[ee]}if(ef){if(eb===ea){if(ei>eg){ec=ei;ei=eg;eg=ec}eg++;if(dW%2===1){d8.translate(0.5,0)}}else{if(ei===eg){if(eb>ea){ec=eb;eb=ea;ea=ec}ea++;if(dW%2===1){d8.translate(0,0.5)}}}if(dW===1){ej=d8.lineCap;d8.lineCap=\"butt\"}}d8.beginPath();d8.moveTo(eb||0,ei||0);d8.lineTo(ea||0,eg||0);dd();if(ef){if(eb===ea&&dW%2===1){d8.translate(-0.5,0)}else{if(ei===eg&&dW%2===1){d8.translate(0,-0.5)}}if(dW===1){d8.lineCap=ej}}};bB.prototype.line=function(ec,ef,eh,eb,ed,eg){if(ed===t||eg===t){eg=0;ed=eb;eb=eh;eh=0}if(ec===eb&&ef===ed&&eh===eg){cW.point(ec,ef,eh);return}var ee=[ec,ef,eh,eb,ed,eg];var ea=new aP;ea.scale(1,-1,1);ea.apply(dJ.array());ea.transpose();if(dW>0&&ce){d8.useProgram(dQ);a9(\"uModel2d\",dQ,\"uModel\",false,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);a9(\"uView2d\",dQ,\"uView\",false,ea.array());d2(\"uColor2d\",dQ,\"uColor\",c0);dZ(\"uIsDrawingText\",dQ,\"uIsDrawingText\",false);dc(\"aVertex2d\",dQ,\"aVertex\",3,b8);cg(\"aTextureCoord2d\",dQ,\"aTextureCoord\");d8.bufferData(d8.ARRAY_BUFFER,new e(ee),d8.STREAM_DRAW);d8.drawArrays(d8.LINES,0,2)}};bR.prototype.bezier=function(){if(arguments.length!==8){throw\"You must use 8 parameters for bezier() in 2D mode\"}cW.beginShape();cW.vertex(arguments[0],arguments[1]);cW.bezierVertex(arguments[2],arguments[3],arguments[4],arguments[5],arguments[6],arguments[7]);cW.endShape()};bB.prototype.bezier=function(){if(arguments.length!==12){throw\"You must use 12 parameters for bezier() in 3D mode\"}cW.beginShape();cW.vertex(arguments[0],arguments[1],arguments[2]);cW.bezierVertex(arguments[3],arguments[4],arguments[5],arguments[6],arguments[7],arguments[8],arguments[9],arguments[10],arguments[11]);cW.endShape()};cW.bezierDetail=function(ea){cy=ea};cW.bezierPoint=function(eb,ea,ee,ed,ec){return(1-ec)*(1-ec)*(1-ec)*eb+3*(1-ec)*(1-ec)*ec*ea+3*(1-ec)*ec*ec*ee+ec*ec*ec*ed};cW.bezierTangent=function(eb,ea,ee,ed,ec){return 3*ec*ec*(-eb+3*ea-3*ee+ed)+6*ec*(eb-2*ea+ee)+3*(-eb+ea)};cW.curvePoint=function(eb,ea,ee,ed,ec){return 0.5*(2*ea+(-eb+ee)*ec+(2*eb-5*ea+4*ee-ed)*ec*ec+(-eb+3*ea-3*ee+ed)*ec*ec*ec)};cW.curveTangent=function(eb,ea,ee,ed,ec){return 0.5*(-eb+ee+2*(2*eb-5*ea+4*ee-ed)*ec+3*(-eb+3*ea-3*ee+ed)*ec*ec)};cW.triangle=function(ed,ef,eb,ee,ea,ec){cW.beginShape(9);cW.vertex(ed,ef,0);cW.vertex(eb,ee,0);cW.vertex(ea,ec,0);cW.endShape()};cW.quad=function(ef,eh,ed,eg,eb,ee,ea,ec){cW.beginShape(16);cW.vertex(ef,eh,0);cW.vertex(ed,eg,0);cW.vertex(eb,ee,0);cW.vertex(ea,ec,0);cW.endShape()};var bN=function(eg,ef,ea,eh,ej,ee,ei,eb){if(eb===t){ee=ej;ei=ej;eb=ej}var ec=ea/2,ed=eh/2;if(ej>ec||ej>ed){ej=q.min(ec,ed)}if(ee>ec||ee>ed){ee=q.min(ec,ed)}if(ei>ec||ei>ed){ei=q.min(ec,ed)}if(eb>ec||eb>ed){eb=q.min(ec,ed)}if(!aH||ce){d8.translate(0.5,0.5)}d8.beginPath();d8.moveTo(eg+ej,ef);d8.lineTo(eg+ea-ee,ef);d8.quadraticCurveTo(eg+ea,ef,eg+ea,ef+ee);d8.lineTo(eg+ea,ef+eh-ei);d8.quadraticCurveTo(eg+ea,ef+eh,eg+ea-ei,ef+eh);d8.lineTo(eg+eb,ef+eh);d8.quadraticCurveTo(eg,ef+eh,eg,ef+eh-eb);d8.lineTo(eg,ef+ej);d8.quadraticCurveTo(eg,ef,eg+ej,ef);if(!aH||ce){d8.translate(-0.5,-0.5)}bn();dd()};bR.prototype.rect=function(eb,eh,ee,ea,ec,ef,ed,eg){if(!ee&&!ea){return}if(bK===1){ee-=eb;ea-=eh}else{if(bK===2){ee*=2;ea*=2;eb-=ee/2;eh-=ea/2}else{if(bK===3){eb-=ee/2;eh-=ea/2}}}eb=q.round(eb);eh=q.round(eh);ee=q.round(ee);ea=q.round(ea);if(ec!==t){bN(eb,eh,ee,ea,ec,ef,ed,eg);return}if(ce&&dW%2===1){d8.translate(0.5,0.5)}d8.beginPath();d8.rect(eb,eh,ee,ea);bn();dd();if(ce&&dW%2===1){d8.translate(-0.5,-0.5)}};bB.prototype.rect=function(ei,eh,ea,ek,em,ef,el,eb){if(em!==t){throw\"rect() with rounded corners is not supported in 3D mode\"}if(bK===1){ea-=ei;ek-=eh}else{if(bK===2){ea*=2;ek*=2;ei-=ea/2;eh-=ek/2}else{if(bK===3){ei-=ea/2;eh-=ek/2}}}var ee=new aP;ee.translate(ei,eh,0);ee.scale(ea,ek,1);ee.transpose();var eg=new aP;eg.scale(1,-1,1);eg.apply(dJ.array());eg.transpose();if(dW>0&&ce){d8.useProgram(dQ);a9(\"uModel2d\",dQ,\"uModel\",false,ee.array());a9(\"uView2d\",dQ,\"uView\",false,eg.array());d2(\"uColor2d\",dQ,\"uColor\",c0);dZ(\"uIsDrawingText2d\",dQ,\"uIsDrawingText\",false);dc(\"aVertex2d\",dQ,\"aVertex\",3,aB);cg(\"aTextureCoord2d\",dQ,\"aTextureCoord\");d8.drawArrays(d8.LINE_LOOP,0,ak.length/3)}if(aH){d8.useProgram(dx);a9(\"uModel3d\",dx,\"uModel\",false,ee.array());a9(\"uView3d\",dx,\"uView\",false,eg.array());d8.enable(d8.POLYGON_OFFSET_FILL);d8.polygonOffset(1,1);d2(\"color3d\",dx,\"uColor\",bo);if(dL>0){var ej=new aP;ej.set(eg);var ec=new aP;ec.set(ee);ej.mult(ec);var ed=new aP;ed.set(ej);ed.invert();ed.transpose();a9(\"uNormalTransform3d\",dx,\"uNormalTransform\",false,ed.array());dc(\"aNormal3d\",dx,\"aNormal\",3,b2)}else{cg(\"normal3d\",dx,\"aNormal\")}dc(\"vertex3d\",dx,\"aVertex\",3,aB);d8.drawArrays(d8.TRIANGLE_FAN,0,ak.length/3);d8.disable(d8.POLYGON_OFFSET_FILL)}};bR.prototype.ellipse=function(eg,ef,eb,ei){eg=eg||0;ef=ef||0;if(eb<=0&&ei<=0){return}if(cN===2){eb*=2;ei*=2}else{if(cN===1){eb=eb-eg;ei=ei-ef;eg+=eb/2;ef+=ei/2}else{if(cN===0){eg+=eb/2;ef+=ei/2}}}if(eb===ei){d8.beginPath();d8.arc(eg,ef,eb/2,0,6.283185307179586,false);bn();dd()}else{var eh=eb/2,ee=ei/2,ea=0.5522847498307933,ed=ea*eh,ec=ea*ee;cW.beginShape();cW.vertex(eg+eh,ef);cW.bezierVertex(eg+eh,ef-ec,eg+ed,ef-ee,eg,ef-ee);cW.bezierVertex(eg-ed,ef-ee,eg-eh,ef-ec,eg-eh,ef);cW.bezierVertex(eg-eh,ef+ec,eg-ed,ef+ee,eg,ef+ee);cW.bezierVertex(eg+ed,ef+ee,eg+eh,ef+ec,eg+eh,ef);cW.endShape()}};bB.prototype.ellipse=function(en,em,ec,ep){en=en||0;em=em||0;if(ec<=0&&ep<=0){return}if(cN===2){ec*=2;ep*=2}else{if(cN===1){ec=ec-en;ep=ep-em;en+=ec/2;em+=ep/2}else{if(cN===0){en+=ec/2;em+=ep/2}}}var eo=ec/2,ej=ep/2,ea=0.5522847498307933,ee=ea*eo,ed=ea*ej;cW.beginShape();cW.vertex(en+eo,em);cW.bezierVertex(en+eo,em-ed,0,en+ee,em-ej,0,en,em-ej,0);cW.bezierVertex(en-ee,em-ej,0,en-eo,em-ed,0,en-eo,em,0);cW.bezierVertex(en-eo,em+ed,0,en-ee,em+ej,0,en,em+ej,0);cW.bezierVertex(en+ee,em+ej,0,en+eo,em+ed,0,en+eo,em,0);cW.endShape();if(aH){var ef=0,ek=0,eh,eg;for(eh=0;eh<bb.length;eh++){ef+=bb[eh][0];ek+=bb[eh][1]}ef/=bb.length;ek/=bb.length;var ei=[],eb=[],el=[];ei[0]=ef;ei[1]=ek;ei[2]=0;ei[3]=0;ei[4]=0;ei[5]=bo[0];ei[6]=bo[1];ei[7]=bo[2];ei[8]=bo[3];ei[9]=c0[0];ei[10]=c0[1];ei[11]=c0[2];ei[12]=c0[3];ei[13]=a8;ei[14]=a7;ei[15]=a6;bb.unshift(ei);for(eh=0;eh<bb.length;eh++){for(eg=0;eg<3;eg++){eb.push(bb[eh][eg])}for(eg=5;eg<9;eg++){el.push(bb[eh][eg])}}dm(eb,\"TRIANGLE_FAN\",el)}};cW.normal=function(ea,ec,eb){if(arguments.length!==3||!(typeof ea===\"number\"&&typeof ec===\"number\"&&typeof eb===\"number\")){throw\"normal() requires three numeric arguments.\"}a8=ea;a7=ec;a6=eb;if(dR!==0){if(a2===0){a2=1}else{if(a2===1){a2=2}}}};cW.save=function(eb,ea){if(ea!==t){return D.open(ea.toDataURL(),\"_blank\")}return D.open(cW.externals.canvas.toDataURL(),\"_blank\")};var cw=0;cW.saveFrame=function(ea){if(ea===t){ea=\"screen-####.png\"}var eb=ea.replace(/#+/,function(ed){var ec=\"\"+cw++;while(ec.length<ed.length){ec=\"0\"+ec}return ec});cW.save(eb)};var cc=d.createElement(\"canvas\").getContext(\"2d\");var X=[t,t,t];function by(eh,eb,eg){var ed=X.shift();if(ed===t){ed={};ed.canvas=d.createElement(\"canvas\");ed.context=ed.canvas.getContext(\"2d\")}X.push(ed);var ec=ed.canvas,ee=ed.context,ef=eb||eh.width,ea=eg||eh.height;ec.width=ef;ec.height=ea;if(!eh){ee.clearRect(0,0,ef,ea)}else{if(\"data\" in eh){ee.putImageData(eh,0,0)}else{ee.clearRect(0,0,ef,ea);ee.drawImage(eh,0,0,ef,ea)}}return ed}function b0(ea){return{getLength:function(eb){return function(){if(eb.isRemote){throw\"Image is loaded remotely. Cannot get length.\"}else{return eb.imageData.data.length?eb.imageData.data.length/4:0}}}(ea),getPixel:function(eb){return function(ec){var ee=ec*4,ed=eb.imageData.data;if(eb.isRemote){throw\"Image is loaded remotely. Cannot get pixels.\"}return(ed[ee+3]&255)<<24|(ed[ee]&255)<<16|(ed[ee+1]&255)<<8|ed[ee+2]&255}}(ea),setPixel:function(eb){return function(ec,ef){var ee=ec*4,ed=eb.imageData.data;if(eb.isRemote){throw\"Image is loaded remotely. Cannot set pixel.\"}ed[ee+0]=(ef>>16)&255;ed[ee+1]=(ef>>8)&255;ed[ee+2]=ef&255;ed[ee+3]=(ef>>24)&255;eb.__isDirty=true}}(ea),toArray:function(eb){return function(){var ec=[],ef=eb.imageData.data,ee=eb.width*eb.height;if(eb.isRemote){throw\"Image is loaded remotely. Cannot get pixels.\"}for(var ed=0,eg=0;ed<ee;ed++,eg+=4){ec.push((ef[eg+3]&255)<<24|(ef[eg]&255)<<16|(ef[eg+1]&255)<<8|ef[eg+2]&255)}return ec}}(ea),set:function(eb){return function(ec){var eg,ef,eh;if(this.isRemote){throw\"Image is loaded remotely. Cannot set pixels.\"}ef=eb.imageData.data;for(var ed=0,ee=ec.length;ed<ee;ed++){eh=ec[ed];eg=ed*4;ef[eg+0]=(eh>>16)&255;ef[eg+1]=(eh>>8)&255;ef[eg+2]=eh&255;ef[eg+3]=(eh>>24)&255}eb.__isDirty=true}}(ea)}}var cG=function(ed,eg,ee){this.__isDirty=false;if(ed instanceof HTMLImageElement){this.fromHTMLImageData(ed)}else{if(eg||ee){this.width=ed||1;this.height=eg||1;var eb=this.sourceImg=d.createElement(\"canvas\");eb.width=this.width;eb.height=this.height;var eh=this.imageData=eb.getContext(\"2d\").createImageData(this.width,this.height);this.format=ee===2||ee===4?ee:1;if(this.format===1){for(var ec=3,ef=this.imageData.data,ea=ef.length;ec<ea;ec+=4){ef[ec]=255}}this.__isDirty=true;this.updatePixels()}else{this.width=0;this.height=0;this.imageData=cc.createImageData(1,1);this.format=2}}this.pixels=b0(this)};cG.prototype={__isPImage:true,updatePixels:function(){var ea=this.sourceImg;if(ea&&ea instanceof HTMLCanvasElement&&this.__isDirty){ea.getContext(\"2d\").putImageData(this.imageData,0,0)}this.__isDirty=false},fromHTMLImageData:function(ea){var eb=by(ea);try{var ed=eb.context.getImageData(0,0,ea.width,ea.height);this.fromImageData(ed)}catch(ec){if(ea.width&&ea.height){this.isRemote=true;this.width=ea.width;this.height=ea.height}}this.sourceImg=ea},get:function(ea,ed,eb,ec){if(!arguments.length){return cW.get(this)}if(arguments.length===2){return cW.get(ea,ed,this)}if(arguments.length===4){return cW.get(ea,ed,eb,ec,this)}},set:function(ea,ec,eb){cW.set(ea,ec,eb,this);this.__isDirty=true},blend:function(ei,ee,ed,eb,eg,ej,eh,ef,ea,ec){if(arguments.length===9){cW.blend(this,ei,ee,ed,eb,eg,ej,eh,ef,ea,this)}else{if(arguments.length===10){cW.blend(ei,ee,ed,eb,eg,ej,eh,ef,ea,ec,this)}}delete this.sourceImg},copy:function(eh,ee,ed,ec,eb,ei,eg,ef,ea){if(arguments.length===8){cW.blend(this,eh,ee,ed,ec,eb,ei,eg,ef,0,this)}else{if(arguments.length===9){cW.blend(eh,ee,ed,ec,eb,ei,eg,ef,ea,0,this)}}delete this.sourceImg},filter:function(eb,ea){if(arguments.length===2){cW.filter(eb,ea,this)}else{if(arguments.length===1){cW.filter(eb,null,this)}}delete this.sourceImg},save:function(ea){cW.save(ea,this)},resize:function(ea,ec){if(this.isRemote){throw\"Image is loaded remotely. Cannot resize.\"}if(this.width!==0||this.height!==0){if(ea===0&&ec!==0){ea=q.floor(this.width/this.height*ec)}else{if(ec===0&&ea!==0){ec=q.floor(this.height/this.width*ea)}}var eb=by(this.imageData).canvas;var ed=by(eb,ea,ec).context.getImageData(0,0,ea,ec);this.fromImageData(ed)}},mask:function(ea){var ed=this.toImageData(),ec,eb;if(ea instanceof cG||ea.__isPImage){if(ea.width===this.width&&ea.height===this.height){ea=ea.toImageData();for(ec=2,eb=this.width*this.height*4;ec<eb;ec+=4){ed.data[ec+1]=ea.data[ec]}}else{throw\"mask must have the same dimensions as PImage.\"}}else{if(ea instanceof Array){if(this.width*this.height===ea.length){for(ec=0,eb=ea.length;ec<eb;++ec){ed.data[ec*4+3]=ea[ec]}}else{throw\"mask array must be the same length as PImage pixels array.\"}}}this.fromImageData(ed)},loadPixels:G,toImageData:function(){if(this.isRemote){return this.sourceImg}if(!this.__isDirty){return this.imageData}var ea=by(this.sourceImg);return ea.context.getImageData(0,0,this.width,this.height)},toDataURL:function(){if(this.isRemote){throw\"Image is loaded remotely. Cannot create dataURI.\"}var ea=by(this.imageData);return ea.canvas.toDataURL()},fromImageData:function(ee){var eb=ee.width,ed=ee.height,ec=d.createElement(\"canvas\"),ea=ec.getContext(\"2d\");this.width=ec.width=eb;this.height=ec.height=ed;ea.putImageData(ee,0,0);this.format=2;this.imageData=ee;this.sourceImg=ec}};cW.PImage=cG;cW.createImage=function(ea,eb,ec){return new cG(ea,eb,ec)};cW.loadImage=function(eb,ec,ee){if(ec){eb=eb+\".\"+ec}var ed;if(cQ.imageCache.images[eb]){ed=new cG(cQ.imageCache.images[eb]);ed.loaded=true;return ed}ed=new cG;var ea=d.createElement(\"img\");ed.sourceImg=ea;ea.onload=function(ei,eg,ef){var ej=ei;var eh=eg;var ek=ef;return function(){eh.fromHTMLImageData(ej);eh.loaded=true;if(ek){ek()}}}(ea,ed,ee);ea.src=eb;return ed};cW.requestImage=cW.loadImage;function c9(ea,ed){var eb;if(ea>=cW.width||ea<0||ed<0||ed>=cW.height){return 0}if(dV){var ec=((0|ea)+cW.width*(0|ed))*4;eb=cW.imageData.data;return(eb[ec+3]&255)<<24|(eb[ec]&255)<<16|(eb[ec+1]&255)<<8|eb[ec+2]&255}eb=cW.toImageData(0|ea,0|ed,1,1).data;return(eb[3]&255)<<24|(eb[0]&255)<<16|(eb[1]&255)<<8|eb[2]&255}function c8(ea,ee,eb){if(eb.isRemote){throw\"Image is loaded remotely. Cannot get x,y.\"}var ed=ee*eb.width*4+ea*4,ec=eb.imageData.data;return(ec[ed+3]&255)<<24|(ec[ed]&255)<<16|(ec[ed+1]&255)<<8|ec[ed+2]&255}function c6(ea,ee,eb,ec){var ed=new cG(eb,ec,2);ed.fromImageData(cW.toImageData(ea,ee,eb,ec));return ed}function c5(ef,ee,eg,el,er){if(er.isRemote){throw\"Image is loaded remotely. Cannot get x,y,w,h.\"}var ep=new cG(eg,el,2),ec=ep.imageData.data,ed=er.width,em=er.height,eo=er.imageData.data;var ea=q.max(0,-ee),eb=q.max(0,-ef),eh=q.min(el,em-ee),ei=q.min(eg,ed-ef);for(var ek=ea;ek<eh;++ek){var en=((ee+ek)*ed+(ef+eb))*4;var eq=(ek*eg+eb)*4;for(var ej=eb;ej<ei;++ej){ec[eq++]=eo[en++];ec[eq++]=eo[en++];ec[eq++]=eo[en++];ec[eq++]=eo[en++]}}ep.__isDirty=true;return ep}cW.get=function(ea,ee,eb,ed,ec){if(ec!==undefined){return c5(ea,ee,eb,ed,ec)}if(ed!==undefined){return c6(ea,ee,eb,ed)}if(eb!==undefined){return c8(ea,ee,eb)}if(ee!==undefined){return c9(ea,ee)}if(ea!==undefined){return c5(0,0,ea.width,ea.height,ea)}return c6(0,0,cW.width,cW.height)};cW.createGraphics=function(ea,ec,eb){var ed=new F;ed.size(ea,ec,eb);ed.background(0,0);return ed};function T(){if(dV){d8=aj;dV=false;cW.updatePixels()}}function cq(){function eb(ef,ed){function ee(){T();d8[ed].apply(d8,arguments)}ef[ed]=ee}function ea(eg,ee){function ed(){T();return d8[ee]}function ef(eh){T();d8[ee]=eh}cW.defineProperty(eg,ee,{get:ed,set:ef})}for(var ec in d8){if(typeof d8[ec]===\"function\"){eb(this,ec)}else{ea(this,ec)}}}function cC(){if(dV){return}cW.loadPixels();if(cn===null){aj=d8;cn=new cq}dV=true;d8=cn;d3=0}function bx(ea,ec,eb){if(ea<cW.width&&ea>=0&&ec>=0&&ec<cW.height){cC();cW.pixels.setPixel((0|ea)+cW.width*(0|ec),eb);if(++d3>bZ){T()}}}function bv(ea,eg,ed,eb){if(eb.isRemote){throw\"Image is loaded remotely. Cannot set x,y.\"}var ef=cW.color.toArray(ed);var ee=eg*eb.width*4+ea*4;var ec=eb.imageData.data;ec[ee]=ef[0];ec[ee+1]=ef[1];ec[ee+2]=ef[2];ec[ee+3]=ef[3]}cW.set=function(ea,ef,ed,ec){var eb,ee;if(arguments.length===3){if(typeof ed===\"number\"){bx(ea,ef,ed)}else{if(ed instanceof cG||ed.__isPImage){cW.image(ed,ea,ef)}}}else{if(arguments.length===4){bv(ea,ef,ed,ec)}}};cW.imageData={};cW.pixels={getLength:function(){return cW.imageData.data.length?cW.imageData.data.length/4:0},getPixel:function(ea){var ec=ea*4,eb=cW.imageData.data;return eb[ec+3]<<24&4278190080|eb[ec+0]<<16&16711680|eb[ec+1]<<8&65280|eb[ec+2]&255},setPixel:function(ea,ed){var ec=ea*4,eb=cW.imageData.data;eb[ec+0]=(ed&16711680)>>>16;eb[ec+1]=(ed&65280)>>>8;eb[ec+2]=ed&255;eb[ec+3]=(ed&4278190080)>>>24},toArray:function(){var ea=[],ec=cW.imageData.width*cW.imageData.height,ed=cW.imageData.data;for(var eb=0,ee=0;eb<ec;eb++,ee+=4){ea.push(ed[ee+3]<<24&4278190080|ed[ee+0]<<16&16711680|ed[ee+1]<<8&65280|ed[ee+2]&255)}return ea},set:function(ea){for(var eb=0,ec=ea.length;eb<ec;eb++){this.setPixel(eb,ea[eb])}}};cW.loadPixels=function(){cW.imageData=dY.$ensureContext().getImageData(0,0,cW.width,cW.height)};cW.updatePixels=function(){if(cW.imageData){dY.$ensureContext().putImageData(cW.imageData,0,0)}};cW.hint=function(eb){var ea=dY.$ensureContext();if(eb===4){ea.disable(ea.DEPTH_TEST);ea.depthMask(false);ea.clear(ea.DEPTH_BUFFER_BIT)}else{if(eb===-4){ea.enable(ea.DEPTH_TEST);ea.depthMask(true)}else{if(eb===-1||eb===2){dO=true}else{if(eb===1){dO=false}}}}};var bE=function(ed,ec,eb,ea){var ee;if(ed instanceof cG||ed.__isPImage){ee=ed;if(!ee.loaded){throw\"Error using image in background(): PImage not loaded.\"}if(ee.width!==cW.width||ee.height!==cW.height){throw\"Background image must be the same dimensions as the canvas.\"}}else{ee=cW.color(ed,ec,eb,ea)}a4=ee};bR.prototype.background=function(ed,ec,eb,ea){if(ed!==t){bE(ed,ec,eb,ea)}if(a4 instanceof cG||a4.__isPImage){aD();d8.setTransform(1,0,0,1,0,0);cW.image(a4,0,0);cP()}else{aD();d8.setTransform(1,0,0,1,0,0);if(cW.alpha(a4)!==bU){d8.clearRect(0,0,cW.width,cW.height)}d8.fillStyle=cW.color.toString(a4);d8.fillRect(0,0,cW.width,cW.height);aq=true;cP()}};bB.prototype.background=function(ed,ec,eb,ea){if(arguments.length>0){bE(ed,ec,eb,ea)}var ee=cW.color.toGLArray(a4);d8.clearColor(ee[0],ee[1],ee[2],ee[3]);d8.clear(d8.COLOR_BUFFER_BIT|d8.DEPTH_BUFFER_BIT)};bR.prototype.image=function(ed,ei,eg,ej,ee){ei=q.round(ei);eg=q.round(eg);if(ed.width>0){var ek=ej||ed.width;var eh=ee||ed.height;var ea=bk(ei||0,eg||0,ej||ed.width,ee||ed.height,arguments.length<4);var ef=!!ed.sourceImg&&bf===null;if(ef){var eb=ed.sourceImg;if(ed.__isDirty){ed.updatePixels()}d8.drawImage(eb,0,0,eb.width,eb.height,ea.x,ea.y,ea.w,ea.h)}else{var ec=ed.toImageData();if(bf!==null){bf(ec);ed.__isDirty=true}d8.drawImage(by(ec).canvas,0,0,ed.width,ed.height,ea.x,ea.y,ea.w,ea.h)}}};bB.prototype.image=function(ec,ea,ee,eb,ed){if(ec.width>0){ea=q.round(ea);ee=q.round(ee);eb=eb||ec.width;ed=ed||ec.height;cW.beginShape(cW.QUADS);cW.texture(ec);cW.vertex(ea,ee,0,0,0);cW.vertex(ea,ee+ed,0,0,ed);cW.vertex(ea+eb,ee+ed,0,eb,ed);cW.vertex(ea+eb,ee,0,eb,0);cW.endShape()}};cW.tint=function(ed,ec,ea,ei){var ef=cW.color(ed,ec,ea,ei);var eb=cW.red(ef)/bJ;var ee=cW.green(ef)/bI;var eg=cW.blue(ef)/bG;var eh=cW.alpha(ef)/bU;bf=function(em){var el=em.data,ek=4*em.width*em.height;for(var ej=0;ej<ek;){el[ej++]*=eb;el[ej++]*=ee;el[ej++]*=eg;el[ej++]*=eh}};bw=function(ek){for(var ej=0;ej<ek.length;){ek[ej++]=eb;ek[ej++]=ee;ek[ej++]=eg;ek[ej++]=eh}}};cW.noTint=function(){bf=null;bw=null};cW.copy=function(ea,ef,ee,eg,ec,ei,eh,eb,ed){if(ed===t){ed=eb;eb=eh;eh=ei;ei=ec;ec=eg;eg=ee;ee=ef;ef=ea;ea=cW}cW.blend(ea,ef,ee,eg,ec,ei,eh,eb,ed,0)};cW.blend=function(ea,ek,ej,en,ef,ep,eo,eb,eh,eg,ed){if(ea.isRemote){throw\"Image is loaded remotely. Cannot blend image.\"}if(eg===t){eg=eh;eh=eb;eb=eo;eo=ep;ep=ef;ef=en;en=ej;ej=ek;ek=ea;ea=cW}var ec=ek+en,ei=ej+ef,em=ep+eb,ee=eo+eh,el=ed||cW;if(ed===t||eg===t){cW.loadPixels()}ea.loadPixels();if(ea===cW&&cW.intersect(ek,ej,ec,ei,ep,eo,em,ee)){cW.blit_resize(cW.get(ek,ej,ec-ek,ei-ej),0,0,ec-ek-1,ei-ej-1,el.imageData.data,el.width,el.height,ep,eo,em,ee,eg)}else{cW.blit_resize(ea,ek,ej,ec,ei,el.imageData.data,el.width,el.height,ep,eo,em,ee,eg)}if(ed===t){cW.updatePixels()}};var bp=function(ee){var ea=cW.floor(ee*3.5),ec,eb;ea=ea<1?1:ea<248?ea:248;if(cW.shared.blurRadius!==ea){cW.shared.blurRadius=ea;cW.shared.blurKernelSize=1+(cW.shared.blurRadius<<1);cW.shared.blurKernel=new e(cW.shared.blurKernelSize);var eg=cW.shared.blurKernel;var ef=cW.shared.blurKernelSize;var ed=cW.shared.blurRadius;for(ec=0;ec<ef;ec++){eg[ec]=0}var eh=(ea-1)*(ea-1);for(ec=1;ec<ea;ec++){eg[ea+ec]=eg[eb]=eh}eg[ea]=ea*ea}};var b7=function(eo,et){var ec,ef,el,eq,er,eA,es;var ev,en,ez,ey,ep;var ei=et.pixels.getLength();var eu=new e(ei);var eD=new e(ei);var eh=new e(ei);var eC=new e(ei);var eB=0;var ek,ej,ex,ee;bp(eo);var eb=et.height;var ea=et.width;var ew=cW.shared.blurKernelSize;var em=cW.shared.blurRadius;var eg=cW.shared.blurKernel;var ed=et.imageData.data;for(ej=0;ej<eb;ej++){for(ek=0;ek<ea;ek++){eq=el=ef=er=ec=0;ev=ek-em;if(ev<0){ep=-ev;ev=0}else{if(ev>=ea){break}ep=0}for(ex=ep;ex<ew;ex++){if(ev>=ea){break}ee=(ev+eB)*4;es=eg[ex];er+=es*ed[ee+3];ef+=es*ed[ee];el+=es*ed[ee+1];eq+=es*ed[ee+2];ec+=es;ev++}en=eB+ek;eC[en]=er/ec;eu[en]=ef/ec;eD[en]=el/ec;eh[en]=eq/ec}eB+=ea}eB=0;ez=-em;ey=ez*ea;for(ej=0;ej<eb;ej++){for(ek=0;ek<ea;ek++){eq=el=ef=er=ec=0;if(ez<0){ep=en=-ez;ev=ek}else{if(ez>=eb){break}ep=0;en=ez;ev=ek+ey}for(ex=ep;ex<ew;ex++){if(en>=eb){break}es=eg[ex];er+=es*eC[ev];ef+=es*eu[ev];el+=es*eD[ev];eq+=es*eh[ev];ec+=es;en++;ev+=ea}ee=(ek+eB)*4;ed[ee]=ef/ec;ed[ee+1]=el/ec;ed[ee+2]=eq/ec;ed[ee+3]=er/ec}eB+=ea;ey+=ea;ez++}};var cf=function(er,el){var eh=0;var ev=el.pixels.getLength();var em=new K(ev);var ep,eb,ek,ej,ed;var eq,ee,eg,ei,ec,en,eu,ea,es,ef,et,eo;if(!er){while(eh<ev){ep=eh;eb=eh+el.width;while(eh<eb){ek=ej=el.pixels.getPixel(eh);ee=eh-1;eq=eh+1;eg=eh-el.width;ei=eh+el.width;if(ee<ep){ee=eh}if(eq>=eb){eq=eh}if(eg<0){eg=0}if(ei>=ev){ei=eh}eu=el.pixels.getPixel(eg);en=el.pixels.getPixel(ee);ea=el.pixels.getPixel(ei);ec=el.pixels.getPixel(eq);ed=77*(ek>>16&255)+151*(ek>>8&255)+28*(ek&255);ef=77*(en>>16&255)+151*(en>>8&255)+28*(en&255);es=77*(ec>>16&255)+151*(ec>>8&255)+28*(ec&255);et=77*(eu>>16&255)+151*(eu>>8&255)+28*(eu&255);eo=77*(ea>>16&255)+151*(ea>>8&255)+28*(ea&255);if(ef>ed){ej=en;ed=ef}if(es>ed){ej=ec;ed=es}if(et>ed){ej=eu;ed=et}if(eo>ed){ej=ea;ed=eo}em[eh++]=ej}}}else{while(eh<ev){ep=eh;eb=eh+el.width;while(eh<eb){ek=ej=el.pixels.getPixel(eh);ee=eh-1;eq=eh+1;eg=eh-el.width;ei=eh+el.width;if(ee<ep){ee=eh}if(eq>=eb){eq=eh}if(eg<0){eg=0}if(ei>=ev){ei=eh}eu=el.pixels.getPixel(eg);en=el.pixels.getPixel(ee);ea=el.pixels.getPixel(ei);ec=el.pixels.getPixel(eq);ed=77*(ek>>16&255)+151*(ek>>8&255)+28*(ek&255);ef=77*(en>>16&255)+151*(en>>8&255)+28*(en&255);es=77*(ec>>16&255)+151*(ec>>8&255)+28*(ec&255);et=77*(eu>>16&255)+151*(eu>>8&255)+28*(eu&255);eo=77*(ea>>16&255)+151*(ea>>8&255)+28*(ea&255);if(ef<ed){ej=en;ed=ef}if(es<ed){ej=ec;ed=es}if(et<ed){ej=eu;ed=et}if(eo<ed){ej=ea;ed=eo}em[eh++]=ej}}}el.pixels.set(em)};cW.filter=function(eh,eg,ed){var ek,ef,eb,ej;if(arguments.length===3){ed.loadPixels();ek=ed}else{cW.loadPixels();ek=cW}if(eg===t){eg=null}if(ek.isRemote){throw\"Image is loaded remotely. Cannot filter image.\"}var el=ek.pixels.getLength();switch(eh){case 11:var em=eg||1;b7(em,ek);break;case 12:if(ek.format===4){for(ej=0;ej<el;ej++){ef=255-ek.pixels.getPixel(ej);ek.pixels.setPixel(ej,4278190080|ef<<16|ef<<8|ef)}ek.format=1}else{for(ej=0;ej<el;ej++){ef=ek.pixels.getPixel(ej);eb=77*(ef>>16&255)+151*(ef>>8&255)+28*(ef&255)>>8;ek.pixels.setPixel(ej,ef&4278190080|eb<<16|eb<<8|eb)}}break;case 13:for(ej=0;ej<el;ej++){ek.pixels.setPixel(ej,ek.pixels.getPixel(ej)^16777215)}break;case 15:if(eg===null){throw\"Use filter(POSTERIZE, int levels) instead of filter(POSTERIZE)\"}var ep=cW.floor(eg);if(ep<2||ep>255){throw\"Levels must be between 2 and 255 for filter(POSTERIZE, levels)\"}var ei=ep-1;for(ej=0;ej<el;ej++){var ea=ek.pixels.getPixel(ej)>>16&255;var en=ek.pixels.getPixel(ej)>>8&255;var ec=ek.pixels.getPixel(ej)&255;ea=(ea*ep>>8)*255/ei;en=(en*ep>>8)*255/ei;ec=(ec*ep>>8)*255/ei;ek.pixels.setPixel(ej,4278190080&ek.pixels.getPixel(ej)|ea<<16|en<<8|ec)}break;case 14:for(ej=0;ej<el;ej++){ek.pixels.setPixel(ej,ek.pixels.getPixel(ej)|4278190080)}ek.format=1;break;case 16:if(eg===null){eg=0.5}if(eg<0||eg>1){throw\"Level must be between 0 and 1 for filter(THRESHOLD, level)\"}var ee=cW.floor(eg*255);for(ej=0;ej<el;ej++){var eo=cW.max((ek.pixels.getPixel(ej)&16711680)>>16,cW.max((ek.pixels.getPixel(ej)&65280)>>8,ek.pixels.getPixel(ej)&255));ek.pixels.setPixel(ej,ek.pixels.getPixel(ej)&4278190080|(eo<ee?0:16777215))}break;case 17:cf(true,ek);break;case 18:cf(false,ek);break}ek.updatePixels()};cW.shared={fracU:0,ifU:0,fracV:0,ifV:0,u1:0,u2:0,v1:0,v2:0,sX:0,sY:0,iw:0,iw1:0,ih1:0,ul:0,ll:0,ur:0,lr:0,cUL:0,cLL:0,cUR:0,cLR:0,srcXOffset:0,srcYOffset:0,r:0,g:0,b:0,a:0,srcBuffer:null,blurRadius:0,blurKernelSize:0,blurKernel:null};cW.intersect=function(ec,ej,eb,ei,en,eg,em,ef){var el=eb-ec+1;var ee=ei-ej+1;var ea=em-en+1;var eh=ef-eg+1;if(en<ec){ea+=en-ec;if(ea>el){ea=el}}else{var ek=el+ec-en;if(ea>ek){ea=ek}}if(eg<ej){eh+=eg-ej;if(eh>ee){eh=ee}}else{var ed=ee+ej-eg;if(eh>ed){eh=ed}}return !(ea<=0||eh<=0)};var dS={};dS[1]=cW.modes.blend;dS[2]=cW.modes.add;dS[4]=cW.modes.subtract;dS[8]=cW.modes.lightest;dS[16]=cW.modes.darkest;dS[0]=cW.modes.replace;dS[32]=cW.modes.difference;dS[64]=cW.modes.exclusion;dS[128]=cW.modes.multiply;dS[256]=cW.modes.screen;dS[512]=cW.modes.overlay;dS[1024]=cW.modes.hard_light;dS[2048]=cW.modes.soft_light;dS[4096]=cW.modes.dodge;dS[8192]=cW.modes.burn;cW.blit_resize=function(en,ez,et,ey,es,eE,ej,er,ex,eo,ew,em,ep){var eC,eB;if(ez<0){ez=0}if(et<0){et=0}if(ey>=en.width){ey=en.width-1}if(es>=en.height){es=en.height-1}var eI=ey-ez;var eN=es-et;var ea=ew-ex;var ek=em-eo;if(ea<=0||ek<=0||eI<=0||eN<=0||ex>=ej||eo>=er||ez>=en.width||et>=en.height){return}var eh=q.floor(eI/ea*32768);var ee=q.floor(eN/ek*32768);var eG=cW.shared;eG.srcXOffset=q.floor(ex<0?-ex*eh:ez*32768);eG.srcYOffset=q.floor(eo<0?-eo*ee:et*32768);if(ex<0){ea+=ex;ex=0}if(eo<0){ek+=eo;eo=0}ea=q.min(ea,ej-ex);ek=q.min(ek,er-eo);var eu=eo*ej+ex;var eQ;eG.srcBuffer=en.imageData.data;eG.iw=en.width;eG.iw1=en.width-1;eG.ih1=en.height-1;var ev=cW.filter_bilinear,eK=cW.filter_new_scanline,ei=dS[ep],eH,eM,eF,eJ,ec,ed,eb=4278190080,eL=16711680,eA=65280,eg=255,eP=32767,eD=15,el=1,eq=9,ef=eG.srcBuffer,eO=q.min;for(eB=0;eB<ek;eB++){eG.sX=eG.srcXOffset;eG.fracV=eG.srcYOffset&eP;eG.ifV=eP-eG.fracV;eG.v1=(eG.srcYOffset>>eD)*eG.iw;eG.v2=eO((eG.srcYOffset>>eD)+1,eG.ih1)*eG.iw;for(eC=0;eC<ea;eC++){eM=(eu+eC)*4;eQ=eE[eM+3]<<24&eb|eE[eM]<<16&eL|eE[eM+1]<<8&eA|eE[eM+2]&eg;eG.fracU=eG.sX&eP;eG.ifU=eP-eG.fracU;eG.ul=eG.ifU*eG.ifV>>eD;eG.ll=eG.ifU*eG.fracV>>eD;eG.ur=eG.fracU*eG.ifV>>eD;eG.lr=eG.fracU*eG.fracV>>eD;eG.u1=eG.sX>>eD;eG.u2=eO(eG.u1+1,eG.iw1);eF=(eG.v1+eG.u1)*4;eJ=(eG.v1+eG.u2)*4;ec=(eG.v2+eG.u1)*4;ed=(eG.v2+eG.u2)*4;eG.cUL=ef[eF+3]<<24&eb|ef[eF]<<16&eL|ef[eF+1]<<8&eA|ef[eF+2]&eg;eG.cUR=ef[eJ+3]<<24&eb|ef[eJ]<<16&eL|ef[eJ+1]<<8&eA|ef[eJ+2]&eg;eG.cLL=ef[ec+3]<<24&eb|ef[ec]<<16&eL|ef[ec+1]<<8&eA|ef[ec+2]&eg;eG.cLR=ef[ed+3]<<24&eb|ef[ed]<<16&eL|ef[ed+1]<<8&eA|ef[ed+2]&eg;eG.r=eG.ul*((eG.cUL&eL)>>16)+eG.ll*((eG.cLL&eL)>>16)+eG.ur*((eG.cUR&eL)>>16)+eG.lr*((eG.cLR&eL)>>16)<<el&eL;eG.g=eG.ul*(eG.cUL&eA)+eG.ll*(eG.cLL&eA)+eG.ur*(eG.cUR&eA)+eG.lr*(eG.cLR&eA)>>>eD&eA;eG.b=eG.ul*(eG.cUL&eg)+eG.ll*(eG.cLL&eg)+eG.ur*(eG.cUR&eg)+eG.lr*(eG.cLR&eg)>>>eD;eG.a=eG.ul*((eG.cUL&eb)>>>24)+eG.ll*((eG.cLL&eb)>>>24)+eG.ur*((eG.cUR&eb)>>>24)+eG.lr*((eG.cLR&eb)>>>24)<<eq&eb;eH=ei(eQ,eG.a|eG.r|eG.g|eG.b);eE[eM]=(eH&eL)>>>16;eE[eM+1]=(eH&eA)>>>8;eE[eM+2]=eH&eg;eE[eM+3]=(eH&eb)>>>24;eG.sX+=eh}eu+=ej;eG.srcYOffset+=ee}};cW.loadFont=function(eb,ec){if(eb===t){throw\"font name required in loadFont.\"}if(eb.indexOf(\".svg\")===-1){if(ec===t){ec=W.size}return H.get(eb,ec)}var ea=cW.loadGlyphs(eb);return{name:eb,css:\"12px sans-serif\",glyph:true,units_per_em:ea.units_per_em,horiz_adv_x:1/ea.units_per_em*ea.horiz_adv_x,ascent:ea.ascent,descent:ea.descent,width:function(eh){var ef=0;var ed=eh.length;for(var ee=0;ee<ed;ee++){try{ef+=parseFloat(cW.glyphLook(cW.glyphTable[eb],eh[ee]).horiz_adv_x)}catch(eg){F.debug(eg)}}return ef/cW.glyphTable[eb].units_per_em}}};cW.createFont=function(ea,eb){return cW.loadFont(ea,eb)};cW.textFont=function(ea,ec){if(ec!==t){if(!ea.glyph){ea=H.get(ea.name,ec)}d0=ec}W=ea;Y=W.name;a3=W.ascent;dA=W.descent;d7=W.leading;var eb=dY.$ensureContext();eb.font=W.css};cW.textSize=function(eb){W=H.get(Y,eb);d0=eb;a3=W.ascent;dA=W.descent;d7=W.leading;var ea=dY.$ensureContext();ea.font=W.css};cW.textAscent=function(){return a3};cW.textDescent=function(){return dA};cW.textLeading=function(ea){d7=ea};cW.textAlign=function(eb,ea){N=eb;c1=ea||0};function bu(ea){if(ea instanceof String){return ea}if(typeof ea===\"number\"){if(ea===(0|ea)){return ea.toString()}return cW.nf(ea,0,3)}if(ea===null||ea===t){return\"\"}return ea.toString()}bR.prototype.textWidth=function(ee){var ea=bu(ee).split(/\\r?\\n/g),ec=0;var eb,ed=ea.length;d8.font=W.css;for(eb=0;eb<ed;++eb){ec=q.max(ec,W.measureTextWidth(ea[eb]))}return ec|0};bB.prototype.textWidth=function(ef){var ea=bu(ef).split(/\\r?\\n/g),ed=0;var ec,ee=ea.length;if(cE===t){cE=d.createElement(\"canvas\")}var eb=cE.getContext(\"2d\");eb.font=W.css;for(ec=0;ec<ee;++ec){ed=q.max(ed,eb.measureText(ea[ec]).width)}return ed|0};cW.glyphLook=function(ea,eb){try{switch(eb){case\"1\":return ea.one;case\"2\":return ea.two;case\"3\":return ea.three;case\"4\":return ea.four;case\"5\":return ea.five;case\"6\":return ea.six;case\"7\":return ea.seven;case\"8\":return ea.eight;case\"9\":return ea.nine;case\"0\":return ea.zero;case\" \":return ea.space;case\"$\":return ea.dollar;case\"!\":return ea.exclam;case'\"':return ea.quotedbl;case\"#\":return ea.numbersign;case\"%\":return ea.percent;case\"&\":return ea.ampersand;case\"'\":return ea.quotesingle;case\"(\":return ea.parenleft;case\")\":return ea.parenright;case\"*\":return ea.asterisk;case\"+\":return ea.plus;case\",\":return ea.comma;case\"-\":return ea.hyphen;case\".\":return ea.period;case\"/\":return ea.slash;case\"_\":return ea.underscore;case\":\":return ea.colon;case\";\":return ea.semicolon;case\"<\":return ea.less;case\"=\":return ea.equal;case\">\":return ea.greater;case\"?\":return ea.question;case\"@\":return ea.at;case\"[\":return ea.bracketleft;case\"\\\\\":return ea.backslash;case\"]\":return ea.bracketright;case\"^\":return ea.asciicircum;case\"`\":return ea.grave;case\"{\":return ea.braceleft;case\"|\":return ea.bar;case\"}\":return ea.braceright;case\"~\":return ea.asciitilde;default:return ea[eb]}}catch(ec){F.debug(ec)}};bR.prototype.text$line=function(ei,el,ek,ej,ef){var eh=0,eg=0;if(!W.glyph){if(ei&&\"fillText\" in d8){if(aq){d8.fillStyle=cW.color.toString(a1);aq=false}if(ef===39||ef===3){eh=W.measureTextWidth(ei);if(ef===39){eg=-eh}else{eg=-eh/2}}d8.fillText(ei,el+eg,ek)}}else{var ea=cW.glyphTable[Y];aD();d8.translate(el,ek+d0);if(ef===39||ef===3){eh=ea.width(ei);if(ef===39){eg=-eh}else{eg=-eh/2}}var em=ea.units_per_em,ee=1/em*d0;d8.scale(ee,ee);for(var eb=0,ec=ei.length;eb<ec;eb++){try{cW.glyphLook(ea,ei[eb]).draw()}catch(ed){F.debug(ed)}}cP()}};bB.prototype.text$line=function(eh,el,ek,ei,ef){if(cE===t){cE=d.createElement(\"canvas\")}var eb=d8;d8=cE.getContext(\"2d\");d8.font=W.css;var eg=W.measureTextWidth(eh);cE.width=eg;cE.height=d0;d8=cE.getContext(\"2d\");d8.font=W.css;d8.textBaseline=\"top\";bR.prototype.text$line(eh,0,0,0,37);var ea=cE.width/cE.height;d8=eb;d8.bindTexture(d8.TEXTURE_2D,bS);d8.texImage2D(d8.TEXTURE_2D,0,d8.RGBA,d8.RGBA,d8.UNSIGNED_BYTE,cE);d8.texParameteri(d8.TEXTURE_2D,d8.TEXTURE_MAG_FILTER,d8.LINEAR);d8.texParameteri(d8.TEXTURE_2D,d8.TEXTURE_MIN_FILTER,d8.LINEAR);d8.texParameteri(d8.TEXTURE_2D,d8.TEXTURE_WRAP_T,d8.CLAMP_TO_EDGE);d8.texParameteri(d8.TEXTURE_2D,d8.TEXTURE_WRAP_S,d8.CLAMP_TO_EDGE);var ee=0;if(ef===39){ee=-eg}else{if(ef===3){ee=-eg/2}}var ec=new aP;var ed=d0*0.5;ec.translate(el+ee-ed/2,ek-ed,ei);ec.scale(-ea*ed,-ed,ed);ec.translate(-1,-1,-1);ec.transpose();var ej=new aP;ej.scale(1,-1,1);ej.apply(dJ.array());ej.transpose();d8.useProgram(dQ);dc(\"aVertex2d\",dQ,\"aVertex\",3,cH);dc(\"aTextureCoord2d\",dQ,\"aTextureCoord\",2,ac);dZ(\"uSampler2d\",dQ,\"uSampler\",[0]);dZ(\"uIsDrawingText2d\",dQ,\"uIsDrawingText\",true);a9(\"uModel2d\",dQ,\"uModel\",false,ec.array());a9(\"uView2d\",dQ,\"uView\",false,ej.array());d2(\"uColor2d\",dQ,\"uColor\",bo);d8.bindBuffer(d8.ELEMENT_ARRAY_BUFFER,R);d8.drawElements(d8.TRIANGLES,6,d8.UNSIGNED_SHORT,0)};function bi(ed,eg,ef,ee){var ei,ec;if(ed.indexOf(\"\\n\")<0){ei=[ed];ec=1}else{ei=ed.split(/\\r?\\n/g);ec=ei.length}var ea=0;if(c1===101){ea=a3+dA}else{if(c1===3){ea=a3/2-(ec-1)*d7/2}else{if(c1===102){ea=-(dA+(ec-1)*d7)}}}for(var eb=0;eb<ec;++eb){var eh=ei[eb];dY.text$line(eh,eg,ef+ea,ee,N);ea+=d7}}function bd(eq,el,ek,ep,en,ej){if(eq.length===0||ep===0||en===0){return}if(d0>en){return}var em=-1;var ee=0;var ea=0;var eg=[];for(var ef=0,es=eq.length;ef<es;ef++){var eh=eq[ef];var ev=eh===\" \";var eo=W.measureTextWidth(eh);if(eh!==\"\\n\"&&ea+eo<=ep){if(ev){em=ef}ea+=eo}else{if(em+1===ee){if(ef>0){em=ef}else{return}}if(eh===\"\\n\"){eg.push({text:eq.substring(ee,ef),width:ea});ee=ef+1}else{eg.push({text:eq.substring(ee,em+1),width:ea});ee=em+1}ea=0;ef=ee-1}}if(ee<es){eg.push({text:eq.substring(ee),width:ea})}var eu=1,ei=a3;if(N===3){eu=ep/2}else{if(N===39){eu=ep}}var er=eg.length,eb=q.min(er,q.floor(en/d7));if(c1===101){ei=a3+dA}else{if(c1===3){ei=en/2-d7*(eb/2-1)}else{if(c1===102){ei=dA+d7}}}var ec,ed,et;for(ec=0;ec<er;ec++){et=ec*d7;if(ei+et>en-dA){break}ed=eg[ec];dY.text$line(ed.text,el+eu,ek+ei+et,ej,N)}}cW.text=function(){if(cI===5){return}if(arguments.length===3){bi(bu(arguments[0]),arguments[1],arguments[2],0)}else{if(arguments.length===4){bi(bu(arguments[0]),arguments[1],arguments[2],arguments[3])}else{if(arguments.length===5){bd(bu(arguments[0]),arguments[1],arguments[2],arguments[3],arguments[4],0)}else{if(arguments.length===6){bd(bu(arguments[0]),arguments[1],arguments[2],arguments[3],arguments[4],arguments[5])}}}}};cW.textMode=function(ea){cI=ea};cW.loadGlyphs=function(eg){var ei,eh,ee,ec,ep,eo,en,eq,ek,er,el,em=\"[0-9\\\\-]+\",ej;var ef=function(ex,ew){var eu=0,et=[],es,ev=new RegExp(ex,\"g\");es=et[eu]=ev.exec(ew);while(es){eu++;es=et[eu]=ev.exec(ew)}return et};var eb=function(ex){var ey=ef(\"[A-Za-z][0-9\\\\- ]+|Z\",ex);var ew=function(){aD();return dY.$ensureContext()};var eu=function(){bn();dd();cP()};ej=\"return {draw:function(){var curContext=beforePathDraw();curContext.beginPath();\";ei=0;eh=0;ee=0;ec=0;ep=0;eo=0;ex=0;eq=0;ek=\"\";er=ey.length-1;for(var et=0;et<er;et++){var es=ey[et][0],ev=ef(em,es);switch(es[0]){case\"M\":ei=parseFloat(ev[0][0]);eh=parseFloat(ev[1][0]);ej+=\"curContext.moveTo(\"+ei+\",\"+-eh+\");\";break;case\"L\":ei=parseFloat(ev[0][0]);eh=parseFloat(ev[1][0]);ej+=\"curContext.lineTo(\"+ei+\",\"+-eh+\");\";break;case\"H\":ei=parseFloat(ev[0][0]);ej+=\"curContext.lineTo(\"+ei+\",\"+-eh+\");\";break;case\"V\":eh=parseFloat(ev[0][0]);ej+=\"curContext.lineTo(\"+ei+\",\"+-eh+\");\";break;case\"T\":ep=parseFloat(ev[0][0]);eo=parseFloat(ev[1][0]);if(ek===\"Q\"||ek===\"T\"){ex=q.sqrt(q.pow(ei-ee,2)+q.pow(ec-eh,2));eq=q.PI+q.atan2(ee-ei,ec-eh);ee=ei+q.sin(eq)*ex;ec=eh+q.cos(eq)*ex}else{ee=ei;ec=eh}ej+=\"curContext.quadraticCurveTo(\"+ee+\",\"+-ec+\",\"+ep+\",\"+-eo+\");\";ei=ep;eh=eo;break;case\"Q\":ee=parseFloat(ev[0][0]);ec=parseFloat(ev[1][0]);ep=parseFloat(ev[2][0]);eo=parseFloat(ev[3][0]);ej+=\"curContext.quadraticCurveTo(\"+ee+\",\"+-ec+\",\"+ep+\",\"+-eo+\");\";ei=ep;eh=eo;break;case\"Z\":ej+=\"curContext.closePath();\";break}ek=es[0]}ej+=\"afterPathDraw();\";ej+=\"curContext.translate(\"+el+\",0);\";ej+=\"}}\";return(new Function(\"beforePathDraw\",\"afterPathDraw\",ej))(ew,eu)};var ea=function(ev){var eu=ev.getElementsByTagName(\"font\");cW.glyphTable[eg].horiz_adv_x=eu[0].getAttribute(\"horiz-adv-x\");var ex=ev.getElementsByTagName(\"font-face\")[0];cW.glyphTable[eg].units_per_em=parseFloat(ex.getAttribute(\"units-per-em\"));cW.glyphTable[eg].ascent=parseFloat(ex.getAttribute(\"ascent\"));cW.glyphTable[eg].descent=parseFloat(ex.getAttribute(\"descent\"));var ez=ev.getElementsByTagName(\"glyph\"),et=ez.length;for(var ey=0;ey<et;ey++){var es=ez[ey].getAttribute(\"unicode\");var ew=ez[ey].getAttribute(\"glyph-name\");el=ez[ey].getAttribute(\"horiz-adv-x\");if(el===null){el=cW.glyphTable[eg].horiz_adv_x}en=ez[ey].getAttribute(\"d\");if(en!==t){ej=eb(en);cW.glyphTable[eg][ew]={name:ew,unicode:es,horiz_adv_x:el,draw:ej.draw}}}};var ed=function(){var eu;try{eu=d.implementation.createDocument(\"\",\"\",null)}catch(ew){F.debug(ew.message);return}try{eu.async=false;eu.load(eg);ea(eu.getElementsByTagName(\"svg\")[0])}catch(et){F.debug(et);try{var es=new D.XMLHttpRequest;es.open(\"GET\",eg,false);es.send(null);ea(es.responseXML.documentElement)}catch(ev){F.debug(et)}}};cW.glyphTable[eg]={};ed(eg);return cW.glyphTable[eg]};cW.param=function(ec){var eb=\"data-processing-\"+ec;if(ae.hasAttribute(eb)){return ae.getAttribute(eb)}for(var ed=0,ea=ae.childNodes.length;ed<ea;++ed){var ee=ae.childNodes.item(ed);if(ee.nodeType!==1||ee.tagName.toLowerCase()!==\"param\"){continue}if(ee.getAttribute(\"name\")===ec){return ee.getAttribute(\"value\")}}if(cQ.params.hasOwnProperty(ec)){return cQ.params[ec]}return null};function cL(eb){if(eb===\"3D\"){dY=new bB}else{if(eb===\"2D\"){dY=new bR}else{dY=new ca}}for(var ea in ca.prototype){if(ca.prototype.hasOwnProperty(ea)&&ea.indexOf(\"$\")<0){cW[ea]=dY[ea]}}dY.$init()}function cU(ea){return function(){cL(\"2D\");return dY[ea].apply(this,arguments)}}ca.prototype.translate=cU(\"translate\");ca.prototype.transform=cU(\"transform\");ca.prototype.scale=cU(\"scale\");ca.prototype.pushMatrix=cU(\"pushMatrix\");ca.prototype.popMatrix=cU(\"popMatrix\");ca.prototype.resetMatrix=cU(\"resetMatrix\");ca.prototype.applyMatrix=cU(\"applyMatrix\");ca.prototype.rotate=cU(\"rotate\");ca.prototype.rotateZ=cU(\"rotateZ\");ca.prototype.shearX=cU(\"shearX\");ca.prototype.shearY=cU(\"shearY\");ca.prototype.redraw=cU(\"redraw\");ca.prototype.toImageData=cU(\"toImageData\");ca.prototype.ambientLight=cU(\"ambientLight\");ca.prototype.directionalLight=cU(\"directionalLight\");ca.prototype.lightFalloff=cU(\"lightFalloff\");ca.prototype.lightSpecular=cU(\"lightSpecular\");ca.prototype.pointLight=cU(\"pointLight\");ca.prototype.noLights=cU(\"noLights\");ca.prototype.spotLight=cU(\"spotLight\");ca.prototype.beginCamera=cU(\"beginCamera\");ca.prototype.endCamera=cU(\"endCamera\");ca.prototype.frustum=cU(\"frustum\");ca.prototype.box=cU(\"box\");ca.prototype.sphere=cU(\"sphere\");ca.prototype.ambient=cU(\"ambient\");ca.prototype.emissive=cU(\"emissive\");ca.prototype.shininess=cU(\"shininess\");ca.prototype.specular=cU(\"specular\");ca.prototype.fill=cU(\"fill\");ca.prototype.stroke=cU(\"stroke\");ca.prototype.strokeWeight=cU(\"strokeWeight\");ca.prototype.smooth=cU(\"smooth\");ca.prototype.noSmooth=cU(\"noSmooth\");ca.prototype.point=cU(\"point\");ca.prototype.vertex=cU(\"vertex\");ca.prototype.endShape=cU(\"endShape\");ca.prototype.bezierVertex=cU(\"bezierVertex\");ca.prototype.curveVertex=cU(\"curveVertex\");ca.prototype.curve=cU(\"curve\");ca.prototype.line=cU(\"line\");ca.prototype.bezier=cU(\"bezier\");ca.prototype.rect=cU(\"rect\");ca.prototype.ellipse=cU(\"ellipse\");ca.prototype.background=cU(\"background\");ca.prototype.image=cU(\"image\");ca.prototype.textWidth=cU(\"textWidth\");ca.prototype.text$line=cU(\"text$line\");ca.prototype.$ensureContext=cU(\"$ensureContext\");ca.prototype.$newPMatrix=cU(\"$newPMatrix\");ca.prototype.size=function(ea,ec,eb){cL(eb===2?\"3D\":\"2D\");cW.size(ea,ec,eb)};ca.prototype.$init=G;bR.prototype.$init=function(){cW.size(cW.width,cW.height);d8.lineCap=\"round\";cW.noSmooth();cW.disableContextMenu()};bB.prototype.$init=function(){cW.use3DContext=true;cW.disableContextMenu()};ds.prototype.$ensureContext=function(){return d8};function dy(eb,ed){var ec=eb,ea=0,ee=0;cW.pmouseX=cW.mouseX;cW.pmouseY=cW.mouseY;if(ec.offsetParent){do{ea+=ec.offsetLeft;ee+=ec.offsetTop}while(!!(ec=ec.offsetParent))}ec=eb;do{ea-=ec.scrollLeft||0;ee-=ec.scrollTop||0}while(!!(ec=ec.parentNode));ea+=ad;ee+=dp;ea+=aU;ee+=bX;ea+=D.pageXOffset;ee+=D.pageYOffset;return{X:ea,Y:ee}}function aI(ea,eb){var ec=dy(ea,eb);cW.mouseX=eb.pageX-ec.X;cW.mouseY=eb.pageY-ec.Y}function cu(eb){var ed=dy(eb.changedTouches[0].target,eb.changedTouches[0]),ea;for(ea=0;ea<eb.touches.length;ea++){var ef=eb.touches[ea];ef.offsetX=ef.pageX-ed.X;ef.offsetY=ef.pageY-ed.Y}for(ea=0;ea<eb.targetTouches.length;ea++){var ec=eb.targetTouches[ea];ec.offsetX=ec.pageX-ed.X;ec.offsetY=ec.pageY-ed.Y}for(ea=0;ea<eb.changedTouches.length;ea++){var ee=eb.changedTouches[ea];ee.offsetX=ee.pageX-ed.X;ee.offsetY=ee.pageY-ed.Y}return eb}bO(ae,\"touchstart\",function(ec){ae.setAttribute(\"style\",\"-webkit-user-select: none\");ae.setAttribute(\"onclick\",\"void(0)\");ae.setAttribute(\"style\",\"-webkit-tap-highlight-color:rgba(0,0,0,0)\");for(var eb=0,ea=au.length;eb<ea;eb++){var ed=au[eb].type;if(ed===\"mouseout\"||ed===\"mousemove\"||ed===\"mousedown\"||ed===\"mouseup\"||ed===\"DOMMouseScroll\"||ed===\"mousewheel\"||ed===\"touchstart\"){de(au[eb])}}if(cW.touchStart!==t||cW.touchMove!==t||cW.touchEnd!==t||cW.touchCancel!==t){bO(ae,\"touchstart\",function(ee){if(cW.touchStart!==t){ee=cu(ee);cW.touchStart(ee)}});bO(ae,\"touchmove\",function(ee){if(cW.touchMove!==t){ee.preventDefault();ee=cu(ee);cW.touchMove(ee)}});bO(ae,\"touchend\",function(ee){if(cW.touchEnd!==t){ee=cu(ee);cW.touchEnd(ee)}});bO(ae,\"touchcancel\",function(ee){if(cW.touchCancel!==t){ee=cu(ee);cW.touchCancel(ee)}})}else{bO(ae,\"touchstart\",function(ee){aI(ae,ee.touches[0]);cW.__mousePressed=true;cW.mouseDragging=false;cW.mouseButton=37;if(typeof cW.mousePressed===\"function\"){cW.mousePressed()}});bO(ae,\"touchmove\",function(ee){ee.preventDefault();aI(ae,ee.touches[0]);if(typeof cW.mouseMoved===\"function\"&&!cW.__mousePressed){cW.mouseMoved()}if(typeof cW.mouseDragged===\"function\"&&cW.__mousePressed){cW.mouseDragged();cW.mouseDragging=true}});bO(ae,\"touchend\",function(ee){cW.__mousePressed=false;if(typeof cW.mouseClicked===\"function\"&&!cW.mouseDragging){cW.mouseClicked()}if(typeof cW.mouseReleased===\"function\"){cW.mouseReleased()}})}ae.dispatchEvent(ec)});(function(){var ea=true,eb=function(ec){ec.preventDefault();ec.stopPropagation()};cW.disableContextMenu=function(){if(!ea){return}bO(ae,\"contextmenu\",eb);ea=false};cW.enableContextMenu=function(){if(ea){return}de({elem:ae,type:\"contextmenu\",fn:eb});ea=true}})();bO(ae,\"mousemove\",function(ea){aI(ae,ea);if(typeof cW.mouseMoved===\"function\"&&!cW.__mousePressed){cW.mouseMoved()}if(typeof cW.mouseDragged===\"function\"&&cW.__mousePressed){cW.mouseDragged();cW.mouseDragging=true}});bO(ae,\"mouseout\",function(ea){if(typeof cW.mouseOut===\"function\"){cW.mouseOut()}});bO(ae,\"mouseover\",function(ea){aI(ae,ea);if(typeof cW.mouseOver===\"function\"){cW.mouseOver()}});ae.onmousedown=function(){ae.focus();return false};bO(ae,\"mousedown\",function(ea){cW.__mousePressed=true;cW.mouseDragging=false;switch(ea.which){case 1:cW.mouseButton=37;break;case 2:cW.mouseButton=3;break;case 3:cW.mouseButton=39;break}if(typeof cW.mousePressed===\"function\"){cW.mousePressed()}});bO(ae,\"mouseup\",function(ea){cW.__mousePressed=false;if(typeof cW.mouseClicked===\"function\"&&!cW.mouseDragging){cW.mouseClicked()}if(typeof cW.mouseReleased===\"function\"){cW.mouseReleased()}});var an=function(ea){var eb=0;if(ea.wheelDelta){eb=ea.wheelDelta/120;if(D.opera){eb=-eb}}else{if(ea.detail){eb=-ea.detail/3}}cW.mouseScroll=eb;if(eb&&typeof cW.mouseScrolled===\"function\"){cW.mouseScrolled()}};bO(d,\"DOMMouseScroll\",an);bO(d,\"mousewheel\",an);if(!ae.getAttribute(\"tabindex\")){ae.setAttribute(\"tabindex\",0)}function dD(eb){var ea=eb.which||eb.keyCode;switch(ea){case 13:return 10;case 91:case 93:case 224:return 157;case 57392:return 17;case 46:return 127;case 45:return 155}return ea}function cB(eb){var ec=eb.which||eb.keyCode;var ea=eb.shiftKey||eb.ctrlKey||eb.altKey||eb.metaKey;switch(ec){case 13:ec=ea?13:10;break;case 8:ec=ea?127:8;break}return new bP(ec)}function cR(ea){if(typeof ea.preventDefault===\"function\"){ea.preventDefault()}else{if(typeof ea.stopPropagation===\"function\"){ea.stopPropagation()}}return false}function dG(){var ea;for(ea in ag){if(ag.hasOwnProperty(ea)){cW.__keyPressed=true;return}}cW.__keyPressed=false}function cx(){cW.__keyPressed=false;ag=[];dI=null}function bq(ea,eb){ag[ea]=eb;dI=null;cW.key=eb;cW.keyCode=ea;cW.keyPressed();cW.keyCode=0;cW.keyTyped();dG()}function cz(eb){var ea=dD(eb);if(ea===127){bq(ea,new bP(127));return}if(dX.indexOf(ea)<0){dI=ea;return}var ec=new bP(65535);cW.key=ec;cW.keyCode=ea;ag[ea]=ec;cW.keyPressed();dI=null;dG();return cR(eb)}function dv(eb){if(dI===null){return}var ea=dI,ec=cB(eb);bq(ea,ec);return cR(eb)}function cp(eb){var ea=dD(eb),ec=ag[ea];if(ec===t){return}cW.key=ec;cW.keyCode=ea;cW.keyReleased();delete ag[ea];dG()}if(!cV){if(ba instanceof F.Sketch){cQ=ba}else{if(typeof ba===\"function\"){cQ=new F.Sketch(ba)}else{if(!ba){cQ=new F.Sketch(function(){})}else{cQ=F.compile(ba)}}}cW.externals.sketch=cQ;cL();ae.onfocus=function(){cW.focused=true};ae.onblur=function(){cW.focused=false;if(!cQ.options.globalKeyEvents){cx()}};if(cQ.options.pauseOnBlur){bO(D,\"focus\",function(){if(aC){cW.loop()}});bO(D,\"blur\",function(){if(aC&&ax){cW.noLoop();aC=true}cx()})}var aV=cQ.options.globalKeyEvents?D:ae;bO(aV,\"keydown\",cz);bO(aV,\"keypress\",dv);bO(aV,\"keyup\",cp);for(var c4 in F.lib){if(F.lib.hasOwnProperty(c4)){if(F.lib[c4].hasOwnProperty(\"attach\")){F.lib[c4].attach(cW)}else{if(F.lib[c4] instanceof Function){F.lib[c4].call(this)}}}}var dB=100;var b6=function(ed){if(!(cQ.imageCache.pending||H.preloading.pending(dB))){if(D.opera){var ec,eb,ea=cQ.imageCache.operaCache;for(ec in ea){if(ea.hasOwnProperty(ec)){eb=ea[ec];if(eb!==null){d.body.removeChild(eb)}delete ea[ec]}}}cQ.attach(ed,g);cQ.onLoad(ed);if(ed.setup){ed.setup();ed.resetMatrix();cQ.onSetup()}T();if(ed.draw){if(!aC){ed.redraw()}else{ed.loop()}}}else{D.setTimeout(function(){b6(ed)},dB)}};a(this);b6(cW)}else{cQ=new F.Sketch;cL();cW.size=function(ea,ec,eb){if(eb&&eb===2){cL(\"3D\")}else{cL(\"2D\")}cW.size(ea,ec,eb)}}};F.debug=s;F.prototype=g;function u(){var R=[\"abs\",\"acos\",\"alpha\",\"ambient\",\"ambientLight\",\"append\",\"applyMatrix\",\"arc\",\"arrayCopy\",\"asin\",\"atan\",\"atan2\",\"background\",\"beginCamera\",\"beginDraw\",\"beginShape\",\"bezier\",\"bezierDetail\",\"bezierPoint\",\"bezierTangent\",\"bezierVertex\",\"binary\",\"blend\",\"blendColor\",\"blit_resize\",\"blue\",\"box\",\"breakShape\",\"brightness\",\"camera\",\"ceil\",\"Character\",\"color\",\"colorMode\",\"concat\",\"constrain\",\"copy\",\"cos\",\"createFont\",\"createGraphics\",\"createImage\",\"cursor\",\"curve\",\"curveDetail\",\"curvePoint\",\"curveTangent\",\"curveTightness\",\"curveVertex\",\"day\",\"degrees\",\"directionalLight\",\"disableContextMenu\",\"dist\",\"draw\",\"ellipse\",\"ellipseMode\",\"emissive\",\"enableContextMenu\",\"endCamera\",\"endDraw\",\"endShape\",\"exit\",\"exp\",\"expand\",\"externals\",\"fill\",\"filter\",\"floor\",\"focused\",\"frameCount\",\"frameRate\",\"frustum\",\"get\",\"glyphLook\",\"glyphTable\",\"green\",\"height\",\"hex\",\"hint\",\"hour\",\"hue\",\"image\",\"imageMode\",\"intersect\",\"join\",\"key\",\"keyCode\",\"keyPressed\",\"keyReleased\",\"keyTyped\",\"lerp\",\"lerpColor\",\"lightFalloff\",\"lights\",\"lightSpecular\",\"line\",\"link\",\"loadBytes\",\"loadFont\",\"loadGlyphs\",\"loadImage\",\"loadPixels\",\"loadShape\",\"loadXML\",\"loadStrings\",\"log\",\"loop\",\"mag\",\"map\",\"match\",\"matchAll\",\"max\",\"millis\",\"min\",\"minute\",\"mix\",\"modelX\",\"modelY\",\"modelZ\",\"modes\",\"month\",\"mouseButton\",\"mouseClicked\",\"mouseDragged\",\"mouseMoved\",\"mouseOut\",\"mouseOver\",\"mousePressed\",\"mouseReleased\",\"mouseScroll\",\"mouseScrolled\",\"mouseX\",\"mouseY\",\"name\",\"nf\",\"nfc\",\"nfp\",\"nfs\",\"noCursor\",\"noFill\",\"noise\",\"noiseDetail\",\"noiseSeed\",\"noLights\",\"noLoop\",\"norm\",\"normal\",\"noSmooth\",\"noStroke\",\"noTint\",\"ortho\",\"param\",\"parseBoolean\",\"parseByte\",\"parseChar\",\"parseFloat\",\"parseInt\",\"peg\",\"perspective\",\"PImage\",\"pixels\",\"PMatrix2D\",\"PMatrix3D\",\"PMatrixStack\",\"pmouseX\",\"pmouseY\",\"point\",\"pointLight\",\"popMatrix\",\"popStyle\",\"pow\",\"print\",\"printCamera\",\"println\",\"printMatrix\",\"printProjection\",\"PShape\",\"PShapeSVG\",\"pushMatrix\",\"pushStyle\",\"quad\",\"radians\",\"random\",\"Random\",\"randomSeed\",\"rect\",\"rectMode\",\"red\",\"redraw\",\"requestImage\",\"resetMatrix\",\"reverse\",\"rotate\",\"rotateX\",\"rotateY\",\"rotateZ\",\"round\",\"saturation\",\"save\",\"saveFrame\",\"saveStrings\",\"scale\",\"screenX\",\"screenY\",\"screenZ\",\"second\",\"set\",\"setup\",\"shape\",\"shapeMode\",\"shared\",\"shearX\",\"shearY\",\"shininess\",\"shorten\",\"sin\",\"size\",\"smooth\",\"sort\",\"specular\",\"sphere\",\"sphereDetail\",\"splice\",\"split\",\"splitTokens\",\"spotLight\",\"sq\",\"sqrt\",\"status\",\"str\",\"stroke\",\"strokeCap\",\"strokeJoin\",\"strokeWeight\",\"subset\",\"tan\",\"text\",\"textAlign\",\"textAscent\",\"textDescent\",\"textFont\",\"textLeading\",\"textMode\",\"textSize\",\"texture\",\"textureMode\",\"textWidth\",\"tint\",\"toImageData\",\"touchCancel\",\"touchEnd\",\"touchMove\",\"touchStart\",\"translate\",\"transform\",\"triangle\",\"trim\",\"unbinary\",\"unhex\",\"updatePixels\",\"use3DContext\",\"vertex\",\"width\",\"XMLElement\",\"XML\",\"year\",\"__contains\",\"__equals\",\"__equalsIgnoreCase\",\"__frameRate\",\"__hashCode\",\"__int_cast\",\"__instanceof\",\"__keyPressed\",\"__mousePressed\",\"__printStackTrace\",\"__replace\",\"__replaceAll\",\"__replaceFirst\",\"__toCharArray\",\"__split\",\"__codePointAt\",\"__startsWith\",\"__endsWith\",\"__matches\"];var P={};var Q,O;for(Q=0,O=R.length;Q<O;++Q){P[R[Q]]=null}for(var S in F.lib){if(F.lib.hasOwnProperty(S)){if(F.lib[S].exports){var N=F.lib[S].exports;for(Q=0,O=N.length;Q<O;++Q){P[N[Q]]=null}}}}return P}function c(ar){var aX=u();function aE(bq){var bt=[];var bv=bq.split(/([\\{\\[\\(\\)\\]\\}])/);var by=bv[0];var bw=[];for(var bs=1;bs<bv.length;bs+=2){var bx=bv[bs];if(bx===\"[\"||bx===\"{\"||bx===\"(\"){bw.push(by);by=bx}else{if(bx===\"]\"||bx===\"}\"||bx===\")\"){var br=bx===\"}\"?\"A\":bx===\")\"?\"B\":\"C\";var bu=bt.length;bt.push(by+bx);by=bw.pop()+'\"'+br+(bu+1)+'\"'}}by+=bv[bs+1]}bt.unshift(by);return bt}function aj(br,bq){return br.replace(/'(\\d+)'/g,function(bt,bs){var bu=bq[bs];if(bu.charAt(0)===\"/\"){return bu}return/^'((?:[^'\\\\\\n])|(?:\\\\.[0-9A-Fa-f]*))'$/.test(bu)?\"(new $p.Character(\"+bu+\"))\":bu})}function aP(bt){var bs=/^\\s*/.exec(bt),bq;if(bs[0].length===bt.length){bq={left:bs[0],middle:\"\",right:\"\"}}else{var br=/\\s*$/.exec(bt);bq={left:bs[0],middle:bt.substring(bs[0].length,br.index),right:br[0]}}bq.untrim=function(bu){return this.left+bu+this.right};return bq}function a6(bq){return bq.replace(/^\\s+/,\"\").replace(/\\s+$/,\"\")}function av(bs,bt){for(var br=0,bq=bt.length;br<bq;++br){bs[bt[br]]=null}return bs}function ba(br){for(var bq in br){if(br.hasOwnProperty(bq)){return false}}return true}function aQ(bq){return bq.substring(2,bq.length-1)}var bg=ar.replace(/\\r\\n?|\\n\\r/g,\"\\n\");var N=[];var a3=bg.replace(/(\"(?:[^\"\\\\\\n]|\\\\.)*\")|('(?:[^'\\\\\\n]|\\\\.)*')|(([\\[\\(=|&!\\^:?]\\s*)(\\/(?![*\\/])(?:[^\\/\\\\\\n]|\\\\.)*\\/[gim]*)\\b)|(\\/\\/[^\\n]*\\n)|(\\/\\*(?:(?!\\*\\/)(?:.|\\n))*\\*\\/)/g,function(by,br,bv,bw,bt,bx,bq,bs){var bu;if(br||bv){bu=N.length;N.push(by);return\"'\"+bu+\"'\"}if(bw){bu=N.length;N.push(bx);return bt+\"'\"+bu+\"'\"}return bs!==\"\"?\" \":\"\\n\"});a3=a3.replace(/__x([0-9A-F]{4})/g,function(br,bq){return\"__x005F_x\"+bq});a3=a3.replace(/\\$/g,\"__x0024\");var Z;var aA=a3;var aa=function(br,bs,bq,bt){if(!!bs||!!bt){return br}Z=true;return\"\"};do{Z=false;aA=aA.replace(/([<]?)<\\s*((?:\\?|[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\[\\])*(?:\\s+(?:extends|super)\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)?(?:\\s*,\\s*(?:\\?|[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\[\\])*(?:\\s+(?:extends|super)\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)?)*)\\s*>([=]?)/g,aa)}while(Z);var bk=aE(aA);var al;var aJ={},a9,az=0;function bc(br,bq){var bs=bk.length;bk.push(br);return'\"'+bq+bs+'\"'}function a7(){return\"class\"+ ++az}function bl(br,bs,bq){br.classId=bs;br.scopeId=bq;aJ[bs]=br}var V,S,ap,aV,bi,aZ;var O=/\\b((?:(?:public|private|final|protected|static|abstract)\\s+)*)(class|interface)\\s+([A-Za-z_$][\\w$]*\\b)(\\s+extends\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\b)*)?(\\s+implements\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\b)*)?\\s*(\"A\\d+\")/g;var bb=/\\b((?:(?:public|private|final|protected|static|abstract|synchronized)\\s+)*)((?!(?:else|new|return|throw|function|public|private|protected)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*([A-Za-z_$][\\w$]*\\b)\\s*(\"B\\d+\")(\\s*throws\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)*)?\\s*(\"A\\d+\"|;)/g;var aM=/^((?:(?:public|private|final|protected|static)\\s+)*)((?!(?:else|new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*([A-Za-z_$][\\w$]*\\b)\\s*(?:\"C\\d+\"\\s*)*([=,]|$)/;var bm=/\\b((?:(?:public|private|final|protected|static|abstract)\\s+)*)((?!(?:new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b)\\s*(\"B\\d+\")(\\s*throws\\s+[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*,\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)*)?\\s*(\"A\\d+\")/g;var W=/^((?:(?:public|private|final|protected|static)\\s+)*)((?!(?:new|return|throw)\\b)[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*(?:\\s*\"C\\d+\")*)\\s*/;var au=/\\bfunction(?:\\s+([A-Za-z_$][\\w$]*))?\\s*(\"B\\d+\")\\s*(\"A\\d+\")/g;function ae(br){var bq=br;bq=bq.replace(O,function(bs){return bc(bs,\"E\")});bq=bq.replace(bb,function(bs){return bc(bs,\"D\")});bq=bq.replace(au,function(bs){return bc(bs,\"H\")});return bq}function bd(bs,br){var bq=bs.replace(bm,function(bx,bu,bv,by,bw,bt){if(bv!==br){return bx}return bc(bx,\"G\")});return bq}function aH(bq){this.name=bq}aH.prototype.toString=function(){return this.name};function ao(br,bq){this.params=br;this.methodArgsParam=bq}ao.prototype.getNames=function(){var bs=[];for(var br=0,bq=this.params.length;br<bq;++br){bs.push(this.params[br].name)}return bs};ao.prototype.prependMethodArgs=function(bq){if(!this.methodArgsParam){return bq}return\"{\\nvar \"+this.methodArgsParam.name+\" = Array.prototype.slice.call(arguments, \"+this.params.length+\");\\n\"+bq.substring(1)};ao.prototype.toString=function(){if(this.params.length===0){return\"()\"}var bq=\"(\";for(var bs=0,br=this.params.length;bs<br;++bs){bq+=this.params[bs]+\", \"}return bq.substring(0,bq.length-2)+\")\"};function aD(bw){var bt=a6(bw.substring(1,bw.length-1));var bq=[],bu=null;if(bt!==\"\"){var br=bt.split(\",\");for(var bs=0;bs<br.length;++bs){var bv=/\\b([A-Za-z_$][\\w$]*\\b)(\\s*\"[ABC][\\d]*\")*\\s*$/.exec(br[bs]);if(bs===br.length-1&&br[bs].indexOf(\"...\")>=0){bu=new aH(bv[1]);break}bq.push(new aH(bv[1]))}}return new ao(bq,bu)}function aq(bu){var bt=bu;bt=bt.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\s*\"C\\d+\")+\\s*(\"A\\d+\")/g,function(bw,bv,bx){return bx});bt=bt.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)(?:\\s*\"B\\d+\")\\s*(\"A\\d+\")/g,function(bw,bv,bx){return bc(bw,\"F\")});bt=bt.replace(au,function(bv){return bc(bv,\"H\")});bt=bt.replace(/\\bnew\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)\\s*(\"C\\d+\"(?:\\s*\"C\\d+\")*)/g,function(bA,bz,bx){var bw=bx.replace(/\"C(\\d+)\"/g,function(bC,bB){return bk[bB]}).replace(/\\[\\s*\\]/g,\"[null]\").replace(/\\s*\\]\\s*\\[\\s*/g,\", \");var by=\"{\"+bw.substring(1,bw.length-1)+\"}\";var bv=\"('\"+bz+\"', \"+bc(by,\"A\")+\")\";return\"$p.createJavaArray\"+bc(bv,\"B\")});bt=bt.replace(/(\\.\\s*length)\\s*\"B\\d+\"/g,\"$1\");bt=bt.replace(/#([0-9A-Fa-f]{6})\\b/g,function(bv,bw){return\"0xFF\"+bw});bt=bt.replace(/\"B(\\d+)\"(\\s*(?:[\\w$']|\"B))/g,function(by,bw,bx){var bz=bk[bw];if(!/^\\(\\s*[A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*\\s*(?:\"C\\d+\"\\s*)*\\)$/.test(bz)){return by}if(/^\\(\\s*int\\s*\\)$/.test(bz)){return\"(int)\"+bx}var bv=bz.split(/\"C(\\d+)\"/g);if(bv.length>1){if(!/^\\[\\s*\\]$/.test(bk[bv[1]])){return by}}return\"\"+bx});bt=bt.replace(/\\(int\\)([^,\\]\\)\\}\\?\\:\\*\\+\\-\\/\\^\\|\\%\\&\\~<\\>\\=]+)/g,function(bw,bv){var bx=aP(bv);return bx.untrim(\"__int_cast(\"+bx.middle+\")\")});bt=bt.replace(/\\bsuper(\\s*\"B\\d+\")/g,\"$$superCstr$1\").replace(/\\bsuper(\\s*\\.)/g,\"$$super$1\");bt=bt.replace(/\\b0+((\\d*)(?:\\.[\\d*])?(?:[eE][\\-\\+]?\\d+)?[fF]?)\\b/,function(bx,bw,bv){if(bw===bv){return bx}return bv===\"\"?\"0\"+bw:bw});bt=bt.replace(/\\b(\\.?\\d+\\.?)[fF]\\b/g,\"$1\");bt=bt.replace(/([^\\s])%([^=\\s])/g,\"$1 % $2\");bt=bt.replace(/\\b(frameRate|keyPressed|mousePressed)\\b(?!\\s*\"B)/g,\"__$1\");bt=bt.replace(/\\b(boolean|byte|char|float|int)\\s*\"B/g,function(bw,bv){return\"parse\"+bv.substring(0,1).toUpperCase()+bv.substring(1)+'\"B'});bt=bt.replace(/\\bpixels\\b\\s*((\"C(\\d+)\")|\\.length)?(\\s*=(?!=)([^,\\]\\)\\}]+))?/g,function(bw,bA,bv,bz,by,bB){if(bv){var bx=bk[bz];if(by){return\"pixels.setPixel\"+bc(\"(\"+bx.substring(1,bx.length-1)+\",\"+bB+\")\",\"B\")}return\"pixels.getPixel\"+bc(\"(\"+bx.substring(1,bx.length-1)+\")\",\"B\")}if(bA){return\"pixels.getLength\"+bc(\"()\",\"B\")}if(by){return\"pixels.set\"+bc(\"(\"+bB+\")\",\"B\")}return\"pixels.toArray\"+bc(\"()\",\"B\")});var bs;function br(bw,bv,bA,by){var bx=bk[by];bs=true;var bz=aP(bx.substring(1,bx.length-1));return\"__\"+bA+(bz.middle===\"\"?bc(\"(\"+bv.replace(/\\.\\s*$/,\"\")+\")\",\"B\"):bc(\"(\"+bv.replace(/\\.\\s*$/,\"\")+\",\"+bz.middle+\")\",\"B\"))}do{bs=false;bt=bt.replace(/((?:'\\d+'|\\b[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\")*)\\s*\\.\\s*(?:[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\"\\s*)*\\.\\s*)*)(replace|replaceAll|replaceFirst|contains|equals|equalsIgnoreCase|hashCode|toCharArray|printStackTrace|split|startsWith|endsWith|codePointAt|matches)\\s*\"B(\\d+)\"/g,br)}while(bs);function bq(bx,bv,bw){bs=true;return\"__instanceof\"+bc(\"(\"+bv+\", \"+bw+\")\",\"B\")}do{bs=false;bt=bt.replace(/((?:'\\d+'|\\b[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\")*)\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*\\s*(?:\"[BC]\\d+\"\\s*)*)*)instanceof\\s+([A-Za-z_$][\\w$]*\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*)*)/g,bq)}while(bs);bt=bt.replace(/\\bthis(\\s*\"B\\d+\")/g,\"$$constr$1\");return bt}function aC(br,bq){this.baseInterfaceName=br;this.body=bq;bq.owner=this}aC.prototype.toString=function(){return\"new (\"+this.body+\")\"};function ai(bs){var br=(new RegExp(/\\bnew\\s*([A-Za-z_$][\\w$]*\\s*(?:\\.\\s*[A-Za-z_$][\\w$]*)*)\\s*\"B\\d+\"\\s*\"A(\\d+)\"/)).exec(bs);var bv=a9,bu=a7();a9=bu;var bq=br[1]+\"$\"+bu;var bt=new aC(bq,V(bk[br[2]],bq,\"\",\"implements \"+br[1]));bl(bt,bu,bv);a9=bv;return bt}function af(br,bs,bq){this.name=br;this.params=bs;this.body=bq}af.prototype.toString=function(){var bs=al;var bt=av({\"this\":null},this.params.getNames());al=function(bu){return bt.hasOwnProperty(bu.name)?bu.name:bs(bu)};var br=\"function\";if(this.name){br+=\" \"+this.name}var bq=this.params.prependMethodArgs(this.body.toString());br+=this.params+\" \"+bq;al=bs;return br};function aK(br){var bq=(new RegExp(/\\b([A-Za-z_$][\\w$]*)\\s*\"B(\\d+)\"\\s*\"A(\\d+)\"/)).exec(br);return new af(bq[1]!==\"function\"?bq[1]:null,aD(bk[bq[2]]),ap(bk[bq[3]]))}function ad(bq){this.members=bq}ad.prototype.toString=function(){var bs=al;al=function(bu){return bu.name===\"this\"?\"this\":bs(bu)};var bq=\"\";for(var bt=0,br=this.members.length;bt<br;++bt){if(this.members[bt].label){bq+=this.members[bt].label+\": \"}bq+=this.members[bt].value.toString()+\", \"}al=bs;return bq.substring(0,bq.length-2)};function aF(bt){var bq=bt.split(\",\");for(var bs=0;bs<bq.length;++bs){var br=bq[bs].indexOf(\":\");if(br<0){bq[bs]={value:aZ(bq[bs])}}else{bq[bs]={label:a6(bq[bs].substring(0,br)),value:aZ(a6(bq[bs].substring(br+1)))}}}return new ad(bq)}function ay(bs){if(bs.charAt(0)===\"(\"||bs.charAt(0)===\"[\"){return bs.charAt(0)+ay(bs.substring(1,bs.length-1))+bs.charAt(bs.length-1)}if(bs.charAt(0)===\"{\"){if(/^\\{\\s*(?:[A-Za-z_$][\\w$]*|'\\d+')\\s*:/.test(bs)){return\"{\"+bc(bs.substring(1,bs.length-1),\"I\")+\"}\"}return\"[\"+ay(bs.substring(1,bs.length-1))+\"]\"}var br=aP(bs);var bq=aq(br.middle);bq=bq.replace(/\"[ABC](\\d+)\"/g,function(bu,bt){return ay(bk[bt])});return br.untrim(bq)}function R(bq){return bq.replace(/(\\.\\s*)?((?:\\b[A-Za-z_]|\\$)[\\w$]*)(\\s*\\.\\s*([A-Za-z_$][\\w$]*)(\\s*\\()?)?/g,function(bt,bv,br,bx,bw,bu){if(bv){return bt}var bs={name:br,member:bw,callSign:!!bu};return al(bs)+(bx===t?\"\":bx)})}function bp(br,bq){this.expr=br;this.transforms=bq}bp.prototype.toString=function(){var bq=this.transforms;var br=R(this.expr);return br.replace(/\"!(\\d+)\"/g,function(bt,bs){return bq[bs].toString()})};aZ=function(bs){var br=[];var bq=ay(bs);bq=bq.replace(/\"H(\\d+)\"/g,function(bu,bt){br.push(aK(bk[bt]));return'\"!'+(br.length-1)+'\"'});bq=bq.replace(/\"F(\\d+)\"/g,function(bu,bt){br.push(ai(bk[bt]));return'\"!'+(br.length-1)+'\"'});bq=bq.replace(/\"I(\\d+)\"/g,function(bu,bt){br.push(aF(bk[bt]));return'\"!'+(br.length-1)+'\"'});return new bp(bq,br)};function a4(bq,bs,br){this.name=bq;this.value=bs;this.isDefault=br}a4.prototype.toString=function(){return this.name+\" = \"+this.value};function ak(bu,br){var bv=bu.indexOf(\"=\");var bq,bt,bs;if(bv<0){bq=bu;bt=br;bs=true}else{bq=bu.substring(0,bv);bt=aZ(bu.substring(bv+1));bs=false}return new a4(a6(bq.replace(/(\\s*\"C\\d+\")+/g,\"\")),bt,bs)}function aT(bq){if(bq===\"int\"||bq===\"float\"){return\"0\"}if(bq===\"boolean\"){return\"false\"}if(bq===\"color\"){return\"0x00000000\"}return\"null\"}function aI(br,bq){this.definitions=br;this.varType=bq}aI.prototype.getNames=function(){var bs=[];for(var br=0,bq=this.definitions.length;br<bq;++br){bs.push(this.definitions[br].name)}return bs};aI.prototype.toString=function(){return\"var \"+this.definitions.join(\",\")};function ah(bq){this.expression=bq}ah.prototype.toString=function(){return this.expression.toString()};function bn(bu){if(aM.test(bu)){var bt=W.exec(bu);var bs=bu.substring(bt[0].length).split(\",\");var bq=aT(bt[2]);for(var br=0;br<bs.length;++br){bs[br]=ak(bs[br],bq)}return new aI(bs,bt[2])}return new ah(aZ(bu))}function a1(bq,bs,br){this.initStatement=bq;this.condition=bs;this.step=br}a1.prototype.toString=function(){return\"(\"+this.initStatement+\"; \"+this.condition+\"; \"+this.step+\")\"};function aS(br,bq){this.initStatement=br;this.container=bq}aS.prototype.toString=function(){var bq=this.initStatement.toString();if(bq.indexOf(\"=\")>=0){bq=bq.substring(0,bq.indexOf(\"=\"))}return\"(\"+bq+\" in \"+this.container+\")\"};function aY(br,bq){this.initStatement=br;this.container=bq}aY.iteratorId=0;aY.prototype.toString=function(){var bu=this.initStatement.toString();var br=\"$it\"+aY.iteratorId++;var bt=bu.replace(/^\\s*var\\s*/,\"\").split(\"=\")[0];var bs=\"var \"+br+\" = new $p.ObjectIterator(\"+this.container+\"), \"+bt+\" = void(0)\";var bq=br+\".hasNext() && ((\"+bt+\" = \"+br+\".next()) || true)\";return\"(\"+bs+\"; \"+bq+\";)\"};function Y(br){var bq;if(/\\bin\\b/.test(br)){bq=br.substring(1,br.length-1).split(/\\bin\\b/g);return new aS(bn(a6(bq[0])),aZ(bq[1]))}if(br.indexOf(\":\")>=0&&br.indexOf(\";\")<0){bq=br.substring(1,br.length-1).split(\":\");return new aY(bn(a6(bq[0])),aZ(bq[1]))}bq=br.substring(1,br.length-1).split(\";\");return new a1(bn(a6(bq[0])),aZ(bq[1]),aZ(bq[2]))}function a2(bq){bq.sort(function(bs,br){return br.weight-bs.weight})}function ab(bs,bq,br){this.name=bs;this.body=bq;this.isStatic=br;bq.owner=this}ab.prototype.toString=function(){return\"\"+this.body};function an(bs,bq,br){this.name=bs;this.body=bq;this.isStatic=br;bq.owner=this}an.prototype.toString=function(){return\"\"+this.body};function T(bs){var br=O.exec(bs);O.lastIndex=0;var bt=br[1].indexOf(\"static\")>=0;var bq=bk[aQ(br[6])],bv;var bw=a9,bu=a7();a9=bu;if(br[2]===\"interface\"){bv=new ab(br[3],S(bq,br[3],br[4]),bt)}else{bv=new an(br[3],V(bq,br[3],br[4],br[5]),bt)}bl(bv,bu,bw);a9=bw;return bv}function ac(bs,bt,bq,br){this.name=bs;this.params=bt;this.body=bq;this.isStatic=br}ac.prototype.toString=function(){var bt=av({},this.params.getNames());var bs=al;al=function(bu){return bt.hasOwnProperty(bu.name)?bu.name:bs(bu)};var br=this.params.prependMethodArgs(this.body.toString());var bq=\"function \"+this.methodId+this.params+\" \"+br+\"\\n\";al=bs;return bq};function P(bt){var br=bb.exec(bt);bb.lastIndex=0;var bs=br[1].indexOf(\"static\")>=0;var bq=br[6]!==\";\"?bk[aQ(br[6])]:\"{}\";return new ac(br[3],aD(bk[aQ(br[4])]),ap(bq),bs)}function am(bs,br,bq){this.definitions=bs;this.fieldType=br;this.isStatic=bq}am.prototype.getNames=function(){var bs=[];for(var br=0,bq=this.definitions.length;br<bq;++br){bs.push(this.definitions[br].name)}return bs};am.prototype.toString=function(){var bx=al({name:\"[this]\"});if(this.isStatic){var bw=this.owner.name;var bu=[];for(var bv=0,bt=this.definitions.length;bv<bt;++bv){var bs=this.definitions[bv];var bq=bs.name,by=bw+\".\"+bq;var br=\"if(\"+by+\" === void(0)) {\\n \"+by+\" = \"+bs.value+\"; }\\n$p.defineProperty(\"+bx+\", '\"+bq+\"', { get: function(){return \"+by+\";}, set: function(val){\"+by+\" = val;} });\\n\";bu.push(br)}return bu.join(\"\")}return bx+\".\"+this.definitions.join(\"; \"+bx+\".\")};function bf(bv){var bu=W.exec(bv);var bq=bu[1].indexOf(\"static\")>=0;var bt=bv.substring(bu[0].length).split(/,\\s*/g);var br=aT(bu[2]);for(var bs=0;bs<bt.length;++bs){bt[bs]=ak(bt[bs],br)}return new am(bt,bu[2],bq)}function aN(br,bq){this.params=br;this.body=bq}aN.prototype.toString=function(){var bt=av({},this.params.getNames());var br=al;al=function(bu){return bt.hasOwnProperty(bu.name)?bu.name:br(bu)};var bs=\"function $constr_\"+this.params.params.length+this.params.toString();var bq=this.params.prependMethodArgs(this.body.toString());if(!/\\$(superCstr|constr)\\b/.test(bq)){bq=\"{\\n$superCstr();\\n\"+bq.substring(1)}al=br;return bs+bq+\"\\n\"};function at(bs){var bq=(new RegExp(/\"B(\\d+)\"\\s*\"A(\\d+)\"/)).exec(bs);var br=aD(bk[bq[1]]);return new aN(br,ap(bk[bq[2]]))}function aO(bs,bv,bu,bq,bw,bx){var bt,br;this.name=bs;this.interfacesNames=bv;this.methodsNames=bu;this.fields=bq;this.innerClasses=bw;this.misc=bx;for(bt=0,br=bq.length;bt<br;++bt){bq[bt].owner=this}}aO.prototype.getMembers=function(bx,bq,bv){if(this.owner.base){this.owner.base.body.getMembers(bx,bq,bv)}var bu,bt,bs,br;for(bu=0,bs=this.fields.length;bu<bs;++bu){var bz=this.fields[bu].getNames();for(bt=0,br=bz.length;bt<br;++bt){bx[bz[bt]]=this.fields[bu]}}for(bu=0,bs=this.methodsNames.length;bu<bs;++bu){var bw=this.methodsNames[bu];bq[bw]=true}for(bu=0,bs=this.innerClasses.length;bu<bs;++bu){var by=this.innerClasses[bu];bv[by.name]=by}};aO.prototype.toString=function(){function br(bH){var bG=0;while(bH){++bG;bH=bH.scope}return bG}var bA=br(this.owner);var bB=this.name;var bx=\"\";var bC=\"\";var bE={},bz={},by={};this.getMembers(bE,bz,by);var bw,bu,bv,bt;if(this.owner.interfaces){var bq=[],bs;for(bw=0,bu=this.interfacesNames.length;bw<bu;++bw){if(!this.owner.interfaces[bw]){continue}bs=al({name:this.interfacesNames[bw]});bq.push(bs);bx+=\"$p.extendInterfaceMembers(\"+bB+\", \"+bs+\");\\n\"}bC+=bB+\".$interfaces = [\"+bq.join(\", \")+\"];\\n\"}bC+=bB+\".$isInterface = true;\\n\";bC+=bB+\".$methods = ['\"+this.methodsNames.join(\"', '\")+\"'];\\n\";a2(this.innerClasses);for(bw=0,bu=this.innerClasses.length;bw<bu;++bw){var bF=this.innerClasses[bw];if(bF.isStatic){bx+=bB+\".\"+bF.name+\" = \"+bF+\";\\n\"}}for(bw=0,bu=this.fields.length;bw<bu;++bw){var bD=this.fields[bw];if(bD.isStatic){bx+=bB+\".\"+bD.definitions.join(\";\\n\"+bB+\".\")+\";\\n\"}}return\"(function() {\\nfunction \"+bB+\"() { throw 'Unable to create the interface'; }\\n\"+bx+bC+\"return \"+bB+\";\\n})()\"};S=function(bw,br,bB){var bC=bw.substring(1,bw.length-1);bC=ae(bC);bC=bd(bC,br);var bz=[],bt=[];bC=bC.replace(/\"([DE])(\\d+)\"/g,function(bF,bE,bD){if(bE===\"D\"){bz.push(bD)}else{if(bE===\"E\"){bt.push(bD)}}return\"\"});var bx=bC.split(/;(?:\\s*;)*/g);var bu;var bv,bs;if(bB!==t){bu=bB.replace(/^\\s*extends\\s+(.+?)\\s*$/g,\"$1\").split(/\\s*,\\s*/g)}for(bv=0,bs=bz.length;bv<bs;++bv){var bq=P(bk[bz[bv]]);bz[bv]=bq.name}for(bv=0,bs=bx.length-1;bv<bs;++bv){var bA=aP(bx[bv]);bx[bv]=bf(bA.middle)}var by=bx.pop();for(bv=0,bs=bt.length;bv<bs;++bv){bt[bv]=T(bk[bt[bv]])}return new aO(br,bu,bz,bx,bt,{tail:by})};function aB(br,by,bx,bw,bs,bz,bA,bu,bq){var bv,bt;this.name=br;this.baseClassName=by;this.interfacesNames=bx;this.functions=bw;this.methods=bs;this.fields=bz;this.cstrs=bA;this.innerClasses=bu;this.misc=bq;for(bv=0,bt=bz.length;bv<bt;++bv){bz[bv].owner=this}}aB.prototype.getMembers=function(bx,br,bw){if(this.owner.base){this.owner.base.body.getMembers(bx,br,bw)}var bv,bu,bt,bs;for(bv=0,bt=this.fields.length;bv<bt;++bv){var bz=this.fields[bv].getNames();for(bu=0,bs=bz.length;bu<bs;++bu){bx[bz[bu]]=this.fields[bv]}}for(bv=0,bt=this.methods.length;bv<bt;++bv){var bq=this.methods[bv];br[bq.name]=bq}for(bv=0,bt=this.innerClasses.length;bv<bt;++bv){var by=this.innerClasses[bv];bw[by.name]=by}};aB.prototype.toString=function(){function bN(bV){var bU=0;while(bV){++bU;bV=bV.scope}return bU}var bB=bN(this.owner);var bG=\"$this_\"+bB;var bs=this.name;var bx=\"var \"+bG+\" = this;\\n\";var bH=\"\";var bz=\"\";var bS={},bT={},bJ={};this.getMembers(bS,bT,bJ);var bR=al;al=function(bV){var bU=bV.name;if(bU===\"this\"){return bV.callSign||!bV.member?bG+\".$self\":bG}if(bS.hasOwnProperty(bU)){return bS[bU].isStatic?bs+\".\"+bU:bG+\".\"+bU}if(bJ.hasOwnProperty(bU)){return bG+\".\"+bU}if(bT.hasOwnProperty(bU)){return bT[bU].isStatic?bs+\".\"+bU:bG+\".$self.\"+bU}return bR(bV)};var bA;if(this.baseClassName){bA=bR({name:this.baseClassName});bx+=\"var $super = { $upcast: \"+bG+\" };\\n\";bx+=\"function $superCstr(){\"+bA+\".apply($super,arguments);if(!('$self' in $super)) $p.extendClassChain($super)}\\n\";bz+=bs+\".$base = \"+bA+\";\\n\"}else{bx+=\"function $superCstr(){$p.extendClassChain(\"+bG+\")}\\n\"}if(this.owner.base){bH+=\"$p.extendStaticMembers(\"+bs+\", \"+bA+\");\\n\"}var bM,bK,bL,bI;if(this.owner.interfaces){var bw=[],bq;for(bM=0,bK=this.interfacesNames.length;bM<bK;++bM){if(!this.owner.interfaces[bM]){continue}bq=bR({name:this.interfacesNames[bM]});bw.push(bq);bH+=\"$p.extendInterfaceMembers(\"+bs+\", \"+bq+\");\\n\"}bz+=bs+\".$interfaces = [\"+bw.join(\", \")+\"];\\n\"}if(this.functions.length>0){bx+=this.functions.join(\"\\n\")+\"\\n\"}a2(this.innerClasses);for(bM=0,bK=this.innerClasses.length;bM<bK;++bM){var bD=this.innerClasses[bM];if(bD.isStatic){bH+=bs+\".\"+bD.name+\" = \"+bD+\";\\n\";bx+=bG+\".\"+bD.name+\" = \"+bs+\".\"+bD.name+\";\\n\"}else{bx+=bG+\".\"+bD.name+\" = \"+bD+\";\\n\"}}for(bM=0,bK=this.fields.length;bM<bK;++bM){var br=this.fields[bM];if(br.isStatic){bH+=bs+\".\"+br.definitions.join(\";\\n\"+bs+\".\")+\";\\n\";for(bL=0,bI=br.definitions.length;bL<bI;++bL){var bu=br.definitions[bL].name,by=bs+\".\"+bu;bx+=\"$p.defineProperty(\"+bG+\", '\"+bu+\"', {get: function(){return \"+by+\"}, set: function(val){\"+by+\" = val}});\\n\"}}else{bx+=bG+\".\"+br.definitions.join(\";\\n\"+bG+\".\")+\";\\n\"}}var bC={};for(bM=0,bK=this.methods.length;bM<bK;++bM){var bt=this.methods[bM];var bP=bC[bt.name];var bv=bt.name+\"$\"+bt.params.params.length;var bF=!!bt.params.methodArgsParam;if(bP){++bP;bv+=\"_\"+bP}else{bP=1}bt.methodId=bv;bC[bt.name]=bP;if(bt.isStatic){bH+=bt;bH+=\"$p.addMethod(\"+bs+\", '\"+bt.name+\"', \"+bv+\", \"+bF+\");\\n\";bx+=\"$p.addMethod(\"+bG+\", '\"+bt.name+\"', \"+bv+\", \"+bF+\");\\n\"}else{bx+=bt;bx+=\"$p.addMethod(\"+bG+\", '\"+bt.name+\"', \"+bv+\", \"+bF+\");\\n\"}}bx+=a6(this.misc.tail);if(this.cstrs.length>0){bx+=this.cstrs.join(\"\\n\")+\"\\n\"}bx+=\"function $constr() {\\n\";var bQ=[];for(bM=0,bK=this.cstrs.length;bM<bK;++bM){var bO=this.cstrs[bM].params.params.length;var bE=!!this.cstrs[bM].params.methodArgsParam;bQ.push(\"if(arguments.length \"+(bE?\">=\":\"===\")+\" \"+bO+\") { $constr_\"+bO+\".apply(\"+bG+\", arguments); }\")}if(bQ.length>0){bx+=bQ.join(\" else \")+\" else \"}bx+=\"$superCstr();\\n}\\n\";bx+=\"$constr.apply(null, arguments);\\n\";al=bR;return\"(function() {\\nfunction \"+bs+\"() {\\n\"+bx+\"}\\n\"+bH+bz+\"return \"+bs+\";\\n})()\"};V=function(bz,br,bq,bC){var bE=bz.substring(1,bz.length-1);bE=ae(bE);bE=bd(bE,br);var bs=[],bt=[],bD=[],bw=[];bE=bE.replace(/\"([DEGH])(\\d+)\"/g,function(bH,bG,bF){if(bG===\"D\"){bs.push(bF)}else{if(bG===\"E\"){bt.push(bF)}else{if(bG===\"H\"){bw.push(bF)}else{bD.push(bF)}}}return\"\"});var by=bE.replace(/^(?:\\s*;)+/,\"\").split(/;(?:\\s*;)*/g);var bx,bv;var bu;if(bq!==t){bx=bq.replace(/^\\s*extends\\s+([A-Za-z_$][\\w$]*\\b(?:\\s*\\.\\s*[A-Za-z_$][\\w$]*\\b)*)\\s*$/g,\"$1\")}if(bC!==t){bv=bC.replace(/^\\s*implements\\s+(.+?)\\s*$/g,\"$1\").split(/\\s*,\\s*/g)}for(bu=0;bu<bw.length;++bu){bw[bu]=aK(bk[bw[bu]])}for(bu=0;bu<bs.length;++bu){bs[bu]=P(bk[bs[bu]])}for(bu=0;bu<by.length-1;++bu){var bB=aP(by[bu]);by[bu]=bf(bB.middle)}var bA=by.pop();for(bu=0;bu<bD.length;++bu){bD[bu]=at(bk[bD[bu]])}for(bu=0;bu<bt.length;++bu){bt[bu]=T(bk[bt[bu]])}return new aB(br,bx,bv,bw,bs,by,bD,bt,{tail:bA})};function aw(br,bq){this.name=br;this.body=bq;bq.owner=this}aw.prototype.toString=function(){return\"var \"+this.name+\" = \"+this.body+\";\\n$p.\"+this.name+\" = \"+this.name+\";\\n\"};function a5(br,bq){this.name=br;this.body=bq;bq.owner=this}a5.prototype.toString=function(){return\"var \"+this.name+\" = \"+this.body+\";\\n$p.\"+this.name+\" = \"+this.name+\";\\n\"};function bo(bs){var br=O.exec(bs);O.lastIndex=0;var bq=bk[aQ(br[6])];var bv=a9,bt=a7();a9=bt;var bu;if(br[2]===\"interface\"){bu=new aw(br[3],S(bq,br[3],br[4]))}else{bu=new a5(br[3],V(bq,br[3],br[4],br[5]))}bl(bu,bt,bv);a9=bv;return bu}function aR(br,bs,bq){this.name=br;this.params=bs;this.body=bq}aR.prototype.toString=function(){var bt=av({},this.params.getNames());var bs=al;al=function(bu){return bt.hasOwnProperty(bu.name)?bu.name:bs(bu)};var br=this.params.prependMethodArgs(this.body.toString());var bq=\"function \"+this.name+this.params+\" \"+br+\"\\n$p.\"+this.name+\" = \"+this.name+\";\";al=bs;return bq};function aW(bs){var br=bb.exec(bs);var bq=bb.lastIndex=0;return new aR(br[3],aD(bk[aQ(br[4])]),ap(bk[aQ(br[6])]))}function ag(bq){var br=bq;br=br.replace(/\\b(catch\\s*\"B\\d+\"\\s*\"A\\d+\")(\\s*catch\\s*\"B\\d+\"\\s*\"A\\d+\")+/g,\"$1\");return br}function aU(bq,br){this.argument=bq;this.misc=br}aU.prototype.toString=function(){return this.misc.prefix+this.argument.toString()};function Q(bq,br){this.argument=bq;this.misc=br}Q.prototype.toString=function(){return this.misc.prefix+this.argument.toString()};function ax(bq,br,bs){this.name=bq;this.argument=br;this.misc=bs}ax.prototype.toString=function(){var bq=this.misc.prefix;if(this.argument!==t){bq+=this.argument.toString()}return bq};function aL(bq){this.expr=bq}aL.prototype.toString=function(){return\"case \"+this.expr+\":\"};function X(bq){this.label=bq}X.prototype.toString=function(){return this.label};aV=function(by,bz,bs){var bD=new RegExp(/\\b(catch|for|if|switch|while|with)\\s*\"B(\\d+)\"|\\b(do|else|finally|return|throw|try|break|continue)\\b|(\"[ADEH](\\d+)\")|\\b(case)\\s+([^:]+):|\\b([A-Za-z_$][\\w$]*\\s*:)|(;)/g);var bA=[];by=ag(by);var bx=0,bt,br;while((bt=bD.exec(by))!==null){if(bt[1]!==t){var bw=by.lastIndexOf('\"B',bD.lastIndex);var bC=by.substring(bx,bw);if(bt[1]===\"for\"){bA.push(new aU(Y(bk[bt[2]]),{prefix:bC}))}else{if(bt[1]===\"catch\"){bA.push(new Q(aD(bk[bt[2]]),{prefix:bC}))}else{bA.push(new ax(bt[1],aZ(bk[bt[2]]),{prefix:bC}))}}}else{if(bt[3]!==t){bA.push(new ax(bt[3],t,{prefix:by.substring(bx,bD.lastIndex)}))}else{if(bt[4]!==t){br=by.substring(bx,bD.lastIndex-bt[4].length);if(a6(br).length!==0){continue}bA.push(br);var bu=bt[4].charAt(1),bq=bt[5];if(bu===\"D\"){bA.push(bz(bk[bq]))}else{if(bu===\"E\"){bA.push(bs(bk[bq]))}else{if(bu===\"H\"){bA.push(aK(bk[bq]))}else{bA.push(ap(bk[bq]))}}}}else{if(bt[6]!==t){bA.push(new aL(aZ(a6(bt[7]))))}else{if(bt[8]!==t){br=by.substring(bx,bD.lastIndex-bt[8].length);if(a6(br).length!==0){continue}bA.push(new X(by.substring(bx,bD.lastIndex)))}else{var bB=aP(by.substring(bx,bD.lastIndex-1));bA.push(bB.left);bA.push(bn(bB.middle));bA.push(bB.right+\";\")}}}}}bx=bD.lastIndex}var bv=aP(by.substring(bx));bA.push(bv.left);if(bv.middle!==\"\"){bA.push(bn(bv.middle));bA.push(\";\"+bv.right)}return bA};function be(br){var bs=[];for(var bt=0,bq=br.length;bt<bq;++bt){var bu=br[bt];if(bu instanceof aI){bs=bs.concat(bu.getNames())}else{if(bu instanceof aU&&bu.argument.initStatement instanceof aI){bs=bs.concat(bu.argument.initStatement.getNames())}else{if(bu instanceof ab||bu instanceof an||bu instanceof aw||bu instanceof a5||bu instanceof aR||bu instanceof af){bs.push(bu.name)}}}}return av({},bs)}function U(bq){this.statements=bq}U.prototype.toString=function(){var bs=be(this.statements);var br=al;if(!ba(bs)){al=function(bt){return bs.hasOwnProperty(bt.name)?bt.name:br(bt)}}var bq=\"{\\n\"+this.statements.join(\"\")+\"\\n}\";al=br;return bq};ap=function(br){var bq=aP(br.substring(1,br.length-1));return new U(aV(bq.middle))};function aG(bq){this.statements=bq}aG.prototype.toString=function(){var bu=[],bv=[],bw;for(var bt=0,br=this.statements.length;bt<br;++bt){bw=this.statements[bt];if(bw instanceof a5||bw instanceof aw){bu.push(bw)}else{bv.push(bw)}}a2(bu);var bs=be(this.statements);al=function(by){var bx=by.name;if(bs.hasOwnProperty(bx)){return bx}if(aX.hasOwnProperty(bx)||B.hasOwnProperty(bx)||g.hasOwnProperty(bx)){return\"$p.\"+bx}return bx};var bq=\"// this code was autogenerated from PJS\\n(function($p) {\\n\"+bu.join(\"\")+\"\\n\"+bv.join(\"\")+\"\\n})\";al=null;return bq};bi=function(){var bq=ae(bk[0]);bq=bq.replace(/\\bimport\\s+[^;]+;/g,\"\");return new aG(aV(bq,aW,bo))};function bj(bq){var bu={};var bs,by;for(bs in aJ){if(aJ.hasOwnProperty(bs)){by=aJ[bs];var bE=by.scopeId,br=by.name;if(bE){var bD=aJ[bE];by.scope=bD;if(bD.inScope===t){bD.inScope={}}bD.inScope[br]=by}else{bu[br]=by}}}function bB(bF,bI){var bL=bI.split(\".\");var bH=bF.scope,bK;while(bH){if(bH.hasOwnProperty(bL[0])){bK=bH[bL[0]];break}bH=bH.scope}if(bK===t){bK=bu[bL[0]]}for(var bJ=1,bG=bL.length;bJ<bG&&bK;++bJ){bK=bK.inScope[bL[bJ]]}return bK}for(bs in aJ){if(aJ.hasOwnProperty(bs)){by=aJ[bs];var bx=by.body.baseClassName;if(bx){var bA=bB(by,bx);if(bA){by.base=bA;if(!bA.derived){bA.derived=[]}bA.derived.push(by)}}var bw=by.body.interfacesNames,bC=[],bv,bt;if(bw&&bw.length>0){for(bv=0,bt=bw.length;bv<bt;++bv){var bz=bB(by,bw[bv]);bC.push(bz);if(!bz){continue}if(!bz.derived){bz.derived=[]}bz.derived.push(by)}if(bC.length>0){by.interfaces=bC}}}}}function a8(bq){var bv=[],bs={};var br,by,bw;for(br in aJ){if(aJ.hasOwnProperty(br)){bw=aJ[br];if(!bw.inScope&&!bw.derived){bv.push(br);bw.weight=0}else{var bx=[];if(bw.inScope){for(by in bw.inScope){if(bw.inScope.hasOwnProperty(by)){bx.push(bw.inScope[by])}}}if(bw.derived){bx=bx.concat(bw.derived)}bs[br]=bx}}}function bz(bB,bD){var bA=bs[bB];if(!bA){return false}var bC=bA.indexOf(bD);if(bC<0){return false}bA.splice(bC,1);if(bA.length>0){return false}delete bs[bB];return true}while(bv.length>0){br=bv.shift();bw=aJ[br];if(bw.scopeId&&bz(bw.scopeId,bw)){bv.push(bw.scopeId);aJ[bw.scopeId].weight=bw.weight+1}if(bw.base&&bz(bw.base.classId,bw)){bv.push(bw.base.classId);bw.base.weight=bw.weight+1}if(bw.interfaces){var bu,bt;for(bu=0,bt=bw.interfaces.length;bu<bt;++bu){if(!bw.interfaces[bu]||!bz(bw.interfaces[bu].classId,bw)){continue}bv.push(bw.interfaces[bu].classId);bw.interfaces[bu].weight=bw.weight+1}}}}var bh=bi();bj(bh);a8(bh);var a0=bh.toString();a0=a0.replace(/\\s*\\n(?:[\\t ]*\\n)+/g,\"\\n\\n\");a0=a0.replace(/__x([0-9A-F]{4})/g,function(br,bq){return String.fromCharCode(parseInt(bq,16))});return aj(a0,N)}function z(O,ad){var X=(new RegExp(/\\/\\*\\s*@pjs\\s+((?:[^\\*]|\\*+[^\\*\\/])*)\\*\\//g)).exec(O);if(X&&X.length===2){var N=[],Q=X.splice(1,2)[0].replace(/\\{([\\s\\S]*?)\\}/g,function(){return function(ag,ah){N.push(ah);return\"{\"+(N.length-1)+\"}\"}}()).replace(\"\\n\",\"\").replace(\"\\r\",\"\").split(\";\");var W=function(ag){return ag.replace(/^\\s*[\"']?/,\"\").replace(/[\"']?\\s*$/,\"\")};for(var aa=0,Y=Q.length;aa<Y;aa++){var U=Q[aa].split(\"=\");if(U&&U.length===2){var af=W(U[0]),V=W(U[1]),ae=[];if(af===\"preload\"){ae=V.split(\",\");for(var Z=0,ab=ae.length;Z<ab;Z++){var ac=W(ae[Z]);ad.imageCache.add(ac)}}else{if(af===\"font\"){ae=V.split(\",\");for(var R=0,T=ae.length;R<T;R++){var S=W(ae[R]),P=/^\\{(\\d*?)\\}$/.exec(S);H.preloading.add(P?JSON.parse(\"{\"+N[P[1]]+\"}\"):S)}}else{if(af===\"pauseOnBlur\"){ad.options.pauseOnBlur=V===\"true\"}else{if(af===\"globalKeyEvents\"){ad.options.globalKeyEvents=V===\"true\"}else{if(af.substring(0,6)===\"param-\"){ad.params[af.substring(6)]=V}else{ad.options[af]=V}}}}}}}}return O}F.compile=function(N){var Q=new F.Sketch;var O=z(N,Q);var P=c(O);Q.sourceCode=P;return Q};var j=function(){var T={},Q=\"undefined\",R=\"function\",N=!1,S=!0,O=512,P=\"log\";if(typeof tinylog!==Q&&typeof tinylog[P]===R){T[P]=tinylog[P]}else{if(typeof d!==Q&&!d.fake){(function(){var ao=d,am=\"div\",ac=\"style\",ag=\"title\",ab={zIndex:10000,position:\"fixed\",bottom:\"0px\",width:\"100%\",height:\"15%\",fontFamily:\"sans-serif\",color:\"#ccc\",backgroundColor:\"black\"},ae={position:\"relative\",fontFamily:\"monospace\",overflow:\"auto\",height:\"100%\",paddingTop:\"5px\"},ai={height:\"5px\",marginTop:\"-5px\",cursor:\"n-resize\",backgroundColor:\"darkgrey\"},an={position:\"absolute\",top:\"5px\",right:\"20px\",color:\"#111\",MozBorderRadius:\"4px\",webkitBorderRadius:\"4px\",borderRadius:\"4px\",cursor:\"pointer\",fontWeight:\"normal\",textAlign:\"center\",padding:\"3px 5px\",backgroundColor:\"#333\",fontSize:\"12px\"},Y={minHeight:\"16px\"},af={fontSize:\"12px\",margin:\"0 8px 0 8px\",maxWidth:\"100%\",whiteSpace:\"pre-wrap\",overflow:\"auto\"},ad=ao.defaultView,al=ao.documentElement,U=al[ac],W=function(){var aq=arguments.length,ap,at,ar;while(aq--){at=arguments[aq--];ap=arguments[aq][ac];for(ar in at){if(at.hasOwnProperty(ar)){ap[ar]=at[ar]}}}},aj=function(ar,aq,ap){if(ar.addEventListener){ar.addEventListener(aq,ap,N)}else{if(ar.attachEvent){ar.attachEvent(\"on\"+aq,ap)}}return[ar,aq,ap]},V=function(ar,aq,ap){if(ar.removeEventListener){ar.removeEventListener(aq,ap,N)}else{if(ar.detachEvent){ar.detachEvent(\"on\"+aq,ap)}}},aa=function(aq){var ap=aq.childNodes,ar=ap.length;while(ar--){aq.removeChild(ap.item(0))}},ak=function(aq,ap){return aq.appendChild(ap)},ah=function(ap){return ao.createElement(ap)},Z=function(ap){return ao.createTextNode(ap)},X=T[P]=function(aE){var aw,ax=U.paddingBottom,ar=ah(am),aB=ar[ac],aC=ak(ar,ah(am)),au=ak(ar,ah(am)),at=ak(ar,ah(am)),aD=N,av=N,aq=N,ay=0,ap=function(){U.paddingBottom=ar.clientHeight+\"px\"},aA=function(aF){var aG=ad.innerHeight,aH=aC.clientHeight;if(aF<0){aF=0}else{if(aF+aH>aG){aF=aG-aH}}aB.height=aF/aG*100+\"%\";ap()},az=[aj(ao,\"mousemove\",function(aF){if(aD){aA(ad.innerHeight-aF.clientY);au.scrollTop=aq}}),aj(ao,\"mouseup\",function(){if(aD){aD=aq=N}}),aj(aC,\"dblclick\",function(aF){aF.preventDefault();if(av){aA(av);av=N}else{av=ar.clientHeight;aB.height=\"0px\"}}),aj(aC,\"mousedown\",function(aF){aF.preventDefault();aD=S;aq=au.scrollTop}),aj(aC,\"contextmenu\",function(){aD=N}),aj(at,\"click\",function(){aw()})];aw=function(){var aF=az.length;while(aF--){V.apply(T,az[aF])}al.removeChild(ar);U.paddingBottom=ax;aa(au);aa(ar);T[P]=X};W(ar,ab,au,ae,aC,ai,at,an);at[ag]=\"Close Log\";ak(at,Z(\"\\u2716\"));aC[ag]=\"Double-click to toggle log minimization\";al.insertBefore(ar,al.firstChild);T[P]=function(aH){if(ay===O){au.removeChild(au.firstChild)}else{ay++}var aG=ak(au,ah(am)),aF=ak(aG,ah(am));aG[ag]=(new Date).toLocaleTimeString();W(aG,Y,aF,af);ak(aF,Z(aH));au.scrollTop=au.scrollHeight};T[P](aE);ap()}})()}else{if(typeof print===R){T[P]=print}}}return T}();F.logger=j;F.version=\"1.4.1\";F.lib={};F.registerLibrary=function(N,O){F.lib[N]=O;if(O.hasOwnProperty(\"init\")){O.init(g)}};F.instances=k;F.getInstanceById=function(N){return k[J[N]]};F.Sketch=function(N){this.attachFunction=N;this.options={pauseOnBlur:false,globalKeyEvents:false};this.onLoad=G;this.onSetup=G;this.onPause=G;this.onLoop=G;this.onFrameStart=G;this.onFrameEnd=G;this.onExit=G;this.params={};this.imageCache={pending:0,images:{},operaCache:{},add:function(P,O){if(this.images[P]){return}if(!n){this.images[P]=null}if(!O){O=new Image;O.onload=function(R){return function(){R.pending--}}(this);this.pending++;O.src=P}this.images[P]=O;if(D.opera){var Q=d.createElement(\"div\");Q.appendChild(O);Q.style.position=\"absolute\";Q.style.opacity=0;Q.style.width=\"1px\";Q.style.height=\"1px\";if(!this.operaCache[P]){d.body.appendChild(Q);this.operaCache[P]=Q}}}};this.sourceCode=undefined;this.attach=function(P){if(typeof this.attachFunction===\"function\"){this.attachFunction(P)}else{if(this.sourceCode){var O=(new Function(\"return (\"+this.sourceCode+\");\"))();O(P);this.attachFunction=O}else{throw\"Unable to attach sketch to the processing instance\"}}};this.toString=function(){var O;var P=\"((function(Sketch) {\\n\";P+=\"var sketch = new Sketch(\\n\"+this.sourceCode+\");\\n\";for(O in this.options){if(this.options.hasOwnProperty(O)){var Q=this.options[O];P+=\"sketch.options.\"+O+\" = \"+(typeof Q===\"string\"?'\"'+Q+'\"':\"\"+Q)+\";\\n\"}}for(O in this.imageCache){if(this.options.hasOwnProperty(O)){P+='sketch.imageCache.add(\"'+O+'\");\\n'}}P+=\"return sketch;\\n})(Processing.Sketch))\";return P}};var v=function(Q,N){var O=[],U=[],V=N.length,S=0;function T(W,Y){var X=new XMLHttpRequest;X.onreadystatechange=function(){if(X.readyState===4){var Z;if(X.status!==200&&X.status!==0){Z=\"Invalid XHR status \"+X.status}else{if(X.responseText===\"\"){if(\"withCredentials\" in new XMLHttpRequest&&(new XMLHttpRequest).withCredentials===false&&D.location.protocol===\"file:\"){Z=\"XMLHttpRequest failure, possibly due to a same-origin policy violation. You can try loading this page in another browser, or load it from http://localhost using a local webserver. See the Processing.js README for a more detailed explanation of this problem and solutions.\"}else{Z=\"File is empty.\"}}}Y(X.responseText,Z)}};X.open(\"GET\",W,true);if(X.overrideMimeType){X.overrideMimeType(\"application/json\")}X.setRequestHeader(\"If-Modified-Since\",\"Fri, 01 Jan 1960 00:00:00 GMT\");X.send(null)}function P(X,W){function Z(ac,aa){O[X]=ac;++S;if(aa){U.push(W+\" ==> \"+aa)}if(S===V){if(U.length===0){try{return new F(Q,O.join(\"\\n\"))}catch(ab){throw\"Processing.js: Unable to execute pjs sketch: \"+ab}}else{throw\"Processing.js: Unable to load pjs sketch files: \"+U.join(\"\\n\")}}}if(W.charAt(0)===\"#\"){var Y=d.getElementById(W.substring(1));if(Y){Z(Y.text||Y.textContent)}else{Z(\"\",\"Unable to load pjs sketch: element with id '\"+W.substring(1)+\"' was not found\")}return}T(W,Z)}for(var R=0;R<V;++R){P(R,N[R])}};var I=function(){d.removeEventListener(\"DOMContentLoaded\",I,false);k=[];var O=d.getElementsByTagName(\"canvas\"),U;for(var T=0,P=O.length;T<P;T++){var W=O[T].getAttribute(\"data-processing-sources\");if(W===null){W=O[T].getAttribute(\"data-src\");if(W===null){W=O[T].getAttribute(\"datasrc\")}}if(W){U=W.split(/\\s+/g);for(var S=0;S<U.length;){if(U[S]){S++}else{U.splice(S,1)}}v(O[T],U)}}var ac,aa,N,Z,ab=d.getElementsByTagName(\"script\"),Q=[];for(ac=ab.length-1;ac>=0;ac--){Q.push(ab[ac])}for(ac=0,aa=Q.length;ac<aa;ac++){var Y=Q[ac];if(!Y.getAttribute){continue}var X=Y.getAttribute(\"type\");if(X&&(X.toLowerCase()===\"text/processing\"||X.toLowerCase()===\"application/processing\")){var V=Y.getAttribute(\"data-processing-target\");O=t;if(V){O=d.getElementById(V)}else{var R=Y.nextSibling;while(R&&R.nodeType!==1){R=R.nextSibling}if(R&&R.nodeName.toLowerCase()===\"canvas\"){O=R}}if(O){if(Y.getAttribute(\"src\")){U=Y.getAttribute(\"src\").split(/\\s+/);v(O,U);continue}N=Y.textContent||Y.text;Z=new F(O,N)}}}};F.reload=function(){if(k.length>0){for(var N=k.length-1;N>=0;N--){if(k[N]){k[N].exit()}}}I()};F.loadSketchFromSources=v;F.disableInit=function(){if(n){d.removeEventListener(\"DOMContentLoaded\",I,false)}};if(n){D.Processing=F;d.addEventListener(\"DOMContentLoaded\",I,false)}else{this.Processing=F}})(window,window.document,Math);\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "processing-1.4.1.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-processing-1",
      "url": "/js/processing-1.4.1.js",
      "urls": [
        "/js/processing-1.4.1.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/three.js",
      "relativePath": "js/three.js",
      "basename": "three",
      "outBasename": "three",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "three.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/three.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js",
      "outFilename": "three.js",
      "relativeOutPath": "js/three.js",
      "relativeDirPath": "js",
      "relativeOutDirPath": "js",
      "relativeBase": "js/three",
      "relativeOutBase": "js/three",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.545Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author mrdoob / http://mrdoob.com/\n * @author Larry Battle / http://bateru.com/news\n * @author bhouston / http://exocortex.com\n */\n\nvar THREE = { REVISION: '65' };\n\nself.console = self.console || {\n\n\tinfo: function () {},\n\tlog: function () {},\n\tdebug: function () {},\n\twarn: function () {},\n\terror: function () {}\n\n};\n\nString.prototype.trim = String.prototype.trim || function () {\n\n\treturn this.replace( /^\\s+|\\s+$/g, '' );\n\n};\n\n// based on https://github.com/documentcloud/underscore/blob/bf657be243a075b5e72acc8a83e6f12a564d8f55/underscore.js#L767\nTHREE.extend = function ( obj, source ) {\n\n\t// ECMAScript5 compatibility based on: http://www.nczonline.net/blog/2012/12/11/are-your-mixins-ecmascript-5-compatible/\n\tif ( Object.keys ) {\n\n\t\tvar keys = Object.keys( source );\n\n\t\tfor (var i = 0, il = keys.length; i < il; i++) {\n\n\t\t\tvar prop = keys[i];\n\t\t\tObject.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );\n\n\t\t}\n\n\t} else {\n\n\t\tvar safeHasOwnProperty = {}.hasOwnProperty;\n\n\t\tfor ( var prop in source ) {\n\n\t\t\tif ( safeHasOwnProperty.call( source, prop ) ) {\n\n\t\t\t\tobj[prop] = source[prop];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn obj;\n\n};\n\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik Mller\n// fixes from Paul Irish and Tino Zijdel\n// using 'self' instead of 'window' for compatibility with both NodeJS and IE10.\n( function () {\n\n\tvar lastTime = 0;\n\tvar vendors = [ 'ms', 'moz', 'webkit', 'o' ];\n\n\tfor ( var x = 0; x < vendors.length && !self.requestAnimationFrame; ++ x ) {\n\n\t\tself.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];\n\t\tself.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];\n\n\t}\n\n\tif ( self.requestAnimationFrame === undefined && self['setTimeout'] !== undefined ) {\n\n\t\tself.requestAnimationFrame = function ( callback ) {\n\n\t\t\tvar currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );\n\t\t\tvar id = self.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );\n\t\t\tlastTime = currTime + timeToCall;\n\t\t\treturn id;\n\n\t\t};\n\n\t}\n\n\tif( self.cancelAnimationFrame === undefined && self['clearTimeout'] !== undefined ) {\n\n\t\tself.cancelAnimationFrame = function ( id ) { self.clearTimeout( id ) };\n\n\t}\n\n}() );\n\n// GL STATE CONSTANTS\n\nTHREE.CullFaceNone = 0;\nTHREE.CullFaceBack = 1;\nTHREE.CullFaceFront = 2;\nTHREE.CullFaceFrontBack = 3;\n\nTHREE.FrontFaceDirectionCW = 0;\nTHREE.FrontFaceDirectionCCW = 1;\n\n// SHADOWING TYPES\n\nTHREE.BasicShadowMap = 0;\nTHREE.PCFShadowMap = 1;\nTHREE.PCFSoftShadowMap = 2;\n\n// MATERIAL CONSTANTS\n\n// side\n\nTHREE.FrontSide = 0;\nTHREE.BackSide = 1;\nTHREE.DoubleSide = 2;\n\n// shading\n\nTHREE.NoShading = 0;\nTHREE.FlatShading = 1;\nTHREE.SmoothShading = 2;\n\n// colors\n\nTHREE.NoColors = 0;\nTHREE.FaceColors = 1;\nTHREE.VertexColors = 2;\n\n// blending modes\n\nTHREE.NoBlending = 0;\nTHREE.NormalBlending = 1;\nTHREE.AdditiveBlending = 2;\nTHREE.SubtractiveBlending = 3;\nTHREE.MultiplyBlending = 4;\nTHREE.CustomBlending = 5;\n\n// custom blending equations\n// (numbers start from 100 not to clash with other\n//  mappings to OpenGL constants defined in Texture.js)\n\nTHREE.AddEquation = 100;\nTHREE.SubtractEquation = 101;\nTHREE.ReverseSubtractEquation = 102;\n\n// custom blending destination factors\n\nTHREE.ZeroFactor = 200;\nTHREE.OneFactor = 201;\nTHREE.SrcColorFactor = 202;\nTHREE.OneMinusSrcColorFactor = 203;\nTHREE.SrcAlphaFactor = 204;\nTHREE.OneMinusSrcAlphaFactor = 205;\nTHREE.DstAlphaFactor = 206;\nTHREE.OneMinusDstAlphaFactor = 207;\n\n// custom blending source factors\n\n//THREE.ZeroFactor = 200;\n//THREE.OneFactor = 201;\n//THREE.SrcAlphaFactor = 204;\n//THREE.OneMinusSrcAlphaFactor = 205;\n//THREE.DstAlphaFactor = 206;\n//THREE.OneMinusDstAlphaFactor = 207;\nTHREE.DstColorFactor = 208;\nTHREE.OneMinusDstColorFactor = 209;\nTHREE.SrcAlphaSaturateFactor = 210;\n\n\n// TEXTURE CONSTANTS\n\nTHREE.MultiplyOperation = 0;\nTHREE.MixOperation = 1;\nTHREE.AddOperation = 2;\n\n// Mapping modes\n\nTHREE.UVMapping = function () {};\n\nTHREE.CubeReflectionMapping = function () {};\nTHREE.CubeRefractionMapping = function () {};\n\nTHREE.SphericalReflectionMapping = function () {};\nTHREE.SphericalRefractionMapping = function () {};\n\n// Wrapping modes\n\nTHREE.RepeatWrapping = 1000;\nTHREE.ClampToEdgeWrapping = 1001;\nTHREE.MirroredRepeatWrapping = 1002;\n\n// Filters\n\nTHREE.NearestFilter = 1003;\nTHREE.NearestMipMapNearestFilter = 1004;\nTHREE.NearestMipMapLinearFilter = 1005;\nTHREE.LinearFilter = 1006;\nTHREE.LinearMipMapNearestFilter = 1007;\nTHREE.LinearMipMapLinearFilter = 1008;\n\n// Data types\n\nTHREE.UnsignedByteType = 1009;\nTHREE.ByteType = 1010;\nTHREE.ShortType = 1011;\nTHREE.UnsignedShortType = 1012;\nTHREE.IntType = 1013;\nTHREE.UnsignedIntType = 1014;\nTHREE.FloatType = 1015;\n\n// Pixel types\n\n//THREE.UnsignedByteType = 1009;\nTHREE.UnsignedShort4444Type = 1016;\nTHREE.UnsignedShort5551Type = 1017;\nTHREE.UnsignedShort565Type = 1018;\n\n// Pixel formats\n\nTHREE.AlphaFormat = 1019;\nTHREE.RGBFormat = 1020;\nTHREE.RGBAFormat = 1021;\nTHREE.LuminanceFormat = 1022;\nTHREE.LuminanceAlphaFormat = 1023;\n\n// Compressed texture formats\n\nTHREE.RGB_S3TC_DXT1_Format = 2001;\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\n\n/*\n// Potential future PVRTC compressed texture formats\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\n*/\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Color = function ( value ) {\n\n\tif ( value !== undefined ) this.set( value );\n\n\treturn this;\n\n};\n\nTHREE.Color.prototype = {\n\n\tconstructor: THREE.Color,\n\n\tr: 1, g: 1, b: 1,\n\n\tset: function ( value ) {\n\n\t\tif ( value instanceof THREE.Color ) {\n\n\t\t\tthis.copy( value );\n\n\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\tthis.setHex( value );\n\n\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\tthis.setStyle( value );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetHex: function ( hex ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\treturn this;\n\n\t},\n\n\tsetRGB: function ( r, g, b ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\treturn this;\n\n\t},\n\n\tsetHSL: function ( h, s, l ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tif ( s === 0 ) {\n\n\t\t\tthis.r = this.g = this.b = l;\n\n\t\t} else {\n\n\t\t\tvar hue2rgb = function ( p, q, t ) {\n\n\t\t\t\tif ( t < 0 ) t += 1;\n\t\t\t\tif ( t > 1 ) t -= 1;\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\t\treturn p;\n\n\t\t\t};\n\n\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetStyle: function ( style ) {\n\n\t\t// rgb(255,0,0)\n\n\t\tif ( /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.test( style ) ) {\n\n\t\t\tvar color = /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.exec( style );\n\n\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// rgb(100%,0%,0%)\n\n\t\tif ( /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.test( style ) ) {\n\n\t\t\tvar color = /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.exec( style );\n\n\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// #ff0000\n\n\t\tif ( /^\\#([0-9a-f]{6})$/i.test( style ) ) {\n\n\t\t\tvar color = /^\\#([0-9a-f]{6})$/i.exec( style );\n\n\t\t\tthis.setHex( parseInt( color[ 1 ], 16 ) );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// #f00\n\n\t\tif ( /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {\n\n\t\t\tvar color = /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );\n\n\t\t\tthis.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// red\n\n\t\tif ( /^(\\w+)$/i.test( style ) ) {\n\n\t\t\tthis.setHex( THREE.ColorKeywords[ style ] );\n\n\t\t\treturn this;\n\n\t\t}\n\n\n\t},\n\n\tcopy: function ( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t},\n\n\tcopyGammaToLinear: function ( color ) {\n\n\t\tthis.r = color.r * color.r;\n\t\tthis.g = color.g * color.g;\n\t\tthis.b = color.b * color.b;\n\n\t\treturn this;\n\n\t},\n\n\tcopyLinearToGamma: function ( color ) {\n\n\t\tthis.r = Math.sqrt( color.r );\n\t\tthis.g = Math.sqrt( color.g );\n\t\tthis.b = Math.sqrt( color.b );\n\n\t\treturn this;\n\n\t},\n\n\tconvertGammaToLinear: function () {\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tthis.r = r * r;\n\t\tthis.g = g * g;\n\t\tthis.b = b * b;\n\n\t\treturn this;\n\n\t},\n\n\tconvertLinearToGamma: function () {\n\n\t\tthis.r = Math.sqrt( this.r );\n\t\tthis.g = Math.sqrt( this.g );\n\t\tthis.b = Math.sqrt( this.b );\n\n\t\treturn this;\n\n\t},\n\n\tgetHex: function () {\n\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t},\n\n\tgetHexString: function () {\n\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t},\n\n\tgetHSL: function ( optionalTarget ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tvar max = Math.max( r, g, b );\n\t\tvar min = Math.min( r, g, b );\n\n\t\tvar hue, saturation;\n\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tvar delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\thsl.h = hue;\n\t\thsl.s = saturation;\n\t\thsl.l = lightness;\n\n\t\treturn hsl;\n\n\t},\n\n\tgetStyle: function () {\n\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t},\n\n\toffsetHSL: function ( h, s, l ) {\n\n\t\tvar hsl = this.getHSL();\n\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t},\n\n\taddColors: function ( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.r = array[ 0 ];\n\t\tthis.g = array[ 1 ];\n\t\tthis.b = array[ 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\treturn [ this.r, this.g, this.b ];\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Color().setRGB( this.r, this.g, this.b );\n\n\t}\n\n};\n\nTHREE.ColorKeywords = { \"aliceblue\": 0xF0F8FF, \"antiquewhite\": 0xFAEBD7, \"aqua\": 0x00FFFF, \"aquamarine\": 0x7FFFD4, \"azure\": 0xF0FFFF,\n\"beige\": 0xF5F5DC, \"bisque\": 0xFFE4C4, \"black\": 0x000000, \"blanchedalmond\": 0xFFEBCD, \"blue\": 0x0000FF, \"blueviolet\": 0x8A2BE2,\n\"brown\": 0xA52A2A, \"burlywood\": 0xDEB887, \"cadetblue\": 0x5F9EA0, \"chartreuse\": 0x7FFF00, \"chocolate\": 0xD2691E, \"coral\": 0xFF7F50,\n\"cornflowerblue\": 0x6495ED, \"cornsilk\": 0xFFF8DC, \"crimson\": 0xDC143C, \"cyan\": 0x00FFFF, \"darkblue\": 0x00008B, \"darkcyan\": 0x008B8B,\n\"darkgoldenrod\": 0xB8860B, \"darkgray\": 0xA9A9A9, \"darkgreen\": 0x006400, \"darkgrey\": 0xA9A9A9, \"darkkhaki\": 0xBDB76B, \"darkmagenta\": 0x8B008B,\n\"darkolivegreen\": 0x556B2F, \"darkorange\": 0xFF8C00, \"darkorchid\": 0x9932CC, \"darkred\": 0x8B0000, \"darksalmon\": 0xE9967A, \"darkseagreen\": 0x8FBC8F,\n\"darkslateblue\": 0x483D8B, \"darkslategray\": 0x2F4F4F, \"darkslategrey\": 0x2F4F4F, \"darkturquoise\": 0x00CED1, \"darkviolet\": 0x9400D3,\n\"deeppink\": 0xFF1493, \"deepskyblue\": 0x00BFFF, \"dimgray\": 0x696969, \"dimgrey\": 0x696969, \"dodgerblue\": 0x1E90FF, \"firebrick\": 0xB22222,\n\"floralwhite\": 0xFFFAF0, \"forestgreen\": 0x228B22, \"fuchsia\": 0xFF00FF, \"gainsboro\": 0xDCDCDC, \"ghostwhite\": 0xF8F8FF, \"gold\": 0xFFD700,\n\"goldenrod\": 0xDAA520, \"gray\": 0x808080, \"green\": 0x008000, \"greenyellow\": 0xADFF2F, \"grey\": 0x808080, \"honeydew\": 0xF0FFF0, \"hotpink\": 0xFF69B4,\n\"indianred\": 0xCD5C5C, \"indigo\": 0x4B0082, \"ivory\": 0xFFFFF0, \"khaki\": 0xF0E68C, \"lavender\": 0xE6E6FA, \"lavenderblush\": 0xFFF0F5, \"lawngreen\": 0x7CFC00,\n\"lemonchiffon\": 0xFFFACD, \"lightblue\": 0xADD8E6, \"lightcoral\": 0xF08080, \"lightcyan\": 0xE0FFFF, \"lightgoldenrodyellow\": 0xFAFAD2, \"lightgray\": 0xD3D3D3,\n\"lightgreen\": 0x90EE90, \"lightgrey\": 0xD3D3D3, \"lightpink\": 0xFFB6C1, \"lightsalmon\": 0xFFA07A, \"lightseagreen\": 0x20B2AA, \"lightskyblue\": 0x87CEFA,\n\"lightslategray\": 0x778899, \"lightslategrey\": 0x778899, \"lightsteelblue\": 0xB0C4DE, \"lightyellow\": 0xFFFFE0, \"lime\": 0x00FF00, \"limegreen\": 0x32CD32,\n\"linen\": 0xFAF0E6, \"magenta\": 0xFF00FF, \"maroon\": 0x800000, \"mediumaquamarine\": 0x66CDAA, \"mediumblue\": 0x0000CD, \"mediumorchid\": 0xBA55D3,\n\"mediumpurple\": 0x9370DB, \"mediumseagreen\": 0x3CB371, \"mediumslateblue\": 0x7B68EE, \"mediumspringgreen\": 0x00FA9A, \"mediumturquoise\": 0x48D1CC,\n\"mediumvioletred\": 0xC71585, \"midnightblue\": 0x191970, \"mintcream\": 0xF5FFFA, \"mistyrose\": 0xFFE4E1, \"moccasin\": 0xFFE4B5, \"navajowhite\": 0xFFDEAD,\n\"navy\": 0x000080, \"oldlace\": 0xFDF5E6, \"olive\": 0x808000, \"olivedrab\": 0x6B8E23, \"orange\": 0xFFA500, \"orangered\": 0xFF4500, \"orchid\": 0xDA70D6,\n\"palegoldenrod\": 0xEEE8AA, \"palegreen\": 0x98FB98, \"paleturquoise\": 0xAFEEEE, \"palevioletred\": 0xDB7093, \"papayawhip\": 0xFFEFD5, \"peachpuff\": 0xFFDAB9,\n\"peru\": 0xCD853F, \"pink\": 0xFFC0CB, \"plum\": 0xDDA0DD, \"powderblue\": 0xB0E0E6, \"purple\": 0x800080, \"red\": 0xFF0000, \"rosybrown\": 0xBC8F8F,\n\"royalblue\": 0x4169E1, \"saddlebrown\": 0x8B4513, \"salmon\": 0xFA8072, \"sandybrown\": 0xF4A460, \"seagreen\": 0x2E8B57, \"seashell\": 0xFFF5EE,\n\"sienna\": 0xA0522D, \"silver\": 0xC0C0C0, \"skyblue\": 0x87CEEB, \"slateblue\": 0x6A5ACD, \"slategray\": 0x708090, \"slategrey\": 0x708090, \"snow\": 0xFFFAFA,\n\"springgreen\": 0x00FF7F, \"steelblue\": 0x4682B4, \"tan\": 0xD2B48C, \"teal\": 0x008080, \"thistle\": 0xD8BFD8, \"tomato\": 0xFF6347, \"turquoise\": 0x40E0D0,\n\"violet\": 0xEE82EE, \"wheat\": 0xF5DEB3, \"white\": 0xFFFFFF, \"whitesmoke\": 0xF5F5F5, \"yellow\": 0xFFFF00, \"yellowgreen\": 0x9ACD32 };\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Quaternion = function ( x, y, z, w ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Quaternion.prototype = {\n\n\tconstructor: THREE.Quaternion,\n\n\t_x: 0,_y: 0, _z: 0, _w: 0,\n\n\t_euler: undefined,\n\n\t_updateEuler: function ( callback ) {\n\n\t\tif ( this._euler !== undefined ) {\n\n\t\t\tthis._euler.setFromQuaternion( this, undefined, false );\n\n\t\t}\n\n\t},\n\n\tget x () {\n\n\t\treturn this._x;\n\n\t},\n\n\tset x ( value ) {\n\n\t\tthis._x = value;\n\t\tthis._updateEuler();\n\n\t},\n\n\tget y () {\n\n\t\treturn this._y;\n\n\t},\n\n\tset y ( value ) {\n\n\t\tthis._y = value;\n\t\tthis._updateEuler();\n\n\t},\n\n\tget z () {\n\n\t\treturn this._z;\n\n\t},\n\n\tset z ( value ) {\n\n\t\tthis._z = value;\n\t\tthis._updateEuler();\n\n\t},\n\n\tget w () {\n\n\t\treturn this._w;\n\n\t},\n\n\tset w ( value ) {\n\n\t\tthis._w = value;\n\t\tthis._updateEuler();\n\n\t},\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( quaternion ) {\n\n\t\tthis._x = quaternion._x;\n\t\tthis._y = quaternion._y;\n\t\tthis._z = quaternion._z;\n\t\tthis._w = quaternion._w;\n\n\t\tthis._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromEuler: function ( euler, update ) {\n\n\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\tthrow new Error( 'ERROR: Quaternion\\'s .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );\n\t\t}\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\tvar s3 = Math.sin( euler._z / 2 );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t}\n\n\t\tif ( update !== false ) this._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\t\t// axis have to be normalized\n\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements,\n\n\t\t\tm11 = te[0], m12 = te[4], m13 = te[8],\n\t\t\tm21 = te[1], m22 = te[5], m23 = te[9],\n\t\t\tm31 = te[2], m32 = te[6], m33 = te[10],\n\n\t\t\ttrace = m11 + m22 + m33,\n\t\t\ts;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = (m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = (m12 + m21 ) / s;\n\t\t\tthis._z = (m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = (m13 - m31 ) / s;\n\t\t\tthis._x = (m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = (m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\tinverse: function () {\n\n\t\tthis.conjugate().normalize();\n\n\t\treturn this;\n\n\t},\n\n\tconjugate: function () {\n\n\t\tthis._x *= -1;\n\t\tthis._y *= -1;\n\t\tthis._z *= -1;\n\n\t\tthis._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\tvar l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( q, p ) {\n\n\t\tif ( p !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Quaternion\\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t}\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t},\n\n\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVector3: function ( vector ) {\n\n\t\tconsole.warn( 'DEPRECATED: Quaternion\\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\treturn vector.applyQuaternion( this );\n\n\t},\n\n\tslerp: function ( qb, t ) {\n\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = -qb._w;\n\t\t\tthis._x = -qb._x;\n\t\t\tthis._y = -qb._y;\n\t\t\tthis._z = -qb._z;\n\n\t\t\tcosHalfTheta = -cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar halfTheta = Math.acos( cosHalfTheta );\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\tthis._z = 0.5 * ( z + this._z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tthis._w = array[ 3 ];\n\n\t\tthis._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\treturn [ this._x, this._y, this._z, this._w ];\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Quaternion( this._x, this._y, this._z, this._w );\n\n\t}\n\n};\n\nTHREE.Quaternion.slerp = function ( qa, qb, qm, t ) {\n\n\treturn qm.copy( qa ).slerp( qb, t );\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author philogb / http://blog.thejit.org/\n * @author egraether / http://egraether.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.Vector2 = function ( x, y ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\n};\n\nTHREE.Vector2.prototype = {\n\n\tconstructor: THREE.Vector2,\n\n\tset: function ( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector2\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector2\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.x *= s;\n\t\tthis.y *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\tif ( scalar !== 0 ) {\n\n\t\t\tvar invScalar = 1 / scalar;\n\n\t\t\tthis.x *= invScalar;\n\t\t\tthis.y *= invScalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tif ( this.x > v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y > v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tif ( this.x < v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y < v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tif ( this.x < min.x ) {\n\n\t\t\tthis.x = min.x;\n\n\t\t} else if ( this.x > max.x ) {\n\n\t\t\tthis.x = max.x;\n\n\t\t}\n\n\t\tif ( this.y < min.y ) {\n\n\t\t\tthis.y = min.y;\n\n\t\t} else if ( this.y > max.y ) {\n\n\t\t\tthis.y = max.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function() {\n\n\t\treturn this.multiplyScalar( - 1 );\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t},\n\n\tsetLength: function ( l ) {\n\n\t\tvar oldLength = this.length();\n\n\t\tif ( oldLength !== 0 && l !== oldLength ) {\n\n\t\t\tthis.multiplyScalar( l / oldLength );\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.x = array[ 0 ];\n\t\tthis.y = array[ 1 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\treturn [ this.x, this.y ];\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Vector2( this.x, this.y );\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author *kile / http://kile.stravaganza.org/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector3 = function ( x, y, z ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\n};\n\nTHREE.Vector3.prototype = {\n\n\tconstructor: THREE.Vector3,\n\n\tset: function ( x, y, z ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t}\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVectors: function ( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix3: function ( m ) {\n\n\t\tvar x = this.x;\n\t\tvar y = this.y;\n\t\tvar z = this.z;\n\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[0] * x + e[3] * y + e[6] * z;\n\t\tthis.y = e[1] * x + e[4] * y + e[7] * z;\n\t\tthis.z = e[2] * x + e[5] * y + e[8] * z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[0] * x + e[4] * y + e[8]  * z + e[12];\n\t\tthis.y = e[1] * x + e[5] * y + e[9]  * z + e[13];\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14];\n\n\t\treturn this;\n\n\t},\n\n\tapplyProjection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 projection matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tvar e = m.elements;\n\t\tvar d = 1 / ( e[3] * x + e[7] * y + e[11] * z + e[15] ); // perspective divide\n\n\t\tthis.x = ( e[0] * x + e[4] * y + e[8]  * z + e[12] ) * d;\n\t\tthis.y = ( e[1] * x + e[5] * y + e[9]  * z + e[13] ) * d;\n\t\tthis.z = ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;\n\n\t\treturn this;\n\n\t},\n\n\tapplyQuaternion: function ( q ) {\n\n\t\tvar x = this.x;\n\t\tvar y = this.y;\n\t\tvar z = this.z;\n\n\t\tvar qx = q.x;\n\t\tvar qy = q.y;\n\t\tvar qz = q.z;\n\t\tvar qw = q.w;\n\n\t\t// calculate quat * vector\n\n\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\tvar iw = -qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n\t\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n\t\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n\t\treturn this;\n\n\t},\n\n\ttransformDirection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[0] * x + e[4] * y + e[8]  * z;\n\t\tthis.y = e[1] * x + e[5] * y + e[9]  * z;\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z;\n\n\t\tthis.normalize();\n\n\t\treturn this;\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\tif ( scalar !== 0 ) {\n\n\t\t\tvar invScalar = 1 / scalar;\n\n\t\t\tthis.x *= invScalar;\n\t\t\tthis.y *= invScalar;\n\t\t\tthis.z *= invScalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tif ( this.x > v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y > v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\tif ( this.z > v.z ) {\n\n\t\t\tthis.z = v.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tif ( this.x < v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y < v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\tif ( this.z < v.z ) {\n\n\t\t\tthis.z = v.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tif ( this.x < min.x ) {\n\n\t\t\tthis.x = min.x;\n\n\t\t} else if ( this.x > max.x ) {\n\n\t\t\tthis.x = max.x;\n\n\t\t}\n\n\t\tif ( this.y < min.y ) {\n\n\t\t\tthis.y = min.y;\n\n\t\t} else if ( this.y > max.y ) {\n\n\t\t\tthis.y = max.y;\n\n\t\t}\n\n\t\tif ( this.z < min.z ) {\n\n\t\t\tthis.z = min.z;\n\n\t\t} else if ( this.z > max.z ) {\n\n\t\t\tthis.z = max.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\treturn this.multiplyScalar( - 1 );\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( l ) {\n\n\t\tvar oldLength = this.length();\n\n\t\tif ( oldLength !== 0 && l !== oldLength  ) {\n\n\t\t\tthis.multiplyScalar( l / oldLength );\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tcross: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\treturn this.crossVectors( v, w );\n\n\t\t}\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tthis.x = y * v.z - z * v.y;\n\t\tthis.y = z * v.x - x * v.z;\n\t\tthis.z = x * v.y - y * v.x;\n\n\t\treturn this;\n\n\t},\n\n\tcrossVectors: function ( a, b ) {\n\n\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\tvar bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t},\n\n\tangleTo: function ( v ) {\n\n\t\tvar theta = this.dot( v ) / ( this.length() * v.length() );\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( THREE.Math.clamp( theta, -1, 1 ) );\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x;\n\t\tvar dy = this.y - v.y;\n\t\tvar dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t},\n\n\tsetEulerFromRotationMatrix: function ( m, order ) {\n\n\t\tconsole.error( \"REMOVED: Vector3\\'s setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.\");\n\n\t},\n\n\tsetEulerFromQuaternion: function ( q, order ) {\n\n\t\tconsole.error( \"REMOVED: Vector3\\'s setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.\");\n\n\t},\n\n\tgetPositionFromMatrix: function ( m ) {\n\n\t\tconsole.warn( \"DEPRECATED: Vector3\\'s .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code.\" );\n\n\t\treturn this.setFromMatrixPosition( m );\n\n\t},\n\n\tgetScaleFromMatrix: function ( m ) {\n\n\t\tconsole.warn( \"DEPRECATED: Vector3\\'s .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code.\" );\n\n\t\treturn this.setFromMatrixScale( m );\n\t},\n\n\tgetColumnFromMatrix: function ( index, matrix ) {\n\n\t\tconsole.warn( \"DEPRECATED: Vector3\\'s .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code.\" );\n\n\t\treturn this.setFromMatrixColumn( index, matrix );\n\n\t},\n\n\tsetFromMatrixPosition: function ( m ) {\n\n\t\tthis.x = m.elements[ 12 ];\n\t\tthis.y = m.elements[ 13 ];\n\t\tthis.z = m.elements[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixScale: function ( m ) {\n\n\t\tvar sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();\n\t\tvar sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();\n\t\tvar sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\t},\n\n\tsetFromMatrixColumn: function ( index, matrix ) {\n\n\t\tvar offset = index * 4;\n\n\t\tvar me = matrix.elements;\n\n\t\tthis.x = me[ offset ];\n\t\tthis.y = me[ offset + 1 ];\n\t\tthis.z = me[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.x = array[ 0 ];\n\t\tthis.y = array[ 1 ];\n\t\tthis.z = array[ 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\treturn [ this.x, this.y, this.z ];\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Vector3( this.x, this.y, this.z );\n\n\t}\n\n};\n\nTHREE.extend( THREE.Vector3.prototype, {\n\n\tapplyEuler: function () {\n\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function ( euler ) {\n\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\t\tconsole.error( 'ERROR: Vector3\\'s .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );\n\n\t\t\t}\n\n\t\t\tthis.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tapplyAxisAngle: function () {\n\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function ( axis, angle ) {\n\n\t\t\tthis.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tprojectOnVector: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( vector ) {\n\n\t\t\tv1.copy( vector ).normalize();\n\t\t\tvar d = this.dot( v1 );\n\t\t\treturn this.copy( v1 ).multiplyScalar( d );\n\n\t\t};\n\n\t}(),\n\n\tprojectOnPlane: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( planeNormal ) {\n\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\treturn this.sub( v1 );\n\n\t\t}\n\n\t}(),\n\n\treflect: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( vector ) {\n\n\t\t    v1.copy( this ).projectOnVector( vector ).multiplyScalar( 2 );\n\n\t\t    return this.subVectors( v1, this );\n\n\t\t}\n\n\t}()\n\n} );\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector4 = function ( x, y, z, w ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\tthis.w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Vector4.prototype = {\n\n\tconstructor: THREE.Vector4,\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector4\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector4\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\tthis.w *= scalar;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\tvar x = this.x;\n\t\tvar y = this.y;\n\t\tvar z = this.z;\n\t\tvar w = this.w;\n\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n\t\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\tif ( scalar !== 0 ) {\n\n\t\t\tvar invScalar = 1 / scalar;\n\n\t\t\tthis.x *= invScalar;\n\t\t\tthis.y *= invScalar;\n\t\t\tthis.z *= invScalar;\n\t\t\tthis.w *= invScalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\t\t\tthis.w = 1;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\t this.x = 1;\n\t\t\t this.y = 0;\n\t\t\t this.z = 0;\n\n\t\t} else {\n\n\t\t\t this.x = q.x / s;\n\t\t\t this.y = q.y / s;\n\t\t\t this.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[0], m12 = te[4], m13 = te[8],\n\t\t\tm21 = te[1], m22 = te[5], m23 = te[9],\n\t\t\tm31 = te[2], m32 = te[6], m33 = te[10];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon )\n\t\t  && ( Math.abs( m13 - m31 ) < epsilon )\n\t\t  && ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 )\n\t\t\t  && ( Math.abs( m13 + m31 ) < epsilon2 )\n\t\t\t  && ( Math.abs( m23 + m32 ) < epsilon2 )\n\t\t\t  && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) { // m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else { // m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\n\t\t\t\t\t\t + ( m13 - m31 ) * ( m13 - m31 )\n\t\t\t\t\t\t + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tif ( this.x > v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y > v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\tif ( this.z > v.z ) {\n\n\t\t\tthis.z = v.z;\n\n\t\t}\n\n\t\tif ( this.w > v.w ) {\n\n\t\t\tthis.w = v.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tif ( this.x < v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y < v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\tif ( this.z < v.z ) {\n\n\t\t\tthis.z = v.z;\n\n\t\t}\n\n\t\tif ( this.w < v.w ) {\n\n\t\t\tthis.w = v.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tif ( this.x < min.x ) {\n\n\t\t\tthis.x = min.x;\n\n\t\t} else if ( this.x > max.x ) {\n\n\t\t\tthis.x = max.x;\n\n\t\t}\n\n\t\tif ( this.y < min.y ) {\n\n\t\t\tthis.y = min.y;\n\n\t\t} else if ( this.y > max.y ) {\n\n\t\t\tthis.y = max.y;\n\n\t\t}\n\n\t\tif ( this.z < min.z ) {\n\n\t\t\tthis.z = min.z;\n\n\t\t} else if ( this.z > max.z ) {\n\n\t\t\tthis.z = max.z;\n\n\t\t}\n\n\t\tif ( this.w < min.w ) {\n\n\t\t\tthis.w = min.w;\n\n\t\t} else if ( this.w > max.w ) {\n\n\t\t\tthis.w = max.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function() {\n\n\t\treturn this.multiplyScalar( -1 );\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( l ) {\n\n\t\tvar oldLength = this.length();\n\n\t\tif ( oldLength !== 0 && l !== oldLength ) {\n\n\t\t\tthis.multiplyScalar( l / oldLength );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.x = array[ 0 ];\n\t\tthis.y = array[ 1 ];\n\t\tthis.z = array[ 2 ];\n\t\tthis.w = array[ 3 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\treturn [ this.x, this.y, this.z, this.w ];\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Vector4( this.x, this.y, this.z, this.w );\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Euler = function ( x, y, z, order ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._order = order || THREE.Euler.DefaultOrder;\n\n};\n\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\nTHREE.Euler.DefaultOrder = 'XYZ';\n\nTHREE.Euler.prototype = {\n\n\tconstructor: THREE.Euler,\n\n\t_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,\n\n\t_quaternion: undefined,\n\n\t_updateQuaternion: function () {\n\n\t\tif ( this._quaternion !== undefined ) {\n\n\t\t\tthis._quaternion.setFromEuler( this, false );\n\n\t\t}\n\n\t},\n\n\tget x () {\n\n\t\treturn this._x;\n\n\t},\n\n\tset x ( value ) {\n\n\t\tthis._x = value;\n\t\tthis._updateQuaternion();\n\n\t},\n\n\tget y () {\n\n\t\treturn this._y;\n\n\t},\n\n\tset y ( value ) {\n\n\t\tthis._y = value;\n\t\tthis._updateQuaternion();\n\n\t},\n\n\tget z () {\n\n\t\treturn this._z;\n\n\t},\n\n\tset z ( value ) {\n\n\t\tthis._z = value;\n\t\tthis._updateQuaternion();\n\n\t},\n\n\tget order () {\n\n\t\treturn this._order;\n\n\t},\n\n\tset order ( value ) {\n\n\t\tthis._order = value;\n\t\tthis._updateQuaternion();\n\n\t},\n\n\tset: function ( x, y, z, order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order || this._order;\n\n\t\tthis._updateQuaternion();\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis._updateQuaternion();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m, order ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t// clamp, to handle numerical problems\n\n\t\tfunction clamp( x ) {\n\n\t\t\treturn Math.min( Math.max( x, -1 ), 1 );\n\n\t\t}\n\n\t\tvar te = m.elements;\n\t\tvar m11 = te[0], m12 = te[4], m13 = te[8];\n\t\tvar m21 = te[1], m22 = te[5], m23 = te[9];\n\t\tvar m31 = te[2], m32 = te[6], m33 = te[10];\n\n\t\torder = order || this._order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._y = Math.asin( clamp( m13 ) );\n\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = Math.asin( - clamp( m23 ) );\n\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = Math.asin( clamp( m32 ) );\n\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._y = Math.asin( - clamp( m31 ) );\n\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._z = Math.asin( clamp( m21 ) );\n\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._z = Math.asin( - clamp( m12 ) );\n\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._y = 0;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'WARNING: Euler.setFromRotationMatrix() given unsupported order: ' + order )\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tthis._updateQuaternion();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromQuaternion: function ( q, order, update ) {\n\n\t\t// q is assumed to be normalized\n\n\t\t// clamp, to handle numerical problems\n\n\t\tfunction clamp( x ) {\n\n\t\t\treturn Math.min( Math.max( x, -1 ), 1 );\n\n\t\t}\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m\n\n\t\tvar sqx = q.x * q.x;\n\t\tvar sqy = q.y * q.y;\n\t\tvar sqz = q.z * q.z;\n\t\tvar sqw = q.w * q.w;\n\n\t\torder = order || this._order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );\n\t\t\tthis._y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ) ) );\n\t\t\tthis._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );\n\n\t\t} else if ( order ===  'YXZ' ) {\n\n\t\t\tthis._x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ) ) );\n\t\t\tthis._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );\n\t\t\tthis._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ) ) );\n\t\t\tthis._y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );\n\t\t\tthis._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );\n\t\t\tthis._y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ) ) );\n\t\t\tthis._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );\n\t\t\tthis._y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );\n\t\t\tthis._z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ) ) );\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );\n\t\t\tthis._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );\n\t\t\tthis._z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ) ) );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'WARNING: Euler.setFromQuaternion() given unsupported order: ' + order )\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update !== false ) this._updateQuaternion();\n\n\t\treturn this;\n\n\t},\n\n\treorder: function () {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\tvar q = new THREE.Quaternion();\n\n\t\treturn function ( newOrder ) {\n\n\t\t\tq.setFromEuler( this );\n\t\t\tthis.setFromQuaternion( q, newOrder );\n\n\t\t};\n\n\n\t}(),\n\n\tfromArray: function ( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis._updateQuaternion();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\treturn [ this._x, this._y, this._z, this._order ];\n\n\t},\n\n\tequals: function ( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Euler( this._x, this._y, this._z, this._order );\n\n\t}\n\n};\n\n/**\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Line3 = function ( start, end ) {\n\n\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\n\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\n\n};\n\nTHREE.Line3.prototype = {\n\n\tconstructor: THREE.Line3,\n\n\tset: function ( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t},\n\n\tdelta: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.end, this.start );\n\n\t},\n\n\tdistanceSq: function () {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t},\n\n\tdistance: function () {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t},\n\n\tat: function ( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tclosestPointToPointParameter: function() {\n\n\t\tvar startP = new THREE.Vector3();\n\t\tvar startEnd = new THREE.Vector3();\n\n\t\treturn function ( point, clampToLine ) {\n\n\t\t\tstartP.subVectors( point, this.start );\n\t\t\tstartEnd.subVectors( this.end, this.start );\n\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\n\t\t\tvar t = startEnd_startP / startEnd2;\n\n\t\t\tif ( clampToLine ) {\n\n\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\n\n\t\t\t}\n\n\t\t\treturn t;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Line3().copy( this );\n\n\t}\n\n};\n\n/**\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Box2 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );\n\n};\n\nTHREE.Box2.prototype = {\n\n\tconstructor: THREE.Box2,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tif ( points.length > 0 ) {\n\n\t\t\tvar point = points[ 0 ];\n\n\t\t\tthis.min.copy( point );\n\t\t\tthis.max.copy( point );\n\n\t\t\tfor ( var i = 1, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tpoint = points[ i ];\n\n\t\t\t\tif ( point.x < this.min.x ) {\n\n\t\t\t\t\tthis.min.x = point.x;\n\n\t\t\t\t} else if ( point.x > this.max.x ) {\n\n\t\t\t\t\tthis.max.x = point.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( point.y < this.min.y ) {\n\n\t\t\t\t\tthis.min.y = point.y;\n\n\t\t\t\t} else if ( point.y > this.max.y ) {\n\n\t\t\t\t\tthis.max.y = point.y;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.makeEmpty();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function ( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = Infinity;\n\t\tthis.max.x = this.max.y = -Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( -scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\n\t\treturn result.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t},\n\n\tisIntersectionBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function ( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Box2().copy( this );\n\n\t}\n\n};\n\n/**\n * @author bhouston / http://exocortex.com\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Box3 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );\n\n};\n\nTHREE.Box3.prototype = {\n\n\tconstructor: THREE.Box3,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\taddPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x ) {\n\n\t\t\tthis.min.x = point.x;\n\n\t\t} else if ( point.x > this.max.x ) {\n\n\t\t\tthis.max.x = point.x;\n\n\t\t}\n\n\t\tif ( point.y < this.min.y ) {\n\n\t\t\tthis.min.y = point.y;\n\n\t\t} else if ( point.y > this.max.y ) {\n\n\t\t\tthis.max.y = point.y;\n\n\t\t}\n\n\t\tif ( point.z < this.min.z ) {\n\n\t\t\tthis.min.z = point.z;\n\n\t\t} else if ( point.z > this.max.z ) {\n\n\t\t\tthis.max.z = point.z;\n\n\t\t}\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tif ( points.length > 0 ) {\n\n\t\t\tvar point = points[ 0 ];\n\n\t\t\tthis.min.copy( point );\n\t\t\tthis.max.copy( point );\n\n\t\t\tfor ( var i = 1, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tthis.addPoint( points[ i ] )\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.makeEmpty();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetFromObject: function() {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and childrens', world transforms\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function( object ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\tif ( node.geometry !== undefined && node.geometry.vertices !== undefined ) {\n\n\t\t\t\t\tvar vertices = node.geometry.vertices;\n\n\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i++ ) {\n\n\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\n\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = this.min.z = Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = -Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( -scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t     point.y < this.min.y || point.y > this.max.y ||\n\t\t     point.z < this.min.z || point.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t},\n\n\tisIntersectionBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t     box.max.z < this.min.z || box.min.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tgetBoundingSphere: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\n\n\t\t\tresult.center = this.center();\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function() {\n\n\t\tvar points = [\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3()\n\t\t];\n\n\t\treturn function ( matrix ) {\n\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\tpoints[0].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\tpoints[1].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\tpoints[2].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\tpoints[3].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\tpoints[4].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\tpoints[5].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\tpoints[6].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\tpoints[7].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111\n\n\t\t\tthis.makeEmpty();\n\t\t\tthis.setFromPoints( points );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Box3().copy( this );\n\n\t}\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Matrix3 = function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\tthis.elements = new Float32Array(9);\n\n\tthis.set(\n\n\t\t( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0,\n\t\tn21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0,\n\t\tn31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1\n\n\t);\n};\n\nTHREE.Matrix3.prototype = {\n\n\tconstructor: THREE.Matrix3,\n\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[0] = n11; te[3] = n12; te[6] = n13;\n\t\tte[1] = n21; te[4] = n22; te[7] = n23;\n\t\tte[2] = n31; te[5] = n32; te[8] = n33;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[0], me[3], me[6],\n\t\t\tme[1], me[4], me[7],\n\t\t\tme[2], me[5], me[8]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVector3: function ( vector ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix3\\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\treturn vector.applyMatrix3( this );\n\n\t},\n\n\tmultiplyVector3Array: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( a ) {\n\n\t\t\tfor ( var i = 0, il = a.length; i < il; i += 3 ) {\n\n\t\t\t\tv1.x = a[ i ];\n\t\t\t\tv1.y = a[ i + 1 ];\n\t\t\t\tv1.z = a[ i + 2 ];\n\n\t\t\t\tv1.applyMatrix3(this);\n\n\t\t\t\ta[ i ]     = v1.x;\n\t\t\t\ta[ i + 1 ] = v1.y;\n\t\t\t\ta[ i + 2 ] = v1.z;\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t};\n\n\t}(),\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[0] *= s; te[3] *= s; te[6] *= s;\n\t\tte[1] *= s; te[4] *= s; te[7] *= s;\n\t\tte[2] *= s; te[5] *= s; te[8] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar a = te[0], b = te[1], c = te[2],\n\t\t\td = te[3], e = te[4], f = te[5],\n\t\t\tg = te[6], h = te[7], i = te[8];\n\n\t\treturn a*e*i - a*f*h - b*d*i + b*f*g + c*d*h - c*e*g;\n\n\t},\n\n\tgetInverse: function ( matrix, throwOnInvertible ) {\n\n\t\t// input: THREE.Matrix4\n\t\t// ( based on http://code.google.com/p/webgl-mjs/ )\n\n\t\tvar me = matrix.elements;\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] =   me[10] * me[5] - me[6] * me[9];\n\t\tte[ 1 ] = - me[10] * me[1] + me[2] * me[9];\n\t\tte[ 2 ] =   me[6] * me[1] - me[2] * me[5];\n\t\tte[ 3 ] = - me[10] * me[4] + me[6] * me[8];\n\t\tte[ 4 ] =   me[10] * me[0] - me[2] * me[8];\n\t\tte[ 5 ] = - me[6] * me[0] + me[2] * me[4];\n\t\tte[ 6 ] =   me[9] * me[4] - me[5] * me[8];\n\t\tte[ 7 ] = - me[9] * me[0] + me[1] * me[8];\n\t\tte[ 8 ] =   me[5] * me[0] - me[1] * me[4];\n\n\t\tvar det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];\n\n\t\t// no inverse\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnInvertible || false ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\tthis.identity();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.multiplyScalar( 1.0 / det );\n\n\t\treturn this;\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar tmp, m = this.elements;\n\n\t\ttmp = m[1]; m[1] = m[3]; m[3] = tmp;\n\t\ttmp = m[2]; m[2] = m[6]; m[6] = tmp;\n\t\ttmp = m[5]; m[5] = m[7]; m[7] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tgetNormalMatrix: function ( m ) {\n\n\t\t// input: THREE.Matrix4\n\n\t\tthis.getInverse( m ).transpose();\n\n\t\treturn this;\n\n\t},\n\n\ttransposeIntoArray: function ( r ) {\n\n\t\tvar m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.elements.set( array );\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\tvar te = this.elements;\n\n\t\treturn [\n\t\t\tte[ 0 ], te[ 1 ], te[ 2 ],\n\t\t\tte[ 3 ], te[ 4 ], te[ 5 ],\n\t\t\tte[ 6 ], te[ 7 ], te[ 8 ]\n\t\t];\n\n\t},\n\n\tclone: function () {\n\n\t\tvar te = this.elements;\n\n\t\treturn new THREE.Matrix3(\n\n\t\t\tte[0], te[3], te[6],\n\t\t\tte[1], te[4], te[7],\n\t\t\tte[2], te[5], te[8]\n\n\t\t);\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author jordi_ros / http://plattsoft.com\n * @author D1plo1d / http://github.com/D1plo1d\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author timknip / http://www.floorplanner.com/\n * @author bhouston / http://exocortex.com\n * @author WestLangley / http://github.com/WestLangley\n */\n\n\nTHREE.Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\tthis.elements = new Float32Array( 16 );\n\n\t// TODO: if n11 is undefined, then just set to identity, otherwise copy all other values into matrix\n\t//   we should not support semi specification of Matrix4, it is just weird.\n\n\tvar te = this.elements;\n\n\tte[0] = ( n11 !== undefined ) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;\n\tte[1] = n21 || 0; te[5] = ( n22 !== undefined ) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;\n\tte[2] = n31 || 0; te[6] = n32 || 0; te[10] = ( n33 !== undefined ) ? n33 : 1; te[14] = n34 || 0;\n\tte[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = ( n44 !== undefined ) ? n44 : 1;\n\n};\n\nTHREE.Matrix4.prototype = {\n\n\tconstructor: THREE.Matrix4,\n\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;\n\t\tte[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;\n\t\tte[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;\n\t\tte[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tthis.elements.set( m.elements );\n\n\t\treturn this;\n\n\t},\n\n\textractPosition: function ( m ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .extractPosition() has been renamed to .copyPosition().' );\n\t\treturn this.copyPosition( m );\n\n\t},\n\n\tcopyPosition: function ( m ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tte[12] = me[12];\n\t\tte[13] = me[13];\n\t\tte[14] = me[14];\n\n\t\treturn this;\n\n\t},\n\n\textractRotation: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( m ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tvar scaleX = 1 / v1.set( me[0], me[1], me[2] ).length();\n\t\t\tvar scaleY = 1 / v1.set( me[4], me[5], me[6] ).length();\n\t\t\tvar scaleZ = 1 / v1.set( me[8], me[9], me[10] ).length();\n\n\t\t\tte[0] = me[0] * scaleX;\n\t\t\tte[1] = me[1] * scaleX;\n\t\t\tte[2] = me[2] * scaleX;\n\n\t\t\tte[4] = me[4] * scaleY;\n\t\t\tte[5] = me[5] * scaleY;\n\t\t\tte[6] = me[6] * scaleY;\n\n\t\t\tte[8] = me[8] * scaleZ;\n\t\t\tte[9] = me[9] * scaleZ;\n\t\t\tte[10] = me[10] * scaleZ;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeRotationFromEuler: function ( euler ) {\n\n\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\tconsole.error( 'ERROR: Matrix\\'s .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );\n\n\t\t}\n\n\t\tvar te = this.elements;\n\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[0] = c * e;\n\t\t\tte[4] = - c * f;\n\t\t\tte[8] = d;\n\n\t\t\tte[1] = af + be * d;\n\t\t\tte[5] = ae - bf * d;\n\t\t\tte[9] = - b * c;\n\n\t\t\tte[2] = bf - ae * d;\n\t\t\tte[6] = be + af * d;\n\t\t\tte[10] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[0] = ce + df * b;\n\t\t\tte[4] = de * b - cf;\n\t\t\tte[8] = a * d;\n\n\t\t\tte[1] = a * f;\n\t\t\tte[5] = a * e;\n\t\t\tte[9] = - b;\n\n\t\t\tte[2] = cf * b - de;\n\t\t\tte[6] = df + ce * b;\n\t\t\tte[10] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[0] = ce - df * b;\n\t\t\tte[4] = - a * f;\n\t\t\tte[8] = de + cf * b;\n\n\t\t\tte[1] = cf + de * b;\n\t\t\tte[5] = a * e;\n\t\t\tte[9] = df - ce * b;\n\n\t\t\tte[2] = - a * d;\n\t\t\tte[6] = b;\n\t\t\tte[10] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[0] = c * e;\n\t\t\tte[4] = be * d - af;\n\t\t\tte[8] = ae * d + bf;\n\n\t\t\tte[1] = c * f;\n\t\t\tte[5] = bf * d + ae;\n\t\t\tte[9] = af * d - be;\n\n\t\t\tte[2] = - d;\n\t\t\tte[6] = b * c;\n\t\t\tte[10] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[0] = c * e;\n\t\t\tte[4] = bd - ac * f;\n\t\t\tte[8] = bc * f + ad;\n\n\t\t\tte[1] = f;\n\t\t\tte[5] = a * e;\n\t\t\tte[9] = - b * e;\n\n\t\t\tte[2] = - d * e;\n\t\t\tte[6] = ad * f + bc;\n\t\t\tte[10] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[0] = c * e;\n\t\t\tte[4] = - f;\n\t\t\tte[8] = d * e;\n\n\t\t\tte[1] = ac * f + bd;\n\t\t\tte[5] = a * e;\n\t\t\tte[9] = ad * f - bc;\n\n\t\t\tte[2] = bc * f - ad;\n\t\t\tte[6] = b * e;\n\t\t\tte[10] = bd * f + ac;\n\n\t\t}\n\n\t\t// last column\n\t\tte[3] = 0;\n\t\tte[7] = 0;\n\t\tte[11] = 0;\n\n\t\t// bottom row\n\t\tte[12] = 0;\n\t\tte[13] = 0;\n\t\tte[14] = 0;\n\t\tte[15] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.' );\n\n\t\treturn this.makeRotationFromQuaternion( q );\n\n\t},\n\n\tmakeRotationFromQuaternion: function ( q ) {\n\n\t\tvar te = this.elements;\n\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tte[0] = 1 - ( yy + zz );\n\t\tte[4] = xy - wz;\n\t\tte[8] = xz + wy;\n\n\t\tte[1] = xy + wz;\n\t\tte[5] = 1 - ( xx + zz );\n\t\tte[9] = yz - wx;\n\n\t\tte[2] = xz - wy;\n\t\tte[6] = yz + wx;\n\t\tte[10] = 1 - ( xx + yy );\n\n\t\t// last column\n\t\tte[3] = 0;\n\t\tte[7] = 0;\n\t\tte[11] = 0;\n\n\t\t// bottom row\n\t\tte[12] = 0;\n\t\tte[13] = 0;\n\t\tte[14] = 0;\n\t\tte[15] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function() {\n\n\t\tvar x = new THREE.Vector3();\n\t\tvar y = new THREE.Vector3();\n\t\tvar z = new THREE.Vector3();\n\n\t\treturn function ( eye, target, up ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tz.subVectors( eye, target ).normalize();\n\n\t\t\tif ( z.length() === 0 ) {\n\n\t\t\t\tz.z = 1;\n\n\t\t\t}\n\n\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\tif ( x.length() === 0 ) {\n\n\t\t\t\tz.x += 0.0001;\n\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t}\n\n\t\t\ty.crossVectors( z, x );\n\n\n\t\t\tte[0] = x.x; te[4] = y.x; te[8] = z.x;\n\t\t\tte[1] = x.y; te[5] = y.y; te[9] = z.y;\n\t\t\tte[2] = x.z; te[6] = y.z; te[10] = z.z;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmultiply: function ( m, n ) {\n\n\t\tif ( n !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t}\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t},\n\n\tmultiplyMatrices: function ( a, b ) {\n\n\t\tvar ae = a.elements;\n\t\tvar be = b.elements;\n\t\tvar te = this.elements;\n\n\t\tvar a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n\t\tvar a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n\t\tvar a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n\t\tvar a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n\n\t\tvar b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n\t\tvar b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n\t\tvar b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\n\t\tvar b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n\n\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyToArray: function ( a, b, r ) {\n\n\t\tvar te = this.elements;\n\n\t\tthis.multiplyMatrices( a, b );\n\n\t\tr[ 0 ] = te[0]; r[ 1 ] = te[1]; r[ 2 ] = te[2]; r[ 3 ] = te[3];\n\t\tr[ 4 ] = te[4]; r[ 5 ] = te[5]; r[ 6 ] = te[6]; r[ 7 ] = te[7];\n\t\tr[ 8 ]  = te[8]; r[ 9 ]  = te[9]; r[ 10 ] = te[10]; r[ 11 ] = te[11];\n\t\tr[ 12 ] = te[12]; r[ 13 ] = te[13]; r[ 14 ] = te[14]; r[ 15 ] = te[15];\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;\n\t\tte[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;\n\t\tte[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;\n\t\tte[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVector3: function ( vector ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\treturn vector.applyProjection( this );\n\n\t},\n\n\tmultiplyVector4: function ( vector ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\n\t},\n\n\tmultiplyVector3Array: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( a ) {\n\n\t\t\tfor ( var i = 0, il = a.length; i < il; i += 3 ) {\n\n\t\t\t\tv1.x = a[ i ];\n\t\t\t\tv1.y = a[ i + 1 ];\n\t\t\t\tv1.z = a[ i + 2 ];\n\n\t\t\t\tv1.applyProjection( this );\n\n\t\t\t\ta[ i ]     = v1.x;\n\t\t\t\ta[ i + 1 ] = v1.y;\n\t\t\t\ta[ i + 2 ] = v1.z;\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t};\n\n\t}(),\n\n\trotateAxis: function ( v ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\n\t\tv.transformDirection( this );\n\n\t},\n\n\tcrossVector: function ( vector ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\n\t},\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n\t\tvar n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n\t\tvar n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n\t\tvar n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+n14 * n23 * n32\n\t\t\t\t-n13 * n24 * n32\n\t\t\t\t-n14 * n22 * n33\n\t\t\t\t+n12 * n24 * n33\n\t\t\t\t+n13 * n22 * n34\n\t\t\t\t-n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+n11 * n23 * n34\n\t\t\t\t-n11 * n24 * n33\n\t\t\t\t+n14 * n21 * n33\n\t\t\t\t-n13 * n21 * n34\n\t\t\t\t+n13 * n24 * n31\n\t\t\t\t-n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+n11 * n24 * n32\n\t\t\t\t-n11 * n22 * n34\n\t\t\t\t-n14 * n21 * n32\n\t\t\t\t+n12 * n21 * n34\n\t\t\t\t+n14 * n22 * n31\n\t\t\t\t-n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t-n13 * n22 * n31\n\t\t\t\t-n11 * n23 * n32\n\t\t\t\t+n11 * n22 * n33\n\t\t\t\t+n13 * n21 * n32\n\t\t\t\t-n12 * n21 * n33\n\t\t\t\t+n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar te = this.elements;\n\t\tvar tmp;\n\n\t\ttmp = te[1]; te[1] = te[4]; te[4] = tmp;\n\t\ttmp = te[2]; te[2] = te[8]; te[8] = tmp;\n\t\ttmp = te[6]; te[6] = te[9]; te[9] = tmp;\n\n\t\ttmp = te[3]; te[3] = te[12]; te[12] = tmp;\n\t\ttmp = te[7]; te[7] = te[13]; te[13] = tmp;\n\t\ttmp = te[11]; te[11] = te[14]; te[14] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tflattenToArray: function ( flat ) {\n\n\t\tvar te = this.elements;\n\t\tflat[ 0 ] = te[0]; flat[ 1 ] = te[1]; flat[ 2 ] = te[2]; flat[ 3 ] = te[3];\n\t\tflat[ 4 ] = te[4]; flat[ 5 ] = te[5]; flat[ 6 ] = te[6]; flat[ 7 ] = te[7];\n\t\tflat[ 8 ] = te[8]; flat[ 9 ] = te[9]; flat[ 10 ] = te[10]; flat[ 11 ] = te[11];\n\t\tflat[ 12 ] = te[12]; flat[ 13 ] = te[13]; flat[ 14 ] = te[14]; flat[ 15 ] = te[15];\n\n\t\treturn flat;\n\n\t},\n\n\tflattenToArrayOffset: function( flat, offset ) {\n\n\t\tvar te = this.elements;\n\t\tflat[ offset ] = te[0];\n\t\tflat[ offset + 1 ] = te[1];\n\t\tflat[ offset + 2 ] = te[2];\n\t\tflat[ offset + 3 ] = te[3];\n\n\t\tflat[ offset + 4 ] = te[4];\n\t\tflat[ offset + 5 ] = te[5];\n\t\tflat[ offset + 6 ] = te[6];\n\t\tflat[ offset + 7 ] = te[7];\n\n\t\tflat[ offset + 8 ]  = te[8];\n\t\tflat[ offset + 9 ]  = te[9];\n\t\tflat[ offset + 10 ] = te[10];\n\t\tflat[ offset + 11 ] = te[11];\n\n\t\tflat[ offset + 12 ] = te[12];\n\t\tflat[ offset + 13 ] = te[13];\n\t\tflat[ offset + 14 ] = te[14];\n\t\tflat[ offset + 15 ] = te[15];\n\n\t\treturn flat;\n\n\t},\n\n\tgetPosition: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function () {\n\n\t\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\n\t\t\tvar te = this.elements;\n\t\t\treturn v1.set( te[12], te[13], te[14] );\n\n\t\t};\n\n\t}(),\n\n\tsetPosition: function ( v ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[12] = v.x;\n\t\tte[13] = v.y;\n\t\tte[14] = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tgetInverse: function ( m, throwOnInvertible ) {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tvar n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];\n\t\tvar n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];\n\t\tvar n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];\n\t\tvar n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];\n\n\t\tte[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;\n\t\tte[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;\n\t\tte[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;\n\t\tte[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;\n\t\tte[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;\n\t\tte[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;\n\t\tte[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;\n\t\tte[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;\n\t\tte[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;\n\t\tte[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;\n\t\tte[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;\n\t\tte[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;\n\t\tte[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;\n\t\tte[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;\n\t\tte[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;\n\t\tte[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;\n\n\t\tvar det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];\n\n\t\tif ( det == 0 ) {\n\n\t\t\tvar msg = \"Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnInvertible || false ) {\n\n\t\t\t\tthrow new Error( msg ); \n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\tthis.identity();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tthis.multiplyScalar( 1 / det );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( v ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .translate() has been removed.');\n\n\t},\n\n\trotateX: function ( angle ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .rotateX() has been removed.');\n\n\t},\n\n\trotateY: function ( angle ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .rotateY() has been removed.');\n\n\t},\n\n\trotateZ: function ( angle ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .rotateZ() has been removed.');\n\n\t},\n\n\trotateByAxis: function ( axis, angle ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .rotateByAxis() has been removed.');\n\n\t},\n\n\tscale: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\tte[0] *= x; te[4] *= y; te[8] *= z;\n\t\tte[1] *= x; te[5] *= y; te[9] *= z;\n\t\tte[2] *= x; te[6] *= y; te[10] *= z;\n\t\tte[3] *= x; te[7] *= y; te[11] *= z;\n\n\t\treturn this;\n\n\t},\n\n\tgetMaxScaleOnAxis: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n\t\tvar scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n\t\tvar scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );\n\n\t},\n\n\tmakeTranslation: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, x,\n\t\t\t0, 1, 0, y,\n\t\t\t0, 0, 1, z,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationX: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0,  0, 0,\n\t\t\t0, c, -s, 0,\n\t\t\t0, s,  c, 0,\n\t\t\t0, 0,  0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationY: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t-s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationZ: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, -s, 0, 0,\n\t\t\ts,  c, 0, 0,\n\t\t\t0,  0, 1, 0,\n\t\t\t0,  0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\t\tvar t = 1 - c;\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\tvar tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\t return this;\n\n\t},\n\n\tmakeScale: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcompose: function ( position, quaternion, scale ) {\n\n\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\tthis.scale( scale );\n\t\tthis.setPosition( position );\n\n\t\treturn this;\n\n\t},\n\n\tdecompose: function () {\n\n\t\tvar vector = new THREE.Vector3();\n\t\tvar matrix = new THREE.Matrix4();\n\n\t\treturn function ( position, quaternion, scale ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar sx = vector.set( te[0], te[1], te[2] ).length();\n\t\t\tvar sy = vector.set( te[4], te[5], te[6] ).length();\n\t\t\tvar sz = vector.set( te[8], te[9], te[10] ).length();\n\n\t\t\t// if determine is negative, we need to invert one scale\n\t\t\tvar det = this.determinant();\n\t\t\tif( det < 0 ) {\n\t\t\t\tsx = -sx;\n\t\t\t}\n\n\t\t\tposition.x = te[12];\n\t\t\tposition.y = te[13];\n\t\t\tposition.z = te[14];\n\n\t\t\t// scale the rotation part\n\n\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\n\t\t\tvar invSX = 1 / sx;\n\t\t\tvar invSY = 1 / sy;\n\t\t\tvar invSZ = 1 / sz;\n\n\t\t\tmatrix.elements[0] *= invSX;\n\t\t\tmatrix.elements[1] *= invSX;\n\t\t\tmatrix.elements[2] *= invSX;\n\n\t\t\tmatrix.elements[4] *= invSY;\n\t\t\tmatrix.elements[5] *= invSY;\n\t\t\tmatrix.elements[6] *= invSY;\n\n\t\t\tmatrix.elements[8] *= invSZ;\n\t\t\tmatrix.elements[9] *= invSZ;\n\t\t\tmatrix.elements[10] *= invSZ;\n\n\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\tscale.x = sx;\n\t\t\tscale.y = sy;\n\t\t\tscale.z = sz;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = 2 * near / ( right - left );\n\t\tvar y = 2 * near / ( top - bottom );\n\n\t\tvar a = ( right + left ) / ( right - left );\n\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\tvar c = - ( far + near ) / ( far - near );\n\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\tte[0] = x;\tte[4] = 0;\tte[8] = a;\tte[12] = 0;\n\t\tte[1] = 0;\tte[5] = y;\tte[9] = b;\tte[13] = 0;\n\t\tte[2] = 0;\tte[6] = 0;\tte[10] = c;\tte[14] = d;\n\t\tte[3] = 0;\tte[7] = 0;\tte[11] = - 1;\tte[15] = 0;\n\n\t\treturn this;\n\n\t},\n\n\tmakePerspective: function ( fov, aspect, near, far ) {\n\n\t\tvar ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\n\t\tvar ymin = - ymax;\n\t\tvar xmin = ymin * aspect;\n\t\tvar xmax = ymax * aspect;\n\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\n\t},\n\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar w = right - left;\n\t\tvar h = top - bottom;\n\t\tvar p = far - near;\n\n\t\tvar x = ( right + left ) / w;\n\t\tvar y = ( top + bottom ) / h;\n\t\tvar z = ( far + near ) / p;\n\n\t\tte[0] = 2 / w;\tte[4] = 0;\tte[8] = 0;\tte[12] = -x;\n\t\tte[1] = 0;\tte[5] = 2 / h;\tte[9] = 0;\tte[13] = -y;\n\t\tte[2] = 0;\tte[6] = 0;\tte[10] = -2/p;\tte[14] = -z;\n\t\tte[3] = 0;\tte[7] = 0;\tte[11] = 0;\tte[15] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.elements.set( array );\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\tvar te = this.elements;\n\n\t\treturn [\n\t\t\tte[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],\n\t\t\tte[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],\n\t\t\tte[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],\n\t\t\tte[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]\n\t\t];\n\n\t},\n\n\tclone: function () {\n\n\t\tvar te = this.elements;\n\n\t\treturn new THREE.Matrix4(\n\n\t\t\tte[0], te[4], te[8], te[12],\n\t\t\tte[1], te[5], te[9], te[13],\n\t\t\tte[2], te[6], te[10], te[14],\n\t\t\tte[3], te[7], te[11], te[15]\n\n\t\t);\n\n\t}\n\n};\n\n/**\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Ray = function ( origin, direction ) {\n\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\n\n};\n\nTHREE.Ray.prototype = {\n\n\tconstructor: THREE.Ray,\n\n\tset: function ( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t},\n\n\tat: function ( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t},\n\n\trecast: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( t ) {\n\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\tresult.subVectors( point, this.origin );\n\t\tvar directionDistance = result.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn result.copy( this.origin );\n\n\t\t}\n\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( point ) {\n\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t// point behind the ray\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn this.origin.distanceTo( point );\n\n\t\t\t}\n\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\treturn v1.distanceTo( point );\n\n\t\t};\n\n\t}(),\n\n\tdistanceSqToSegment: function( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\tvar segCenter = v0.clone().add( v1 ).multiplyScalar( 0.5 );\n\t\tvar segDir = v1.clone().sub( v0 ).normalize();\n\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\tvar diff = this.origin.clone().sub( segCenter );\n\t\tvar a01 = - this.direction.dot( segDir );\n\t\tvar b0 = diff.dot( this.direction );\n\t\tvar b1 = - diff.dot( segDir );\n\t\tvar c = diff.lengthSq();\n\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\tvar s0, s1, sqrDist, extDet;\n\n\t\tif ( det >= 0 ) {\n\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0;\n\t\t\ts1 = a01 * b0 - b1;\n\t\t\textDet = segExtent * det;\n\n\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( s1 <= - extDet) {\n\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0;\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t}\n\n\t\tif ( optionalPointOnRay ) {\n\n\t\t\toptionalPointOnRay.copy( this.direction.clone().multiplyScalar( s0 ).add( this.origin ) );\n\n\t\t}\n\n\t\tif ( optionalPointOnSegment ) {\n\n\t\t\toptionalPointOnSegment.copy( segDir.clone().multiplyScalar( s1 ).add( segCenter ) );\n\n\t\t}\n\n\t\treturn sqrDist;\n\n\t},\n\n\tisIntersectionSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\n\t},\n\n\tisIntersectionPlane: function ( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t},\n\n\tdistanceToPlane: function ( plane ) {\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\t\tif ( denominator == 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif( plane.distanceToPoint( this.origin ) == 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t :  null;\n\n\t},\n\n\tintersectPlane: function ( plane, optionalTarget ) {\n\n\t\tvar t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.at( t, optionalTarget );\n\n\t},\n\n\tisIntersectionBox: function () {\n\t\t\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function ( box ) {\n\n\t\t\treturn this.intersectBox( box, v ) !== null;\n\n\t\t}\n\n\t}(),\n\n\tintersectBox: function ( box , optionalTarget ) {\n\n\t\t// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/\n\n\t\tvar tmin,tmax,tymin,tymax,tzmin,tzmax;\n\n\t\tvar invdirx = 1/this.direction.x,\n\t\t\tinvdiry = 1/this.direction.y,\n\t\t\tinvdirz = 1/this.direction.z;\n\n\t\tvar origin = this.origin;\n\n\t\tif (invdirx >= 0) {\n\t\t\t\t\n\t\t\ttmin = (box.min.x - origin.x) * invdirx;\n\t\t\ttmax = (box.max.x - origin.x) * invdirx;\n\n\t\t} else { \n\n\t\t\ttmin = (box.max.x - origin.x) * invdirx;\n\t\t\ttmax = (box.min.x - origin.x) * invdirx;\n\t\t}\t\t\t\n\n\t\tif (invdiry >= 0) {\n\t\t\n\t\t\ttymin = (box.min.y - origin.y) * invdiry;\n\t\t\ttymax = (box.max.y - origin.y) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = (box.max.y - origin.y) * invdiry;\n\t\t\ttymax = (box.min.y - origin.y) * invdiry;\n\t\t}\n\n\t\tif ((tmin > tymax) || (tymin > tmax)) return null;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\t\t\n\t\tif (tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\tif (tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\tif (invdirz >= 0) {\n\t\t\n\t\t\ttzmin = (box.min.z - origin.z) * invdirz;\n\t\t\ttzmax = (box.max.z - origin.z) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = (box.max.z - origin.z) * invdirz;\n\t\t\ttzmax = (box.min.z - origin.z) * invdirz;\n\t\t}\n\n\t\tif ((tmin > tzmax) || (tzmin > tmax)) return null;\n\n\t\tif (tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif (tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\n\t},\n\n\tintersectTriangle: function() {\n\n\t\t// Compute the offset origin, edges, and normal.\n\t\tvar diff = new THREE.Vector3();\n\t\tvar edge1 = new THREE.Vector3();\n\t\tvar edge2 = new THREE.Vector3();\n\t\tvar normal = new THREE.Vector3();\n\n\t\treturn function ( a, b, c, backfaceCulling, optionalTarget ) {\n\n\t\t\t// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\n\n\t\t\tedge1.subVectors( b, a );\n\t\t\tedge2.subVectors( c, a );\n\t\t\tnormal.crossVectors( edge1, edge2 );\n\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\tvar sign;\n\n\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\tsign = 1;\n\n\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\tsign = - 1;\n\t\t\t\tDdN = - DdN;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tdiff.subVectors( this.origin, a );\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n\t\t\t// b1 < 0, no intersection\n\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n\t\t\t// b2 < 0, no intersection\n\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// b1+b2 > 1, no intersection\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Line intersects triangle, check if ray does.\n\t\t\tvar QdN = - sign * diff.dot( normal );\n\n\t\t\t// t < 0, no intersection\n\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Ray intersects triangle.\n\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\t\n\t\t}\n\t\n\t}(),\n\n\tapplyMatrix4: function ( matrix4 ) {\n\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.sub( this.origin );\n\t\tthis.direction.normalize();\n\n\t\treturn this;\n\t},\n\n\tequals: function ( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Ray().copy( this );\n\n\t}\n\n};\n\n/**\n * @author bhouston / http://exocortex.com\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Sphere = function ( center, radius ) {\n\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n};\n\nTHREE.Sphere.prototype = {\n\n\tconstructor: THREE.Sphere,\n\n\tset: function ( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\t},\n\n\n\tsetFromPoints: function () {\n\n\t\tvar box = new THREE.Box3();\n\n\t\treturn function ( points, optionalCenter )  {\n\n\t\t\tvar center = this.center;\n\n\t\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\t\tcenter.copy( optionalCenter );\n\n\t\t\t} else {\n\n\t\t\t\tbox.setFromPoints( points ).center( center );\n\n\t\t\t}\n\n\t\t\tvar maxRadiusSq = 0;\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\treturn this;\t\t\t\n \t\t\n \t\t};\n\n\t}(),\n\n\tcopy: function ( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\treturn ( this.radius <= 0 );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\tresult.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\tresult.sub( this.center ).normalize();\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tgetBoundingBox: function ( optionalTarget ) {\n\n\t\tvar box = optionalTarget || new THREE.Box3();\n\n\t\tbox.set( this.center, this.center );\n\t\tbox.expandByScalar( this.radius );\n\n\t\treturn box;\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Sphere().copy( this );\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\n\n\tthis.planes = [\n\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\n\n\t];\n\n};\n\nTHREE.Frustum.prototype = {\n\n\tconstructor: THREE.Frustum,\n\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tvar planes = this.planes;\n\n\t\tplanes[0].copy( p0 );\n\t\tplanes[1].copy( p1 );\n\t\tplanes[2].copy( p2 );\n\t\tplanes[3].copy( p3 );\n\t\tplanes[4].copy( p4 );\n\t\tplanes[5].copy( p5 );\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( frustum ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor( var i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[i].copy( frustum.planes[i] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix: function ( m ) {\n\n\t\tvar planes = this.planes;\n\t\tvar me = m.elements;\n\t\tvar me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\n\t\tvar me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];\n\t\tvar me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];\n\t\tvar me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\tintersectsObject: function () {\n\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function ( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( object.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar planes = this.planes;\n\t\tvar center = sphere.center;\n\t\tvar negRadius = -sphere.radius;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectsBox : function() {\n\n\t\tvar p1 = new THREE.Vector3(),\n\t\t\tp2 = new THREE.Vector3();\n\n\t\treturn function( box ) {\n\n\t\t\tvar planes = this.planes;\n\t\t\t\n\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\t\t\t\n\t\t\t\tvar plane = planes[i];\n\t\t\t\t\n\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\t\t\t\t\n\t\t\t\t// if both outside plane, no intersection\n\n\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\t\t\t\t\t\n\t\t\t\t\treturn false;\n\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t};\n\n\t}(),\n\n\n\tcontainsPoint: function ( point ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Frustum().copy( this );\n\n\t}\n\n};\n\n/**\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Plane = function ( normal, constant ) {\n\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n};\n\nTHREE.Plane.prototype = {\n\n\tconstructor: THREE.Plane,\n\n\tset: function ( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponents: function ( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCoplanarPoints: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\n\t\treturn function ( a, b, c ) {\n\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\n\tcopy: function ( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.constant *= -1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t},\n\n\tdistanceToSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t},\n\n\tprojectPoint: function ( point, optionalTarget ) {\n\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\n\t},\n\n\torthoPoint: function ( point, optionalTarget ) {\n\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\n\t},\n\n\tisIntersectionLine: function ( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tvar startSign = this.distanceToPoint( line.start );\n\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t},\n\n\tintersectLine: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( line, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tvar direction = line.delta( v1 );\n\n\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\tif ( denominator == 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif( this.distanceToPoint( line.start ) == 0 ) {\n\n\t\t\t\t\treturn result.copy( line.start );\n\n\t\t\t\t}\n\n\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\tif( t < 0 || t > 1 ) {\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t};\n\n\t}(),\n\n\n\tcoplanarPoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t},\n\n\tapplyMatrix4: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\t\tvar m1 = new THREE.Matrix3();\n\n\t\treturn function ( matrix, optionalNormalMatrix ) {\n\n\t\t\t// compute new normal based on theory here:\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\tvar newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );\n\t\t\t\n\t\t\tvar newCoplanarPoint = this.coplanarPoint( v2 );\n\t\t\tnewCoplanarPoint.applyMatrix4( matrix );\n\n\t\t\tthis.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.constant = this.constant - offset.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant == this.constant );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Plane().copy( this );\n\n\t}\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Math = {\n\n\tPI2: Math.PI * 2,\n\n\tgenerateUUID: function () {\n\n\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\t\t\n\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n\t\tvar uuid = new Array(36);\n\t\tvar rnd = 0, r;\n\n\t\treturn function () {\n\n\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\n\t\t\t\tif ( i == 8 || i == 13 || i == 18 || i == 23 ) {\n\t\t\t\n\t\t\t\t\tuuid[ i ] = '-';\n\t\t\t\n\t\t\t\t} else if ( i == 14 ) {\n\t\t\t\n\t\t\t\t\tuuid[ i ] = '4';\n\t\t\t\n\t\t\t\t} else {\n\t\t\t\n\t\t\t\t\tif (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;\n\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\tuuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn uuid.join('');\n\n\t\t};\n\n\t}(),\n\n\t// Clamp value to range <a, b>\n\n\tclamp: function ( x, a, b ) {\n\n\t\treturn ( x < a ) ? a : ( ( x > b ) ? b : x );\n\n\t},\n\n\t// Clamp value to range <a, inf)\n\n\tclampBottom: function ( x, a ) {\n\n\t\treturn x < a ? a : x;\n\n\t},\n\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t},\n\n\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\tsmoothstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min )/( max - min );\n\n\t\treturn x*x*(3 - 2*x);\n\n\t},\n\n\tsmootherstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min )/( max - min );\n\n\t\treturn x*x*x*(x*(x*6 - 15) + 10);\n\n\t},\n\n\t// Random float from <0, 1> with 16 bits of randomness\n\t// (standard Math.random() creates repetitive patterns when applied over larger space)\n\n\trandom16: function () {\n\n\t\treturn ( 65280 * Math.random() + 255 * Math.random() ) / 65535;\n\n\t},\n\n\t// Random integer from <low, high> interval\n\n\trandInt: function ( low, high ) {\n\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t},\n\n\t// Random float from <low, high> interval\n\n\trandFloat: function ( low, high ) {\n\n\t\treturn low + Math.random() * ( high - low );\n\n\t},\n\n\t// Random float from <-range/2, range/2> interval\n\n\trandFloatSpread: function ( range ) {\n\n\t\treturn range * ( 0.5 - Math.random() );\n\n\t},\n\n\tsign: function ( x ) {\n\n\t\treturn ( x < 0 ) ? -1 : ( ( x > 0 ) ? 1 : 0 );\n\n\t},\n\n\tdegToRad: function() {\n\n\t\tvar degreeToRadiansFactor = Math.PI / 180;\n\n\t\treturn function ( degrees ) {\n\n\t\t\treturn degrees * degreeToRadiansFactor;\n\n\t\t};\n\n\t}(),\n\n\tradToDeg: function() {\n\n\t\tvar radianToDegreesFactor = 180 / Math.PI;\n\n\t\treturn function ( radians ) {\n\n\t\t\treturn radians * radianToDegreesFactor;\n\n\t\t};\n\n\t}()\n\n};\n\n/**\n * Spline from Tween.js, slightly optimized (and trashed)\n * http://sole.github.com/tween.js/examples/05_spline.html\n *\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Spline = function ( points ) {\n\n\tthis.points = points;\n\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\tpoint, intPoint, weight, w2, w3,\n\tpa, pb, pc, pd;\n\n\tthis.initFromArray = function( a ) {\n\n\t\tthis.points = [];\n\n\t\tfor ( var i = 0; i < a.length; i++ ) {\n\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\n\t\t}\n\n\t};\n\n\tthis.getPoint = function ( k ) {\n\n\t\tpoint = ( this.points.length - 1 ) * k;\n\t\tintPoint = Math.floor( point );\n\t\tweight = point - intPoint;\n\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\tc[ 1 ] = intPoint;\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\n\t\tpa = this.points[ c[ 0 ] ];\n\t\tpb = this.points[ c[ 1 ] ];\n\t\tpc = this.points[ c[ 2 ] ];\n\t\tpd = this.points[ c[ 3 ] ];\n\n\t\tw2 = weight * weight;\n\t\tw3 = weight * w2;\n\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\n\t\treturn v3;\n\n\t};\n\n\tthis.getControlPointsArray = function () {\n\n\t\tvar i, p, l = this.points.length,\n\t\t\tcoords = [];\n\n\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\tp = this.points[ i ];\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\n\t\t}\n\n\t\treturn coords;\n\n\t};\n\n\t// approximate length by summing linear segments\n\n\tthis.getLength = function ( nSubDivisions ) {\n\n\t\tvar i, index, nSamples, position,\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\toldPosition = new THREE.Vector3(),\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tchunkLengths = [],\n\t\t\ttotalLength = 0;\n\n\t\t// first point has 0 length\n\n\t\tchunkLengths[ 0 ] = 0;\n\n\t\tif ( !nSubDivisions ) nSubDivisions = 100;\n\n\t\tnSamples = this.points.length * nSubDivisions;\n\n\t\toldPosition.copy( this.points[ 0 ] );\n\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\n\t\t\tindex = i / nSamples;\n\n\t\t\tposition = this.getPoint( index );\n\t\t\ttmpVec.copy( position );\n\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\n\t\t\toldPosition.copy( position );\n\n\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\tintPoint = Math.floor( point );\n\n\t\t\tif ( intPoint != oldIntPoint ) {\n\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\toldIntPoint = intPoint;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// last point ends with total length\n\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\n\t\treturn { chunks: chunkLengths, total: totalLength };\n\n\t};\n\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\n\t\tvar i, j,\n\t\t\tindex, indexCurrent, indexNext,\n\t\t\tlinearDistance, realDistance,\n\t\t\tsampling, position,\n\t\t\tnewpoints = [],\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tsl = this.getLength();\n\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\n\t\tfor ( i = 1; i < this.points.length; i++ ) {\n\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\tindexNext = i / ( this.points.length - 1 );\n\n\t\t\tfor ( j = 1; j < sampling - 1; j++ ) {\n\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\n\t\t\t}\n\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\n\t\t}\n\n\t\tthis.points = newpoints;\n\n\t};\n\n\t// Catmull-Rom\n\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t};\n\n};\n\n/**\n * @author bhouston / http://exocortex.com\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Triangle = function ( a, b, c ) {\n\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\n\n};\n\nTHREE.Triangle.normal = function() {\n\n\tvar v0 = new THREE.Vector3();\n\n\treturn function ( a, b, c, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tresult.subVectors( c, b );\n\t\tv0.subVectors( a, b );\n\t\tresult.cross( v0 );\n\n\t\tvar resultLengthSq = result.lengthSq();\n\t\tif( resultLengthSq > 0 ) {\n\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\n\t\t}\n\n\t\treturn result.set( 0, 0, 0 );\n\n\t};\n\n}();\n\n// static/instance method to calculate barycoordinates\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\nTHREE.Triangle.barycoordFromPoint = function() {\n\n\tvar v0 = new THREE.Vector3();\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\n\treturn function ( point, a, b, c, optionalTarget ) {\n\n\t\tv0.subVectors( c, a );\n\t\tv1.subVectors( b, a );\n\t\tv2.subVectors( point, a );\n\n\t\tvar dot00 = v0.dot( v0 );\n\t\tvar dot01 = v0.dot( v1 );\n\t\tvar dot02 = v0.dot( v2 );\n\t\tvar dot11 = v1.dot( v1 );\n\t\tvar dot12 = v1.dot( v2 );\n\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t// colinear or singular triangle\n\t\tif( denom == 0 ) {\n\t\t\t// arbitrary location outside of triangle?\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\treturn result.set( -2, -1, -1 );\n\t\t}\n\n\t\tvar invDenom = 1 / denom;\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycoordinates must always sum to 1\n\t\treturn result.set( 1 - u - v, v, u );\n\n\t};\n\n}();\n\nTHREE.Triangle.containsPoint = function() {\n\n\tvar v1 = new THREE.Vector3();\n\n\treturn function ( point, a, b, c ) {\n\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\n\t};\n\n}();\n\nTHREE.Triangle.prototype = {\n\n\tconstructor: THREE.Triangle,\n\n\tset: function ( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[i0] );\n\t\tthis.b.copy( points[i1] );\n\t\tthis.c.copy( points[i2] );\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t},\n\n\tarea: function() {\n\n\t\tvar v0 = new THREE.Vector3();\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function () {\n\n\t\t\tv0.subVectors( this.c, this.b );\n\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t};\n\n\t}(),\n\n\tmidpoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t},\n\n\tnormal: function ( optionalTarget ) {\n\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tplane: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Plane();\n\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t},\n\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t},\n\n\tequals: function ( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Triangle().copy( this );\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Vertex = function ( v ) {\n\n\tconsole.warn( 'THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.')\n\treturn v;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.UV = function ( u, v ) {\n\n\tconsole.warn( 'THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.')\n\treturn new THREE.Vector2( u, v );\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Clock = function ( autoStart ) {\n\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\tthis.startTime = 0;\n\tthis.oldTime = 0;\n\tthis.elapsedTime = 0;\n\n\tthis.running = false;\n\n};\n\nTHREE.Clock.prototype = {\n\n\tconstructor: THREE.Clock,\n\n\tstart: function () {\n\n\t\tthis.startTime = self.performance !== undefined && self.performance.now !== undefined\n\t\t\t\t\t? self.performance.now()\n\t\t\t\t\t: Date.now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.running = true;\n\t},\n\n\tstop: function () {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\n\t},\n\n\tgetElapsedTime: function () {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t},\n\n\tgetDelta: function () {\n\n\t\tvar diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tvar newTime = self.performance !== undefined && self.performance.now !== undefined\n\t\t\t\t\t? self.performance.now()\n\t\t\t\t\t: Date.now();\n\n\t\t\tdiff = 0.001 * ( newTime - this.oldTime );\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n};\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nTHREE.EventDispatcher = function () {}\n\nTHREE.EventDispatcher.prototype = {\n\n\tconstructor: THREE.EventDispatcher,\n\n\tapply: function ( object ) {\n\n\t\tobject.addEventListener = THREE.EventDispatcher.prototype.addEventListener;\n\t\tobject.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;\n\t\tobject.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;\n\t\tobject.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\n\n\t},\n\n\taddEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t},\n\n\thasEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tremoveEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tdispatchEvent: function () {\n\n\t\tvar array = [];\n\n\t\treturn function ( event ) {\n\n\t\t\tif ( this._listeners === undefined ) return;\n\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ event.type ];\n\n\t\t\tif ( listenerArray !== undefined ) {\n\n\t\t\t\tevent.target = this;\n\n\t\t\t\tvar length = listenerArray.length;\n\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = listenerArray[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}()\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author bhouston / http://exocortex.com/\n * @author stephomi / http://stephaneginier.com/\n */\n\n( function ( THREE ) {\n\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\n\n\t\tthis.ray = new THREE.Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near || 0;\n\t\tthis.far = far || Infinity;\n\n\t};\n\n\tvar sphere = new THREE.Sphere();\n\tvar localRay = new THREE.Ray();\n\tvar facePlane = new THREE.Plane();\n\tvar intersectPoint = new THREE.Vector3();\n\tvar matrixPosition = new THREE.Vector3();\n\n\tvar inverseMatrix = new THREE.Matrix4();\n\n\tvar descSort = function ( a, b ) {\n\n\t\treturn a.distance - b.distance;\n\n\t};\n\n\tvar vA = new THREE.Vector3();\n\tvar vB = new THREE.Vector3();\n\tvar vC = new THREE.Vector3();\n\n\tvar intersectObject = function ( object, raycaster, intersects ) {\n\n\t\tif ( object instanceof THREE.Sprite ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( object.matrixWorld );\n\t\t\tvar distance = raycaster.ray.distanceToPoint( matrixPosition );\n\n\t\t\tif ( distance > object.scale.x ) {\n\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\tintersects.push( {\n\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: object.position,\n\t\t\t\tface: null,\n\t\t\t\tobject: object\n\n\t\t\t} );\n\n\t\t} else if ( object instanceof THREE.LOD ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( object.matrixWorld );\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n\t\t\tintersectObject( object.getObjectForDistance( distance ), raycaster, intersects );\n\n\t\t} else if ( object instanceof THREE.Mesh ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( object.matrixWorld );\n\n\t\t\tif ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\n\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\t// Check boundingBox before continuing\n\t\t\t\n\t\t\tinverseMatrix.getInverse( object.matrixWorld );  \n\t\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tif ( localRay.isIntersectionBox( geometry.boundingBox ) === false )  {\n\n\t\t\t\t\treturn intersects;\n\n\t\t\t\t}\n\n\t\t\t} \n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar material = object.material;\n\n\t\t\t\tif ( material === undefined ) return intersects;\n\t\t\t\tif ( geometry.dynamic === false ) return intersects;\n\n\t\t\t\tvar a, b, c;\n\t\t\t\tvar precision = raycaster.precision;\n\n\t\t\t\tif ( geometry.attributes.index !== undefined ) {\n\n\t\t\t\t\tvar offsets = geometry.offsets;\n\t\t\t\t\tvar indices = geometry.attributes.index.array;\n\t\t\t\t\tvar positions = geometry.attributes.position.array;\n\t\t\t\t\tvar offLength = geometry.offsets.length;\n\n\t\t\t\t\tvar fl = geometry.attributes.index.array.length / 3;\n\n\t\t\t\t\tfor ( var oi = 0; oi < offLength; ++oi ) {\n\n\t\t\t\t\t\tvar start = offsets[ oi ].start;\n\t\t\t\t\t\tvar count = offsets[ oi ].count;\n\t\t\t\t\t\tvar index = offsets[ oi ].index;\n\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\ta = index + indices[ i ];\n\t\t\t\t\t\t\tb = index + indices[ i + 1 ]; \n\t\t\t\t\t\t\tc = index + indices[ i + 2 ];\n\n\t\t\t\t\t\t\tvA.set(\n\t\t\t\t\t\t\t\tpositions[ a * 3 ],\n\t\t\t\t\t\t\t\tpositions[ a * 3 + 1 ],\n\t\t\t\t\t\t\t\tpositions[ a * 3 + 2 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tvB.set(\n\t\t\t\t\t\t\t\tpositions[ b * 3 ],\n\t\t\t\t\t\t\t\tpositions[ b * 3 + 1 ],\n\t\t\t\t\t\t\t\tpositions[ b * 3 + 2 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tvC.set(\n\t\t\t\t\t\t\t\tpositions[ c * 3 ],\n\t\t\t\t\t\t\t\tpositions[ c * 3 + 1 ],\n\t\t\t\t\t\t\t\tpositions[ c * 3 + 2 ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ( material.side === THREE.BackSide ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( vC, vB, vA, true ); \n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( intersectionPoint === null ) continue;\n\n\t\t\t\t\t\t\tintersectionPoint.applyMatrix4( object.matrixWorld );\n\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\n\n\t\t\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\tpoint: intersectionPoint,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar offsets = geometry.offsets;\n\t\t\t\t\tvar positions = geometry.attributes.position.array;\n\t\t\t\t\tvar offLength = geometry.offsets.length;\n\n\t\t\t\t\tvar fl = geometry.attributes.position.array.length;\n\n\t\t\t\t\tfor ( var i = 0; i < fl; i += 3 ) {\n\n\t\t\t\t\t\ta = i;\n\t\t\t\t\t\tb = i + 1;\n\t\t\t\t\t\tc = i + 2;\n\n\t\t\t\t\t\tvA.set(\n\t\t\t\t\t\t\tpositions[ a * 3 ],\n\t\t\t\t\t\t\tpositions[ a * 3 + 1 ],\n\t\t\t\t\t\t\tpositions[ a * 3 + 2 ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tvB.set(\n\t\t\t\t\t\t\tpositions[ b * 3 ],\n\t\t\t\t\t\t\tpositions[ b * 3 + 1 ],\n\t\t\t\t\t\t\tpositions[ b * 3 + 2 ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tvC.set(\n\t\t\t\t\t\t\tpositions[ c * 3 ],\n\t\t\t\t\t\t\tpositions[ c * 3 + 1 ],\n\t\t\t\t\t\t\tpositions[ c * 3 + 2 ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( material.side === THREE.BackSide ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( vC, vB, vA, true ); \n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( intersectionPoint === null ) continue;\n\n\t\t\t\t\t\tintersectionPoint.applyMatrix4( object.matrixWorld );\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\n\n\t\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\tpoint: intersectionPoint,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tvar isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\n\t\t\t\tvar objectMaterials = isFaceMaterial === true ? object.material.materials : null;\n\n\t\t\t\tvar a, b, c, d;\n\t\t\t\tvar precision = raycaster.precision;\n\n\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\tfor ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tvar face = geometry.faces[ f ];\n\n\t\t\t\t\tvar material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : object.material;\n\n\t\t\t\t\tif ( material === undefined ) continue;\n\n\t\t\t\t\ta = vertices[ face.a ];\n\t\t\t\t\tb = vertices[ face.b ];\n\t\t\t\t\tc = vertices[ face.c ];\n\n\t\t\t\t\tif ( material.morphTargets === true ) {\n\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\n\n\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\tvA.x += ( targets[ face.a ].x - a.x ) * influence;\n\t\t\t\t\t\t\tvA.y += ( targets[ face.a ].y - a.y ) * influence;\n\t\t\t\t\t\t\tvA.z += ( targets[ face.a ].z - a.z ) * influence;\n\n\t\t\t\t\t\t\tvB.x += ( targets[ face.b ].x - b.x ) * influence;\n\t\t\t\t\t\t\tvB.y += ( targets[ face.b ].y - b.y ) * influence;\n\t\t\t\t\t\t\tvB.z += ( targets[ face.b ].z - b.z ) * influence;\n\n\t\t\t\t\t\t\tvC.x += ( targets[ face.c ].x - c.x ) * influence;\n\t\t\t\t\t\t\tvC.y += ( targets[ face.c ].y - c.y ) * influence;\n\t\t\t\t\t\t\tvC.z += ( targets[ face.c ].z - c.z ) * influence;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvA.add( a );\n\t\t\t\t\t\tvB.add( b );\n\t\t\t\t\t\tvC.add( c );\n\n\t\t\t\t\t\ta = vA;\n\t\t\t\t\t\tb = vB;\n\t\t\t\t\t\tc = vC;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material.side === THREE.BackSide ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( c, b, a, true );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( intersectionPoint === null ) continue;\n\n\t\t\t\t\tintersectionPoint.applyMatrix4( object.matrixWorld );\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\n\n\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\tpoint: intersectionPoint,\n\t\t\t\t\t\tface: face,\n\t\t\t\t\t\tfaceIndex: f,\n\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tvar precision = raycaster.linePrecision;\n\t\t\tvar precisionSq = precision * precision;\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( object.matrixWorld );\n\t\t\t\n\t\t\tif ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\n\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\t\t\t\n\t\t\tinverseMatrix.getInverse( object.matrixWorld );\n\t\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t/* if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t} else */ if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar nbVertices = vertices.length;\n\t\t\t\tvar interSegment = new THREE.Vector3();\n\t\t\t\tvar interRay = new THREE.Vector3();\n\t\t\t\tvar step = object.type === THREE.LineStrip ? 1 : 2;\n\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i = i + step ) {\n\n\t\t\t\t\tvar distSq = localRay.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\tvar distance = localRay.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( object.matrixWorld ),\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tvar intersectDescendants = function ( object, raycaster, intersects ) {\n\n\t\tvar descendants = object.getDescendants();\n\n\t\tfor ( var i = 0, l = descendants.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( descendants[ i ], raycaster, intersects );\n\n\t\t}\n\t};\n\n\t//\n\n\tTHREE.Raycaster.prototype.precision = 0.0001;\n\tTHREE.Raycaster.prototype.linePrecision = 1;\n\n\tTHREE.Raycaster.prototype.set = function ( origin, direction ) {\n\n\t\tthis.ray.set( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t};\n\n\tTHREE.Raycaster.prototype.intersectObject = function ( object, recursive ) {\n\n\t\tvar intersects = [];\n\n\t\tif ( recursive === true ) {\n\n\t\t\tintersectDescendants( object, this, intersects );\n\n\t\t}\n\n\t\tintersectObject( object, this, intersects );\n\n\t\tintersects.sort( descSort );\n\n\t\treturn intersects;\n\n\t};\n\n\tTHREE.Raycaster.prototype.intersectObjects = function ( objects, recursive ) {\n\n\t\tvar intersects = [];\n\n\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( objects[ i ], this, intersects );\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tintersectDescendants( objects[ i ], this, intersects );\n\n\t\t\t}\n\n\t\t}\n\n\t\tintersects.sort( descSort );\n\n\t\treturn intersects;\n\n\t};\n\n}( THREE ) );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Object3D = function () {\n\n\tthis.id = THREE.Object3DIdCount ++;\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\n\tthis.parent = undefined;\n\tthis.children = [];\n\n\tthis.up = new THREE.Vector3( 0, 1, 0 );\n\n\tthis.position = new THREE.Vector3();\n\tthis._rotation = new THREE.Euler();\n\tthis._quaternion = new THREE.Quaternion();\n\tthis.scale = new THREE.Vector3( 1, 1, 1 );\n\n\t// keep rotation and quaternion in sync\n\n\tthis._rotation._quaternion = this.quaternion;\n\tthis._quaternion._euler = this.rotation;\n\n\tthis.renderDepth = null;\n\n\tthis.rotationAutoUpdate = true;\n\n\tthis.matrix = new THREE.Matrix4();\n\tthis.matrixWorld = new THREE.Matrix4();\n\n\tthis.matrixAutoUpdate = true;\n\tthis.matrixWorldNeedsUpdate = true;\n\n\tthis.visible = true;\n\n\tthis.castShadow = false;\n\tthis.receiveShadow = false;\n\n\tthis.frustumCulled = true;\n\n\tthis.userData = {};\n\n};\n\n\nTHREE.Object3D.prototype = {\n\n\tconstructor: THREE.Object3D,\n\t\n\tget rotation () { \n\t\treturn this._rotation; \n\t},\n\n\tset rotation ( value ) {\n\t\t\n\t\tthis._rotation = value;\n\t\tthis._rotation._quaternion = this._quaternion;\n\t\tthis._quaternion._euler = this._rotation;\n\t\tthis._rotation._updateQuaternion();\n\t\t\n\t},\n\n\tget quaternion () { \n\t\treturn this._quaternion; \n\t},\n\t\n\tset quaternion ( value ) {\n\t\t\n\t\tthis._quaternion = value;\n\t\tthis._quaternion._euler = this._rotation;\n\t\tthis._rotation._quaternion = this._quaternion;\n\t\tthis._quaternion._updateEuler();\n\t\t\n\t},\n\n\tget eulerOrder () {\n\n\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .eulerOrder has been moved to Object3D\\'s .rotation.order.' );\n\n\t\treturn this.rotation.order;\n\n\t},\n\n\tset eulerOrder ( value ) {\n\n\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .eulerOrder has been moved to Object3D\\'s .rotation.order.' );\n\n\t\tthis.rotation.order = value;\n\n\t},\n\n\tget useQuaternion () {\n\n\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .useQuaternion has been removed. The library now uses quaternions by default.' );\n\n\t},\n\n\tset useQuaternion ( value ) {\n\n\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .useQuaternion has been removed. The library now uses quaternions by default.' );\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t},\n\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t},\n\n\tsetRotationFromEuler: function ( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t},\n\n\tsetRotationFromMatrix: function ( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t},\n\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t},\n\n\trotateOnAxis: function() {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar q1 = new THREE.Quaternion();\n\n\t\treturn function ( axis, angle ) {\n\n\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\tthis.quaternion.multiply( q1 );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t}(),\n\n\trotateX: function () {\n\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\n\t\treturn function ( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\n\t\treturn function ( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\n\t\treturn function ( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\ttranslateOnAxis: function () {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( axis, distance ) {\n\n\t\t\tv1.copy( axis );\n\n\t\t\tv1.applyQuaternion( this.quaternion );\n\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t}(),\n\n\ttranslate: function ( distance, axis ) {\n\n\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.' );\n\t\treturn this.translateOnAxis( axis, distance );\n\n\t},\n\n\ttranslateX: function () {\n\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\n\t\treturn function ( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateY: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\n\t\treturn function ( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateZ: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\n\t\treturn function ( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\tlocalToWorld: function ( vector ) {\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t},\n\n\tworldToLocal: function () {\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function ( vector ) {\n\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function ( vector ) {\n\n\t\t\tm1.lookAt( vector, this.position, this.up );\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t};\n\n\t}(),\n\n\tadd: function ( object ) {\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D.add: An object can\\'t be added as a child of itself.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( object instanceof THREE.Object3D ) {\n\n\t\t\tif ( object.parent !== undefined ) {\n\n\t\t\t\tobject.parent.remove( object );\n\n\t\t\t}\n\n\t\t\tobject.parent = this;\n\t\t\tobject.dispatchEvent( { type: 'added' } );\n\n\t\t\tthis.children.push( object );\n\n\t\t\t// add to scene\n\n\t\t\tvar scene = this;\n\n\t\t\twhile ( scene.parent !== undefined ) {\n\n\t\t\t\tscene = scene.parent;\n\n\t\t\t}\n\n\t\t\tif ( scene !== undefined && scene instanceof THREE.Scene )  {\n\n\t\t\t\tscene.__addObject( object );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tremove: function ( object ) {\n\n\t\tvar index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = undefined;\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t\t// remove from scene\n\n\t\t\tvar scene = this;\n\n\t\t\twhile ( scene.parent !== undefined ) {\n\n\t\t\t\tscene = scene.parent;\n\n\t\t\t}\n\n\t\t\tif ( scene !== undefined && scene instanceof THREE.Scene ) {\n\n\t\t\t\tscene.__removeObject( object );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttraverse: function ( callback ) {\n\n\t\tcallback( this );\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].traverse( callback );\n\n\t\t}\n\n\t},\n\n\tgetObjectById: function ( id, recursive ) {\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\n\t\t\tif ( child.id === id ) {\n\n\t\t\t\treturn child;\n\n\t\t\t}\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tchild = child.getObjectById( id, recursive );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\treturn child;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t},\n\n\tgetObjectByName: function ( name, recursive ) {\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\n\t\t\tif ( child.name === name ) {\n\n\t\t\t\treturn child;\n\n\t\t\t}\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tchild = child.getObjectByName( name, recursive );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\treturn child;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t},\n\n\tgetChildByName: function ( name, recursive ) {\n\n\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .getChildByName() has been renamed to .getObjectByName().' );\n\t\treturn this.getObjectByName( name, recursive );\n\n\t},\n\n\tgetDescendants: function ( array ) {\n\n\t\tif ( array === undefined ) array = [];\n\n\t\tArray.prototype.push.apply( array, this.children );\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].getDescendants( array );\n\n\t\t}\n\n\t\treturn array;\n\n\t},\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\n\t\t\tif ( this.parent === undefined ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\n\n\t\t}\n\n\t},\n\n\tclone: function ( object, recursive ) {\n\n\t\tif ( object === undefined ) object = new THREE.Object3D();\n\t\tif ( recursive === undefined ) recursive = true;\n\n\t\tobject.name = this.name;\n\n\t\tobject.up.copy( this.up );\n\n\t\tobject.position.copy( this.position );\n\t\tobject.quaternion.copy( this.quaternion );\n\t\tobject.scale.copy( this.scale );\n\n\t\tobject.renderDepth = this.renderDepth;\n\n\t\tobject.rotationAutoUpdate = this.rotationAutoUpdate;\n\n\t\tobject.matrix.copy( this.matrix );\n\t\tobject.matrixWorld.copy( this.matrixWorld );\n\n\t\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\n\t\tobject.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\n\n\t\tobject.visible = this.visible;\n\n\t\tobject.castShadow = this.castShadow;\n\t\tobject.receiveShadow = this.receiveShadow;\n\n\t\tobject.frustumCulled = this.frustumCulled;\n\n\t\tobject.userData = JSON.parse( JSON.stringify( this.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tvar child = this.children[ i ];\n\t\t\t\tobject.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n};\n\nTHREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );\n\nTHREE.Object3DIdCount = 0;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author julianwa / https://github.com/julianwa\n */\n\nTHREE.Projector = function () {\n\n\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\n\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\n\t_face, _face3Count, _face3Pool = [], _face3PoolLength = 0,\n\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\n\t_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,\n\n\t_renderData = { objects: [], sprites: [], lights: [], elements: [] },\n\n\t_vA = new THREE.Vector3(),\n\t_vB = new THREE.Vector3(),\n\t_vC = new THREE.Vector3(),\n\n\t_vector3 = new THREE.Vector3(),\n\t_vector4 = new THREE.Vector4(),\n\n\t_clipBox = new THREE.Box3( new THREE.Vector3( -1, -1, -1 ), new THREE.Vector3( 1, 1, 1 ) ),\n\t_boundingBox = new THREE.Box3(),\n\t_points3 = new Array( 3 ),\n\t_points4 = new Array( 4 ),\n\n\t_viewMatrix = new THREE.Matrix4(),\n\t_viewProjectionMatrix = new THREE.Matrix4(),\n\n\t_modelMatrix,\n\t_modelViewProjectionMatrix = new THREE.Matrix4(),\n\n\t_normalMatrix = new THREE.Matrix3(),\n\t_normalViewMatrix = new THREE.Matrix3(),\n\n\t_centroid = new THREE.Vector3(),\n\n\t_frustum = new THREE.Frustum(),\n\n\t_clippedVertex1PositionScreen = new THREE.Vector4(),\n\t_clippedVertex2PositionScreen = new THREE.Vector4();\n\n\tthis.projectVector = function ( vector, camera ) {\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\n\t\treturn vector.applyProjection( _viewProjectionMatrix );\n\n\t};\n\n\tthis.unprojectVector = function () {\n\n\t\tvar projectionMatrixInverse = new THREE.Matrix4();\n\n\t\treturn function ( vector, camera ) {\n\n\t\t\tprojectionMatrixInverse.getInverse( camera.projectionMatrix );\n\t\t\t_viewProjectionMatrix.multiplyMatrices( camera.matrixWorld, projectionMatrixInverse );\n\n\t\t\treturn vector.applyProjection( _viewProjectionMatrix );\n\n\t\t};\n\n\t}();\n\n\tthis.pickingRay = function ( vector, camera ) {\n\n\t\t// set two vectors with opposing z values\n\t\tvector.z = -1.0;\n\t\tvar end = new THREE.Vector3( vector.x, vector.y, 1.0 );\n\n\t\tthis.unprojectVector( vector, camera );\n\t\tthis.unprojectVector( end, camera );\n\n\t\t// find direction from vector to end\n\t\tend.sub( vector ).normalize();\n\n\t\treturn new THREE.Raycaster( vector, end );\n\n\t};\n\n\tvar getObject = function ( object ) {\n\n\t\t_object = getNextObjectInPool();\n\t\t_object.id = object.id;\n\t\t_object.object = object;\n\n\t\tif ( object.renderDepth !== null ) {\n\n\t\t\t_object.z = object.renderDepth;\n\n\t\t} else {\n\n\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\n\t\t\t_object.z = _vector3.z;\n\n\t\t}\n\n\t\treturn _object;\n\n\t};\n\n\tvar projectVertex = function ( vertex ) {\n\n\t\tvar position = vertex.position;\n\t\tvar positionWorld = vertex.positionWorld;\n\t\tvar positionScreen = vertex.positionScreen;\n\n\t\tpositionWorld.copy( position ).applyMatrix4( _modelMatrix );\n\t\tpositionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );\n\n\t\tvar invW = 1 / positionScreen.w;\n\n\t\tpositionScreen.x *= invW;\n\t\tpositionScreen.y *= invW;\n\t\tpositionScreen.z *= invW;\n\n\t\tvertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 &&\n\t\t\t\t positionScreen.y >= -1 && positionScreen.y <= 1 &&\n\t\t\t\t positionScreen.z >= -1 && positionScreen.z <= 1;\n\n\t};\n\n\tvar projectObject = function ( object ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tif ( object instanceof THREE.Light ) {\n\n\t\t\t_renderData.lights.push( object );\n\n\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line ) {\n\n\t\t\tif ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\n\n\t\t\t\t_renderData.objects.push( getObject( object ) );\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t_renderData.sprites.push( getObject( object ) );\n\n\t\t}\n\n\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( object.children[ i ] );\n\n\t\t}\n\n\t};\n\n\tvar projectGraph = function ( root, sortObjects ) {\n\n\t\t_objectCount = 0;\n\n\t\t_renderData.objects.length = 0;\n\t\t_renderData.sprites.length = 0;\n\t\t_renderData.lights.length = 0;\n\n\t\tprojectObject( root );\n\n\t\tif ( sortObjects === true ) {\n\n\t\t\t_renderData.objects.sort( painterSort );\n\n\t\t}\n\n\t};\n\n\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\n\n\t\tvar visible = false,\n\t\tobject, geometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs,\n\t\tv1, v2, v3, v4, isFaceMaterial, objectMaterials;\n\n\t\t_face3Count = 0;\n\t\t_lineCount = 0;\n\t\t_spriteCount = 0;\n\n\t\t_renderData.elements.length = 0;\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\n\t\t_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\n\n\t\t_normalViewMatrix.getNormalMatrix( _viewMatrix );\n\n\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\n\n\t\tprojectGraph( scene, sortObjects );\n\n\t\tfor ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {\n\n\t\t\tobject = _renderData.objects[ o ].object;\n\n\t\t\t_modelMatrix = object.matrixWorld;\n\n\t\t\t_vertexCount = 0;\n\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t\tgeometry = object.geometry;\n\n\t\t\t\tvertices = geometry.vertices;\n\t\t\t\tfaces = geometry.faces;\n\t\t\t\tfaceVertexUvs = geometry.faceVertexUvs;\n\n\t\t\t\t_normalMatrix.getNormalMatrix( _modelMatrix );\n\n\t\t\t\tisFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\n\t\t\t\tobjectMaterials = isFaceMaterial === true ? object.material : null;\n\n\t\t\t\tfor ( var v = 0, vl = vertices.length; v < vl; v ++ ) {\n\n\t\t\t\t\t_vertex = getNextVertexInPool();\n\t\t\t\t\t_vertex.position.copy( vertices[ v ] );\n\n\t\t\t\t\tprojectVertex( _vertex );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = faces[ f ];\n\n\t\t\t\t\tvar material = isFaceMaterial === true\n\t\t\t\t\t\t? objectMaterials.materials[ face.materialIndex ]\n\t\t\t\t\t\t: object.material;\n\n\t\t\t\t\tif ( material === undefined ) continue;\n\n\t\t\t\t\tvar side = material.side;\n\n\t\t\t\t\tv1 = _vertexPool[ face.a ];\n\t\t\t\t\tv2 = _vertexPool[ face.b ];\n\t\t\t\t\tv3 = _vertexPool[ face.c ];\n\n\t\t\t\t\tif ( material.morphTargets === true ) {\n\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\n\n\t\t\t\t\t\tvar v1p = v1.position;\n\t\t\t\t\t\tvar v2p = v2.position;\n\t\t\t\t\t\tvar v3p = v3.position;\n\n\t\t\t\t\t\t_vA.set( 0, 0, 0 );\n\t\t\t\t\t\t_vB.set( 0, 0, 0 );\n\t\t\t\t\t\t_vC.set( 0, 0, 0 );\n\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\t_vA.x += ( targets[ face.a ].x - v1p.x ) * influence;\n\t\t\t\t\t\t\t_vA.y += ( targets[ face.a ].y - v1p.y ) * influence;\n\t\t\t\t\t\t\t_vA.z += ( targets[ face.a ].z - v1p.z ) * influence;\n\n\t\t\t\t\t\t\t_vB.x += ( targets[ face.b ].x - v2p.x ) * influence;\n\t\t\t\t\t\t\t_vB.y += ( targets[ face.b ].y - v2p.y ) * influence;\n\t\t\t\t\t\t\t_vB.z += ( targets[ face.b ].z - v2p.z ) * influence;\n\n\t\t\t\t\t\t\t_vC.x += ( targets[ face.c ].x - v3p.x ) * influence;\n\t\t\t\t\t\t\t_vC.y += ( targets[ face.c ].y - v3p.y ) * influence;\n\t\t\t\t\t\t\t_vC.z += ( targets[ face.c ].z - v3p.z ) * influence;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tv1.position.add( _vA );\n\t\t\t\t\t\tv2.position.add( _vB );\n\t\t\t\t\t\tv3.position.add( _vC );\n\n\t\t\t\t\t\tprojectVertex( v1 );\n\t\t\t\t\t\tprojectVertex( v2 );\n\t\t\t\t\t\tprojectVertex( v3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_points3[ 0 ] = v1.positionScreen;\n\t\t\t\t\t_points3[ 1 ] = v2.positionScreen;\n\t\t\t\t\t_points3[ 2 ] = v3.positionScreen;\n\n\t\t\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true ||\n\t\t\t\t\t\t_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) ) ) {\n\n\t\t\t\t\t\tvisible = ( ( v3.positionScreen.x - v1.positionScreen.x ) *\n\t\t\t\t\t\t\t    ( v2.positionScreen.y - v1.positionScreen.y ) -\n\t\t\t\t\t\t\t    ( v3.positionScreen.y - v1.positionScreen.y ) *\n\t\t\t\t\t\t\t    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\n\n\t\t\t\t\t\tif ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {\n\n\t\t\t\t\t\t\t_face = getNextFace3InPool();\n\n\t\t\t\t\t\t\t_face.id = object.id;\n\t\t\t\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t\t\t\t_face.v3.copy( v3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_face.normalModel.copy( face.normal );\n\n\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\n\t\t\t\t\t\t_face.normalModel.negate();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_face.normalModel.applyMatrix3( _normalMatrix ).normalize();\n\n\t\t\t\t\t_face.normalModelView.copy( _face.normalModel ).applyMatrix3( _normalViewMatrix );\n\n\t\t\t\t\t_face.centroidModel.copy( face.centroid ).applyMatrix4( _modelMatrix );\n\n\t\t\t\t\tfaceVertexNormals = face.vertexNormals;\n\n\t\t\t\t\tfor ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {\n\n\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[ n ];\n\t\t\t\t\t\tnormalModel.copy( faceVertexNormals[ n ] );\n\n\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\n\t\t\t\t\t\t\tnormalModel.negate();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormalModel.applyMatrix3( _normalMatrix ).normalize();\n\n\t\t\t\t\t\tvar normalModelView = _face.vertexNormalsModelView[ n ];\n\t\t\t\t\t\tnormalModelView.copy( normalModel ).applyMatrix3( _normalViewMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\n\n\t\t\t\t\tfor ( var c = 0, cl = Math.min( faceVertexUvs.length, 3 ); c < cl; c ++ ) {\n\n\t\t\t\t\t\tuvs = faceVertexUvs[ c ][ f ];\n\n\t\t\t\t\t\tif ( uvs === undefined ) continue;\n\n\t\t\t\t\t\tfor ( var u = 0, ul = uvs.length; u < ul; u ++ ) {\n\n\t\t\t\t\t\t\t_face.uvs[ c ][ u ] = uvs[ u ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_face.color = face.color;\n\t\t\t\t\t_face.material = material;\n\n\t\t\t\t\t_centroid.copy( _face.centroidModel ).applyProjection( _viewProjectionMatrix );\n\n\t\t\t\t\t_face.z = _centroid.z;\n\n\t\t\t\t\t_renderData.elements.push( _face );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\n\n\t\t\t\tvertices = object.geometry.vertices;\n\n\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );\n\n\t\t\t\t// Handle LineStrip and LinePieces\n\t\t\t\tvar step = object.type === THREE.LinePieces ? 2 : 1;\n\n\t\t\t\tfor ( v = 1, vl = vertices.length; v < vl; v ++ ) {\n\n\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );\n\n\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) continue;\n\n\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\n\n\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\n\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\n\n\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\n\n\t\t\t\t\t\t// Perform the perspective divide\n\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\n\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\n\n\t\t\t\t\t\t_line = getNextLineInPool();\n\n\t\t\t\t\t\t_line.id = object.id;\n\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\n\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\n\n\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\n\n\t\t\t\t\t\t_line.material = object.material;\n\n\t\t\t\t\t\tif ( object.material.vertexColors === THREE.VertexColors ) {\n\n\t\t\t\t\t\t\t_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );\n\t\t\t\t\t\t\t_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_renderData.elements.push( _line );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( o = 0, ol = _renderData.sprites.length; o < ol; o++ ) {\n\n\t\t\tobject = _renderData.sprites[ o ].object;\n\n\t\t\t_modelMatrix = object.matrixWorld;\n\n\t\t\t_vector4.set( _modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1 );\n\t\t\t_vector4.applyMatrix4( _viewProjectionMatrix );\n\n\t\t\tvar invW = 1 / _vector4.w;\n\n\t\t\t_vector4.z *= invW;\n\n\t\t\tif ( _vector4.z >= -1 && _vector4.z <= 1 ) {\n\n\t\t\t\t_sprite = getNextSpriteInPool();\n\t\t\t\t_sprite.id = object.id;\n\t\t\t\t_sprite.x = _vector4.x * invW;\n\t\t\t\t_sprite.y = _vector4.y * invW;\n\t\t\t\t_sprite.z = _vector4.z;\n\t\t\t\t_sprite.object = object;\n\n\t\t\t\t_sprite.rotation = object.rotation;\n\n\t\t\t\t_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[0] ) / ( _vector4.w + camera.projectionMatrix.elements[12] ) );\n\t\t\t\t_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[5] ) / ( _vector4.w + camera.projectionMatrix.elements[13] ) );\n\n\t\t\t\t_sprite.material = object.material;\n\n\t\t\t\t_renderData.elements.push( _sprite );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( sortElements === true ) _renderData.elements.sort( painterSort );\n\n\t\treturn _renderData;\n\n\t};\n\n\t// Pools\n\n\tfunction getNextObjectInPool() {\n\n\t\tif ( _objectCount === _objectPoolLength ) {\n\n\t\t\tvar object = new THREE.RenderableObject();\n\t\t\t_objectPool.push( object );\n\t\t\t_objectPoolLength ++;\n\t\t\t_objectCount ++;\n\t\t\treturn object;\n\n\t\t}\n\n\t\treturn _objectPool[ _objectCount ++ ];\n\n\t}\n\n\tfunction getNextVertexInPool() {\n\n\t\tif ( _vertexCount === _vertexPoolLength ) {\n\n\t\t\tvar vertex = new THREE.RenderableVertex();\n\t\t\t_vertexPool.push( vertex );\n\t\t\t_vertexPoolLength ++;\n\t\t\t_vertexCount ++;\n\t\t\treturn vertex;\n\n\t\t}\n\n\t\treturn _vertexPool[ _vertexCount ++ ];\n\n\t}\n\n\tfunction getNextFace3InPool() {\n\n\t\tif ( _face3Count === _face3PoolLength ) {\n\n\t\t\tvar face = new THREE.RenderableFace3();\n\t\t\t_face3Pool.push( face );\n\t\t\t_face3PoolLength ++;\n\t\t\t_face3Count ++;\n\t\t\treturn face;\n\n\t\t}\n\n\t\treturn _face3Pool[ _face3Count ++ ];\n\n\n\t}\n\n\tfunction getNextLineInPool() {\n\n\t\tif ( _lineCount === _linePoolLength ) {\n\n\t\t\tvar line = new THREE.RenderableLine();\n\t\t\t_linePool.push( line );\n\t\t\t_linePoolLength ++;\n\t\t\t_lineCount ++\n\t\t\treturn line;\n\n\t\t}\n\n\t\treturn _linePool[ _lineCount ++ ];\n\n\t}\n\n\tfunction getNextSpriteInPool() {\n\n\t\tif ( _spriteCount === _spritePoolLength ) {\n\n\t\t\tvar sprite = new THREE.RenderableSprite();\n\t\t\t_spritePool.push( sprite );\n\t\t\t_spritePoolLength ++;\n\t\t\t_spriteCount ++\n\t\t\treturn sprite;\n\n\t\t}\n\n\t\treturn _spritePool[ _spriteCount ++ ];\n\n\t}\n\n\t//\n\n\tfunction painterSort( a, b ) {\n\n\t\tif ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else if ( a.id !== b.id ) {\n\n\t\t\treturn a.id - b.id;\n\n\t\t} else {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\tfunction clipLine( s1, s2 ) {\n\n\t\tvar alpha1 = 0, alpha2 = 1,\n\n\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\n\t\t// Z = -1 and Z = +1, respectively.\n\t\tbc1near =  s1.z + s1.w,\n\t\tbc2near =  s2.z + s2.w,\n\t\tbc1far =  - s1.z + s1.w,\n\t\tbc2far =  - s2.z + s2.w;\n\n\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\n\n\t\t\t// Both vertices lie entirely within all clip planes.\n\t\t\treturn true;\n\n\t\t} else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {\n\n\t\t\t// Both vertices lie entirely outside one of the clip planes.\n\t\t\treturn false;\n\n\t\t} else {\n\n\t\t\t// The line segment spans at least one clip plane.\n\n\t\t\tif ( bc1near < 0 ) {\n\n\t\t\t\t// v1 lies outside the near plane, v2 inside\n\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\n\n\t\t\t} else if ( bc2near < 0 ) {\n\n\t\t\t\t// v2 lies outside the near plane, v1 inside\n\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\n\n\t\t\t}\n\n\t\t\tif ( bc1far < 0 ) {\n\n\t\t\t\t// v1 lies outside the far plane, v2 inside\n\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\n\n\t\t\t} else if ( bc2far < 0 ) {\n\n\t\t\t\t// v2 lies outside the far plane, v2 inside\n\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\n\n\t\t\t}\n\n\t\t\tif ( alpha2 < alpha1 ) {\n\n\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\n\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\n\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\n\t\t\t\treturn false;\n\n\t\t\t} else {\n\n\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\n\t\t\t\ts1.lerp( s2, alpha1 );\n\t\t\t\ts2.lerp( s1, 1 - alpha2 );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\n\n\tthis.a = a;\n\tthis.b = b;\n\tthis.c = c;\n\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n\tthis.vertexNormals = normal instanceof Array ? normal : [ ];\n\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\n\tthis.vertexColors = color instanceof Array ? color : [];\n\n\tthis.vertexTangents = [];\n\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n\tthis.centroid = new THREE.Vector3();\n\n};\n\nTHREE.Face3.prototype = {\n\n\tconstructor: THREE.Face3,\n\n\tclone: function () {\n\n\t\tvar face = new THREE.Face3( this.a, this.b, this.c );\n\n\t\tface.normal.copy( this.normal );\n\t\tface.color.copy( this.color );\n\t\tface.centroid.copy( this.centroid );\n\n\t\tface.materialIndex = this.materialIndex;\n\n\t\tvar i, il;\n\t\tfor ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\n\t\tfor ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();\n\t\tfor ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\n\n\t\treturn face;\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\n\n\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.')\n\n\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Geometry = function () {\n\n\tthis.id = THREE.GeometryIdCount ++;\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\n\tthis.vertices = [];\n\tthis.colors = [];  // one-to-one vertex colors, used in ParticleSystem and Line\n\n\tthis.faces = [];\n\n\tthis.faceVertexUvs = [[]];\n\n\tthis.morphTargets = [];\n\tthis.morphColors = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.hasTangents = false;\n\n\tthis.dynamic = true; // the intermediate typed arrays will be deleted when set to false\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.elementsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.tangentsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.lineDistancesNeedUpdate = false;\n\n\tthis.buffersNeedUpdate = false;\n\n};\n\nTHREE.Geometry.prototype = {\n\n\tconstructor: THREE.Geometry,\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tface.centroid.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tif ( this.boundingBox instanceof THREE.Box3 ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere instanceof THREE.Sphere ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t},\n\n\tcomputeCentroids: function () {\n\n\t\tvar f, fl, face;\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\t\t\tface.centroid.set( 0, 0, 0 );\n\n\t\t\tface.centroid.add( this.vertices[ face.a ] );\n\t\t\tface.centroid.add( this.vertices[ face.b ] );\n\t\t\tface.centroid.add( this.vertices[ face.c ] );\n\t\t\tface.centroid.divideScalar( 3 );\n\n\t\t}\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tvar face = this.faces[ f ];\n\n\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\tvar v, vl, f, fl, face, vertices;\n\n\t\tvertices = new Array( this.vertices.length );\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tvar vA, vB, vC, vD;\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3(),\n\t\t\t\tdb = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tface.vertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\tface.vertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\tface.vertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\tvar i, il, f, fl, face;\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tvar tmpGeo = new THREE.Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\n\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// tangents go to vertices\n\n\t\tvar f, fl, v, vl, i, il, vertexIndex,\n\t\t\tface, uv, vA, vB, vC, uvA, uvB, uvC,\n\t\t\tx1, x2, y1, y2, z1, z2,\n\t\t\ts1, s2, t1, t2, r, t, test,\n\t\t\ttan1 = [], tan2 = [],\n\t\t\tsdir = new THREE.Vector3(), tdir = new THREE.Vector3(),\n\t\t\ttmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),\n\t\t\tn = new THREE.Vector3(), w;\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\ttan1[ v ] = new THREE.Vector3();\n\t\t\ttan2[ v ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tfunction handleTriangle( context, a, b, c, ua, ub, uc ) {\n\n\t\t\tvA = context.vertices[ a ];\n\t\t\tvB = context.vertices[ b ];\n\t\t\tvC = context.vertices[ c ];\n\n\t\t\tuvA = uv[ ua ];\n\t\t\tuvB = uv[ ub ];\n\t\t\tuvC = uv[ uc ];\n\n\t\t\tx1 = vB.x - vA.x;\n\t\t\tx2 = vC.x - vA.x;\n\t\t\ty1 = vB.y - vA.y;\n\t\t\ty2 = vC.y - vA.y;\n\t\t\tz1 = vB.z - vA.z;\n\t\t\tz2 = vC.z - vA.z;\n\n\t\t\ts1 = uvB.x - uvA.x;\n\t\t\ts2 = uvC.x - uvA.x;\n\t\t\tt1 = uvB.y - uvA.y;\n\t\t\tt2 = uvC.y - uvA.y;\n\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\n\t\t\tsdir.set( ( t2 * x1 - t1 * x2 ) * r,\n\t\t\t\t\t  ( t2 * y1 - t1 * y2 ) * r,\n\t\t\t\t\t  ( t2 * z1 - t1 * z2 ) * r );\n\t\t\ttdir.set( ( s1 * x2 - s2 * x1 ) * r,\n\t\t\t\t\t  ( s1 * y2 - s2 * y1 ) * r,\n\t\t\t\t\t  ( s1 * z2 - s2 * z1 ) * r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\t\t\tuv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents\n\n\t\t\thandleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );\n\n\t\t}\n\n\t\tvar faceIndex = [ 'a', 'b', 'c', 'd' ];\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tfor ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i++ ) {\n\n\t\t\t\tn.copy( face.vertexNormals[ i ] );\n\n\t\t\t\tvertexIndex = face[ faceIndex[ i ] ];\n\n\t\t\t\tt = tan1[ vertexIndex ];\n\n\t\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\t\ttmp.copy( t );\n\t\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t\t// Calculate handedness\n\n\t\t\t\ttmp2.crossVectors( face.vertexNormals[ i ], t );\n\t\t\t\ttest = tmp2.dot( tan2[ vertexIndex ] );\n\t\t\t\tw = (test < 0.0) ? -1.0 : 1.0;\n\n\t\t\t\tface.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.hasTangents = true;\n\n\t},\n\n\tcomputeLineDistances: function ( ) {\n\n\t\tvar d = 0;\n\t\tvar vertices = this.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tif ( i > 0 ) {\n\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\n\t\t\t}\n\n\t\t\tthis.lineDistances[ i ] = d;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function () {\n\n\t\tvar verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)\n\t\tvar unique = [], changes = [];\n\n\t\tvar v, key;\n\t\tvar precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001\n\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\tvar i,il, face;\n\t\tvar indices, k, j, jl, u;\n\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tv = this.vertices[ i ];\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t};\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tvar faceIndicesToRemove = [];\n\n\t\tfor( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tface = this.faces[ i ];\n\n\t\t\tface.a = changes[ face.a ];\n\t\t\tface.b = changes[ face.b ];\n\t\t\tface.c = changes[ face.c ];\n\n\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\tvar dupIndex = -1;\n\n\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t// we have to remove the face as nothing can be saved\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\t\t\t\tif ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\tdupIndex = n;\n\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tvar diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tclone: function () {\n\n\t\tvar geometry = new THREE.Geometry();\n\n\t\tvar vertices = this.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tgeometry.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\tvar faces = this.faces;\n\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tgeometry.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\tvar uvs = this.faceVertexUvs[ 0 ];\n\n\t\tfor ( var i = 0, il = uvs.length; i < il; i ++ ) {\n\n\t\t\tvar uv = uvs[ i ], uvCopy = [];\n\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );\n\n\t\t\t}\n\n\t\t\tgeometry.faceVertexUvs[ 0 ].push( uvCopy );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nTHREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );\n\nTHREE.GeometryIdCount = 0;\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.BufferGeometry = function () {\n\n\tthis.id = THREE.GeometryIdCount ++;\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\n\t// attributes\n\n\tthis.attributes = {};\n\n\t// attributes typed arrays are kept only if dynamic flag is set\n\n\tthis.dynamic = true;\n\n\t// offsets for chunks when using indexed elements\n\n\tthis.offsets = [];\n\n\t// boundings\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.hasTangents = false;\n\n\t// for compatibility\n\n\tthis.morphTargets = [];\n\n};\n\nTHREE.BufferGeometry.prototype = {\n\n\tconstructor: THREE.BufferGeometry,\n\n\taddAttribute: function( name, type, numItems, itemSize ) {\n\n\t\tthis.attributes[ name ] = {\n\n\t\t\titemSize: itemSize,\n\t\t\tarray: new type( numItems * itemSize )\n\n\t\t};\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar positionArray;\n\t\tvar normalArray;\n\n\t\tif ( this.attributes[ \"position\" ] ) positionArray = this.attributes[ \"position\" ].array;\n\t\tif ( this.attributes[ \"normal\" ] ) normalArray = this.attributes[ \"normal\" ].array;\n\n\t\tif ( positionArray !== undefined ) {\n\n\t\t\tmatrix.multiplyVector3Array( positionArray );\n\t\t\tthis.verticesNeedUpdate = true;\n\n\t\t}\n\n\t\tif ( normalArray !== undefined ) {\n\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormalMatrix.multiplyVector3Array( normalArray );\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tvar positions = this.attributes[ \"position\" ].array;\n\n\t\tif ( positions ) {\n\n\t\t\tvar bb = this.boundingBox;\n\t\t\tvar x, y, z;\n\n\t\t\tif( positions.length >= 3 ) {\n\t\t\t\tbb.min.x = bb.max.x = positions[ 0 ];\n\t\t\t\tbb.min.y = bb.max.y = positions[ 1 ];\n\t\t\t\tbb.min.z = bb.max.z = positions[ 2 ];\n\t\t\t}\n\n\t\t\tfor ( var i = 3, il = positions.length; i < il; i += 3 ) {\n\n\t\t\t\tx = positions[ i ];\n\t\t\t\ty = positions[ i + 1 ];\n\t\t\t\tz = positions[ i + 2 ];\n\n\t\t\t\t// bounding box\n\n\t\t\t\tif ( x < bb.min.x ) {\n\n\t\t\t\t\tbb.min.x = x;\n\n\t\t\t\t} else if ( x > bb.max.x ) {\n\n\t\t\t\t\tbb.max.x = x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( y < bb.min.y ) {\n\n\t\t\t\t\tbb.min.y = y;\n\n\t\t\t\t} else if ( y > bb.max.y ) {\n\n\t\t\t\t\tbb.max.y = y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( z < bb.min.z ) {\n\n\t\t\t\t\tbb.min.z = z;\n\n\t\t\t\t} else if ( z > bb.max.z ) {\n\n\t\t\t\t\tbb.max.z = z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( positions === undefined || positions.length === 0 ) {\n\n\t\t\tthis.boundingBox.min.set( 0, 0, 0 );\n\t\t\tthis.boundingBox.max.set( 0, 0, 0 );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tvar box = new THREE.Box3();\n\t\tvar vector = new THREE.Vector3();\n\n\t\treturn function () {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t\t}\n\n\t\t\tvar positions = this.attributes[ \"position\" ].array;\n\n\t\t\tif ( positions ) {\n\n\t\t\t\tbox.makeEmpty();\n\n\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\n\n\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\t\t\t\t\tbox.addPoint( vector );\n\n\t\t\t\t}\n\n\t\t\t\tbox.center( center );\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\n\n\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t}\n\n\t\t}\n\n\t}(),\n\n\tcomputeVertexNormals: function () {\n\n\t\tif ( this.attributes[ \"position\" ] ) {\n\n\t\t\tvar i, il;\n\t\t\tvar j, jl;\n\n\t\t\tvar nVertexElements = this.attributes[ \"position\" ].array.length;\n\n\t\t\tif ( this.attributes[ \"normal\" ] === undefined ) {\n\n\t\t\t\tthis.attributes[ \"normal\" ] = {\n\n\t\t\t\t\titemSize: 3,\n\t\t\t\t\tarray: new Float32Array( nVertexElements )\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( i = 0, il = this.attributes[ \"normal\" ].array.length; i < il; i ++ ) {\n\n\t\t\t\t\tthis.attributes[ \"normal\" ].array[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar positions = this.attributes[ \"position\" ].array;\n\t\t\tvar normals = this.attributes[ \"normal\" ].array;\n\n\t\t\tvar vA, vB, vC, x, y, z,\n\n\t\t\tpA = new THREE.Vector3(),\n\t\t\tpB = new THREE.Vector3(),\n\t\t\tpC = new THREE.Vector3(),\n\n\t\t\tcb = new THREE.Vector3(),\n\t\t\tab = new THREE.Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( this.attributes[ \"index\" ] ) {\n\n\t\t\t\tvar indices = this.attributes[ \"index\" ].array;\n\n\t\t\t\tvar offsets = this.offsets;\n\n\t\t\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\n\n\t\t\t\t\tvar start = offsets[ j ].start;\n\t\t\t\t\tvar count = offsets[ j ].count;\n\t\t\t\t\tvar index = offsets[ j ].index;\n\n\t\t\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\tvA = index + indices[ i ];\n\t\t\t\t\t\tvB = index + indices[ i + 1 ];\n\t\t\t\t\t\tvC = index + indices[ i + 2 ];\n\n\t\t\t\t\t\tx = positions[ vA * 3 ];\n\t\t\t\t\t\ty = positions[ vA * 3 + 1 ];\n\t\t\t\t\t\tz = positions[ vA * 3 + 2 ];\n\t\t\t\t\t\tpA.set( x, y, z );\n\n\t\t\t\t\t\tx = positions[ vB * 3 ];\n\t\t\t\t\t\ty = positions[ vB * 3 + 1 ];\n\t\t\t\t\t\tz = positions[ vB * 3 + 2 ];\n\t\t\t\t\t\tpB.set( x, y, z );\n\n\t\t\t\t\t\tx = positions[ vC * 3 ];\n\t\t\t\t\t\ty = positions[ vC * 3 + 1 ];\n\t\t\t\t\t\tz = positions[ vC * 3 + 2 ];\n\t\t\t\t\t\tpC.set( x, y, z );\n\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\tnormals[ vA * 3 ]     += cb.x;\n\t\t\t\t\t\tnormals[ vA * 3 + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vA * 3 + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vB * 3 ]     += cb.x;\n\t\t\t\t\t\tnormals[ vB * 3 + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vB * 3 + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vC * 3 ]     += cb.x;\n\t\t\t\t\t\tnormals[ vC * 3 + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vC * 3 + 2 ] += cb.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t} else {\n\n\t\t\t\tfor ( i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\tx = positions[ i ];\n\t\t\t\t\ty = positions[ i + 1 ];\n\t\t\t\t\tz = positions[ i + 2 ];\n\t\t\t\t\tpA.set( x, y, z );\n\n\t\t\t\t\tx = positions[ i + 3 ];\n\t\t\t\t\ty = positions[ i + 4 ];\n\t\t\t\t\tz = positions[ i + 5 ];\n\t\t\t\t\tpB.set( x, y, z );\n\n\t\t\t\t\tx = positions[ i + 6 ];\n\t\t\t\t\ty = positions[ i + 7 ];\n\t\t\t\t\tz = positions[ i + 8 ];\n\t\t\t\t\tpC.set( x, y, z );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ i ] \t = cb.x;\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tnormalizeNormals: function () {\n\n\t\tvar normals = this.attributes[ \"normal\" ].array;\n\n\t\tvar x, y, z, n;\n\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\n\t\t\tx = normals[ i ];\n\t\t\ty = normals[ i + 1 ];\n\t\t\tz = normals[ i + 2 ];\n\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\n\t\t\tnormals[ i ] \t *= n;\n\t\t\tnormals[ i + 1 ] *= n;\n\t\t\tnormals[ i + 2 ] *= n;\n\n\t\t}\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( this.attributes[ \"index\" ] === undefined ||\n\t\t\t this.attributes[ \"position\" ] === undefined ||\n\t\t\t this.attributes[ \"normal\" ] === undefined ||\n\t\t\t this.attributes[ \"uv\" ] === undefined ) {\n\n\t\t\tconsole.warn( \"Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()\" );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar indices = this.attributes[ \"index\" ].array;\n\t\tvar positions = this.attributes[ \"position\" ].array;\n\t\tvar normals = this.attributes[ \"normal\" ].array;\n\t\tvar uvs = this.attributes[ \"uv\" ].array;\n\n\t\tvar nVertices = positions.length / 3;\n\n\t\tif ( this.attributes[ \"tangent\" ] === undefined ) {\n\n\t\t\tvar nTangentElements = 4 * nVertices;\n\n\t\t\tthis.attributes[ \"tangent\" ] = {\n\n\t\t\t\titemSize: 4,\n\t\t\t\tarray: new Float32Array( nTangentElements )\n\n\t\t\t};\n\n\t\t}\n\n\t\tvar tangents = this.attributes[ \"tangent\" ].array;\n\n\t\tvar tan1 = [], tan2 = [];\n\n\t\tfor ( var k = 0; k < nVertices; k ++ ) {\n\n\t\t\ttan1[ k ] = new THREE.Vector3();\n\t\t\ttan2[ k ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tvar xA, yA, zA,\n\t\t\txB, yB, zB,\n\t\t\txC, yC, zC,\n\n\t\t\tuA, vA,\n\t\t\tuB, vB,\n\t\t\tuC, vC,\n\n\t\t\tx1, x2, y1, y2, z1, z2,\n\t\t\ts1, s2, t1, t2, r;\n\n\t\tvar sdir = new THREE.Vector3(), tdir = new THREE.Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\txA = positions[ a * 3 ];\n\t\t\tyA = positions[ a * 3 + 1 ];\n\t\t\tzA = positions[ a * 3 + 2 ];\n\n\t\t\txB = positions[ b * 3 ];\n\t\t\tyB = positions[ b * 3 + 1 ];\n\t\t\tzB = positions[ b * 3 + 2 ];\n\n\t\t\txC = positions[ c * 3 ];\n\t\t\tyC = positions[ c * 3 + 1 ];\n\t\t\tzC = positions[ c * 3 + 2 ];\n\n\t\t\tuA = uvs[ a * 2 ];\n\t\t\tvA = uvs[ a * 2 + 1 ];\n\n\t\t\tuB = uvs[ b * 2 ];\n\t\t\tvB = uvs[ b * 2 + 1 ];\n\n\t\t\tuC = uvs[ c * 2 ];\n\t\t\tvC = uvs[ c * 2 + 1 ];\n\n\t\t\tx1 = xB - xA;\n\t\t\tx2 = xC - xA;\n\n\t\t\ty1 = yB - yA;\n\t\t\ty2 = yC - yA;\n\n\t\t\tz1 = zB - zA;\n\t\t\tz2 = zC - zA;\n\n\t\t\ts1 = uB - uA;\n\t\t\ts2 = uC - uA;\n\n\t\t\tt1 = vB - vA;\n\t\t\tt2 = vC - vA;\n\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\n\n\t\t\tsdir.set(\n\t\t\t\t( t2 * x1 - t1 * x2 ) * r,\n\t\t\t\t( t2 * y1 - t1 * y2 ) * r,\n\t\t\t\t( t2 * z1 - t1 * z2 ) * r\n\t\t\t);\n\n\t\t\ttdir.set(\n\t\t\t\t( s1 * x2 - s2 * x1 ) * r,\n\t\t\t\t( s1 * y2 - s2 * y1 ) * r,\n\t\t\t\t( s1 * z2 - s2 * z1 ) * r\n\t\t\t);\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tvar i, il;\n\t\tvar j, jl;\n\t\tvar iA, iB, iC;\n\n\t\tvar offsets = this.offsets;\n\n\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\n\n\t\t\tvar start = offsets[ j ].start;\n\t\t\tvar count = offsets[ j ].count;\n\t\t\tvar index = offsets[ j ].index;\n\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\tiA = index + indices[ i ];\n\t\t\t\tiB = index + indices[ i + 1 ];\n\t\t\t\tiC = index + indices[ i + 2 ];\n\n\t\t\t\thandleTriangle( iA, iB, iC );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();\n\t\tvar n = new THREE.Vector3(), n2 = new THREE.Vector3();\n\t\tvar w, t, test;\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.x = normals[ v * 3 ];\n\t\t\tn.y = normals[ v * 3 + 1 ];\n\t\t\tn.z = normals[ v * 3 + 2 ];\n\n\t\t\tn2.copy( n );\n\n\t\t\tt = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\ttest = tmp2.dot( tan2[ v ] );\n\t\t\tw = ( test < 0.0 ) ? -1.0 : 1.0;\n\n\t\t\ttangents[ v * 4 ]     = tmp.x;\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\n\t\t\ttangents[ v * 4 + 3 ] = w;\n\n\t\t}\n\n\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\n\n\t\t\tvar start = offsets[ j ].start;\n\t\t\tvar count = offsets[ j ].count;\n\t\t\tvar index = offsets[ j ].index;\n\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\tiA = index + indices[ i ];\n\t\t\t\tiB = index + indices[ i + 1 ];\n\t\t\t\tiC = index + indices[ i + 2 ];\n\n\t\t\t\thandleVertex( iA );\n\t\t\t\thandleVertex( iB );\n\t\t\t\thandleVertex( iC );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.hasTangents = true;\n\t\tthis.tangentsNeedUpdate = true;\n\n\t},\n\n\tclone: function () {\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\tvar types = [ Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];\n\n\t\tfor ( var attr in this.attributes ) {\n\n\t\t\tvar sourceAttr = this.attributes[ attr ];\n\t\t\tvar sourceArray = sourceAttr.array;\n\n\t\t\tvar attribute = {\n\n\t\t\t\titemSize: sourceAttr.itemSize,\n\t\t\t\tnumItems: sourceAttr.numItems,\n\t\t\t\tarray: null\n\n\t\t\t};\n\n\t\t\tfor ( var i = 0, il = types.length; i < il; i ++ ) {\n\n\t\t\t\tvar type = types[ i ];\n\n\t\t\t\tif ( sourceArray instanceof type ) {\n\n\t\t\t\t\tattribute.array = new type( sourceArray );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.attributes[ attr ] = attribute;\n\n\t\t}\n\n\t\tfor ( var i = 0, il = this.offsets.length; i < il; i ++ ) {\n\n\t\t\tvar offset = this.offsets[ i ];\n\n\t\t\tgeometry.offsets.push( {\n\n\t\t\t\tstart: offset.start,\n\t\t\t\tindex: offset.index,\n\t\t\t\tcount: offset.count\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nTHREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.Camera = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.matrixWorldInverse = new THREE.Matrix4();\n\tthis.projectionMatrix = new THREE.Matrix4();\n\n};\n\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Camera.prototype.lookAt = function () {\n\n\t// This routine does not support cameras with rotated and/or translated parent(s)\n\n\tvar m1 = new THREE.Matrix4();\n\n\treturn function ( vector ) {\n\n\t\tm1.lookAt( this.position, vector, this.up );\n\n\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t};\n\n}();\n\nTHREE.Camera.prototype.clone = function (camera) {\n\n\tif ( camera === undefined ) camera = new THREE.Camera();\n\n\tTHREE.Object3D.prototype.clone.call( this, camera );\n\n\tcamera.matrixWorldInverse.copy( this.matrixWorldInverse );\n\tcamera.projectionMatrix.copy( this.projectionMatrix );\n\n\treturn camera;\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.left = left;\n\tthis.right = right;\n\tthis.top = top;\n\tthis.bottom = bottom;\n\n\tthis.near = ( near !== undefined ) ? near : 0.1;\n\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\n\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\n\n\tthis.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );\n\n};\n\nTHREE.OrthographicCamera.prototype.clone = function () {\n\n\tvar camera = new THREE.OrthographicCamera();\n\n\tTHREE.Camera.prototype.clone.call( this, camera );\n\n\tcamera.left = this.left;\n\tcamera.right = this.right;\n\tcamera.top = this.top;\n\tcamera.bottom = this.bottom;\n\t\n\tcamera.near = this.near;\n\tcamera.far = this.far;\n\n\treturn camera;\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author greggman / http://games.greggman.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.fov = fov !== undefined ? fov : 50;\n\tthis.aspect = aspect !== undefined ? aspect : 1;\n\tthis.near = near !== undefined ? near : 0.1;\n\tthis.far = far !== undefined ? far : 2000;\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\n\n\n/**\n * Uses Focal Length (in mm) to estimate and set FOV\n * 35mm (fullframe) camera is used if frame size is not specified;\n * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\n */\n\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\n\n\tif ( frameHeight === undefined ) frameHeight = 24;\n\n\tthis.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\n\tthis.updateProjectionMatrix();\n\n}\n\n\n/**\n * Sets an offset in a larger frustum. This is useful for multi-window or\n * multi-monitor/multi-machine setups.\n *\n * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n * the monitors are in grid like this\n *\n *   +---+---+---+\n *   | A | B | C |\n *   +---+---+---+\n *   | D | E | F |\n *   +---+---+---+\n *\n * then for each monitor you would call it like this\n *\n *   var w = 1920;\n *   var h = 1080;\n *   var fullWidth = w * 3;\n *   var fullHeight = h * 2;\n *\n *   --A--\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n *   --B--\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n *   --C--\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n *   --D--\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n *   --E--\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n *   --F--\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n *\n *   Note there is no reason monitors have to be the same size or in a grid.\n */\n\nTHREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\tthis.fullWidth = fullWidth;\n\tthis.fullHeight = fullHeight;\n\tthis.x = x;\n\tthis.y = y;\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.updateProjectionMatrix();\n\n};\n\n\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\n\n\tif ( this.fullWidth ) {\n\n\t\tvar aspect = this.fullWidth / this.fullHeight;\n\t\tvar top = Math.tan( THREE.Math.degToRad( this.fov * 0.5 ) ) * this.near;\n\t\tvar bottom = -top;\n\t\tvar left = aspect * bottom;\n\t\tvar right = aspect * top;\n\t\tvar width = Math.abs( right - left );\n\t\tvar height = Math.abs( top - bottom );\n\n\t\tthis.projectionMatrix.makeFrustum(\n\t\t\tleft + this.x * width / this.fullWidth,\n\t\t\tleft + ( this.x + this.width ) * width / this.fullWidth,\n\t\t\ttop - ( this.y + this.height ) * height / this.fullHeight,\n\t\t\ttop - this.y * height / this.fullHeight,\n\t\t\tthis.near,\n\t\t\tthis.far\n\t\t);\n\n\t} else {\n\n\t\tthis.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far );\n\n\t}\n\n};\n\nTHREE.PerspectiveCamera.prototype.clone = function () {\n\n\tvar camera = new THREE.PerspectiveCamera();\n\n\tTHREE.Camera.prototype.clone.call( this, camera );\n\n\tcamera.fov = this.fov;\n\tcamera.aspect = this.aspect;\n\tcamera.near = this.near;\n\tcamera.far = this.far;\n\n\treturn camera;\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n \nTHREE.Light = function ( hex ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.color = new THREE.Color( hex );\n\n};\n\nTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Light.prototype.clone = function ( light ) {\n\n\tif ( light === undefined ) light = new THREE.Light();\n\n\tTHREE.Object3D.prototype.clone.call( this, light );\n\n\tlight.color.copy( this.color );\n\n\treturn light;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AmbientLight = function ( hex ) {\n\n\tTHREE.Light.call( this, hex );\n\n};\n\nTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\n\nTHREE.AmbientLight.prototype.clone = function () {\n\n\tvar light = new THREE.AmbientLight();\n\n\tTHREE.Light.prototype.clone.call( this, light );\n\n\treturn light;\n\n};\n\n/**\n * @author MPanknin / http://www.redplant.de/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.AreaLight = function ( hex, intensity ) {\n\n\tTHREE.Light.call( this, hex );\n\n\tthis.normal = new THREE.Vector3( 0, -1, 0 );\n\tthis.right = new THREE.Vector3( 1, 0, 0 );\n\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\n\tthis.width = 1.0;\n\tthis.height = 1.0;\n\n\tthis.constantAttenuation = 1.5;\n\tthis.linearAttenuation = 0.5;\n\tthis.quadraticAttenuation = 0.1;\n\n};\n\nTHREE.AreaLight.prototype = Object.create( THREE.Light.prototype );\n\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DirectionalLight = function ( hex, intensity ) {\n\n\tTHREE.Light.call( this, hex );\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.target = new THREE.Object3D();\n\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\n\tthis.castShadow = false;\n\tthis.onlyShadow = false;\n\n\t//\n\n\tthis.shadowCameraNear = 50;\n\tthis.shadowCameraFar = 5000;\n\n\tthis.shadowCameraLeft = -500;\n\tthis.shadowCameraRight = 500;\n\tthis.shadowCameraTop = 500;\n\tthis.shadowCameraBottom = -500;\n\n\tthis.shadowCameraVisible = false;\n\n\tthis.shadowBias = 0;\n\tthis.shadowDarkness = 0.5;\n\n\tthis.shadowMapWidth = 512;\n\tthis.shadowMapHeight = 512;\n\n\t//\n\n\tthis.shadowCascade = false;\n\n\tthis.shadowCascadeOffset = new THREE.Vector3( 0, 0, -1000 );\n\tthis.shadowCascadeCount = 2;\n\n\tthis.shadowCascadeBias = [ 0, 0, 0 ];\n\tthis.shadowCascadeWidth = [ 512, 512, 512 ];\n\tthis.shadowCascadeHeight = [ 512, 512, 512 ];\n\n\tthis.shadowCascadeNearZ = [ -1.000, 0.990, 0.998 ];\n\tthis.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];\n\n\tthis.shadowCascadeArray = [];\n\n\t//\n\n\tthis.shadowMap = null;\n\tthis.shadowMapSize = null;\n\tthis.shadowCamera = null;\n\tthis.shadowMatrix = null;\n\n};\n\nTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\n\nTHREE.DirectionalLight.prototype.clone = function () {\n\n\tvar light = new THREE.DirectionalLight();\n\n\tTHREE.Light.prototype.clone.call( this, light );\n\n\tlight.target = this.target.clone();\n\n\tlight.intensity = this.intensity;\n\n\tlight.castShadow = this.castShadow;\n\tlight.onlyShadow = this.onlyShadow;\n\n\treturn light;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.HemisphereLight = function ( skyColorHex, groundColorHex, intensity ) {\n\n\tTHREE.Light.call( this, skyColorHex );\n\n\tthis.position.set( 0, 100, 0 );\n\n\tthis.groundColor = new THREE.Color( groundColorHex );\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\n};\n\nTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\n\nTHREE.HemisphereLight.prototype.clone = function () {\n\n\tvar light = new THREE.HemisphereLight();\n\n\tTHREE.Light.prototype.clone.call( this, light );\n\n\tlight.groundColor.copy( this.groundColor );\n\tlight.intensity = this.intensity;\n\n\treturn light;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PointLight = function ( hex, intensity, distance ) {\n\n\tTHREE.Light.call( this, hex );\n\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\n};\n\nTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\n\nTHREE.PointLight.prototype.clone = function () {\n\n\tvar light = new THREE.PointLight();\n\n\tTHREE.Light.prototype.clone.call( this, light );\n\n\tlight.intensity = this.intensity;\n\tlight.distance = this.distance;\n\n\treturn light;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpotLight = function ( hex, intensity, distance, angle, exponent ) {\n\n\tTHREE.Light.call( this, hex );\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.target = new THREE.Object3D();\n\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\tthis.exponent = ( exponent !== undefined ) ? exponent : 10;\n\n\tthis.castShadow = false;\n\tthis.onlyShadow = false;\n\n\t//\n\n\tthis.shadowCameraNear = 50;\n\tthis.shadowCameraFar = 5000;\n\tthis.shadowCameraFov = 50;\n\n\tthis.shadowCameraVisible = false;\n\n\tthis.shadowBias = 0;\n\tthis.shadowDarkness = 0.5;\n\n\tthis.shadowMapWidth = 512;\n\tthis.shadowMapHeight = 512;\n\n\t//\n\n\tthis.shadowMap = null;\n\tthis.shadowMapSize = null;\n\tthis.shadowCamera = null;\n\tthis.shadowMatrix = null;\n\n};\n\nTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\n\nTHREE.SpotLight.prototype.clone = function () {\n\n\tvar light = new THREE.SpotLight();\n\n\tTHREE.Light.prototype.clone.call( this, light );\n\n\tlight.target = this.target.clone();\n\n\tlight.intensity = this.intensity;\n\tlight.distance = this.distance;\n\tlight.angle = this.angle;\n\tlight.exponent = this.exponent;\n\n\tlight.castShadow = this.castShadow;\n\tlight.onlyShadow = this.onlyShadow;\n\n\treturn light;\n\n};\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Loader = function ( showStatus ) {\r\n\r\n\tthis.showStatus = showStatus;\r\n\tthis.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;\r\n\r\n\tthis.onLoadStart = function () {};\r\n\tthis.onLoadProgress = function () {};\r\n\tthis.onLoadComplete = function () {};\r\n\r\n};\r\n\r\nTHREE.Loader.prototype = {\r\n\r\n\tconstructor: THREE.Loader,\r\n\r\n\tcrossOrigin: undefined,\r\n\r\n\taddStatusElement: function () {\r\n\r\n\t\tvar e = document.createElement( \"div\" );\r\n\r\n\t\te.style.position = \"absolute\";\r\n\t\te.style.right = \"0px\";\r\n\t\te.style.top = \"0px\";\r\n\t\te.style.fontSize = \"0.8em\";\r\n\t\te.style.textAlign = \"left\";\r\n\t\te.style.background = \"rgba(0,0,0,0.25)\";\r\n\t\te.style.color = \"#fff\";\r\n\t\te.style.width = \"120px\";\r\n\t\te.style.padding = \"0.5em 0.5em 0.5em 0.5em\";\r\n\t\te.style.zIndex = 1000;\r\n\r\n\t\te.innerHTML = \"Loading ...\";\r\n\r\n\t\treturn e;\r\n\r\n\t},\r\n\r\n\tupdateProgress: function ( progress ) {\r\n\r\n\t\tvar message = \"Loaded \";\r\n\r\n\t\tif ( progress.total ) {\r\n\r\n\t\t\tmessage += ( 100 * progress.loaded / progress.total ).toFixed(0) + \"%\";\r\n\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmessage += ( progress.loaded / 1000 ).toFixed(2) + \" KB\";\r\n\r\n\t\t}\r\n\r\n\t\tthis.statusDomElement.innerHTML = message;\r\n\r\n\t},\r\n\r\n\textractUrlBase: function ( url ) {\r\n\r\n\t\tvar parts = url.split( '/' );\r\n\t\tparts.pop();\r\n\t\treturn ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';\r\n\r\n\t},\r\n\r\n\tinitMaterials: function ( materials, texturePath ) {\r\n\r\n\t\tvar array = [];\r\n\r\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\r\n\r\n\t\t\tarray[ i ] = THREE.Loader.prototype.createMaterial( materials[ i ], texturePath );\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tneedsTangents: function ( materials ) {\r\n\r\n\t\tfor( var i = 0, il = materials.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar m = materials[ i ];\r\n\r\n\t\t\tif ( m instanceof THREE.ShaderMaterial ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tcreateMaterial: function ( m, texturePath ) {\r\n\r\n\t\tvar _this = this;\r\n\r\n\t\tfunction is_pow2( n ) {\r\n\r\n\t\t\tvar l = Math.log( n ) / Math.LN2;\r\n\t\t\treturn Math.floor( l ) == l;\r\n\r\n\t\t}\r\n\r\n\t\tfunction nearest_pow2( n ) {\r\n\r\n\t\t\tvar l = Math.log( n ) / Math.LN2;\r\n\t\t\treturn Math.pow( 2, Math.round(  l ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction load_image( where, url ) {\r\n\r\n\t\t\tvar image = new Image();\r\n\r\n\t\t\timage.onload = function () {\r\n\r\n\t\t\t\tif ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {\r\n\r\n\t\t\t\t\tvar width = nearest_pow2( this.width );\r\n\t\t\t\t\tvar height = nearest_pow2( this.height );\r\n\r\n\t\t\t\t\twhere.image.width = width;\r\n\t\t\t\t\twhere.image.height = height;\r\n\t\t\t\t\twhere.image.getContext( '2d' ).drawImage( this, 0, 0, width, height );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\twhere.image = this;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhere.needsUpdate = true;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tif ( _this.crossOrigin !== undefined ) image.crossOrigin = _this.crossOrigin;\r\n\t\t\timage.src = url;\r\n\r\n\t\t}\r\n\r\n\t\tfunction create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {\r\n\r\n\t\t\tvar isCompressed = /\\.dds$/i.test( sourceFile );\r\n\t\t\tvar fullPath = texturePath + \"/\" + sourceFile;\r\n\r\n\t\t\tif ( isCompressed ) {\r\n\r\n\t\t\t\tvar texture = THREE.ImageUtils.loadCompressedTexture( fullPath );\r\n\r\n\t\t\t\twhere[ name ] = texture;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar texture = document.createElement( 'canvas' );\r\n\r\n\t\t\t\twhere[ name ] = new THREE.Texture( texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhere[ name ].sourceFile = sourceFile;\r\n\r\n\t\t\tif( repeat ) {\r\n\r\n\t\t\t\twhere[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );\r\n\r\n\t\t\t\tif ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = THREE.RepeatWrapping;\r\n\t\t\t\tif ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = THREE.RepeatWrapping;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset ) {\r\n\r\n\t\t\t\twhere[ name ].offset.set( offset[ 0 ], offset[ 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( wrap ) {\r\n\r\n\t\t\t\tvar wrapMap = {\r\n\t\t\t\t\t\"repeat\": THREE.RepeatWrapping,\r\n\t\t\t\t\t\"mirror\": THREE.MirroredRepeatWrapping\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];\r\n\t\t\t\tif ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( anisotropy ) {\r\n\r\n\t\t\t\twhere[ name ].anisotropy = anisotropy;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! isCompressed ) {\r\n\r\n\t\t\t\tload_image( where[ name ], fullPath );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction rgb2hex( rgb ) {\r\n\r\n\t\t\treturn ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;\r\n\r\n\t\t}\r\n\r\n\t\t// defaults\r\n\r\n\t\tvar mtype = \"MeshLambertMaterial\";\r\n\t\tvar mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };\r\n\r\n\t\t// parameters from model file\r\n\r\n\t\tif ( m.shading ) {\r\n\r\n\t\t\tvar shading = m.shading.toLowerCase();\r\n\r\n\t\t\tif ( shading === \"phong\" ) mtype = \"MeshPhongMaterial\";\r\n\t\t\telse if ( shading === \"basic\" ) mtype = \"MeshBasicMaterial\";\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {\r\n\r\n\t\t\tmpars.blending = THREE[ m.blending ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.transparent !== undefined || m.opacity < 1.0 ) {\r\n\r\n\t\t\tmpars.transparent = m.transparent;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.depthTest !== undefined ) {\r\n\r\n\t\t\tmpars.depthTest = m.depthTest;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.depthWrite !== undefined ) {\r\n\r\n\t\t\tmpars.depthWrite = m.depthWrite;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.visible !== undefined ) {\r\n\r\n\t\t\tmpars.visible = m.visible;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.flipSided !== undefined ) {\r\n\r\n\t\t\tmpars.side = THREE.BackSide;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.doubleSided !== undefined ) {\r\n\r\n\t\t\tmpars.side = THREE.DoubleSide;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.wireframe !== undefined ) {\r\n\r\n\t\t\tmpars.wireframe = m.wireframe;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.vertexColors !== undefined ) {\r\n\r\n\t\t\tif ( m.vertexColors === \"face\" ) {\r\n\r\n\t\t\t\tmpars.vertexColors = THREE.FaceColors;\r\n\r\n\t\t\t} else if ( m.vertexColors ) {\r\n\r\n\t\t\t\tmpars.vertexColors = THREE.VertexColors;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// colors\r\n\r\n\t\tif ( m.colorDiffuse ) {\r\n\r\n\t\t\tmpars.color = rgb2hex( m.colorDiffuse );\r\n\r\n\t\t} else if ( m.DbgColor ) {\r\n\r\n\t\t\tmpars.color = m.DbgColor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.colorSpecular ) {\r\n\r\n\t\t\tmpars.specular = rgb2hex( m.colorSpecular );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.colorAmbient ) {\r\n\r\n\t\t\tmpars.ambient = rgb2hex( m.colorAmbient );\r\n\r\n\t\t}\r\n\r\n\t\t// modifiers\r\n\r\n\t\tif ( m.transparency ) {\r\n\r\n\t\t\tmpars.opacity = m.transparency;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.specularCoef ) {\r\n\r\n\t\t\tmpars.shininess = m.specularCoef;\r\n\r\n\t\t}\r\n\r\n\t\t// textures\r\n\r\n\t\tif ( m.mapDiffuse && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"map\", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapLight && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"lightMap\", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapBump && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"bumpMap\", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapNormal && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"normalMap\", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapSpecular && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"specularMap\", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( m.mapBumpScale ) {\r\n\r\n\t\t\tmpars.bumpScale = m.mapBumpScale;\r\n\r\n\t\t}\r\n\r\n\t\t// special case for normal mapped material\r\n\r\n\t\tif ( m.mapNormal ) {\r\n\r\n\t\t\tvar shader = THREE.ShaderLib[ \"normalmap\" ];\r\n\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\t\tuniforms[ \"tNormal\" ].value = mpars.normalMap;\r\n\r\n\t\t\tif ( m.mapNormalFactor ) {\r\n\r\n\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( m.mapNormalFactor, m.mapNormalFactor );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( mpars.map ) {\r\n\r\n\t\t\t\tuniforms[ \"tDiffuse\" ].value = mpars.map;\r\n\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( mpars.specularMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tSpecular\" ].value = mpars.specularMap;\r\n\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( mpars.lightMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tAO\" ].value = mpars.lightMap;\r\n\t\t\t\tuniforms[ \"enableAO\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// for the moment don't handle displacement texture\r\n\r\n\t\t\tuniforms[ \"diffuse\" ].value.setHex( mpars.color );\r\n\t\t\tuniforms[ \"specular\" ].value.setHex( mpars.specular );\r\n\t\t\tuniforms[ \"ambient\" ].value.setHex( mpars.ambient );\r\n\r\n\t\t\tuniforms[ \"shininess\" ].value = mpars.shininess;\r\n\r\n\t\t\tif ( mpars.opacity !== undefined ) {\r\n\r\n\t\t\t\tuniforms[ \"opacity\" ].value = mpars.opacity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\r\n\t\t\tvar material = new THREE.ShaderMaterial( parameters );\r\n\r\n\t\t\tif ( mpars.transparent ) {\r\n\r\n\t\t\t\tmaterial.transparent = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar material = new THREE[ mtype ]( mpars );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.DbgName !== undefined ) material.name = m.DbgName;\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.XHRLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nTHREE.XHRLoader.prototype = {\n\n\tconstructor: THREE.XHRLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\t\tvar request = new XMLHttpRequest();\n\n\t\tif ( onLoad !== undefined ) {\n\n\t\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\t\tonLoad( event.target.responseText );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\tif ( onProgress !== undefined ) {\n\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tonProgress( event );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\tif ( onError !== undefined ) {\n\n\t\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\t\tonError( event );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\tif ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;\n\n\t\trequest.open( 'GET', url, true );\n\t\trequest.send( null );\n\n\t\tscope.manager.itemStart( url );\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ImageLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nTHREE.ImageLoader.prototype = {\n\n\tconstructor: THREE.ImageLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\t\tvar image = document.createElement( 'img' );\n\n\t\tif ( onLoad !== undefined ) {\n\n\t\t\timage.addEventListener( 'load', function ( event ) {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\t\t\t\tonLoad( this );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\tif ( onProgress !== undefined ) {\n\n\t\t\timage.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tonProgress( event );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\tif ( onError !== undefined ) {\n\n\t\t\timage.addEventListener( 'error', function ( event ) {\n\n\t\t\t\tonError( event );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n\t\timage.src = url;\n\n\t\tscope.manager.itemStart( url );\n\n\t\treturn image;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t}\n\n}\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.JSONLoader = function ( showStatus ) {\r\n\r\n\tTHREE.Loader.call( this, showStatus );\r\n\r\n\tthis.withCredentials = false;\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );\r\n\r\nTHREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {\r\n\r\n\tvar scope = this;\r\n\r\n\t// todo: unify load API to for easier SceneLoader use\r\n\r\n\ttexturePath = texturePath && ( typeof texturePath === \"string\" ) ? texturePath : this.extractUrlBase( url );\r\n\r\n\tthis.onLoadStart();\r\n\tthis.loadAjaxJSON( this, url, callback, texturePath );\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {\r\n\r\n\tvar xhr = new XMLHttpRequest();\r\n\r\n\tvar length = 0;\r\n\r\n\txhr.onreadystatechange = function () {\r\n\r\n\t\tif ( xhr.readyState === xhr.DONE ) {\r\n\r\n\t\t\tif ( xhr.status === 200 || xhr.status === 0 ) {\r\n\r\n\t\t\t\tif ( xhr.responseText ) {\r\n\r\n\t\t\t\t\tvar json = JSON.parse( xhr.responseText );\r\n\t\t\t\t\tvar result = context.parse( json, texturePath );\r\n\t\t\t\t\tcallback( result.geometry, result.materials );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( \"THREE.JSONLoader: [\" + url + \"] seems to be unreachable or file there is empty\" );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// in context of more complex asset initialization\r\n\t\t\t\t// do not block on single failed file\r\n\t\t\t\t// maybe should go even one more level up\r\n\r\n\t\t\t\tcontext.onLoadComplete();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( \"THREE.JSONLoader: Couldn't load [\" + url + \"] [\" + xhr.status + \"]\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( xhr.readyState === xhr.LOADING ) {\r\n\r\n\t\t\tif ( callbackProgress ) {\r\n\r\n\t\t\t\tif ( length === 0 ) {\r\n\r\n\t\t\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcallbackProgress( { total: length, loaded: xhr.responseText.length } );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {\r\n\r\n\t\t\tif ( callbackProgress !== undefined ) {\r\n\r\n\t\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\txhr.open( \"GET\", url, true );\r\n\txhr.withCredentials = this.withCredentials;\r\n\txhr.send( null );\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype.parse = function ( json, texturePath ) {\r\n\r\n\tvar scope = this,\r\n\tgeometry = new THREE.Geometry(),\r\n\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\r\n\tparseModel( scale );\r\n\r\n\tparseSkin();\r\n\tparseMorphing( scale );\r\n\r\n\tgeometry.computeCentroids();\r\n\tgeometry.computeFaceNormals();\r\n\tgeometry.computeBoundingSphere();\r\n\r\n\tfunction parseModel( scale ) {\r\n\r\n\t\tfunction isBitSet( value, position ) {\r\n\r\n\t\t\treturn value & ( 1 << position );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, j, fi,\r\n\r\n\t\toffset, zLength,\r\n\r\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\r\n\r\n\t\ttype,\r\n\t\tisQuad,\r\n\t\thasMaterial,\r\n\t\thasFaceVertexUv,\r\n\t\thasFaceNormal, hasFaceVertexNormal,\r\n\t\thasFaceColor, hasFaceVertexColor,\r\n\r\n\t\tvertex, face, faceA, faceB, color, hex, normal,\r\n\r\n\t\tuvLayer, uv, u, v,\r\n\r\n\t\tfaces = json.faces,\r\n\t\tvertices = json.vertices,\r\n\t\tnormals = json.normals,\r\n\t\tcolors = json.colors,\r\n\r\n\t\tnUvLayers = 0;\r\n\r\n\t\tif ( json.uvs !== undefined ) {\r\n\r\n\t\t\t// disregard empty arrays\r\n\r\n\t\t\tfor ( i = 0; i < json.uvs.length; i++ ) {\r\n\r\n\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\r\n\r\n\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\toffset = 0;\r\n\t\tzLength = vertices.length;\r\n\r\n\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\tvertex = new THREE.Vector3();\r\n\r\n\t\t\tvertex.x = vertices[ offset ++ ] * scale;\r\n\t\t\tvertex.y = vertices[ offset ++ ] * scale;\r\n\t\t\tvertex.z = vertices[ offset ++ ] * scale;\r\n\r\n\t\t\tgeometry.vertices.push( vertex );\r\n\r\n\t\t}\r\n\r\n\t\toffset = 0;\r\n\t\tzLength = faces.length;\r\n\r\n\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\ttype = faces[ offset ++ ];\r\n\r\n\r\n\t\t\tisQuad              = isBitSet( type, 0 );\r\n\t\t\thasMaterial         = isBitSet( type, 1 );\r\n\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\r\n\t\t\thasFaceNormal       = isBitSet( type, 4 );\r\n\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\r\n\t\t\thasFaceColor\t    = isBitSet( type, 6 );\r\n\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\r\n\r\n\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\r\n\t\t\tif ( isQuad ) {\r\n\r\n\t\t\t\tfaceA = new THREE.Face3();\r\n\t\t\t\tfaceA.a = faces[ offset ];\r\n\t\t\t\tfaceA.b = faces[ offset + 1 ];\r\n\t\t\t\tfaceA.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\tfaceB = new THREE.Face3();\r\n\t\t\t\tfaceB.a = faces[ offset + 1 ];\r\n\t\t\t\tfaceB.b = faces[ offset + 2 ];\r\n\t\t\t\tfaceB.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\toffset += 4;\r\n\r\n\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\tfaceA.materialIndex = materialIndex;\r\n\t\t\t\t\tfaceB.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\r\n\r\n\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = []\r\n\r\n\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\tfaceA.normal.set(\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tfaceB.normal.copy( faceA.normal );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 4; i++ ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\r\n\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\r\n\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\tfaceA.color.setHex( hex );\r\n\t\t\t\t\tfaceB.color.setHex( hex );\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 4; i++ ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\r\n\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.faces.push( faceA );\r\n\t\t\t\tgeometry.faces.push( faceB );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface = new THREE.Face3();\r\n\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\tface.c = faces[ offset ++ ];\r\n\r\n\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\r\n\r\n\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\r\n\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\tface.normal.set(\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i++ ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tface.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i++ ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.faces.push( face );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction parseSkin() {\r\n\r\n\t\tvar i, l, x, y, z, w, a, b, c, d;\r\n\r\n\t\tif ( json.skinWeights ) {\r\n\r\n\t\t\tfor ( i = 0, l = json.skinWeights.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\tx = json.skinWeights[ i     ];\r\n\t\t\t\ty = json.skinWeights[ i + 1 ];\r\n\t\t\t\tz = 0;\r\n\t\t\t\tw = 0;\r\n\r\n\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.skinIndices ) {\r\n\r\n\t\t\tfor ( i = 0, l = json.skinIndices.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\ta = json.skinIndices[ i     ];\r\n\t\t\t\tb = json.skinIndices[ i + 1 ];\r\n\t\t\t\tc = 0;\r\n\t\t\t\td = 0;\r\n\r\n\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.bones = json.bones;\r\n\t\t// could change this to json.animations[0] or remove completely\r\n\t\tgeometry.animation = json.animation;\r\n\t\tgeometry.animations = json.animations;\r\n\t};\r\n\r\n\tfunction parseMorphing( scale ) {\r\n\r\n\t\tif ( json.morphTargets !== undefined ) {\r\n\r\n\t\t\tvar i, l, v, vl, dstVertices, srcVertices;\r\n\r\n\t\t\tfor ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tgeometry.morphTargets[ i ] = {};\r\n\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\r\n\r\n\t\t\t\tdstVertices = geometry.morphTargets[ i ].vertices;\r\n\t\t\t\tsrcVertices = json.morphTargets [ i ].vertices;\r\n\r\n\t\t\t\tfor( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\r\n\t\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\r\n\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\r\n\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\r\n\r\n\t\t\t\t\tdstVertices.push( vertex );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.morphColors !== undefined ) {\r\n\r\n\t\t\tvar i, l, c, cl, dstColors, srcColors, color;\r\n\r\n\t\t\tfor ( i = 0, l = json.morphColors.length; i < l; i++ ) {\r\n\r\n\t\t\t\tgeometry.morphColors[ i ] = {};\r\n\t\t\t\tgeometry.morphColors[ i ].name = json.morphColors[ i ].name;\r\n\t\t\t\tgeometry.morphColors[ i ].colors = [];\r\n\r\n\t\t\t\tdstColors = geometry.morphColors[ i ].colors;\r\n\t\t\t\tsrcColors = json.morphColors [ i ].colors;\r\n\r\n\t\t\t\tfor ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {\r\n\r\n\t\t\t\t\tcolor = new THREE.Color( 0xffaa00 );\r\n\t\t\t\t\tcolor.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );\r\n\t\t\t\t\tdstColors.push( color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tif ( json.materials === undefined ) {\r\n\r\n\t\treturn { geometry: geometry };\r\n\r\n\t} else {\r\n\r\n\t\tvar materials = this.initMaterials( json.materials, texturePath );\r\n\r\n\t\tif ( this.needsTangents( materials ) ) {\r\n\r\n\t\t\tgeometry.computeTangents();\r\n\r\n\t\t}\r\n\r\n\t\treturn { geometry: geometry, materials: materials };\r\n\r\n\t}\r\n\r\n};\r\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\n\n\tvar scope = this;\n\n\tvar loaded = 0, total = 0;\n\n\tthis.onLoad = onLoad;\n\tthis.onProgress = onProgress;\n\tthis.onError = onError;\n\n\tthis.itemStart = function ( url ) {\n\n\t\ttotal ++;\n\n\t};\n\n\tthis.itemEnd = function ( url ) {\n\n\t\tloaded ++;\n\n\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\tscope.onProgress( url, loaded, total );\n\n\t\t}\n\n\t\tif ( loaded === total && scope.onLoad !== undefined ) {\n\n\t\t\tscope.onLoad();\n\n\t\t}\n\n\t};\n\n};\n\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometryLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.BufferGeometryLoader.prototype = {\r\n\r\n\tconstructor: THREE.BufferGeometryLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader();\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\t\tvar attributes = json.attributes;\r\n\t\tvar offsets = json.offsets;\r\n\t\tvar boundingSphere = json.boundingSphere;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\r\n\t\t\tgeometry.attributes[ key ] = {\r\n\t\t\t\titemSize: attribute.itemSize,\r\n\t\t\t\tarray: new self[ attribute.type ]( attribute.array )\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( offsets !== undefined ) {\r\n\r\n\t\t\tgeometry.offsets = JSON.parse( JSON.stringify( offsets ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( boundingSphere !== undefined ) {\r\n\r\n\t\t\tgeometry.boundingSphere = new THREE.Sphere(\r\n\t\t\t\tnew THREE.Vector3().fromArray( boundingSphere.center !== undefined ? boundingSphere.center : [ 0, 0, 0 ] ),\r\n\t\t\t\tboundingSphere.radius\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n};\r\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.GeometryLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.GeometryLoader.prototype = {\r\n\r\n\tconstructor: THREE.GeometryLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader();\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\t\r\n\r\n\t}\r\n\r\n};\r\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MaterialLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.MaterialLoader.prototype = {\r\n\r\n\tconstructor: THREE.MaterialLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader();\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar material = new THREE[ json.type ];\r\n\r\n\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\r\n\t\tif ( json.ambient !== undefined ) material.ambient.setHex( json.ambient );\r\n\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\r\n\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\r\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\r\n\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\r\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\r\n\t\tif ( json.side !== undefined ) material.side = json.side;\r\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\r\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\r\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\r\n\r\n\t\tif ( json.materials !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ObjectLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nTHREE.ObjectLoader.prototype = {\n\n\tconstructor: THREE.ObjectLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t} );\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar geometries = this.parseGeometries( json.geometries );\n\t\tvar materials = this.parseMaterials( json.materials );\n\t\tvar object = this.parseObject( json.object, geometries, materials );\n\n\t\treturn object;\n\n\t},\n\n\tparseGeometries: function ( json ) {\n\n\t\tvar geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar geometryLoader = new THREE.JSONLoader();\n\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar geometry;\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'PlaneGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE.PlaneGeometry(\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CircleGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE.CircleGeometry(\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.segments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CubeGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE.CubeGeometry(\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CylinderGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE.CylinderGeometry(\n\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SphereGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE.SphereGeometry(\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'IcosahedronGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE.IcosahedronGeometry(\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE.TorusGeometry(\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusKnotGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE.TorusKnotGeometry(\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\tdata.q,\n\t\t\t\t\t\t\tdata.heightScale\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data.data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data ).geometry;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t},\n\n\tparseMaterials: function ( json ) {\n\n\t\tvar materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar loader = new THREE.MaterialLoader();\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar data = json[ i ];\n\t\t\t\tvar material = loader.parse( data );\n\n\t\t\t\tmaterial.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) material.name = data.name;\n\n\t\t\t\tmaterials[ data.uuid ] = material;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t},\n\n\tparseObject: function () {\n\n\t\tvar matrix = new THREE.Matrix4();\n\n\t\treturn function ( data, geometries, materials ) {\n\n\t\t\tvar object;\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'Scene':\n\n\t\t\t\t\tobject = new THREE.Scene();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientLight':\n\n\t\t\t\t\tobject = new THREE.AmbientLight( data.color );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DirectionalLight':\n\n\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\n\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\n\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Mesh':\n\n\t\t\t\t\tvar geometry = geometries[ data.geometry ];\n\t\t\t\t\tvar material = materials[ data.material ];\n\n\t\t\t\t\tif ( geometry === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.ObjectLoader: Undefined geometry ' + data.geometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.ObjectLoader: Undefined material ' + data.material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Sprite':\n\n\t\t\t\t\tvar material = materials[ data.material ];\n\n\t\t\t\t\tif ( material === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.ObjectLoader: Undefined material ' + data.material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new THREE.Sprite( material );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tobject = new THREE.Object3D();\n\n\t\t\t}\n\n\t\t\tobject.uuid = data.uuid;\n\n\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\tif ( data.matrix !== undefined ) {\n\n\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t} else {\n\n\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t\t}\n\n\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\n\t\t\tif ( data.children !== undefined ) {\n\n\t\t\t\tfor ( var child in data.children ) {\n\n\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t}\n\n\t}()\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SceneLoader = function () {\n\n\tthis.onLoadStart = function () {};\n\tthis.onLoadProgress = function() {};\n\tthis.onLoadComplete = function () {};\n\n\tthis.callbackSync = function () {};\n\tthis.callbackProgress = function () {};\n\n\tthis.geometryHandlers = {};\n\tthis.hierarchyHandlers = {};\n\n\tthis.addGeometryHandler( \"ascii\", THREE.JSONLoader );\n\n};\n\nTHREE.SceneLoader.prototype = {\n\n\tconstructor: THREE.SceneLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tscope.parse( JSON.parse( text ), onLoad, url );\n\n\t\t} );\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t},\n\n\taddGeometryHandler: function ( typeID, loaderClass ) {\n\n\t\tthis.geometryHandlers[ typeID ] = { \"loaderClass\": loaderClass };\n\n\t},\n\n\taddHierarchyHandler: function ( typeID, loaderClass ) {\n\n\t\tthis.hierarchyHandlers[ typeID ] = { \"loaderClass\": loaderClass };\n\n\t},\n\n\tparse: function ( json, callbackFinished, url ) {\n\n\t\tvar scope = this;\n\n\t\tvar urlBase = THREE.Loader.prototype.extractUrlBase( url );\n\n\t\tvar geometry, material, camera, fog,\n\t\t\ttexture, images, color,\n\t\t\tlight, hex, intensity,\n\t\t\tcounter_models, counter_textures,\n\t\t\ttotal_models, total_textures,\n\t\t\tresult;\n\n\t\tvar target_array = [];\n\n\t\tvar data = json;\n\n\t\t// async geometry loaders\n\n\t\tfor ( var typeID in this.geometryHandlers ) {\n\n\t\t\tvar loaderClass = this.geometryHandlers[ typeID ][ \"loaderClass\" ];\n\t\t\tthis.geometryHandlers[ typeID ][ \"loaderObject\" ] = new loaderClass();\n\n\t\t}\n\n\t\t// async hierachy loaders\n\n\t\tfor ( var typeID in this.hierarchyHandlers ) {\n\n\t\t\tvar loaderClass = this.hierarchyHandlers[ typeID ][ \"loaderClass\" ];\n\t\t\tthis.hierarchyHandlers[ typeID ][ \"loaderObject\" ] = new loaderClass();\n\n\t\t}\n\n\t\tcounter_models = 0;\n\t\tcounter_textures = 0;\n\n\t\tresult = {\n\n\t\t\tscene: new THREE.Scene(),\n\t\t\tgeometries: {},\n\t\t\tface_materials: {},\n\t\t\tmaterials: {},\n\t\t\ttextures: {},\n\t\t\tobjects: {},\n\t\t\tcameras: {},\n\t\t\tlights: {},\n\t\t\tfogs: {},\n\t\t\tempties: {},\n\t\t\tgroups: {}\n\n\t\t};\n\n\t\tif ( data.transform ) {\n\n\t\t\tvar position = data.transform.position,\n\t\t\t\trotation = data.transform.rotation,\n\t\t\t\tscale = data.transform.scale;\n\n\t\t\tif ( position ) {\n\n\t\t\t\tresult.scene.position.fromArray( position );\n\n\t\t\t}\n\n\t\t\tif ( rotation ) {\n\n\t\t\t\tresult.scene.rotation.fromArray( rotation );\n\n\t\t\t}\n\n\t\t\tif ( scale ) {\n\n\t\t\t\tresult.scene.scale.fromArray( scale );\n\n\t\t\t}\n\n\t\t\tif ( position || rotation || scale ) {\n\n\t\t\t\tresult.scene.updateMatrix();\n\t\t\t\tresult.scene.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction get_url( source_url, url_type ) {\n\n\t\t\tif ( url_type == \"relativeToHTML\" ) {\n\n\t\t\t\treturn source_url;\n\n\t\t\t} else {\n\n\t\t\t\treturn urlBase + \"/\" + source_url;\n\n\t\t\t}\n\n\t\t};\n\n\t\t// toplevel loader function, delegates to handle_children\n\n\t\tfunction handle_objects() {\n\n\t\t\thandle_children( result.scene, data.objects );\n\n\t\t}\n\n\t\t// handle all the children from the loaded json and attach them to given parent\n\n\t\tfunction handle_children( parent, children ) {\n\n\t\t\tvar mat, dst, pos, rot, scl, quat;\n\n\t\t\tfor ( var objID in children ) {\n\n\t\t\t\t// check by id if child has already been handled,\n\t\t\t\t// if not, create new object\n\n\t\t\t\tvar object = result.objects[ objID ];\n\t\t\t\tvar objJSON = children[ objID ];\n\n\t\t\t\tif ( object === undefined ) {\n\n\t\t\t\t\t// meshes\n\n\t\t\t\t\tif ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {\n\n\t\t\t\t\t\tif ( objJSON.loading === undefined ) {\n\n\t\t\t\t\t\t\tvar reservedTypes = {\n\t\t\t\t\t\t\t\t\"type\": 1, \"url\": 1, \"material\": 1,\n\t\t\t\t\t\t\t\t\"position\": 1, \"rotation\": 1, \"scale\" : 1,\n\t\t\t\t\t\t\t\t\"visible\": 1, \"children\": 1, \"userData\": 1,\n\t\t\t\t\t\t\t\t\"skin\": 1, \"morph\": 1, \"mirroredLoop\": 1, \"duration\": 1\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tvar loaderParameters = {};\n\n\t\t\t\t\t\t\tfor ( var parType in objJSON ) {\n\n\t\t\t\t\t\t\t\tif ( ! ( parType in reservedTypes ) ) {\n\n\t\t\t\t\t\t\t\t\tloaderParameters[ parType ] = objJSON[ parType ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmaterial = result.materials[ objJSON.material ];\n\n\t\t\t\t\t\t\tobjJSON.loading = true;\n\n\t\t\t\t\t\t\tvar loader = scope.hierarchyHandlers[ objJSON.type ][ \"loaderObject\" ];\n\n\t\t\t\t\t\t\t// ColladaLoader\n\n\t\t\t\t\t\t\tif ( loader.options ) {\n\n\t\t\t\t\t\t\t\tloader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ) );\n\n\t\t\t\t\t\t\t// UTF8Loader\n\t\t\t\t\t\t\t// OBJLoader\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tloader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ), loaderParameters );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( objJSON.geometry !== undefined ) {\n\n\t\t\t\t\t\tgeometry = result.geometries[ objJSON.geometry ];\n\n\t\t\t\t\t\t// geometry already loaded\n\n\t\t\t\t\t\tif ( geometry ) {\n\n\t\t\t\t\t\t\tvar needsTangents = false;\n\n\t\t\t\t\t\t\tmaterial = result.materials[ objJSON.material ];\n\t\t\t\t\t\t\tneedsTangents = material instanceof THREE.ShaderMaterial;\n\n\t\t\t\t\t\t\tpos = objJSON.position;\n\t\t\t\t\t\t\trot = objJSON.rotation;\n\t\t\t\t\t\t\tscl = objJSON.scale;\n\t\t\t\t\t\t\tmat = objJSON.matrix;\n\t\t\t\t\t\t\tquat = objJSON.quaternion;\n\n\t\t\t\t\t\t\t// use materials from the model file\n\t\t\t\t\t\t\t// if there is no material specified in the object\n\n\t\t\t\t\t\t\tif ( ! objJSON.material ) {\n\n\t\t\t\t\t\t\t\tmaterial = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// use materials from the model file\n\t\t\t\t\t\t\t// if there is just empty face material\n\t\t\t\t\t\t\t// (must create new material as each model has its own face material)\n\n\t\t\t\t\t\t\tif ( ( material instanceof THREE.MeshFaceMaterial ) && material.materials.length === 0 ) {\n\n\t\t\t\t\t\t\t\tmaterial = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( material instanceof THREE.MeshFaceMaterial ) {\n\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < material.materials.length; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tneedsTangents = needsTangents || ( material.materials[ i ] instanceof THREE.ShaderMaterial );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( needsTangents ) {\n\n\t\t\t\t\t\t\t\tgeometry.computeTangents();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( objJSON.skin ) {\n\n\t\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\n\n\t\t\t\t\t\t\t} else if ( objJSON.morph ) {\n\n\t\t\t\t\t\t\t\tobject = new THREE.MorphAnimMesh( geometry, material );\n\n\t\t\t\t\t\t\t\tif ( objJSON.duration !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tobject.duration = objJSON.duration;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( objJSON.time !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tobject.time = objJSON.time;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( objJSON.mirroredLoop !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tobject.mirroredLoop = objJSON.mirroredLoop;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t\t\t\t\tgeometry.computeMorphNormals();\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.name = objID;\n\n\t\t\t\t\t\t\tif ( mat ) {\n\n\t\t\t\t\t\t\t\tobject.matrixAutoUpdate = false;\n\t\t\t\t\t\t\t\tobject.matrix.set(\n\t\t\t\t\t\t\t\t\tmat[0],  mat[1],  mat[2],  mat[3],\n\t\t\t\t\t\t\t\t\tmat[4],  mat[5],  mat[6],  mat[7],\n\t\t\t\t\t\t\t\t\tmat[8],  mat[9],  mat[10], mat[11],\n\t\t\t\t\t\t\t\t\tmat[12], mat[13], mat[14], mat[15]\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tobject.position.fromArray( pos );\n\n\t\t\t\t\t\t\t\tif ( quat ) {\n\n\t\t\t\t\t\t\t\t\tobject.quaternion.fromArray( quat );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tobject.rotation.fromArray( rot );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tobject.scale.fromArray( scl );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.visible = objJSON.visible;\n\t\t\t\t\t\t\tobject.castShadow = objJSON.castShadow;\n\t\t\t\t\t\t\tobject.receiveShadow = objJSON.receiveShadow;\n\n\t\t\t\t\t\t\tparent.add( object );\n\n\t\t\t\t\t\t\tresult.objects[ objID ] = object;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// lights\n\n\t\t\t\t\t} else if ( objJSON.type === \"AmbientLight\" || objJSON.type === \"PointLight\" ||\n\t\t\t\t\t\tobjJSON.type === \"DirectionalLight\" || objJSON.type === \"SpotLight\" ||\n\t\t\t\t\t\tobjJSON.type === \"HemisphereLight\" || objJSON.type === \"AreaLight\" ) {\n\n\t\t\t\t\t\tvar color = objJSON.color;\n\t\t\t\t\t\tvar intensity = objJSON.intensity;\n\t\t\t\t\t\tvar distance = objJSON.distance;\n\t\t\t\t\t\tvar position = objJSON.position;\n\t\t\t\t\t\tvar rotation = objJSON.rotation;\n\n\t\t\t\t\t\tswitch ( objJSON.type ) {\n\n\t\t\t\t\t\t\tcase 'AmbientLight':\n\t\t\t\t\t\t\t\tlight = new THREE.AmbientLight( color );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\t\t\tlight = new THREE.PointLight( color, intensity, distance );\n\t\t\t\t\t\t\t\tlight.position.fromArray( position );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\t\t\tlight = new THREE.DirectionalLight( color, intensity );\n\t\t\t\t\t\t\t\tlight.position.fromArray( objJSON.direction );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\t\t\tlight = new THREE.SpotLight( color, intensity, distance, 1 );\n\t\t\t\t\t\t\t\tlight.angle = objJSON.angle;\n\t\t\t\t\t\t\t\tlight.position.fromArray( position );\n\t\t\t\t\t\t\t\tlight.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );\n\t\t\t\t\t\t\t\tlight.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\t\t\t\tlight = new THREE.DirectionalLight( color, intensity, distance );\n\t\t\t\t\t\t\t\tlight.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );\n\t\t\t\t\t\t\t\tlight.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'AreaLight':\n\t\t\t\t\t\t\t\tlight = new THREE.AreaLight(color, intensity);\n\t\t\t\t\t\t\t\tlight.position.fromArray( position );\n\t\t\t\t\t\t\t\tlight.width = objJSON.size;\n\t\t\t\t\t\t\t\tlight.height = objJSON.size_y;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparent.add( light );\n\n\t\t\t\t\t\tlight.name = objID;\n\t\t\t\t\t\tresult.lights[ objID ] = light;\n\t\t\t\t\t\tresult.objects[ objID ] = light;\n\n\t\t\t\t\t// cameras\n\n\t\t\t\t\t} else if ( objJSON.type === \"PerspectiveCamera\" || objJSON.type === \"OrthographicCamera\" ) {\n\n\t\t\t\t\t\tpos = objJSON.position;\n\t\t\t\t\t\trot = objJSON.rotation;\n\t\t\t\t\t\tquat = objJSON.quaternion;\n\n\t\t\t\t\t\tif ( objJSON.type === \"PerspectiveCamera\" ) {\n\n\t\t\t\t\t\t\tcamera = new THREE.PerspectiveCamera( objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far );\n\n\t\t\t\t\t\t} else if ( objJSON.type === \"OrthographicCamera\" ) {\n\n\t\t\t\t\t\t\tcamera = new THREE.OrthographicCamera( objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcamera.name = objID;\n\t\t\t\t\t\tcamera.position.fromArray( pos );\n\n\t\t\t\t\t\tif ( quat !== undefined ) {\n\n\t\t\t\t\t\t\tcamera.quaternion.fromArray( quat );\n\n\t\t\t\t\t\t} else if ( rot !== undefined ) {\n\n\t\t\t\t\t\t\tcamera.rotation.fromArray( rot );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparent.add( camera );\n\n\t\t\t\t\t\tresult.cameras[ objID ] = camera;\n\t\t\t\t\t\tresult.objects[ objID ] = camera;\n\n\t\t\t\t\t// pure Object3D\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpos = objJSON.position;\n\t\t\t\t\t\trot = objJSON.rotation;\n\t\t\t\t\t\tscl = objJSON.scale;\n\t\t\t\t\t\tquat = objJSON.quaternion;\n\n\t\t\t\t\t\tobject = new THREE.Object3D();\n\t\t\t\t\t\tobject.name = objID;\n\t\t\t\t\t\tobject.position.fromArray( pos );\n\n\t\t\t\t\t\tif ( quat ) {\n\n\t\t\t\t\t\t\tobject.quaternion.fromArray( quat );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject.rotation.fromArray( rot );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobject.scale.fromArray( scl );\n\t\t\t\t\t\tobject.visible = ( objJSON.visible !== undefined ) ? objJSON.visible : false;\n\n\t\t\t\t\t\tparent.add( object );\n\n\t\t\t\t\t\tresult.objects[ objID ] = object;\n\t\t\t\t\t\tresult.empties[ objID ] = object;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( object ) {\n\n\t\t\t\t\t\tif ( objJSON.userData !== undefined ) {\n\n\t\t\t\t\t\t\tfor ( var key in objJSON.userData ) {\n\n\t\t\t\t\t\t\t\tvar value = objJSON.userData[ key ];\n\t\t\t\t\t\t\t\tobject.userData[ key ] = value;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( objJSON.groups !== undefined ) {\n\n\t\t\t\t\t\t\tfor ( var i = 0; i < objJSON.groups.length; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar groupID = objJSON.groups[ i ];\n\n\t\t\t\t\t\t\t\tif ( result.groups[ groupID ] === undefined ) {\n\n\t\t\t\t\t\t\t\t\tresult.groups[ groupID ] = [];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tresult.groups[ groupID ].push( objID );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( object !== undefined && objJSON.children !== undefined ) {\n\n\t\t\t\t\thandle_children( object, objJSON.children );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction handle_mesh( geo, mat, id ) {\n\n\t\t\tresult.geometries[ id ] = geo;\n\t\t\tresult.face_materials[ id ] = mat;\n\t\t\thandle_objects();\n\n\t\t};\n\n\t\tfunction handle_hierarchy( node, id, parent, material, obj ) {\n\n\t\t\tvar p = obj.position;\n\t\t\tvar r = obj.rotation;\n\t\t\tvar q = obj.quaternion;\n\t\t\tvar s = obj.scale;\n\n\t\t\tnode.position.fromArray( p );\n\n\t\t\tif ( q ) {\n\n\t\t\t\tnode.quaternion.fromArray( q );\n\n\t\t\t} else {\n\n\t\t\t\tnode.rotation.fromArray( r );\n\n\t\t\t}\n\n\t\t\tnode.scale.fromArray( s );\n\n\t\t\t// override children materials\n\t\t\t// if object material was specified in JSON explicitly\n\n\t\t\tif ( material ) {\n\n\t\t\t\tnode.traverse( function ( child ) {\n\n\t\t\t\t\tchild.material = material;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// override children visibility\n\t\t\t// with root node visibility as specified in JSON\n\n\t\t\tvar visible = ( obj.visible !== undefined ) ? obj.visible : true;\n\n\t\t\tnode.traverse( function ( child ) {\n\n\t\t\t\tchild.visible = visible;\n\n\t\t\t} );\n\n\t\t\tparent.add( node );\n\n\t\t\tnode.name = id;\n\n\t\t\tresult.objects[ id ] = node;\n\t\t\thandle_objects();\n\n\t\t};\n\n\t\tfunction create_callback_geometry( id ) {\n\n\t\t\treturn function ( geo, mat ) {\n\n\t\t\t\tgeo.name = id;\n\n\t\t\t\thandle_mesh( geo, mat, id );\n\n\t\t\t\tcounter_models -= 1;\n\n\t\t\t\tscope.onLoadComplete();\n\n\t\t\t\tasync_callback_gate();\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction create_callback_hierachy( id, parent, material, obj ) {\n\n\t\t\treturn function ( event ) {\n\n\t\t\t\tvar result;\n\n\t\t\t\t// loaders which use EventDispatcher\n\n\t\t\t\tif ( event.content ) {\n\n\t\t\t\t\tresult = event.content;\n\n\t\t\t\t// ColladaLoader\n\n\t\t\t\t} else if ( event.dae ) {\n\n\t\t\t\t\tresult = event.scene;\n\n\n\t\t\t\t// UTF8Loader\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult = event;\n\n\t\t\t\t}\n\n\t\t\t\thandle_hierarchy( result, id, parent, material, obj );\n\n\t\t\t\tcounter_models -= 1;\n\n\t\t\t\tscope.onLoadComplete();\n\n\t\t\t\tasync_callback_gate();\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction create_callback_embed( id ) {\n\n\t\t\treturn function ( geo, mat ) {\n\n\t\t\t\tgeo.name = id;\n\n\t\t\t\tresult.geometries[ id ] = geo;\n\t\t\t\tresult.face_materials[ id ] = mat;\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction async_callback_gate() {\n\n\t\t\tvar progress = {\n\n\t\t\t\ttotalModels : total_models,\n\t\t\t\ttotalTextures : total_textures,\n\t\t\t\tloadedModels : total_models - counter_models,\n\t\t\t\tloadedTextures : total_textures - counter_textures\n\n\t\t\t};\n\n\t\t\tscope.callbackProgress( progress, result );\n\n\t\t\tscope.onLoadProgress();\n\n\t\t\tif ( counter_models === 0 && counter_textures === 0 ) {\n\n\t\t\t\tfinalize();\n\t\t\t\tcallbackFinished( result );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction finalize() {\n\n\t\t\t// take care of targets which could be asynchronously loaded objects\n\n\t\t\tfor ( var i = 0; i < target_array.length; i ++ ) {\n\n\t\t\t\tvar ta = target_array[ i ];\n\n\t\t\t\tvar target = result.objects[ ta.targetName ];\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\tta.object.target = target;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if there was error and target of specified name doesn't exist in the scene file\n\t\t\t\t\t// create instead dummy target\n\t\t\t\t\t// (target must be added to scene explicitly as parent is already added)\n\n\t\t\t\t\tta.object.target = new THREE.Object3D();\n\t\t\t\t\tresult.scene.add( ta.object.target );\n\n\t\t\t\t}\n\n\t\t\t\tta.object.target.userData.targetInverse = ta.object;\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar callbackTexture = function ( count ) {\n\n\t\t\tcounter_textures -= count;\n\t\t\tasync_callback_gate();\n\n\t\t\tscope.onLoadComplete();\n\n\t\t};\n\n\t\t// must use this instead of just directly calling callbackTexture\n\t\t// because of closure in the calling context loop\n\n\t\tvar generateTextureCallback = function ( count ) {\n\n\t\t\treturn function () {\n\n\t\t\t\tcallbackTexture( count );\n\n\t\t\t};\n\n\t\t};\n\n\t\tfunction traverse_json_hierarchy( objJSON, callback ) {\n\n\t\t\tcallback( objJSON );\n\n\t\t\tif ( objJSON.children !== undefined ) {\n\n\t\t\t\tfor ( var objChildID in objJSON.children ) {\n\n\t\t\t\t\ttraverse_json_hierarchy( objJSON.children[ objChildID ], callback );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\t// first go synchronous elements\n\n\t\t// fogs\n\n\t\tvar fogID, fogJSON;\n\n\t\tfor ( fogID in data.fogs ) {\n\n\t\t\tfogJSON = data.fogs[ fogID ];\n\n\t\t\tif ( fogJSON.type === \"linear\" ) {\n\n\t\t\t\tfog = new THREE.Fog( 0x000000, fogJSON.near, fogJSON.far );\n\n\t\t\t} else if ( fogJSON.type === \"exp2\" ) {\n\n\t\t\t\tfog = new THREE.FogExp2( 0x000000, fogJSON.density );\n\n\t\t\t}\n\n\t\t\tcolor = fogJSON.color;\n\t\t\tfog.color.setRGB( color[0], color[1], color[2] );\n\n\t\t\tresult.fogs[ fogID ] = fog;\n\n\t\t}\n\n\t\t// now come potentially asynchronous elements\n\n\t\t// geometries\n\n\t\t// count how many geometries will be loaded asynchronously\n\n\t\tvar geoID, geoJSON;\n\n\t\tfor ( geoID in data.geometries ) {\n\n\t\t\tgeoJSON = data.geometries[ geoID ];\n\n\t\t\tif ( geoJSON.type in this.geometryHandlers ) {\n\n\t\t\t\tcounter_models += 1;\n\n\t\t\t\tscope.onLoadStart();\n\n\t\t\t}\n\n\t\t}\n\n\t\t// count how many hierarchies will be loaded asynchronously\n\n\t\tfor ( var objID in data.objects ) {\n\n\t\t\ttraverse_json_hierarchy( data.objects[ objID ], function ( objJSON ) {\n\n\t\t\t\tif ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {\n\n\t\t\t\t\tcounter_models += 1;\n\n\t\t\t\t\tscope.onLoadStart();\n\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t}\n\n\t\ttotal_models = counter_models;\n\n\t\tfor ( geoID in data.geometries ) {\n\n\t\t\tgeoJSON = data.geometries[ geoID ];\n\n\t\t\tif ( geoJSON.type === \"cube\" ) {\n\n\t\t\t\tgeometry = new THREE.CubeGeometry( geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments );\n\t\t\t\tgeometry.name = geoID;\n\t\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t\t} else if ( geoJSON.type === \"plane\" ) {\n\n\t\t\t\tgeometry = new THREE.PlaneGeometry( geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments );\n\t\t\t\tgeometry.name = geoID;\n\t\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t\t} else if ( geoJSON.type === \"sphere\" ) {\n\n\t\t\t\tgeometry = new THREE.SphereGeometry( geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments );\n\t\t\t\tgeometry.name = geoID;\n\t\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t\t} else if ( geoJSON.type === \"cylinder\" ) {\n\n\t\t\t\tgeometry = new THREE.CylinderGeometry( geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs );\n\t\t\t\tgeometry.name = geoID;\n\t\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t\t} else if ( geoJSON.type === \"torus\" ) {\n\n\t\t\t\tgeometry = new THREE.TorusGeometry( geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT );\n\t\t\t\tgeometry.name = geoID;\n\t\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t\t} else if ( geoJSON.type === \"icosahedron\" ) {\n\n\t\t\t\tgeometry = new THREE.IcosahedronGeometry( geoJSON.radius, geoJSON.subdivisions );\n\t\t\t\tgeometry.name = geoID;\n\t\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t\t} else if ( geoJSON.type in this.geometryHandlers ) {\n\n\t\t\t\tvar loaderParameters = {};\n\n\t\t\t\tfor ( var parType in geoJSON ) {\n\n\t\t\t\t\tif ( parType !== \"type\" && parType !== \"url\" ) {\n\n\t\t\t\t\t\tloaderParameters[ parType ] = geoJSON[ parType ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar loader = this.geometryHandlers[ geoJSON.type ][ \"loaderObject\" ];\n\t\t\t\tloader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry( geoID ), loaderParameters );\n\n\t\t\t} else if ( geoJSON.type === \"embedded\" ) {\n\n\t\t\t\tvar modelJson = data.embeds[ geoJSON.id ],\n\t\t\t\t\ttexture_path = \"\";\n\n\t\t\t\t// pass metadata along to jsonLoader so it knows the format version\n\n\t\t\t\tmodelJson.metadata = data.metadata;\n\n\t\t\t\tif ( modelJson ) {\n\n\t\t\t\t\tvar jsonLoader = this.geometryHandlers[ \"ascii\" ][ \"loaderObject\" ];\n\t\t\t\t\tvar model = jsonLoader.parse( modelJson, texture_path );\n\t\t\t\t\tcreate_callback_embed( geoID )( model.geometry, model.materials );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// textures\n\n\t\t// count how many textures will be loaded asynchronously\n\n\t\tvar textureID, textureJSON;\n\n\t\tfor ( textureID in data.textures ) {\n\n\t\t\ttextureJSON = data.textures[ textureID ];\n\n\t\t\tif ( textureJSON.url instanceof Array ) {\n\n\t\t\t\tcounter_textures += textureJSON.url.length;\n\n\t\t\t\tfor( var n = 0; n < textureJSON.url.length; n ++ ) {\n\n\t\t\t\t\tscope.onLoadStart();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tcounter_textures += 1;\n\n\t\t\t\tscope.onLoadStart();\n\n\t\t\t}\n\n\t\t}\n\n\t\ttotal_textures = counter_textures;\n\n\t\tfor ( textureID in data.textures ) {\n\n\t\t\ttextureJSON = data.textures[ textureID ];\n\n\t\t\tif ( textureJSON.mapping !== undefined && THREE[ textureJSON.mapping ] !== undefined ) {\n\n\t\t\t\ttextureJSON.mapping = new THREE[ textureJSON.mapping ]();\n\n\t\t\t}\n\n\t\t\tif ( textureJSON.url instanceof Array ) {\n\n\t\t\t\tvar count = textureJSON.url.length;\n\t\t\t\tvar url_array = [];\n\n\t\t\t\tfor( var i = 0; i < count; i ++ ) {\n\n\t\t\t\t\turl_array[ i ] = get_url( textureJSON.url[ i ], data.urlBaseType );\n\n\t\t\t\t}\n\n\t\t\t\tvar isCompressed = /\\.dds$/i.test( url_array[ 0 ] );\n\n\t\t\t\tif ( isCompressed ) {\n\n\t\t\t\t\ttexture = THREE.ImageUtils.loadCompressedTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture = THREE.ImageUtils.loadTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar isCompressed = /\\.dds$/i.test( textureJSON.url );\n\t\t\t\tvar fullUrl = get_url( textureJSON.url, data.urlBaseType );\n\t\t\t\tvar textureCallback = generateTextureCallback( 1 );\n\n\t\t\t\tif ( isCompressed ) {\n\n\t\t\t\t\ttexture = THREE.ImageUtils.loadCompressedTexture( fullUrl, textureJSON.mapping, textureCallback );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture = THREE.ImageUtils.loadTexture( fullUrl, textureJSON.mapping, textureCallback );\n\n\t\t\t\t}\n\n\t\t\t\tif ( THREE[ textureJSON.minFilter ] !== undefined )\n\t\t\t\t\ttexture.minFilter = THREE[ textureJSON.minFilter ];\n\n\t\t\t\tif ( THREE[ textureJSON.magFilter ] !== undefined )\n\t\t\t\t\ttexture.magFilter = THREE[ textureJSON.magFilter ];\n\n\t\t\t\tif ( textureJSON.anisotropy ) texture.anisotropy = textureJSON.anisotropy;\n\n\t\t\t\tif ( textureJSON.repeat ) {\n\n\t\t\t\t\ttexture.repeat.set( textureJSON.repeat[ 0 ], textureJSON.repeat[ 1 ] );\n\n\t\t\t\t\tif ( textureJSON.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tif ( textureJSON.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( textureJSON.offset ) {\n\n\t\t\t\t\ttexture.offset.set( textureJSON.offset[ 0 ], textureJSON.offset[ 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\t// handle wrap after repeat so that default repeat can be overriden\n\n\t\t\t\tif ( textureJSON.wrap ) {\n\n\t\t\t\t\tvar wrapMap = {\n\t\t\t\t\t\t\"repeat\": THREE.RepeatWrapping,\n\t\t\t\t\t\t\"mirror\": THREE.MirroredRepeatWrapping\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( wrapMap[ textureJSON.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ textureJSON.wrap[ 0 ] ];\n\t\t\t\t\tif ( wrapMap[ textureJSON.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ textureJSON.wrap[ 1 ] ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tresult.textures[ textureID ] = texture;\n\n\t\t}\n\n\t\t// materials\n\n\t\tvar matID, matJSON;\n\t\tvar parID;\n\n\t\tfor ( matID in data.materials ) {\n\n\t\t\tmatJSON = data.materials[ matID ];\n\n\t\t\tfor ( parID in matJSON.parameters ) {\n\n\t\t\t\tif ( parID === \"envMap\" || parID === \"map\" || parID === \"lightMap\" || parID === \"bumpMap\" ) {\n\n\t\t\t\t\tmatJSON.parameters[ parID ] = result.textures[ matJSON.parameters[ parID ] ];\n\n\t\t\t\t} else if ( parID === \"shading\" ) {\n\n\t\t\t\t\tmatJSON.parameters[ parID ] = ( matJSON.parameters[ parID ] === \"flat\" ) ? THREE.FlatShading : THREE.SmoothShading;\n\n\t\t\t\t} else if ( parID === \"side\" ) {\n\n\t\t\t\t\tif ( matJSON.parameters[ parID ] == \"double\" ) {\n\n\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.DoubleSide;\n\n\t\t\t\t\t} else if ( matJSON.parameters[ parID ] == \"back\" ) {\n\n\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.BackSide;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.FrontSide;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( parID === \"blending\" ) {\n\n\t\t\t\t\tmatJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.NormalBlending;\n\n\t\t\t\t} else if ( parID === \"combine\" ) {\n\n\t\t\t\t\tmatJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.MultiplyOperation;\n\n\t\t\t\t} else if ( parID === \"vertexColors\" ) {\n\n\t\t\t\t\tif ( matJSON.parameters[ parID ] == \"face\" ) {\n\n\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.FaceColors;\n\n\t\t\t\t\t// default to vertex colors if \"vertexColors\" is anything else face colors or 0 / null / false\n\n\t\t\t\t\t} else if ( matJSON.parameters[ parID ] ) {\n\n\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.VertexColors;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( parID === \"wrapRGB\" ) {\n\n\t\t\t\t\tvar v3 = matJSON.parameters[ parID ];\n\t\t\t\t\tmatJSON.parameters[ parID ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0 ) {\n\n\t\t\t\tmatJSON.parameters.transparent = true;\n\n\t\t\t}\n\n\t\t\tif ( matJSON.parameters.normalMap ) {\n\n\t\t\t\tvar shader = THREE.ShaderLib[ \"normalmap\" ];\n\t\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\t\t\tvar diffuse = matJSON.parameters.color;\n\t\t\t\tvar specular = matJSON.parameters.specular;\n\t\t\t\tvar ambient = matJSON.parameters.ambient;\n\t\t\t\tvar shininess = matJSON.parameters.shininess;\n\n\t\t\t\tuniforms[ \"tNormal\" ].value = result.textures[ matJSON.parameters.normalMap ];\n\n\t\t\t\tif ( matJSON.parameters.normalScale ) {\n\n\t\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( matJSON.parameters.normalScale[ 0 ], matJSON.parameters.normalScale[ 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( matJSON.parameters.map ) {\n\n\t\t\t\t\tuniforms[ \"tDiffuse\" ].value = matJSON.parameters.map;\n\t\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( matJSON.parameters.envMap ) {\n\n\t\t\t\t\tuniforms[ \"tCube\" ].value = matJSON.parameters.envMap;\n\t\t\t\t\tuniforms[ \"enableReflection\" ].value = true;\n\t\t\t\t\tuniforms[ \"reflectivity\" ].value = matJSON.parameters.reflectivity;\n\n\t\t\t\t}\n\n\t\t\t\tif ( matJSON.parameters.lightMap ) {\n\n\t\t\t\t\tuniforms[ \"tAO\" ].value = matJSON.parameters.lightMap;\n\t\t\t\t\tuniforms[ \"enableAO\" ].value = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( matJSON.parameters.specularMap ) {\n\n\t\t\t\t\tuniforms[ \"tSpecular\" ].value = result.textures[ matJSON.parameters.specularMap ];\n\t\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( matJSON.parameters.displacementMap ) {\n\n\t\t\t\t\tuniforms[ \"tDisplacement\" ].value = result.textures[ matJSON.parameters.displacementMap ];\n\t\t\t\t\tuniforms[ \"enableDisplacement\" ].value = true;\n\n\t\t\t\t\tuniforms[ \"uDisplacementBias\" ].value = matJSON.parameters.displacementBias;\n\t\t\t\t\tuniforms[ \"uDisplacementScale\" ].value = matJSON.parameters.displacementScale;\n\n\t\t\t\t}\n\n\t\t\t\tuniforms[ \"diffuse\" ].value.setHex( diffuse );\n\t\t\t\tuniforms[ \"specular\" ].value.setHex( specular );\n\t\t\t\tuniforms[ \"ambient\" ].value.setHex( ambient );\n\n\t\t\t\tuniforms[ \"shininess\" ].value = shininess;\n\n\t\t\t\tif ( matJSON.parameters.opacity ) {\n\n\t\t\t\t\tuniforms[ \"opacity\" ].value = matJSON.parameters.opacity;\n\n\t\t\t\t}\n\n\t\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\n\n\t\t\t\tmaterial = new THREE.ShaderMaterial( parameters );\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = new THREE[ matJSON.type ]( matJSON.parameters );\n\n\t\t\t}\n\n\t\t\tmaterial.name = matID;\n\n\t\t\tresult.materials[ matID ] = material;\n\n\t\t}\n\n\t\t// second pass through all materials to initialize MeshFaceMaterials\n\t\t// that could be referring to other materials out of order\n\n\t\tfor ( matID in data.materials ) {\n\n\t\t\tmatJSON = data.materials[ matID ];\n\n\t\t\tif ( matJSON.parameters.materials ) {\n\n\t\t\t\tvar materialArray = [];\n\n\t\t\t\tfor ( var i = 0; i < matJSON.parameters.materials.length; i ++ ) {\n\n\t\t\t\t\tvar label = matJSON.parameters.materials[ i ];\n\t\t\t\t\tmaterialArray.push( result.materials[ label ] );\n\n\t\t\t\t}\n\n\t\t\t\tresult.materials[ matID ].materials = materialArray;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// objects ( synchronous init of procedural primitives )\n\n\t\thandle_objects();\n\n\t\t// defaults\n\n\t\tif ( result.cameras && data.defaults.camera ) {\n\n\t\t\tresult.currentCamera = result.cameras[ data.defaults.camera ];\n\n\t\t}\n\n\t\tif ( result.fogs && data.defaults.fog ) {\n\n\t\t\tresult.scene.fog = result.fogs[ data.defaults.fog ];\n\n\t\t}\n\n\t\t// synchronous callback\n\n\t\tscope.callbackSync( result );\n\n\t\t// just in case there are no async elements\n\n\t\tasync_callback_gate();\n\n\t}\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.TextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nTHREE.TextureLoader.prototype = {\n\n\tconstructor: THREE.TextureLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.ImageLoader( scope.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.load( url, function ( image ) {\n\n\t\t\tvar texture = new THREE.Texture( image );\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t} );\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Material = function () {\n\n\tthis.id = THREE.MaterialIdCount ++;\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\n\tthis.side = THREE.FrontSide;\n\n\tthis.opacity = 1;\n\tthis.transparent = false;\n\n\tthis.blending = THREE.NormalBlending;\n\n\tthis.blendSrc = THREE.SrcAlphaFactor;\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\n\tthis.blendEquation = THREE.AddEquation;\n\n\tthis.depthTest = true;\n\tthis.depthWrite = true;\n\n\tthis.polygonOffset = false;\n\tthis.polygonOffsetFactor = 0;\n\tthis.polygonOffsetUnits = 0;\n\n\tthis.alphaTest = 0;\n\n\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\n\tthis.visible = true;\n\n\tthis.needsUpdate = true;\n\n};\n\nTHREE.Material.prototype = {\n\n\tconstructor: THREE.Material,\n\n\tsetValues: function ( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( var key in values ) {\n\n\t\t\tvar newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Material: \\'' + key + '\\' parameter is undefined.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( key in this ) {\n\n\t\t\t\tvar currentValue = this[ key ];\n\n\t\t\t\tif ( currentValue instanceof THREE.Color ) {\n\n\t\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\n\n\t\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t\t} else if ( key == 'overdraw') {\n\n\t\t\t\t\t// ensure overdraw is backwards-compatable with legacy boolean type\n\t\t\t\t\tthis[ key ] = Number(newValue);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tclone: function ( material ) {\n\n\t\tif ( material === undefined ) material = new THREE.Material();\n\n\t\tmaterial.name = this.name;\n\n\t\tmaterial.side = this.side;\n\n\t\tmaterial.opacity = this.opacity;\n\t\tmaterial.transparent = this.transparent;\n\n\t\tmaterial.blending = this.blending;\n\n\t\tmaterial.blendSrc = this.blendSrc;\n\t\tmaterial.blendDst = this.blendDst;\n\t\tmaterial.blendEquation = this.blendEquation;\n\n\t\tmaterial.depthTest = this.depthTest;\n\t\tmaterial.depthWrite = this.depthWrite;\n\n\t\tmaterial.polygonOffset = this.polygonOffset;\n\t\tmaterial.polygonOffsetFactor = this.polygonOffsetFactor;\n\t\tmaterial.polygonOffsetUnits = this.polygonOffsetUnits;\n\n\t\tmaterial.alphaTest = this.alphaTest;\n\n\t\tmaterial.overdraw = this.overdraw;\n\n\t\tmaterial.visible = this.visible;\n\n\t\treturn material;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nTHREE.EventDispatcher.prototype.apply( THREE.Material.prototype );\n\nTHREE.MaterialIdCount = 0;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\",\n *\n *  vertexColors: <bool>\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.LineBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\tthis.linecap = 'round';\n\tthis.linejoin = 'round';\n\n\tthis.vertexColors = false;\n\n\tthis.fog = true;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.LineBasicMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.LineBasicMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\n\tmaterial.linewidth = this.linewidth;\n\tmaterial.linecap = this.linecap;\n\tmaterial.linejoin = this.linejoin;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.fog = this.fog;\n\n\treturn material;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  linewidth: <float>,\n *\n *  scale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>,\n *\n *  vertexColors: <bool>\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.LineDashedMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\n\tthis.scale = 1;\n\tthis.dashSize = 3;\n\tthis.gapSize = 1;\n\n\tthis.vertexColors = false;\n\n\tthis.fog = true;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.LineDashedMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.LineDashedMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\n\tmaterial.linewidth = this.linewidth;\n\n\tmaterial.scale = this.scale;\n\tmaterial.dashSize = this.dashSize;\n\tmaterial.gapSize = this.gapSize;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.fog = this.fog;\n\n\treturn material;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.MeshBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.fog = true;\n\n\tthis.shading = THREE.SmoothShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.vertexColors = THREE.NoColors;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshBasicMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshBasicMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\n\tmaterial.map = this.map;\n\n\tmaterial.lightMap = this.lightMap;\n\n\tmaterial.specularMap = this.specularMap;\n\n\tmaterial.envMap = this.envMap;\n\tmaterial.combine = this.combine;\n\tmaterial.reflectivity = this.reflectivity;\n\tmaterial.refractionRatio = this.refractionRatio;\n\n\tmaterial.fog = this.fog;\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.skinning = this.skinning;\n\tmaterial.morphTargets = this.morphTargets;\n\n\treturn material;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  ambient: <hex>,\n *  emissive: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *\tfog: <bool>\n * }\n */\n\nTHREE.MeshLambertMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.ambient = new THREE.Color( 0xffffff );\n\tthis.emissive = new THREE.Color( 0x000000 );\n\n\tthis.wrapAround = false;\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.fog = true;\n\n\tthis.shading = THREE.SmoothShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.vertexColors = THREE.NoColors;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshLambertMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshLambertMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\tmaterial.ambient.copy( this.ambient );\n\tmaterial.emissive.copy( this.emissive );\n\n\tmaterial.wrapAround = this.wrapAround;\n\tmaterial.wrapRGB.copy( this.wrapRGB );\n\n\tmaterial.map = this.map;\n\n\tmaterial.lightMap = this.lightMap;\n\n\tmaterial.specularMap = this.specularMap;\n\n\tmaterial.envMap = this.envMap;\n\tmaterial.combine = this.combine;\n\tmaterial.reflectivity = this.reflectivity;\n\tmaterial.refractionRatio = this.refractionRatio;\n\n\tmaterial.fog = this.fog;\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.skinning = this.skinning;\n\tmaterial.morphTargets = this.morphTargets;\n\tmaterial.morphNormals = this.morphNormals;\n\n\treturn material;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  ambient: <hex>,\n *  emissive: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *\tfog: <bool>\n * }\n */\n\nTHREE.MeshPhongMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.ambient = new THREE.Color( 0xffffff );\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.specular = new THREE.Color( 0x111111 );\n\tthis.shininess = 30;\n\n\tthis.metal = false;\n\tthis.perPixel = true;\n\n\tthis.wrapAround = false;\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\n\tthis.specularMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.fog = true;\n\n\tthis.shading = THREE.SmoothShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.vertexColors = THREE.NoColors;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshPhongMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshPhongMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\tmaterial.ambient.copy( this.ambient );\n\tmaterial.emissive.copy( this.emissive );\n\tmaterial.specular.copy( this.specular );\n\tmaterial.shininess = this.shininess;\n\n\tmaterial.metal = this.metal;\n\tmaterial.perPixel = this.perPixel;\n\n\tmaterial.wrapAround = this.wrapAround;\n\tmaterial.wrapRGB.copy( this.wrapRGB );\n\n\tmaterial.map = this.map;\n\n\tmaterial.lightMap = this.lightMap;\n\n\tmaterial.bumpMap = this.bumpMap;\n\tmaterial.bumpScale = this.bumpScale;\n\n\tmaterial.normalMap = this.normalMap;\n\tmaterial.normalScale.copy( this.normalScale );\n\n\tmaterial.specularMap = this.specularMap;\n\n\tmaterial.envMap = this.envMap;\n\tmaterial.combine = this.combine;\n\tmaterial.reflectivity = this.reflectivity;\n\tmaterial.refractionRatio = this.refractionRatio;\n\n\tmaterial.fog = this.fog;\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.skinning = this.skinning;\n\tmaterial.morphTargets = this.morphTargets;\n\tmaterial.morphNormals = this.morphNormals;\n\n\treturn material;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  opacity: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshDepthMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshDepthMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshDepthMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\n\treturn material;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  opacity: <float>,\n *\n *  shading: THREE.FlatShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshNormalMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this, parameters );\n\n\tthis.shading = THREE.FlatShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.morphTargets = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshNormalMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshNormalMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\n\treturn material;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.MeshFaceMaterial = function ( materials ) {\n\n\tthis.materials = materials instanceof Array ? materials : [];\n\n};\n\nTHREE.MeshFaceMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshFaceMaterial();\n\n\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\n\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\n\t}\n\n\treturn material;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  vertexColors: <bool>,\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.ParticleSystemMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.map = null;\n\n\tthis.size = 1;\n\tthis.sizeAttenuation = true;\n\n\tthis.vertexColors = false;\n\n\tthis.fog = true;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.ParticleSystemMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.ParticleSystemMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.ParticleSystemMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\n\tmaterial.map = this.map;\n\n\tmaterial.size = this.size;\n\tmaterial.sizeAttenuation = this.sizeAttenuation;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.fog = this.fog;\n\n\treturn material;\n\n};\n\n// backwards compatibility\n\nTHREE.ParticleBasicMaterial = THREE.ParticleSystemMaterial;\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\n *\n *  defines: { \"label\" : \"value\" },\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *\tfog: <bool>\n * }\n */\n\nTHREE.ShaderMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.fragmentShader = \"void main() {}\";\n\tthis.vertexShader = \"void main() {}\";\n\tthis.uniforms = {};\n\tthis.defines = {};\n\tthis.attributes = null;\n\n\tthis.shading = THREE.SmoothShading;\n\n\tthis.linewidth = 1;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false; // set to use scene fog\n\n\tthis.lights = false; // set to use scene lights\n\n\tthis.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\n\n\tthis.skinning = false; // set to use skinning attribute streams\n\n\tthis.morphTargets = false; // set to use morph targets\n\tthis.morphNormals = false; // set to use morph normals\n\n\t// When rendered geometry doesn't include these attributes but the material does,\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\tthis.defaultAttributeValues = {\n\t\t\"color\" : [ 1, 1, 1],\n\t\t\"uv\" : [ 0, 0 ],\n\t\t\"uv2\" : [ 0, 0 ]\n\t};\n\n\t// By default, bind position to attribute index 0. In WebGL, attribute 0\n\t// should always be used to avoid potentially expensive emulation.\n\tthis.index0AttributeName = \"position\";\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.ShaderMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.ShaderMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.fragmentShader = this.fragmentShader;\n\tmaterial.vertexShader = this.vertexShader;\n\n\tmaterial.uniforms = THREE.UniformsUtils.clone( this.uniforms );\n\n\tmaterial.attributes = this.attributes;\n\tmaterial.defines = this.defines;\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\n\tmaterial.fog = this.fog;\n\n\tmaterial.lights = this.lights;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.skinning = this.skinning;\n\n\tmaterial.morphTargets = this.morphTargets;\n\tmaterial.morphNormals = this.morphNormals;\n\n\treturn material;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *\tuvOffset: new THREE.Vector2(),\n *\tuvScale: new THREE.Vector2(),\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.SpriteMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\t// defaults\n\n\tthis.color = new THREE.Color( 0xffffff );\n\tthis.map = null;\n\n\tthis.rotation = 0;\n\n\tthis.fog = false;\n\n\t// set parameters\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.SpriteMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.SpriteMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\tmaterial.map = this.map;\n\n\tmaterial.rotation = this.rotation;\n\n\tmaterial.fog = this.fog;\n\n\treturn material;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  color: <hex>,\n *  program: <function>,\n *  opacity: <float>,\n *  blending: THREE.NormalBlending\n * }\n */\n\nTHREE.SpriteCanvasMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff );\n\tthis.program = function ( context, color ) {};\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.SpriteCanvasMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.SpriteCanvasMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.SpriteCanvasMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\tmaterial.program = this.program;\n\n\treturn material;\n\n};\n\n// backwards compatibility\n\nTHREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial;\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tthis.id = THREE.TextureIdCount ++;\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\n\tthis.image = image;\n\tthis.mipmaps = [];\n\n\tthis.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();\n\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\n\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\n\n\tthis.offset = new THREE.Vector2( 0, 0 );\n\tthis.repeat = new THREE.Vector2( 1, 1 );\n\n\tthis.generateMipmaps = true;\n\tthis.premultiplyAlpha = false;\n\tthis.flipY = true;\n\tthis.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\tthis._needsUpdate = false;\n\tthis.onUpdate = null;\n\n};\n\nTHREE.Texture.prototype = {\n\n\tconstructor: THREE.Texture,\n\n\tget needsUpdate () {\n\n\t\treturn this._needsUpdate;\n\n\t},\n\n\tset needsUpdate ( value ) {\n\n\t\tif ( value === true ) this.update();\n\n\t\tthis._needsUpdate = value;\n\n\t},\n\n\tclone: function ( texture ) {\n\n\t\tif ( texture === undefined ) texture = new THREE.Texture();\n\n\t\ttexture.image = this.image;\n\t\ttexture.mipmaps = this.mipmaps.slice(0);\n\n\t\ttexture.mapping = this.mapping;\n\n\t\ttexture.wrapS = this.wrapS;\n\t\ttexture.wrapT = this.wrapT;\n\n\t\ttexture.magFilter = this.magFilter;\n\t\ttexture.minFilter = this.minFilter;\n\n\t\ttexture.anisotropy = this.anisotropy;\n\n\t\ttexture.format = this.format;\n\t\ttexture.type = this.type;\n\n\t\ttexture.offset.copy( this.offset );\n\t\ttexture.repeat.copy( this.repeat );\n\n\t\ttexture.generateMipmaps = this.generateMipmaps;\n\t\ttexture.premultiplyAlpha = this.premultiplyAlpha;\n\t\ttexture.flipY = this.flipY;\n\t\ttexture.unpackAlignment = this.unpackAlignment;\n\n\t\treturn texture;\n\n\t},\n\n\tupdate: function () {\n\n\t\tthis.dispatchEvent( { type: 'update' } );\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nTHREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );\n\nTHREE.TextureIdCount = 0;\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.image = { width: width, height: height };\n\tthis.mipmaps = mipmaps;\n\n\tthis.generateMipmaps = false; // WebGL currently can't generate mipmaps for compressed textures, they must be embedded in DDS file\n\n};\n\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\n\nTHREE.CompressedTexture.prototype.clone = function () {\n\n\tvar texture = new THREE.CompressedTexture();\n\n\tTHREE.Texture.prototype.clone.call( this, texture );\n\n\treturn texture;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.image = { data: data, width: width, height: height };\n\n};\n\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\n\nTHREE.DataTexture.prototype.clone = function () {\n\n\tvar texture = new THREE.DataTexture();\n\n\tTHREE.Texture.prototype.clone.call( this, texture );\n\n\treturn texture;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ParticleSystem = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\n\tthis.material = material !== undefined ? material : new THREE.ParticleSystemMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.sortParticles = false;\n\tthis.frustumCulled = false;\n\n};\n\nTHREE.ParticleSystem.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.ParticleSystem.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.ParticleSystem( this.geometry, this.material );\n\n\tobject.sortParticles = this.sortParticles;\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Line = function ( geometry, material, type ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\n\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.type = ( type !== undefined ) ? type : THREE.LineStrip;\n\n};\n\nTHREE.LineStrip = 0;\nTHREE.LinePieces = 1;\n\nTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Line.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.type );\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author jonobr1 / http://jonobr1.com/\n */\n\nTHREE.Mesh = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\n\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.updateMorphTargets();\n\n};\n\nTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Mesh.prototype.updateMorphTargets = function () {\n\n\tif ( this.geometry.morphTargets.length > 0 ) {\n\n\t\tthis.morphTargetBase = -1;\n\t\tthis.morphTargetForcedOrder = [];\n\t\tthis.morphTargetInfluences = [];\n\t\tthis.morphTargetDictionary = {};\n\n\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\n\n\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\n\n\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\n\n\t\treturn this.morphTargetDictionary[ name ];\n\n\t}\n\n\tconsole.log( \"THREE.Mesh.getMorphTargetIndexByName: morph target \" + name + \" does not exist. Returning 0.\" );\n\n\treturn 0;\n\n};\n\nTHREE.Mesh.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Bone = function( belongsToSkin ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.skin = belongsToSkin;\n\tthis.skinMatrix = new THREE.Matrix4();\n\n};\n\nTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Bone.prototype.update = function ( parentSkinMatrix, forceUpdate ) {\n\n\t// update local\n\n\tif ( this.matrixAutoUpdate ) {\n\n\t\tforceUpdate |= this.updateMatrix();\n\n\t}\n\n\t// update skin matrix\n\n\tif ( forceUpdate || this.matrixWorldNeedsUpdate ) {\n\n\t\tif( parentSkinMatrix ) {\n\n\t\t\tthis.skinMatrix.multiplyMatrices( parentSkinMatrix, this.matrix );\n\n\t\t} else {\n\n\t\t\tthis.skinMatrix.copy( this.matrix );\n\n\t\t}\n\n\t\tthis.matrixWorldNeedsUpdate = false;\n\t\tforceUpdate = true;\n\n\t}\n\n\t// update children\n\n\tvar child, i, l = this.children.length;\n\n\tfor ( i = 0; i < l; i ++ ) {\n\n\t\tthis.children[ i ].update( this.skinMatrix, forceUpdate );\n\n\t}\n\n};\n\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\t//\n\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\n\t// init bones\n\n\tthis.identityMatrix = new THREE.Matrix4();\n\n\tthis.bones = [];\n\tthis.boneMatrices = [];\n\n\tvar b, bone, gbone, p, q, s;\n\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\n\t\tfor ( b = 0; b < this.geometry.bones.length; b ++ ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\tp = gbone.pos;\n\t\t\tq = gbone.rotq;\n\t\t\ts = gbone.scl;\n\n\t\t\tbone = this.addBone();\n\n\t\t\tbone.name = gbone.name;\n\t\t\tbone.position.set( p[0], p[1], p[2] );\n\t\t\tbone.quaternion.set( q[0], q[1], q[2], q[3] );\n\t\t\n\t\t\tif ( s !== undefined ) {\n\n\t\t\t\tbone.scale.set( s[0], s[1], s[2] );\n\n\t\t\t} else {\n\n\t\t\t\tbone.scale.set( 1, 1, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( b = 0; b < this.bones.length; b ++ ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\t\t\tbone = this.bones[ b ];\n\n\t\t\tif ( gbone.parent === -1 ) {\n\n\t\t\t\tthis.add( bone );\n\n\t\t\t} else {\n\n\t\t\t\tthis.bones[ gbone.parent ].add( bone );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tvar nBones = this.bones.length;\n\n\t\tif ( this.useVertexTexture ) {\n\n\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t//\tRGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)\n\t\t\t//  \t 16x16 pixel texture max   64 bones (16 * 16 / 4)\n\t\t\t//  \t 32x32 pixel texture max  256 bones (32 * 32 / 4)\n\t\t\t//  \t 64x64 pixel texture max 1024 bones (64 * 64 / 4)\n\n\t\t\tvar size;\n\n\t\t\tif ( nBones > 256 )\n\t\t\t\tsize = 64;\n\t\t\telse if ( nBones > 64 )\n\t\t\t\tsize = 32;\n\t\t\telse if ( nBones > 16 )\n\t\t\t\tsize = 16;\n\t\t\telse\n\t\t\t\tsize = 8;\n\n\t\t\tthis.boneTextureWidth = size;\n\t\t\tthis.boneTextureHeight = size;\n\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\n\t\t\tthis.boneTexture.minFilter = THREE.NearestFilter;\n\t\t\tthis.boneTexture.magFilter = THREE.NearestFilter;\n\t\t\tthis.boneTexture.generateMipmaps = false;\n\t\t\tthis.boneTexture.flipY = false;\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = new Float32Array( 16 * nBones );\n\n\t\t}\n\n\t\tthis.pose();\n\n\t}\n\n};\n\nTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\n\nTHREE.SkinnedMesh.prototype.addBone = function( bone ) {\n\n\tif ( bone === undefined ) {\n\n\t\tbone = new THREE.Bone( this );\n\n\t}\n\n\tthis.bones.push( bone );\n\n\treturn bone;\n\n};\n\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function () {\n\n\tvar offsetMatrix = new THREE.Matrix4();\n\n\treturn function ( force ) {\n\n\t\tthis.matrixAutoUpdate && this.updateMatrix();\n\n\t\t// update matrixWorld\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.parent ) {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\n\t\t\tif ( child instanceof THREE.Bone ) {\n\n\t\t\t\tchild.update( this.identityMatrix, false );\n\n\t\t\t} else {\n\n\t\t\t\tchild.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// make a snapshot of the bones' rest position\n\n\t\tif ( this.boneInverses == undefined ) {\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tvar inverse = new THREE.Matrix4();\n\n\t\t\t\tinverse.getInverse( this.bones[ b ].skinMatrix );\n\n\t\t\t\tthis.boneInverses.push( inverse );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flatten bone matrices to array\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t// compute the offset between the current and the original transform;\n\n\t\t\t// TODO: we could get rid of this multiplication step if the skinMatrix\n\t\t\t// was already representing the offset; however, this requires some\n\t\t\t// major changes to the animation system\n\n\t\t\toffsetMatrix.multiplyMatrices( this.bones[ b ].skinMatrix, this.boneInverses[ b ] );\n\t\t\toffsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\n\n\t\t}\n\n\t\tif ( this.useVertexTexture ) {\n\n\t\t\tthis.boneTexture.needsUpdate = true;\n\n\t\t}\n\n\t};\n\n}();\n\nTHREE.SkinnedMesh.prototype.pose = function () {\n\n\tthis.updateMatrixWorld( true );\n\n\tthis.normalizeSkinWeights();\n\n};\n\nTHREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\n\n\tif ( this.geometry instanceof THREE.Geometry ) {\n\n\t\tfor ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {\n\n\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\n\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\n\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\tsw.multiplyScalar( scale );\n\n\t\t\t} else {\n\n\t\t\t\tsw.set( 1 ); // this will be normalized by the shader anyway\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// skinning weights assumed to be normalized for THREE.BufferGeometry\n\n\t}\n\n};\n\nTHREE.SkinnedMesh.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) {\n\n\t\tobject = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );\n\n\t}\n\n\tTHREE.Mesh.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.MorphAnimMesh = function ( geometry, material ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\t// API\n\n\tthis.duration = 1000; // milliseconds\n\tthis.mirroredLoop = false;\n\tthis.time = 0;\n\n\t// internals\n\n\tthis.lastKeyframe = 0;\n\tthis.currentKeyframe = 0;\n\n\tthis.direction = 1;\n\tthis.directionBackwards = false;\n\n\tthis.setFrameRange( 0, this.geometry.morphTargets.length - 1 );\n\n};\n\nTHREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );\n\nTHREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {\n\n\tthis.startKeyframe = start;\n\tthis.endKeyframe = end;\n\n\tthis.length = this.endKeyframe - this.startKeyframe + 1;\n\n};\n\nTHREE.MorphAnimMesh.prototype.setDirectionForward = function () {\n\n\tthis.direction = 1;\n\tthis.directionBackwards = false;\n\n};\n\nTHREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\n\n\tthis.direction = -1;\n\tthis.directionBackwards = true;\n\n};\n\nTHREE.MorphAnimMesh.prototype.parseAnimations = function () {\n\n\tvar geometry = this.geometry;\n\n\tif ( ! geometry.animations ) geometry.animations = {};\n\n\tvar firstAnimation, animations = geometry.animations;\n\n\tvar pattern = /([a-z]+)(\\d+)/;\n\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\n\t\tvar morph = geometry.morphTargets[ i ];\n\t\tvar parts = morph.name.match( pattern );\n\n\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\tvar label = parts[ 1 ];\n\t\t\tvar num = parts[ 2 ];\n\n\t\t\tif ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: -Infinity };\n\n\t\t\tvar animation = animations[ label ];\n\n\t\t\tif ( i < animation.start ) animation.start = i;\n\t\t\tif ( i > animation.end ) animation.end = i;\n\n\t\t\tif ( ! firstAnimation ) firstAnimation = label;\n\n\t\t}\n\n\t}\n\n\tgeometry.firstAnimation = firstAnimation;\n\n};\n\nTHREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {\n\n\tif ( ! this.geometry.animations ) this.geometry.animations = {};\n\n\tthis.geometry.animations[ label ] = { start: start, end: end };\n\n};\n\nTHREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {\n\n\tvar animation = this.geometry.animations[ label ];\n\n\tif ( animation ) {\n\n\t\tthis.setFrameRange( animation.start, animation.end );\n\t\tthis.duration = 1000 * ( ( animation.end - animation.start ) / fps );\n\t\tthis.time = 0;\n\n\t} else {\n\n\t\tconsole.warn( \"animation[\" + label + \"] undefined\" );\n\n\t}\n\n};\n\nTHREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {\n\n\tvar frameTime = this.duration / this.length;\n\n\tthis.time += this.direction * delta;\n\n\tif ( this.mirroredLoop ) {\n\n\t\tif ( this.time > this.duration || this.time < 0 ) {\n\n\t\t\tthis.direction *= -1;\n\n\t\t\tif ( this.time > this.duration ) {\n\n\t\t\t\tthis.time = this.duration;\n\t\t\t\tthis.directionBackwards = true;\n\n\t\t\t}\n\n\t\t\tif ( this.time < 0 ) {\n\n\t\t\t\tthis.time = 0;\n\t\t\t\tthis.directionBackwards = false;\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tthis.time = this.time % this.duration;\n\n\t\tif ( this.time < 0 ) this.time += this.duration;\n\n\t}\n\n\tvar keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );\n\n\tif ( keyframe !== this.currentKeyframe ) {\n\n\t\tthis.morphTargetInfluences[ this.lastKeyframe ] = 0;\n\t\tthis.morphTargetInfluences[ this.currentKeyframe ] = 1;\n\n\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\n\t\tthis.lastKeyframe = this.currentKeyframe;\n\t\tthis.currentKeyframe = keyframe;\n\n\t}\n\n\tvar mix = ( this.time % frameTime ) / frameTime;\n\n\tif ( this.directionBackwards ) {\n\n\t\tmix = 1 - mix;\n\n\t}\n\n\tthis.morphTargetInfluences[ this.currentKeyframe ] = mix;\n\tthis.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;\n\n};\n\nTHREE.MorphAnimMesh.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );\n\n\tobject.duration = this.duration;\n\tobject.mirroredLoop = this.mirroredLoop;\n\tobject.time = this.time;\n\n\tobject.lastKeyframe = this.lastKeyframe;\n\tobject.currentKeyframe = this.currentKeyframe;\n\n\tobject.direction = this.direction;\n\tobject.directionBackwards = this.directionBackwards;\n\n\tTHREE.Mesh.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LOD = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.objects = [];\n\n};\n\n\nTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.LOD.prototype.addLevel = function ( object, distance ) {\n\n\tif ( distance === undefined ) distance = 0;\n\n\tdistance = Math.abs( distance );\n\n\tfor ( var l = 0; l < this.objects.length; l ++ ) {\n\n\t\tif ( distance < this.objects[ l ].distance ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tthis.objects.splice( l, 0, { distance: distance, object: object } );\n\tthis.add( object );\n\n};\n\nTHREE.LOD.prototype.getObjectForDistance = function ( distance ) {\n\n\tfor ( var i = 1, l = this.objects.length; i < l; i ++ ) {\n\n\t\tif ( distance < this.objects[ i ].distance ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn this.objects[ i - 1 ].object;\n\n};\n\nTHREE.LOD.prototype.update = function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\n\treturn function ( camera ) {\n\n\t\tif ( this.objects.length > 1 ) {\n\n\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tvar distance = v1.distanceTo( v2 );\n\n\t\t\tthis.objects[ 0 ].object.visible = true;\n\n\t\t\tfor ( var i = 1, l = this.objects.length; i < l; i ++ ) {\n\n\t\t\t\tif ( distance >= this.objects[ i ].distance ) {\n\n\t\t\t\t\tthis.objects[ i - 1 ].object.visible = false;\n\t\t\t\t\tthis.objects[ i     ].object.visible = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor( ; i < l; i ++ ) {\n\n\t\t\t\tthis.objects[ i ].object.visible = false;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n}();\n\nTHREE.LOD.prototype.clone = function () {\n\n\t// TODO\n\n};\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Sprite = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\n\n};\n\nTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\n\n/*\n * Custom update matrix\n */\n\nTHREE.Sprite.prototype.updateMatrix = function () {\n\n\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\tthis.matrixWorldNeedsUpdate = true;\n\n};\n\nTHREE.Sprite.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Sprite( this.material );\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n\n// Backwards compatibility\n\nTHREE.Particle = THREE.Sprite;\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Scene = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.fog = null;\n\tthis.overrideMaterial = null;\n\n\tthis.autoUpdate = true; // checked by the renderer\n\tthis.matrixAutoUpdate = false;\n\n\tthis.__lights = [];\n\n\tthis.__objectsAdded = [];\n\tthis.__objectsRemoved = [];\n\n};\n\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Scene.prototype.__addObject = function ( object ) {\n\n\tif ( object instanceof THREE.Light ) {\n\n\t\tif ( this.__lights.indexOf( object ) === - 1 ) {\n\n\t\t\tthis.__lights.push( object );\n\n\t\t}\n\n\t\tif ( object.target && object.target.parent === undefined ) {\n\n\t\t\tthis.add( object.target );\n\n\t\t}\n\n\t} else if ( !( object instanceof THREE.Camera || object instanceof THREE.Bone ) ) {\n\n\t\tthis.__objectsAdded.push( object );\n\n\t\t// check if previously removed\n\n\t\tvar i = this.__objectsRemoved.indexOf( object );\n\n\t\tif ( i !== -1 ) {\n\n\t\t\tthis.__objectsRemoved.splice( i, 1 );\n\n\t\t}\n\n\t}\n\n\tthis.dispatchEvent( { type: 'objectAdded', object: object } );\n\tobject.dispatchEvent( { type: 'addedToScene', scene: this } );\n\n\tfor ( var c = 0; c < object.children.length; c ++ ) {\n\n\t\tthis.__addObject( object.children[ c ] );\n\n\t}\n\n};\n\nTHREE.Scene.prototype.__removeObject = function ( object ) {\n\n\tif ( object instanceof THREE.Light ) {\n\n\t\tvar i = this.__lights.indexOf( object );\n\n\t\tif ( i !== -1 ) {\n\n\t\t\tthis.__lights.splice( i, 1 );\n\n\t\t}\n\n\t\tif ( object.shadowCascadeArray ) {\n\n\t\t\tfor ( var x = 0; x < object.shadowCascadeArray.length; x ++ ) {\n\n\t\t\t\tthis.__removeObject( object.shadowCascadeArray[ x ] );\n\n\t\t\t}\n\n\t\t}\n\n\t} else if ( !( object instanceof THREE.Camera ) ) {\n\n\t\tthis.__objectsRemoved.push( object );\n\n\t\t// check if previously added\n\n\t\tvar i = this.__objectsAdded.indexOf( object );\n\n\t\tif ( i !== -1 ) {\n\n\t\t\tthis.__objectsAdded.splice( i, 1 );\n\n\t\t}\n\n\t}\n\n\tthis.dispatchEvent( { type: 'objectRemoved', object: object } );\n\tobject.dispatchEvent( { type: 'removedFromScene', scene: this } );\n\n\tfor ( var c = 0; c < object.children.length; c ++ ) {\n\n\t\tthis.__removeObject( object.children[ c ] );\n\n\t}\n\n};\n\nTHREE.Scene.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Scene();\n\n\tTHREE.Object3D.prototype.clone.call(this, object);\n\n\tif ( this.fog !== null ) object.fog = this.fog.clone();\n\tif ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();\n\n\tobject.autoUpdate = this.autoUpdate;\n\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\n\n\treturn object;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Fog = function ( hex, near, far ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( hex );\n\n\tthis.near = ( near !== undefined ) ? near : 1;\n\tthis.far = ( far !== undefined ) ? far : 1000;\n\n};\n\nTHREE.Fog.prototype.clone = function () {\n\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.FogExp2 = function ( hex, density ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( hex );\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n};\n\nTHREE.FogExp2.prototype.clone = function () {\n\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CanvasRenderer = function ( parameters ) {\n\n\tconsole.log( 'THREE.CanvasRenderer', THREE.REVISION );\n\n\tvar smoothstep = THREE.Math.smoothstep;\n\n\tparameters = parameters || {};\n\n\tvar _this = this,\n\t_renderData, _elements, _lights,\n\t_projector = new THREE.Projector(),\n\n\t_canvas = parameters.canvas !== undefined\n\t\t\t? parameters.canvas\n\t\t\t: document.createElement( 'canvas' ),\n\n\t_canvasWidth = _canvas.width,\n\t_canvasHeight = _canvas.height,\n\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 ),\n\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 ),\n\t\n\t_context = _canvas.getContext( '2d' ),\n\n\t_clearColor = new THREE.Color( 0x000000 ),\n\t_clearAlpha = 0,\n\n\t_contextGlobalAlpha = 1,\n\t_contextGlobalCompositeOperation = 0,\n\t_contextStrokeStyle = null,\n\t_contextFillStyle = null,\n\t_contextLineWidth = null,\n\t_contextLineCap = null,\n\t_contextLineJoin = null,\n\t_contextDashSize = null,\n\t_contextGapSize = 0,\n\n\t_camera,\n\n\t_v1, _v2, _v3, _v4,\n\t_v5 = new THREE.RenderableVertex(),\n\t_v6 = new THREE.RenderableVertex(),\n\n\t_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,\n\t_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,\n\n\t_color = new THREE.Color(),\n\t_color1 = new THREE.Color(),\n\t_color2 = new THREE.Color(),\n\t_color3 = new THREE.Color(),\n\t_color4 = new THREE.Color(),\n\n\t_diffuseColor = new THREE.Color(),\n\t_emissiveColor = new THREE.Color(),\n\n\t_lightColor = new THREE.Color(),\n\n\t_patterns = {},\n\n\t_near, _far,\n\n\t_image, _uvs,\n\t_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,\n\n\t_clipBox = new THREE.Box2(),\n\t_clearBox = new THREE.Box2(),\n\t_elemBox = new THREE.Box2(),\n\n\t_ambientLight = new THREE.Color(),\n\t_directionalLights = new THREE.Color(),\n\t_pointLights = new THREE.Color(),\n\n\t_vector3 = new THREE.Vector3(), // Needed for PointLight\n\n\t_pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData,\n\t_gradientMap, _gradientMapContext, _gradientMapQuality = 16;\n\n\t_pixelMap = document.createElement( 'canvas' );\n\t_pixelMap.width = _pixelMap.height = 2;\n\n\t_pixelMapContext = _pixelMap.getContext( '2d' );\n\t_pixelMapContext.fillStyle = 'rgba(0,0,0,1)';\n\t_pixelMapContext.fillRect( 0, 0, 2, 2 );\n\n\t_pixelMapImage = _pixelMapContext.getImageData( 0, 0, 2, 2 );\n\t_pixelMapData = _pixelMapImage.data;\n\n\t_gradientMap = document.createElement( 'canvas' );\n\t_gradientMap.width = _gradientMap.height = _gradientMapQuality;\n\n\t_gradientMapContext = _gradientMap.getContext( '2d' );\n\t_gradientMapContext.translate( - _gradientMapQuality / 2, - _gradientMapQuality / 2 );\n\t_gradientMapContext.scale( _gradientMapQuality, _gradientMapQuality );\n\n\t_gradientMapQuality --; // Fix UVs\n\n\t// dash+gap fallbacks for Firefox and everything else\n\n\tif ( _context.setLineDash === undefined ) {\n\n\t\tif ( _context.mozDash !== undefined ) {\n\n\t\t\t_context.setLineDash = function ( values ) {\n\n\t\t\t\t_context.mozDash = values[ 0 ] !== null ? values : null;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_context.setLineDash = function () {}\n\n\t\t}\n\n\t}\n\n\tthis.domElement = _canvas;\n\n\tthis.devicePixelRatio = parameters.devicePixelRatio !== undefined\n\t\t\t\t? parameters.devicePixelRatio\n\t\t\t\t: self.devicePixelRatio !== undefined\n\t\t\t\t\t? self.devicePixelRatio\n\t\t\t\t\t: 1;\n\n\tthis.autoClear = true;\n\tthis.sortObjects = true;\n\tthis.sortElements = true;\n\n\tthis.info = {\n\n\t\trender: {\n\n\t\t\tvertices: 0,\n\t\t\tfaces: 0\n\n\t\t}\n\n\t}\n\n\t// WebGLRenderer compatibility\n\n\tthis.supportsVertexTextures = function () {};\n\tthis.setFaceCulling = function () {};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t_canvasWidth = width * this.devicePixelRatio;\n\t\t_canvasHeight = height * this.devicePixelRatio;\n\n\t\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 );\n\t\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 );\n\n\t\t_canvas.width = _canvasWidth;\n\t\t_canvas.height = _canvasHeight;\n\n\t\tif ( this.devicePixelRatio !== 1 && updateStyle !== false ) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\n\t\t}\n\n\t\t_clipBox.set(\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\n\t\t);\n\n\t\t_clearBox.set(\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\n\t\t);\n\n\t\t_contextGlobalAlpha = 1;\n\t\t_contextGlobalCompositeOperation = 0;\n\t\t_contextStrokeStyle = null;\n\t\t_contextFillStyle = null;\n\t\t_contextLineWidth = null;\n\t\t_contextLineCap = null;\n\t\t_contextLineJoin = null;\n\n\t};\n\n\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t_clearColor.set( color );\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\t_clearBox.set(\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\n\t\t);\n\n\t};\n\n\tthis.setClearColorHex = function ( hex, alpha ) {\n\n\t\tconsole.warn( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );\n\t\tthis.setClearColor( hex, alpha );\n\n\t};\n\n\tthis.getMaxAnisotropy = function () {\n\n\t\treturn 0;\n\n\t};\n\n\tthis.clear = function () {\n\n\t\t_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );\n\n\t\tif ( _clearBox.empty() === false ) {\n\n\t\t\t_clearBox.intersect( _clipBox );\n\t\t\t_clearBox.expandByScalar( 2 );\n\n\t\t\tif ( _clearAlpha < 1 ) {\n\n\t\t\t\t_context.clearRect(\n\t\t\t\t\t_clearBox.min.x | 0,\n\t\t\t\t\t_clearBox.min.y | 0,\n\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\n\t\t\t\t\t( _clearBox.max.y - _clearBox.min.y ) | 0\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( _clearAlpha > 0 ) {\n\n\t\t\t\tsetBlending( THREE.NormalBlending );\n\t\t\t\tsetOpacity( 1 );\n\n\t\t\t\tsetFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearAlpha + ')' );\n\n\t\t\t\t_context.fillRect(\n\t\t\t\t\t_clearBox.min.x | 0,\n\t\t\t\t\t_clearBox.min.y | 0,\n\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\n\t\t\t\t\t( _clearBox.max.y - _clearBox.min.y ) | 0\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t_clearBox.makeEmpty();\n\n\t\t}\n\n\t};\n\n\t// compatibility\n\n\tthis.clearColor = function () {};\n\tthis.clearDepth = function () {};\n\tthis.clearStencil = function () {};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( camera instanceof THREE.Camera === false ) {\n\n\t\t\tconsole.error( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.autoClear === true ) this.clear();\n\n\t\t_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );\n\n\t\t_this.info.render.vertices = 0;\n\t\t_this.info.render.faces = 0;\n\n\t\t_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );\n\t\t_elements = _renderData.elements;\n\t\t_lights = _renderData.lights;\n\t\t_camera = camera;\n\n\t\t/* DEBUG\n\t\tsetFillStyle( 'rgba( 0, 255, 255, 0.5 )' );\n\t\t_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );\n\t\t*/\n\n\t\tcalculateLights();\n\n\t\tfor ( var e = 0, el = _elements.length; e < el; e++ ) {\n\n\t\t\tvar element = _elements[ e ];\n\n\t\t\tvar material = element.material;\n\n\t\t\tif ( material === undefined || material.visible === false ) continue;\n\n\t\t\t_elemBox.makeEmpty();\n\n\t\t\tif ( element instanceof THREE.RenderableSprite ) {\n\n\t\t\t\t_v1 = element;\n\t\t\t\t_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;\n\n\t\t\t\trenderSprite( _v1, element, material );\n\n\t\t\t} else if ( element instanceof THREE.RenderableLine ) {\n\n\t\t\t\t_v1 = element.v1; _v2 = element.v2;\n\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\n\n\t\t\t\t_elemBox.setFromPoints( [\n\t\t\t\t\t_v1.positionScreen,\n\t\t\t\t\t_v2.positionScreen\n\t\t\t\t] );\n\n\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === true ) {\n\n\t\t\t\t\trenderLine( _v1, _v2, element, material );\n\n\t\t\t\t}\n\n\t\t\t} else if ( element instanceof THREE.RenderableFace3 ) {\n\n\t\t\t\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;\n\n\t\t\t\tif ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;\n\t\t\t\tif ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;\n\t\t\t\tif ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;\n\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;\n\n\t\t\t\tif ( material.overdraw > 0 ) {\n\n\t\t\t\t\texpand( _v1.positionScreen, _v2.positionScreen, material.overdraw );\n\t\t\t\t\texpand( _v2.positionScreen, _v3.positionScreen, material.overdraw );\n\t\t\t\t\texpand( _v3.positionScreen, _v1.positionScreen, material.overdraw );\n\n\t\t\t\t}\n\n\t\t\t\t_elemBox.setFromPoints( [\n\t\t\t\t\t_v1.positionScreen,\n\t\t\t\t\t_v2.positionScreen,\n\t\t\t\t\t_v3.positionScreen\n\t\t\t\t] );\n\n\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === true ) {\n\n\t\t\t\t\trenderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* DEBUG\n\t\t\tsetLineWidth( 1 );\n\t\t\tsetStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );\n\t\t\t_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );\n\t\t\t*/\n\n\t\t\t_clearBox.union( _elemBox );\n\n\t\t}\n\n\t\t/* DEBUG\n\t\tsetLineWidth( 1 );\n\t\tsetStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );\n\t\t_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );\n\t\t*/\n\n\t\t_context.setTransform( 1, 0, 0, 1, 0, 0 );\n\n\t};\n\n\t//\n\n\tfunction calculateLights() {\n\n\t\t_ambientLight.setRGB( 0, 0, 0 );\n\t\t_directionalLights.setRGB( 0, 0, 0 );\n\t\t_pointLights.setRGB( 0, 0, 0 );\n\n\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\n\n\t\t\tvar light = _lights[ l ];\n\t\t\tvar lightColor = light.color;\n\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\n\t\t\t\t_ambientLight.add( lightColor );\n\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\t// for sprites\n\n\t\t\t\t_directionalLights.add( lightColor );\n\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\t// for sprites\n\n\t\t\t\t_pointLights.add( lightColor );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction calculateLight( position, normal, color ) {\n\n\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\n\n\t\t\tvar light = _lights[ l ];\n\n\t\t\t_lightColor.copy( light.color );\n\n\t\t\tif ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\tvar lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld ).normalize();\n\n\t\t\t\tvar amount = normal.dot( lightPosition );\n\n\t\t\t\tif ( amount <= 0 ) continue;\n\n\t\t\t\tamount *= light.intensity;\n\n\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\n\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tvar lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld );\n\n\t\t\t\tvar amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );\n\n\t\t\t\tif ( amount <= 0 ) continue;\n\n\t\t\t\tamount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );\n\n\t\t\t\tif ( amount == 0 ) continue;\n\n\t\t\t\tamount *= light.intensity;\n\n\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction renderSprite( v1, element, material ) {\n\n\t\tsetOpacity( material.opacity );\n\t\tsetBlending( material.blending );\n\n\t\tvar scaleX = element.scale.x * _canvasWidthHalf;\n\t\tvar scaleY = element.scale.y * _canvasHeightHalf;\n\n\t\tvar dist = 0.5 * Math.sqrt( scaleX * scaleX + scaleY * scaleY ); // allow for rotated sprite\n\t\t_elemBox.min.set( v1.x - dist, v1.y - dist );\n\t\t_elemBox.max.set( v1.x + dist, v1.y + dist );\n\n\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === false ) {\n\n\t\t\t_elemBox.makeEmpty();\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( material instanceof THREE.SpriteMaterial ||\n\t\t\t material instanceof THREE.ParticleSystemMaterial ) { // Backwards compatibility\n\n\t\t\tvar texture = material.map;\n\n\t\t\tif ( texture !== null ) {\n\n\t\t\t\tif ( texture.hasEventListener( 'update', onTextureUpdate ) === false ) {\n\n\t\t\t\t\tif ( texture.image !== undefined && texture.image.width > 0 ) {\n\n\t\t\t\t\t\ttextureToPattern( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.addEventListener( 'update', onTextureUpdate );\n\n\t\t\t\t}\n\n\t\t\t\tvar pattern = _patterns[ texture.id ];\n\n\t\t\t\tif ( pattern !== undefined ) {\n\n\t\t\t\t\tsetFillStyle( pattern );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetFillStyle( 'rgba( 0, 0, 0, 1 )' );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar bitmap = texture.image;\n\n\t\t\t\tvar ox = bitmap.width * texture.offset.x;\n\t\t\t\tvar oy = bitmap.height * texture.offset.y;\n\n\t\t\t\tvar sx = bitmap.width * texture.repeat.x;\n\t\t\t\tvar sy = bitmap.height * texture.repeat.y;\n\n\t\t\t\tvar cx = scaleX / sx;\n\t\t\t\tvar cy = scaleY / sy;\n\n\t\t\t\t_context.save();\n\t\t\t\t_context.translate( v1.x, v1.y );\n\t\t\t\tif ( material.rotation !== 0 ) _context.rotate( material.rotation );\n\t\t\t\t_context.translate( - scaleX / 2, - scaleY / 2 );\n\t\t\t\t_context.scale( cx, cy );\n\t\t\t\t_context.translate( - ox, - oy );\n\t\t\t\t_context.fillRect( ox, oy, sx, sy );\n\t\t\t\t_context.restore();\n\n\t\t\t} else { // no texture\n\n\t\t\t\tsetFillStyle( material.color.getStyle() );\n\n\t\t\t\t_context.save();\n\t\t\t\t_context.translate( v1.x, v1.y );\n\t\t\t\tif ( material.rotation !== 0 ) _context.rotate( material.rotation );\n\t\t\t\t_context.scale( scaleX, - scaleY );\n\t\t\t\t_context.fillRect( - 0.5, - 0.5, 1, 1 );\n\t\t\t\t_context.restore();\n\n\t\t\t}\n\n\t\t} else if ( material instanceof THREE.SpriteCanvasMaterial ) {\n\n\t\t\tsetStrokeStyle( material.color.getStyle() );\n\t\t\tsetFillStyle( material.color.getStyle() );\n\n\t\t\t_context.save();\n\t\t\t_context.translate( v1.x, v1.y );\n\t\t\tif ( material.rotation !== 0 ) _context.rotate( material.rotation );\n\t\t\t_context.scale( scaleX, scaleY );\n\n\t\t\tmaterial.program( _context );\n\n\t\t\t_context.restore();\n\n\t\t}\n\n\t\t/* DEBUG\n\t\tsetStrokeStyle( 'rgb(255,255,0)' );\n\t\t_context.beginPath();\n\t\t_context.moveTo( v1.x - 10, v1.y );\n\t\t_context.lineTo( v1.x + 10, v1.y );\n\t\t_context.moveTo( v1.x, v1.y - 10 );\n\t\t_context.lineTo( v1.x, v1.y + 10 );\n\t\t_context.stroke();\n\t\t*/\n\n\t}\n\n\tfunction renderLine( v1, v2, element, material ) {\n\n\t\tsetOpacity( material.opacity );\n\t\tsetBlending( material.blending );\n\n\t\t_context.beginPath();\n\t\t_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );\n\t\t_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );\n\n\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\tsetLineWidth( material.linewidth );\n\t\t\tsetLineCap( material.linecap );\n\t\t\tsetLineJoin( material.linejoin );\n\n\t\t\tif ( material.vertexColors !== THREE.VertexColors ) {\n\n\t\t\t\tsetStrokeStyle( material.color.getStyle() );\n\n\t\t\t} else {\n\n\t\t\t\tvar colorStyle1 = element.vertexColors[0].getStyle();\n\t\t\t\tvar colorStyle2 = element.vertexColors[1].getStyle();\n\n\t\t\t\tif ( colorStyle1 === colorStyle2 ) {\n\n\t\t\t\t\tsetStrokeStyle( colorStyle1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tvar grad = _context.createLinearGradient(\n\t\t\t\t\t\t\tv1.positionScreen.x,\n\t\t\t\t\t\t\tv1.positionScreen.y,\n\t\t\t\t\t\t\tv2.positionScreen.x,\n\t\t\t\t\t\t\tv2.positionScreen.y\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgrad.addColorStop( 0, colorStyle1 );\n\t\t\t\t\t\tgrad.addColorStop( 1, colorStyle2 );\n\n\t\t\t\t\t} catch ( exception ) {\n\n\t\t\t\t\t\tgrad = colorStyle1;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsetStrokeStyle( grad );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_context.stroke();\n\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\n\n\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\n\t\t\tsetLineWidth( material.linewidth );\n\t\t\tsetLineCap( material.linecap );\n\t\t\tsetLineJoin( material.linejoin );\n\t\t\tsetStrokeStyle( material.color.getStyle() );\n\t\t\tsetDashAndGap( material.dashSize, material.gapSize );\n\n\t\t\t_context.stroke();\n\n\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\n\n\t\t\tsetDashAndGap( null, null );\n\n\t\t}\n\n\t}\n\n\tfunction renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {\n\n\t\t_this.info.render.vertices += 3;\n\t\t_this.info.render.faces ++;\n\n\t\tsetOpacity( material.opacity );\n\t\tsetBlending( material.blending );\n\n\t\t_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;\n\t\t_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;\n\t\t_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;\n\n\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );\n\n\t\tif ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) && material.map === null ) {\n\n\t\t\t_diffuseColor.copy( material.color );\n\t\t\t_emissiveColor.copy( material.emissive );\n\n\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\n\t\t\t\t_diffuseColor.multiply( element.color );\n\n\t\t\t}\n\n\t\t\tif ( material.wireframe === false && material.shading === THREE.SmoothShading && element.vertexNormalsLength === 3 ) {\n\n\t\t\t\t_color1.copy( _ambientLight );\n\t\t\t\t_color2.copy( _ambientLight );\n\t\t\t\t_color3.copy( _ambientLight );\n\n\t\t\t\tcalculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );\n\t\t\t\tcalculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );\n\t\t\t\tcalculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color3 );\n\n\t\t\t\t_color1.multiply( _diffuseColor ).add( _emissiveColor );\n\t\t\t\t_color2.multiply( _diffuseColor ).add( _emissiveColor );\n\t\t\t\t_color3.multiply( _diffuseColor ).add( _emissiveColor );\n\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\n\n\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\n\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\n\n\t\t\t} else {\n\n\t\t\t\t_color.copy( _ambientLight );\n\n\t\t\t\tcalculateLight( element.centroidModel, element.normalModel, _color );\n\n\t\t\t\t_color.multiply( _diffuseColor ).add( _emissiveColor );\n\n\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t: fillPath( _color );\n\n\t\t\t}\n\n\t\t} else if ( material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\tif ( material.map.mapping instanceof THREE.UVMapping ) {\n\n\t\t\t\t\t_uvs = element.uvs[ 0 ];\n\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );\n\n\t\t\t\t}\n\n\n\t\t\t} else if ( material.envMap !== null ) {\n\n\t\t\t\tif ( material.envMap.mapping instanceof THREE.SphericalReflectionMapping ) {\n\n\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv1 ] );\n\t\t\t\t\t_uv1x = 0.5 * _vector3.x + 0.5;\n\t\t\t\t\t_uv1y = 0.5 * _vector3.y + 0.5;\n\n\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv2 ] );\n\t\t\t\t\t_uv2x = 0.5 * _vector3.x + 0.5;\n\t\t\t\t\t_uv2y = 0.5 * _vector3.y + 0.5;\n\n\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv3 ] );\n\t\t\t\t\t_uv3x = 0.5 * _vector3.x + 0.5;\n\t\t\t\t\t_uv3y = 0.5 * _vector3.y + 0.5;\n\n\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );\n\n\t\t\t\t}/* else if ( material.envMap.mapping === THREE.SphericalRefractionMapping ) {\n\n\n\n\t\t\t\t}*/\n\n\n\t\t\t} else {\n\n\t\t\t\t_color.copy( material.color );\n\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\n\t\t\t\t\t_color.multiply( element.color );\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t: fillPath( _color );\n\n\t\t\t}\n\n\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t_near = _camera.near;\n\t\t\t_far = _camera.far;\n\n\t\t\t_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );\n\t\t\t_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );\n\t\t\t_color3.r = _color3.g = _color3.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );\n\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\n\n\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\n\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\n\n\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\tvar normal;\n\n\t\t\tif ( material.shading === THREE.FlatShading ) {\n\n\t\t\t\tnormal = element.normalModelView;\n\n\t\t\t\t_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t: fillPath( _color );\n\n\t\t\t} else if ( material.shading === THREE.SmoothShading ) {\n\n\t\t\t\tnormal = element.vertexNormalsModelView[ uv1 ];\n\t\t\t\t_color1.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\tnormal = element.vertexNormalsModelView[ uv2 ];\n\t\t\t\t_color2.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\tnormal = element.vertexNormalsModelView[ uv3 ];\n\t\t\t\t_color3.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\n\n\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\n\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction drawTriangle( x0, y0, x1, y1, x2, y2 ) {\n\n\t\t_context.beginPath();\n\t\t_context.moveTo( x0, y0 );\n\t\t_context.lineTo( x1, y1 );\n\t\t_context.lineTo( x2, y2 );\n\t\t_context.closePath();\n\n\t}\n\n\tfunction strokePath( color, linewidth, linecap, linejoin ) {\n\n\t\tsetLineWidth( linewidth );\n\t\tsetLineCap( linecap );\n\t\tsetLineJoin( linejoin );\n\t\tsetStrokeStyle( color.getStyle() );\n\n\t\t_context.stroke();\n\n\t\t_elemBox.expandByScalar( linewidth * 2 );\n\n\t}\n\n\tfunction fillPath( color ) {\n\n\t\tsetFillStyle( color.getStyle() );\n\t\t_context.fill();\n\n\t}\n\n\tfunction onTextureUpdate ( event ) {\n\n\t\ttextureToPattern( event.target );\n\n\t}\n\n\tfunction textureToPattern( texture ) {\n\n\t\tvar repeatX = texture.wrapS === THREE.RepeatWrapping;\n\t\tvar repeatY = texture.wrapT === THREE.RepeatWrapping;\n\n\t\tvar image = texture.image;\n\n\t\tvar canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = image.width;\n\t\tcanvas.height = image.height;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tcontext.setTransform( 1, 0, 0, - 1, 0, image.height );\n\t\tcontext.drawImage( image, 0, 0 );\n\n\t\t_patterns[ texture.id ] = _context.createPattern(\n\t\t\tcanvas, repeatX === true && repeatY === true\n\t\t\t\t? 'repeat'\n\t\t\t\t: repeatX === true && repeatY === false\n\t\t\t\t\t? 'repeat-x'\n\t\t\t\t\t: repeatX === false && repeatY === true\n\t\t\t\t\t\t? 'repeat-y'\n\t\t\t\t\t\t: 'no-repeat'\n\t\t);\n\n\t}\n\n\tfunction patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {\n\n\t\tif ( texture instanceof THREE.DataTexture ) return;\n\n\t\tif ( texture.hasEventListener( 'update', onTextureUpdate ) === false ) {\n\n\t\t\tif ( texture.image !== undefined && texture.image.width > 0 ) {\n\n\t\t\t\ttextureToPattern( texture );\n\n\t\t\t}\n\n\t\t\ttexture.addEventListener( 'update', onTextureUpdate );\n\n\t\t}\n\n\t\tvar pattern = _patterns[ texture.id ];\n\n\t\tif ( pattern !== undefined ) {\n\n\t\t\tsetFillStyle( pattern );\n\n\t\t} else {\n\n\t\t\tsetFillStyle( 'rgba(0,0,0,1)' );\n\t\t\t_context.fill();\n\n\t\t\treturn;\n\n\t\t}\t\n\n\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n\n\t\tvar a, b, c, d, e, f, det, idet,\n\t\toffsetX = texture.offset.x / texture.repeat.x,\n\t\toffsetY = texture.offset.y / texture.repeat.y,\n\t\twidth = texture.image.width * texture.repeat.x,\n\t\theight = texture.image.height * texture.repeat.y;\n\n\t\tu0 = ( u0 + offsetX ) * width;\n\t\tv0 = ( v0 + offsetY ) * height;\n\n\t\tu1 = ( u1 + offsetX ) * width;\n\t\tv1 = ( v1 + offsetY ) * height;\n\n\t\tu2 = ( u2 + offsetX ) * width;\n\t\tv2 = ( v2 + offsetY ) * height;\n\n\t\tx1 -= x0; y1 -= y0;\n\t\tx2 -= x0; y2 -= y0;\n\n\t\tu1 -= u0; v1 -= v0;\n\t\tu2 -= u0; v2 -= v0;\n\n\t\tdet = u1 * v2 - u2 * v1;\n\n\t\tif ( det === 0 ) return;\n\n\t\tidet = 1 / det;\n\n\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\n\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\n\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\n\t\td = ( u1 * y2 - u2 * y1 ) * idet;\n\n\t\te = x0 - a * u0 - c * v0;\n\t\tf = y0 - b * u0 - d * v0;\n\n\t\t_context.save();\n\t\t_context.transform( a, b, c, d, e, f );\n\t\t_context.fill();\n\t\t_context.restore();\n\n\t}\n\n\tfunction clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {\n\n\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n\n\t\tvar a, b, c, d, e, f, det, idet,\n\t\twidth = image.width - 1,\n\t\theight = image.height - 1;\n\n\t\tu0 *= width; v0 *= height;\n\t\tu1 *= width; v1 *= height;\n\t\tu2 *= width; v2 *= height;\n\n\t\tx1 -= x0; y1 -= y0;\n\t\tx2 -= x0; y2 -= y0;\n\n\t\tu1 -= u0; v1 -= v0;\n\t\tu2 -= u0; v2 -= v0;\n\n\t\tdet = u1 * v2 - u2 * v1;\n\n\t\tidet = 1 / det;\n\n\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\n\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\n\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\n\t\td = ( u1 * y2 - u2 * y1 ) * idet;\n\n\t\te = x0 - a * u0 - c * v0;\n\t\tf = y0 - b * u0 - d * v0;\n\n\t\t_context.save();\n\t\t_context.transform( a, b, c, d, e, f );\n\t\t_context.clip();\n\t\t_context.drawImage( image, 0, 0 );\n\t\t_context.restore();\n\n\t}\n\n\tfunction getGradientTexture( color1, color2, color3, color4 ) {\n\n\t\t// http://mrdoob.com/blog/post/710\n\n\t\t_pixelMapData[ 0 ] = ( color1.r * 255 ) | 0;\n\t\t_pixelMapData[ 1 ] = ( color1.g * 255 ) | 0;\n\t\t_pixelMapData[ 2 ] = ( color1.b * 255 ) | 0;\n\n\t\t_pixelMapData[ 4 ] = ( color2.r * 255 ) | 0;\n\t\t_pixelMapData[ 5 ] = ( color2.g * 255 ) | 0;\n\t\t_pixelMapData[ 6 ] = ( color2.b * 255 ) | 0;\n\n\t\t_pixelMapData[ 8 ] = ( color3.r * 255 ) | 0;\n\t\t_pixelMapData[ 9 ] = ( color3.g * 255 ) | 0;\n\t\t_pixelMapData[ 10 ] = ( color3.b * 255 ) | 0;\n\n\t\t_pixelMapData[ 12 ] = ( color4.r * 255 ) | 0;\n\t\t_pixelMapData[ 13 ] = ( color4.g * 255 ) | 0;\n\t\t_pixelMapData[ 14 ] = ( color4.b * 255 ) | 0;\n\n\t\t_pixelMapContext.putImageData( _pixelMapImage, 0, 0 );\n\t\t_gradientMapContext.drawImage( _pixelMap, 0, 0 );\n\n\t\treturn _gradientMap;\n\n\t}\n\n\t// Hide anti-alias gaps\n\n\tfunction expand( v1, v2, pixels ) {\n\n\t\tvar x = v2.x - v1.x, y = v2.y - v1.y,\n\t\tdet = x * x + y * y, idet;\n\n\t\tif ( det === 0 ) return;\n\n\t\tidet = pixels / Math.sqrt( det );\n\n\t\tx *= idet; y *= idet;\n\n\t\tv2.x += x; v2.y += y;\n\t\tv1.x -= x; v1.y -= y;\n\n\t}\n\n\t// Context cached methods.\n\n\tfunction setOpacity( value ) {\n\n\t\tif ( _contextGlobalAlpha !== value ) {\n\n\t\t\t_context.globalAlpha = value;\n\t\t\t_contextGlobalAlpha = value;\n\n\t\t}\n\n\t}\n\n\tfunction setBlending( value ) {\n\n\t\tif ( _contextGlobalCompositeOperation !== value ) {\n\n\t\t\tif ( value === THREE.NormalBlending ) {\n\n\t\t\t\t_context.globalCompositeOperation = 'source-over';\n\n\t\t\t} else if ( value === THREE.AdditiveBlending ) {\n\n\t\t\t\t_context.globalCompositeOperation = 'lighter';\n\n\t\t\t} else if ( value === THREE.SubtractiveBlending ) {\n\n\t\t\t\t_context.globalCompositeOperation = 'darker';\n\n\t\t\t}\n\n\t\t\t_contextGlobalCompositeOperation = value;\n\n\t\t}\n\n\t}\n\n\tfunction setLineWidth( value ) {\n\n\t\tif ( _contextLineWidth !== value ) {\n\n\t\t\t_context.lineWidth = value;\n\t\t\t_contextLineWidth = value;\n\n\t\t}\n\n\t}\n\n\tfunction setLineCap( value ) {\n\n\t\t// \"butt\", \"round\", \"square\"\n\n\t\tif ( _contextLineCap !== value ) {\n\n\t\t\t_context.lineCap = value;\n\t\t\t_contextLineCap = value;\n\n\t\t}\n\n\t}\n\n\tfunction setLineJoin( value ) {\n\n\t\t// \"round\", \"bevel\", \"miter\"\n\n\t\tif ( _contextLineJoin !== value ) {\n\n\t\t\t_context.lineJoin = value;\n\t\t\t_contextLineJoin = value;\n\n\t\t}\n\n\t}\n\n\tfunction setStrokeStyle( value ) {\n\n\t\tif ( _contextStrokeStyle !== value ) {\n\n\t\t\t_context.strokeStyle = value;\n\t\t\t_contextStrokeStyle = value;\n\n\t\t}\n\n\t}\n\n\tfunction setFillStyle( value ) {\n\n\t\tif ( _contextFillStyle !== value ) {\n\n\t\t\t_context.fillStyle = value;\n\t\t\t_contextFillStyle = value;\n\n\t\t}\n\n\t}\n\n\tfunction setDashAndGap( dashSizeValue, gapSizeValue ) {\n\n\t\tif ( _contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue ) {\n\n\t\t\t_context.setLineDash( [ dashSizeValue, gapSizeValue ] );\n\t\t\t_contextDashSize = dashSizeValue;\n\t\t\t_contextGapSize = gapSizeValue;\n\n\t\t}\n\n\t}\n\n};\n\n/**\n * Shader chunks for WebLG Shader library\n * \n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\nTHREE.ShaderChunk = {\n\n\t// FOG\n\n\tfog_pars_fragment: [\n\n\t\t\"#ifdef USE_FOG\",\n\n\t\t\t\"uniform vec3 fogColor;\",\n\n\t\t\t\"#ifdef FOG_EXP2\",\n\n\t\t\t\t\"uniform float fogDensity;\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"uniform float fogNear;\",\n\t\t\t\t\"uniform float fogFar;\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tfog_fragment: [\n\n\t\t\"#ifdef USE_FOG\",\n\n\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\n\n\t\t\t\"#ifdef FOG_EXP2\",\n\n\t\t\t\t\"const float LOG2 = 1.442695;\",\n\t\t\t\t\"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\",\n\t\t\t\t\"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"float fogFactor = smoothstep( fogNear, fogFar, depth );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// ENVIRONMENT MAP\n\n\tenvmap_pars_fragment: [\n\n\t\t\"#ifdef USE_ENVMAP\",\n\n\t\t\t\"uniform float reflectivity;\",\n\t\t\t\"uniform samplerCube envMap;\",\n\t\t\t\"uniform float flipEnvMap;\",\n\t\t\t\"uniform int combine;\",\n\n\t\t\t\"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\",\n\n\t\t\t\t\"uniform bool useRefract;\",\n\t\t\t\t\"uniform float refractionRatio;\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"varying vec3 vReflect;\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tenvmap_fragment: [\n\n\t\t\"#ifdef USE_ENVMAP\",\n\n\t\t\t\"vec3 reflectVec;\",\n\n\t\t\t\"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\",\n\n\t\t\t\t\"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\n\n\t\t\t\t\"if ( useRefract ) {\",\n\n\t\t\t\t\t\"reflectVec = refract( cameraToVertex, normal, refractionRatio );\",\n\n\t\t\t\t\"} else { \",\n\n\t\t\t\t\t\"reflectVec = reflect( cameraToVertex, normal );\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"reflectVec = vReflect;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\n\t\t\t\t\"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\"cubeColor.xyz *= cubeColor.xyz;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"if ( combine == 1 ) {\",\n\n\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\",\n\n\t\t\t\"} else if ( combine == 2 ) {\",\n\n\t\t\t\t\"gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\",\n\n\t\t\t\"} else {\",\n\n\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tenvmap_pars_vertex: [\n\n\t\t\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\",\n\n\t\t\t\"varying vec3 vReflect;\",\n\n\t\t\t\"uniform float refractionRatio;\",\n\t\t\t\"uniform bool useRefract;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tworldpos_vertex : [\n\n\t\t\"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\",\n\n\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\"vec4 worldPosition = modelMatrix * skinned;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\n\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\n\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tenvmap_vertex : [\n\n\t\t\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\",\n\n\t\t\t\"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\",\n\t\t\t\"worldNormal = normalize( worldNormal );\",\n\n\t\t\t\"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\",\n\n\t\t\t\"if ( useRefract ) {\",\n\n\t\t\t\t\"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\",\n\n\t\t\t\"} else {\",\n\n\t\t\t\t\"vReflect = reflect( cameraToVertex, worldNormal );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// COLOR MAP (particles)\n\n\tmap_particle_pars_fragment: [\n\n\t\t\"#ifdef USE_MAP\",\n\n\t\t\t\"uniform sampler2D map;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n\tmap_particle_fragment: [\n\n\t\t\"#ifdef USE_MAP\",\n\n\t\t\t\"gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// COLOR MAP (triangles)\n\n\tmap_pars_vertex: [\n\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"uniform vec4 offsetRepeat;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tmap_pars_fragment: [\n\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef USE_MAP\",\n\n\t\t\t\"uniform sampler2D map;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tmap_vertex: [\n\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n\n\t\t\t\"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tmap_fragment: [\n\n\t\t\"#ifdef USE_MAP\",\n\n\t\t\t\"vec4 texelColor = texture2D( map, vUv );\",\n\n\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\"texelColor.xyz *= texelColor.xyz;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"gl_FragColor = gl_FragColor * texelColor;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// LIGHT MAP\n\n\tlightmap_pars_fragment: [\n\n\t\t\"#ifdef USE_LIGHTMAP\",\n\n\t\t\t\"varying vec2 vUv2;\",\n\t\t\t\"uniform sampler2D lightMap;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlightmap_pars_vertex: [\n\n\t\t\"#ifdef USE_LIGHTMAP\",\n\n\t\t\t\"varying vec2 vUv2;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlightmap_fragment: [\n\n\t\t\"#ifdef USE_LIGHTMAP\",\n\n\t\t\t\"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlightmap_vertex: [\n\n\t\t\"#ifdef USE_LIGHTMAP\",\n\n\t\t\t\"vUv2 = uv2;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// BUMP MAP\n\n\tbumpmap_pars_fragment: [\n\n\t\t\"#ifdef USE_BUMPMAP\",\n\n\t\t\t\"uniform sampler2D bumpMap;\",\n\t\t\t\"uniform float bumpScale;\",\n\n\t\t\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n\t\t\t//\thttp://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n\t\t\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\t\t\t\"vec2 dHdxy_fwd() {\",\n\n\t\t\t\t\"vec2 dSTdx = dFdx( vUv );\",\n\t\t\t\t\"vec2 dSTdy = dFdy( vUv );\",\n\n\t\t\t\t\"float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\",\n\t\t\t\t\"float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\",\n\t\t\t\t\"float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\",\n\n\t\t\t\t\"return vec2( dBx, dBy );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\",\n\n\t\t\t\t\"vec3 vSigmaX = dFdx( surf_pos );\",\n\t\t\t\t\"vec3 vSigmaY = dFdy( surf_pos );\",\n\t\t\t\t\"vec3 vN = surf_norm;\",\t\t// normalized\n\n\t\t\t\t\"vec3 R1 = cross( vSigmaY, vN );\",\n\t\t\t\t\"vec3 R2 = cross( vN, vSigmaX );\",\n\n\t\t\t\t\"float fDet = dot( vSigmaX, R1 );\",\n\n\t\t\t\t\"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\",\n\t\t\t\t\"return normalize( abs( fDet ) * surf_norm - vGrad );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// NORMAL MAP\n\n\tnormalmap_pars_fragment: [\n\n\t\t\"#ifdef USE_NORMALMAP\",\n\n\t\t\t\"uniform sampler2D normalMap;\",\n\t\t\t\"uniform vec2 normalScale;\",\n\n\t\t\t// Per-Pixel Tangent Space Normal Mapping\n\t\t\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\t\t\t\"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\",\n\n\t\t\t\t\"vec3 q0 = dFdx( eye_pos.xyz );\",\n\t\t\t\t\"vec3 q1 = dFdy( eye_pos.xyz );\",\n\t\t\t\t\"vec2 st0 = dFdx( vUv.st );\",\n\t\t\t\t\"vec2 st1 = dFdy( vUv.st );\",\n\n\t\t\t\t\"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );\",\n\t\t\t\t\"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\",\n\t\t\t\t\"vec3 N = normalize( surf_norm );\",\n\n\t\t\t\t\"vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\",\n\t\t\t\t\"mapN.xy = normalScale * mapN.xy;\",\n\t\t\t\t\"mat3 tsn = mat3( S, T, N );\",\n\t\t\t\t\"return normalize( tsn * mapN );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// SPECULAR MAP\n\n\tspecularmap_pars_fragment: [\n\n\t\t\"#ifdef USE_SPECULARMAP\",\n\n\t\t\t\"uniform sampler2D specularMap;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tspecularmap_fragment: [\n\n\t\t\"float specularStrength;\",\n\n\t\t\"#ifdef USE_SPECULARMAP\",\n\n\t\t\t\"vec4 texelSpecular = texture2D( specularMap, vUv );\",\n\t\t\t\"specularStrength = texelSpecular.r;\",\n\n\t\t\"#else\",\n\n\t\t\t\"specularStrength = 1.0;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// LIGHTS LAMBERT\n\n\tlights_lambert_pars_vertex: [\n\n\t\t\"uniform vec3 ambient;\",\n\t\t\"uniform vec3 diffuse;\",\n\t\t\"uniform vec3 emissive;\",\n\n\t\t\"uniform vec3 ambientLightColor;\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\"uniform vec3 wrapRGB;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlights_lambert_vertex: [\n\n\t\t\"vLightFront = vec3( 0.0 );\",\n\n\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\"vLightBack = vec3( 0.0 );\",\n\n\t\t\"#endif\",\n\n\t\t\"transformedNormal = normalize( transformedNormal );\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\n\n\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\n\n\t\t\t\"float dotProduct = dot( transformedNormal, dirVector );\",\n\t\t\t\"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n\t\t\t\t\"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\",\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\",\n\n\t\t\t\"#endif\",\n\n\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\"lVector = normalize( lVector );\",\n\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\n\n\t\t\t\t\"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n\t\t\t\t\t\"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\",\n\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\t\"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\",\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\",\n\n\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\n\n\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\n\n\t\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\"lVector = normalize( lVector );\",\n\n\t\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\n\t\t\t\t\t\"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\t\"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\t\"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n\t\t\t\t\t\t\"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\",\n\n\t\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\t\t\"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\",\n\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\t\"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\n\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\n\n\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\t\t\t\t\"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\",\n\n\t\t\t\t\"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\",\n\n\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\"vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// LIGHTS PHONG\n\n\tlights_phong_pars_vertex: [\n\n\t\t\"#ifndef PHONG_PER_PIXEL\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n\tlights_phong_vertex: [\n\n\t\t\"#ifndef PHONG_PER_PIXEL\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\"vPointLight[ i ] = vec4( lVector, lDistance );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\"vSpotLight[ i ] = vec4( lVector, lDistance );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n\n\t\t\t\"vWorldPosition = worldPosition.xyz;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlights_phong_pars_fragment: [\n\n\t\t\"uniform vec3 ambientLightColor;\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\n\t\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\t\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\n\t\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\"uniform vec3 wrapRGB;\",\n\n\t\t\"#endif\",\n\n\t\t\"varying vec3 vViewPosition;\",\n\t\t\"varying vec3 vNormal;\"\n\n\t].join(\"\\n\"),\n\n\tlights_phong_fragment: [\n\n\t\t\"vec3 normal = normalize( vNormal );\",\n\t\t\"vec3 viewPosition = normalize( vViewPosition );\",\n\n\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef USE_NORMALMAP\",\n\n\t\t\t\"normal = perturbNormal2Arb( -vViewPosition, normal );\",\n\n\t\t\"#elif defined( USE_BUMPMAP )\",\n\n\t\t\t\"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"vec3 pointDiffuse  = vec3( 0.0 );\",\n\t\t\t\"vec3 pointSpecular = vec3( 0.0 );\",\n\n\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\n\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\n\n\t\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\"lVector = normalize( lVector );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"vec3 lVector = normalize( vPointLight[ i ].xyz );\",\n\t\t\t\t\t\"float lDistance = vPointLight[ i ].w;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// diffuse\n\n\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"float pointDiffuseWeightFull = max( dotProduct, 0.0 );\",\n\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n\n\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"float pointDiffuseWeight = max( dotProduct, 0.0 );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\",\n\n\t\t\t\t// specular\n\n\t\t\t\t\"vec3 pointHalfVector = normalize( lVector + viewPosition );\",\n\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\n\t\t\t\t\"float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\",\n\t\t\t\t\"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"vec3 spotDiffuse  = vec3( 0.0 );\",\n\t\t\t\"vec3 spotSpecular = vec3( 0.0 );\",\n\n\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\n\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\n\n\t\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\"lVector = normalize( lVector );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"vec3 lVector = normalize( vSpotLight[ i ].xyz );\",\n\t\t\t\t\t\"float lDistance = vSpotLight[ i ].w;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\n\n\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\n\n\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\n\n\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\"float spotDiffuseWeightFull = max( dotProduct, 0.0 );\",\n\t\t\t\t\t\t\"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n\n\t\t\t\t\t\t\"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"float spotDiffuseWeight = max( dotProduct, 0.0 );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\",\n\n\t\t\t\t\t// specular\n\n\t\t\t\t\t\"vec3 spotHalfVector = normalize( lVector + viewPosition );\",\n\t\t\t\t\t\"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\n\t\t\t\t\t\"float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\",\n\t\t\t\t\t\"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\"vec3 dirDiffuse  = vec3( 0.0 );\",\n\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\" ,\n\n\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n\t\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t// diffuse\n\n\t\t\t\t\"float dotProduct = dot( normal, dirVector );\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"float dirDiffuseWeightFull = max( dotProduct, 0.0 );\",\n\t\t\t\t\t\"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n\n\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"float dirDiffuseWeight = max( dotProduct, 0.0 );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\",\n\n\t\t\t\t// specular\n\n\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\n\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\n\t\t\t\t\"float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\t/*\n\t\t\t\t// fresnel term from skin shader\n\t\t\t\t\"const float F0 = 0.128;\",\n\n\t\t\t\t\"float base = 1.0 - dot( viewPosition, dirHalfVector );\",\n\t\t\t\t\"float exponential = pow( base, 5.0 );\",\n\n\t\t\t\t\"float fresnel = exponential + F0 * ( 1.0 - exponential );\",\n\t\t\t\t*/\n\n\t\t\t\t/*\n\t\t\t\t// fresnel term from fresnel shader\n\t\t\t\t\"const float mFresnelBias = 0.08;\",\n\t\t\t\t\"const float mFresnelScale = 0.3;\",\n\t\t\t\t\"const float mFresnelPower = 5.0;\",\n\n\t\t\t\t\"float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\",\n\t\t\t\t*/\n\n\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t//\"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\",\n\n\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\n\t\t\t\t\"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\n\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\n\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\" ,\n\n\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\n\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t// diffuse\n\n\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\n\t\t\t\t\"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\n\t\t\t\t\"hemiDiffuse += diffuse * hemiColor;\",\n\n\t\t\t\t// specular (sky light)\n\n\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\n\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\n\t\t\t\t\"float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\",\n\n\t\t\t\t// specular (ground light)\n\n\t\t\t\t\"vec3 lVectorGround = -lVector;\",\n\n\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\n\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\n\t\t\t\t\"float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\",\n\n\t\t\t\t\"float dotProductGround = dot( normal, lVectorGround );\",\n\n\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\n\t\t\t\t\"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\n\t\t\t\t\"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"vec3 totalDiffuse = vec3( 0.0 );\",\n\t\t\"vec3 totalSpecular = vec3( 0.0 );\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\"totalDiffuse += dirDiffuse;\",\n\t\t\t\"totalSpecular += dirSpecular;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"totalDiffuse += hemiDiffuse;\",\n\t\t\t\"totalSpecular += hemiSpecular;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"totalDiffuse += pointDiffuse;\",\n\t\t\t\"totalSpecular += pointSpecular;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"totalDiffuse += spotDiffuse;\",\n\t\t\t\"totalSpecular += spotSpecular;\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef METAL\",\n\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\",\n\n\t\t\"#else\",\n\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// VERTEX COLORS\n\n\tcolor_pars_fragment: [\n\n\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\"varying vec3 vColor;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n\tcolor_fragment: [\n\n\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\"gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tcolor_pars_vertex: [\n\n\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\"varying vec3 vColor;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n\tcolor_vertex: [\n\n\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\"vColor = color * color;\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"vColor = color;\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// SKINNING\n\n\tskinning_pars_vertex: [\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"#ifdef BONE_TEXTURE\",\n\n\t\t\t\t\"uniform sampler2D boneTexture;\",\n\t\t\t\t\"uniform int boneTextureWidth;\",\n\t\t\t\t\"uniform int boneTextureHeight;\",\n\n\t\t\t\t\"mat4 getBoneMatrix( const in float i ) {\",\n\n\t\t\t\t\t\"float j = i * 4.0;\",\n\t\t\t\t\t\"float x = mod( j, float( boneTextureWidth ) );\",\n\t\t\t\t\t\"float y = floor( j / float( boneTextureWidth ) );\",\n\n\t\t\t\t\t\"float dx = 1.0 / float( boneTextureWidth );\",\n\t\t\t\t\t\"float dy = 1.0 / float( boneTextureHeight );\",\n\n\t\t\t\t\t\"y = dy * ( y + 0.5 );\",\n\n\t\t\t\t\t\"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\",\n\t\t\t\t\t\"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\",\n\t\t\t\t\t\"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\",\n\t\t\t\t\t\"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\",\n\n\t\t\t\t\t\"mat4 bone = mat4( v1, v2, v3, v4 );\",\n\n\t\t\t\t\t\"return bone;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"uniform mat4 boneGlobalMatrices[ MAX_BONES ];\",\n\n\t\t\t\t\"mat4 getBoneMatrix( const in float i ) {\",\n\n\t\t\t\t\t\"mat4 bone = boneGlobalMatrices[ int(i) ];\",\n\t\t\t\t\t\"return bone;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tskinbase_vertex: [\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"mat4 boneMatX = getBoneMatrix( skinIndex.x );\",\n\t\t\t\"mat4 boneMatY = getBoneMatrix( skinIndex.y );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tskinning_vertex: [\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"#ifdef USE_MORPHTARGETS\",\n\n\t\t\t\"vec4 skinVertex = vec4( morphed, 1.0 );\",\n\n\t\t\t\"#else\",\n\n\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// MORPHING\n\n\tmorphtarget_pars_vertex: [\n\n\t\t\"#ifdef USE_MORPHTARGETS\",\n\n\t\t\t\"#ifndef USE_MORPHNORMALS\",\n\n\t\t\t\"uniform float morphTargetInfluences[ 8 ];\",\n\n\t\t\t\"#else\",\n\n\t\t\t\"uniform float morphTargetInfluences[ 4 ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tmorphtarget_vertex: [\n\n\t\t\"#ifdef USE_MORPHTARGETS\",\n\n\t\t\t\"vec3 morphed = vec3( 0.0 );\",\n\t\t\t\"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\",\n\t\t\t\"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\",\n\t\t\t\"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\",\n\t\t\t\"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\",\n\n\t\t\t\"#ifndef USE_MORPHNORMALS\",\n\n\t\t\t\"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\",\n\t\t\t\"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\",\n\t\t\t\"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\",\n\t\t\t\"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"morphed += position;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tdefault_vertex : [\n\n\t\t\"vec4 mvPosition;\",\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"mvPosition = modelViewMatrix * skinned;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\",\n\n\t\t\t\"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\",\n\n\t\t\"#endif\",\n\n\t\t\"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\",\n\n\t\t\t\"mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"#endif\",\n\n\t\t\"gl_Position = projectionMatrix * mvPosition;\"\n\n\t].join(\"\\n\"),\n\n\tmorphnormal_vertex: [\n\n\t\t\"#ifdef USE_MORPHNORMALS\",\n\n\t\t\t\"vec3 morphedNormal = vec3( 0.0 );\",\n\n\t\t\t\"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\",\n\t\t\t\"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\",\n\t\t\t\"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\",\n\t\t\t\"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\",\n\n\t\t\t\"morphedNormal += normal;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tskinnormal_vertex: [\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"mat4 skinMatrix = skinWeight.x * boneMatX;\",\n\t\t\t\"skinMatrix \t+= skinWeight.y * boneMatY;\",\n\n\t\t\t\"#ifdef USE_MORPHNORMALS\",\n\n\t\t\t\"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\",\n\n\t\t\t\"#else\",\n\n\t\t\t\"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tdefaultnormal_vertex: [\n\n\t\t\"vec3 objectNormal;\",\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"objectNormal = skinnedNormal.xyz;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\",\n\n\t\t\t\"objectNormal = morphedNormal;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\",\n\n\t\t\t\"objectNormal = normal;\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef FLIP_SIDED\",\n\n\t\t\t\"objectNormal = -objectNormal;\",\n\n\t\t\"#endif\",\n\n\t\t\"vec3 transformedNormal = normalMatrix * objectNormal;\"\n\n\t].join(\"\\n\"),\n\n\t// SHADOW MAP\n\n\t// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples\n\t//  http://spidergl.org/example.php?id=6\n\t// \thttp://fabiensanglard.net/shadowmapping\n\n\tshadowmap_pars_fragment: [\n\n\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\"uniform sampler2D shadowMap[ MAX_SHADOWS ];\",\n\t\t\t\"uniform vec2 shadowMapSize[ MAX_SHADOWS ];\",\n\n\t\t\t\"uniform float shadowDarkness[ MAX_SHADOWS ];\",\n\t\t\t\"uniform float shadowBias[ MAX_SHADOWS ];\",\n\n\t\t\t\"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\n\n\t\t\t\"float unpackDepth( const in vec4 rgba_depth ) {\",\n\n\t\t\t\t\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\n\t\t\t\t\"float depth = dot( rgba_depth, bit_shift );\",\n\t\t\t\t\"return depth;\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tshadowmap_fragment: [\n\n\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\"#ifdef SHADOWMAP_DEBUG\",\n\n\t\t\t\t\"vec3 frustumColors[3];\",\n\t\t\t\t\"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\",\n\t\t\t\t\"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\",\n\t\t\t\t\"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\n\n\t\t\t\t\"int inFrustumCount = 0;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"float fDepth;\",\n\t\t\t\"vec3 shadowColor = vec3( 1.0 );\",\n\n\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n\n\t\t\t\t\"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\",\n\n\t\t\t\t// \"if ( something && something )\" \t\t breaks ATI OpenGL shader compiler\n\t\t\t\t// \"if ( all( something, something ) )\"  using this instead\n\n\t\t\t\t\"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\",\n\t\t\t\t\"bool inFrustum = all( inFrustumVec );\",\n\n\t\t\t\t// don't shadow pixels outside of light frustum\n\t\t\t\t// use just first frustum (for cascades)\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\n\n\t\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\n\n\t\t\t\t\t\"inFrustumCount += int( inFrustum );\",\n\t\t\t\t\t\"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"bool frustumTest = all( frustumTestVec );\",\n\n\t\t\t\t\"if ( frustumTest ) {\",\n\n\t\t\t\t\t\"shadowCoord.z += shadowBias[ i ];\",\n\n\t\t\t\t\t\"#if defined( SHADOWMAP_TYPE_PCF )\",\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\t\t\t\"float shadow = 0.0;\",\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n\t\t\t\t\t\t// must enroll loop manually\n\n\t\t\t\t\t\t\"for ( float y = -1.25; y <= 1.25; y += 1.25 )\",\n\t\t\t\t\t\t\t\"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\",\n\n\t\t\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\",\n\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple \"texture2D\" lookup\n\t\t\t\t\t\t\t\t//\"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\",\n\n\t\t\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\n\n\t\t\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\n\t\t\t\t\t\t\t\t\t\"shadow += 1.0;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\t\"shadow /= 9.0;\",\n\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\t\"const float shadowDelta = 1.0 / 9.0;\",\n\n\t\t\t\t\t\t\"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\n\t\t\t\t\t\t\"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\n\n\t\t\t\t\t\t\"float dx0 = -1.25 * xPixelOffset;\",\n\t\t\t\t\t\t\"float dy0 = -1.25 * yPixelOffset;\",\n\t\t\t\t\t\t\"float dx1 = 1.25 * xPixelOffset;\",\n\t\t\t\t\t\t\"float dy1 = 1.25 * yPixelOffset;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\n\n\t\t\t\t\t\"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\",\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\t\t\t\"float shadow = 0.0;\",\n\n\t\t\t\t\t\t\"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\n\t\t\t\t\t\t\"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\n\n\t\t\t\t\t\t\"float dx0 = -1.0 * xPixelOffset;\",\n\t\t\t\t\t\t\"float dy0 = -1.0 * yPixelOffset;\",\n\t\t\t\t\t\t\"float dx1 = 1.0 * xPixelOffset;\",\n\t\t\t\t\t\t\"float dy1 = 1.0 * yPixelOffset;\",\n\n\t\t\t\t\t\t\"mat3 shadowKernel;\",\n\t\t\t\t\t\t\"mat3 depthKernel;\",\n\n\t\t\t\t\t\t\"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\n\t\t\t\t\t\t\"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\n\t\t\t\t\t\t\"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\n\t\t\t\t\t\t\"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\n\t\t\t\t\t\t\"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\n\t\t\t\t\t\t\"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\n\t\t\t\t\t\t\"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\n\t\t\t\t\t\t\"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\n\t\t\t\t\t\t\"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\n\n\t\t\t\t\t\t\"vec3 shadowZ = vec3( shadowCoord.z );\",\n\t\t\t\t\t\t\"shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\",\n\t\t\t\t\t\t\"shadowKernel[0] *= vec3(0.25);\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\"shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\",\n\t\t\t\t\t\t\"shadowKernel[1] *= vec3(0.25);\",\n\n\t\t\t\t\t\t\"shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\",\n\t\t\t\t\t\t\"shadowKernel[2] *= vec3(0.25);\",\n\n\t\t\t\t\t\t\"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\",\n\n\t\t\t\t\t\t\"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\",\n\t\t\t\t\t\t\"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\",\n\n\t\t\t\t\t\t\"vec4 shadowValues;\",\n\t\t\t\t\t\t\"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\",\n\t\t\t\t\t\t\"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\",\n\t\t\t\t\t\t\"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\",\n\t\t\t\t\t\t\"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\",\n\n\t\t\t\t\t\t\"shadow = dot( shadowValues, vec4( 1.0 ) );\",\n\n\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\",\n\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\n\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\n\n\t\t\t\t\t\t\t// spot with multiple shadows is darker\n\n\t\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\",\n\n\t\t\t\t\t\t\t// spot with multiple shadows has the same color as single shadow spot\n\n\t\t\t\t\t\t\t//\"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\n\t\t\t\t\"#ifdef SHADOWMAP_DEBUG\",\n\n\t\t\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\n\n\t\t\t\t\t\t\"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\t\"#ifdef GAMMA_OUTPUT\",\n\n\t\t\t\t\"shadowColor *= shadowColor;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tshadowmap_pars_vertex: [\n\n\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\n\t\t\t\"uniform mat4 shadowMatrix[ MAX_SHADOWS ];\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tshadowmap_vertex: [\n\n\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n\n\t\t\t\t\"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// ALPHATEST\n\n\talphatest_fragment: [\n\n\t\t\"#ifdef ALPHATEST\",\n\n\t\t\t\"if ( gl_FragColor.a < ALPHATEST ) discard;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// LINEAR SPACE\n\n\tlinear_to_gamma_fragment: [\n\n\t\t\"#ifdef GAMMA_OUTPUT\",\n\n\t\t\t\"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\")\n\n\n};\n/**\n * Uniform Utilities\n */\n\nTHREE.UniformsUtils = {\n\n\tmerge: function ( uniforms ) {\n\n\t\tvar u, p, tmp, merged = {};\n\n\t\tfor ( u = 0; u < uniforms.length; u ++ ) {\n\n\t\t\ttmp = this.clone( uniforms[ u ] );\n\n\t\t\tfor ( p in tmp ) {\n\n\t\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn merged;\n\n\t},\n\n\tclone: function ( uniforms_src ) {\n\n\t\tvar u, p, parameter, parameter_src, uniforms_dst = {};\n\n\t\tfor ( u in uniforms_src ) {\n\n\t\t\tuniforms_dst[ u ] = {};\n\n\t\t\tfor ( p in uniforms_src[ u ] ) {\n\n\t\t\t\tparameter_src = uniforms_src[ u ][ p ];\n\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\n\t\t\t\t} else if ( parameter_src instanceof Array ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uniforms_dst;\n\n\t}\n\n};\n/**\n * Uniforms library for shared webgl shaders\n */\n\nTHREE.UniformsLib = {\n\n\tcommon: {\n\n\t\t\"diffuse\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\n\n\t\t\"map\" : { type: \"t\", value: null },\n\t\t\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\n\n\t\t\"lightMap\" : { type: \"t\", value: null },\n\t\t\"specularMap\" : { type: \"t\", value: null },\n\n\t\t\"envMap\" : { type: \"t\", value: null },\n\t\t\"flipEnvMap\" : { type: \"f\", value: -1 },\n\t\t\"useRefract\" : { type: \"i\", value: 0 },\n\t\t\"reflectivity\" : { type: \"f\", value: 1.0 },\n\t\t\"refractionRatio\" : { type: \"f\", value: 0.98 },\n\t\t\"combine\" : { type: \"i\", value: 0 },\n\n\t\t\"morphTargetInfluences\" : { type: \"f\", value: 0 }\n\n\t},\n\n\tbump: {\n\n\t\t\"bumpMap\" : { type: \"t\", value: null },\n\t\t\"bumpScale\" : { type: \"f\", value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\t\"normalMap\" : { type: \"t\", value: null },\n\t\t\"normalScale\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\n\t},\n\n\tfog : {\n\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\t\"ambientLightColor\" : { type: \"fv\", value: [] },\n\n\t\t\"directionalLightDirection\" : { type: \"fv\", value: [] },\n\t\t\"directionalLightColor\" : { type: \"fv\", value: [] },\n\n\t\t\"hemisphereLightDirection\" : { type: \"fv\", value: [] },\n\t\t\"hemisphereLightSkyColor\" : { type: \"fv\", value: [] },\n\t\t\"hemisphereLightGroundColor\" : { type: \"fv\", value: [] },\n\n\t\t\"pointLightColor\" : { type: \"fv\", value: [] },\n\t\t\"pointLightPosition\" : { type: \"fv\", value: [] },\n\t\t\"pointLightDistance\" : { type: \"fv1\", value: [] },\n\n\t\t\"spotLightColor\" : { type: \"fv\", value: [] },\n\t\t\"spotLightPosition\" : { type: \"fv\", value: [] },\n\t\t\"spotLightDirection\" : { type: \"fv\", value: [] },\n\t\t\"spotLightDistance\" : { type: \"fv1\", value: [] },\n\t\t\"spotLightAngleCos\" : { type: \"fv1\", value: [] },\n\t\t\"spotLightExponent\" : { type: \"fv1\", value: [] }\n\n\t},\n\n\tparticle: {\n\n\t\t\"psColor\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\n\t\t\"size\" : { type: \"f\", value: 1.0 },\n\t\t\"scale\" : { type: \"f\", value: 1.0 },\n\t\t\"map\" : { type: \"t\", value: null },\n\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\n\n\t},\n\n\tshadowmap: {\n\n\t\t\"shadowMap\": { type: \"tv\", value: [] },\n\t\t\"shadowMapSize\": { type: \"v2v\", value: [] },\n\n\t\t\"shadowBias\" : { type: \"fv1\", value: [] },\n\t\t\"shadowDarkness\": { type: \"fv1\", value: [] },\n\n\t\t\"shadowMatrix\" : { type: \"m4v\", value: [] }\n\n\t}\n\n};\n/**\n * Webgl Shader Library for three.js\n *\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\n\nTHREE.ShaderLib = {\n\n\t'basic': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"common\" ],\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\n\t\t\t\t\"#ifdef USE_ENVMAP\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( diffuse, opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'lambert': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"common\" ],\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\n\n\t\t\t{\n\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\t\"#define LAMBERT\",\n\n\t\t\t\"varying vec3 vLightFront;\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"varying vec3 vLightBack;\",\n\n\t\t\t\"#endif\",\n\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lights_lambert_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lights_lambert_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"varying vec3 vLightFront;\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"varying vec3 vLightBack;\",\n\n\t\t\t\"#endif\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t//\"float isFront = float( gl_FrontFacing );\",\n\t\t\t\t\t//\"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;\",\n\n\t\t\t\t\t\"if ( gl_FrontFacing )\",\n\t\t\t\t\t\t\"gl_FragColor.xyz *= vLightFront;\",\n\t\t\t\t\t\"else\",\n\t\t\t\t\t\t\"gl_FragColor.xyz *= vLightBack;\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"gl_FragColor.xyz *= vLightFront;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'phong': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"common\" ],\n\t\t\tTHREE.UniformsLib[ \"bump\" ],\n\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\n\n\t\t\t{\n\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\n\t\t\t\t\"shininess\": { type: \"f\", value: 30 },\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\t\"#define PHONG\",\n\n\t\t\t\"varying vec3 vViewPosition;\",\n\t\t\t\"varying vec3 vNormal;\",\n\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\n\t\t\t\t\"vNormal = normalize( transformedNormal );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform vec3 ambient;\",\n\t\t\t\"uniform vec3 emissive;\",\n\t\t\t\"uniform vec3 specular;\",\n\t\t\t\"uniform float shininess;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'particle_basic': {\n\n\t\tuniforms:  THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"particle\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform float size;\",\n\t\t\t\"uniform float scale;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\t\"#ifdef USE_SIZEATTENUATION\",\n\t\t\t\t\t\"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\",\n\t\t\t\t\"#else\",\n\t\t\t\t\t\"gl_PointSize = size;\",\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 psColor;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"map_particle_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( psColor, opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_particle_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'dashed': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"common\" ],\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\n\t\t\t{\n\t\t\t\t\"scale\":     { type: \"f\", value: 1 },\n\t\t\t\t\"dashSize\":  { type: \"f\", value: 1 },\n\t\t\t\t\"totalSize\": { type: \"f\", value: 2 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform float scale;\",\n\t\t\t\"attribute float lineDistance;\",\n\n\t\t\t\"varying float vLineDistance;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\n\t\t\t\t\"vLineDistance = scale * lineDistance;\",\n\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform float dashSize;\",\n\t\t\t\"uniform float totalSize;\",\n\n\t\t\t\"varying float vLineDistance;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"if ( mod( vLineDistance, totalSize ) > dashSize ) {\",\n\n\t\t\t\t\t\"discard;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_FragColor = vec4( diffuse, opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'depth': {\n\n\t\tuniforms: {\n\n\t\t\t\"mNear\": { type: \"f\", value: 1.0 },\n\t\t\t\"mFar\" : { type: \"f\", value: 2000.0 },\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float mNear;\",\n\t\t\t\"uniform float mFar;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\n\t\t\t\t\"float color = 1.0 - smoothstep( mNear, mFar, depth );\",\n\t\t\t\t\"gl_FragColor = vec4( vec3( color ), opacity );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'normal': {\n\n\t\tuniforms: {\n\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec3 vNormal;\",\n\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float opacity;\",\n\t\t\t\"varying vec3 vNormal;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tNormal map shader\n\t//\t\t- Blinn-Phong\n\t//\t\t- normal + diffuse + specular + AO + displacement + reflection + shadow maps\n\t//\t\t- point and directional lights (use with \"lights: true\" material option)\n\t ------------------------------------------------------------------------- */\n\n\t'normalmap' : {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\n\n\t\t\t{\n\n\t\t\t\"enableAO\"\t\t  : { type: \"i\", value: 0 },\n\t\t\t\"enableDiffuse\"\t  : { type: \"i\", value: 0 },\n\t\t\t\"enableSpecular\"  : { type: \"i\", value: 0 },\n\t\t\t\"enableReflection\": { type: \"i\", value: 0 },\n\t\t\t\"enableDisplacement\": { type: \"i\", value: 0 },\n\n\t\t\t\"tDisplacement\": { type: \"t\", value: null }, // must go first as this is vertex texture\n\t\t\t\"tDiffuse\"\t   : { type: \"t\", value: null },\n\t\t\t\"tCube\"\t\t   : { type: \"t\", value: null },\n\t\t\t\"tNormal\"\t   : { type: \"t\", value: null },\n\t\t\t\"tSpecular\"\t   : { type: \"t\", value: null },\n\t\t\t\"tAO\"\t\t   : { type: \"t\", value: null },\n\n\t\t\t\"uNormalScale\": { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\n\n\t\t\t\"uDisplacementBias\": { type: \"f\", value: 0.0 },\n\t\t\t\"uDisplacementScale\": { type: \"f\", value: 1.0 },\n\n\t\t\t\"diffuse\": { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\t\t\t\"specular\": { type: \"c\", value: new THREE.Color( 0x111111 ) },\n\t\t\t\"ambient\": { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\t\t\t\"shininess\": { type: \"f\", value: 30 },\n\t\t\t\"opacity\": { type: \"f\", value: 1 },\n\n\t\t\t\"useRefract\": { type: \"i\", value: 0 },\n\t\t\t\"refractionRatio\": { type: \"f\", value: 0.98 },\n\t\t\t\"reflectivity\": { type: \"f\", value: 0.5 },\n\n\t\t\t\"uOffset\" : { type: \"v2\", value: new THREE.Vector2( 0, 0 ) },\n\t\t\t\"uRepeat\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\n\n\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\n\t\t\t}\n\n\t\t] ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 ambient;\",\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform vec3 specular;\",\n\t\t\t\"uniform float shininess;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform bool enableDiffuse;\",\n\t\t\t\"uniform bool enableSpecular;\",\n\t\t\t\"uniform bool enableAO;\",\n\t\t\t\"uniform bool enableReflection;\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform sampler2D tNormal;\",\n\t\t\t\"uniform sampler2D tSpecular;\",\n\t\t\t\"uniform sampler2D tAO;\",\n\n\t\t\t\"uniform samplerCube tCube;\",\n\n\t\t\t\"uniform vec2 uNormalScale;\",\n\n\t\t\t\"uniform bool useRefract;\",\n\t\t\t\"uniform float refractionRatio;\",\n\t\t\t\"uniform float reflectivity;\",\n\n\t\t\t\"varying vec3 vTangent;\",\n\t\t\t\"varying vec3 vBinormal;\",\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"uniform vec3 ambientLightColor;\",\n\n\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\t\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\"uniform vec3 wrapRGB;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( vec3( 1.0 ), opacity );\",\n\n\t\t\t\t\"vec3 specularTex = vec3( 1.0 );\",\n\n\t\t\t\t\"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\",\n\t\t\t\t\"normalTex.xy *= uNormalScale;\",\n\t\t\t\t\"normalTex = normalize( normalTex );\",\n\n\t\t\t\t\"if( enableDiffuse ) {\",\n\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\t\t\"vec4 texelColor = texture2D( tDiffuse, vUv );\",\n\t\t\t\t\t\t\"texelColor.xyz *= texelColor.xyz;\",\n\n\t\t\t\t\t\t\"gl_FragColor = gl_FragColor * texelColor;\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"if( enableAO ) {\",\n\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\t\t\"vec4 aoColor = texture2D( tAO, vUv );\",\n\t\t\t\t\t\t\"aoColor.xyz *= aoColor.xyz;\",\n\n\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"if( enableSpecular )\",\n\t\t\t\t\t\"specularTex = texture2D( tSpecular, vUv ).xyz;\",\n\n\t\t\t\t\"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\",\n\t\t\t\t\"vec3 finalNormal = tsb * normalTex;\",\n\n\t\t\t\t\"#ifdef FLIP_SIDED\",\n\n\t\t\t\t\t\"finalNormal = -finalNormal;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"vec3 normal = normalize( finalNormal );\",\n\t\t\t\t\"vec3 viewPosition = normalize( vViewPosition );\",\n\n\t\t\t\t// point lights\n\n\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\t\t\"vec3 pointDiffuse = vec3( 0.0 );\",\n\t\t\t\t\t\"vec3 pointSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\t\"vec3 pointVector = lPosition.xyz + vViewPosition.xyz;\",\n\n\t\t\t\t\t\t\"float pointDistance = 1.0;\",\n\t\t\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\t\"pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\t\"pointVector = normalize( pointVector );\",\n\n\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\t\"float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\",\n\t\t\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\",\n\n\t\t\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\"pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\",\n\n\t\t\t\t\t\t// specular\n\n\t\t\t\t\t\t\"vec3 pointHalfVector = normalize( pointVector + viewPosition );\",\n\t\t\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\n\t\t\t\t\t\t\"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\",\n\t\t\t\t\t\t\"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// spot lights\n\n\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\t\t\"vec3 spotDiffuse = vec3( 0.0 );\",\n\t\t\t\t\t\"vec3 spotSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\t\"vec3 spotVector = lPosition.xyz + vViewPosition.xyz;\",\n\n\t\t\t\t\t\t\"float spotDistance = 1.0;\",\n\t\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\t\"spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\t\"spotVector = normalize( spotVector );\",\n\n\t\t\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\n\n\t\t\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\n\n\t\t\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\n\n\t\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\",\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\",\n\n\t\t\t\t\t\t\t\t\"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\",\n\n\t\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\t\"spotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\",\n\n\t\t\t\t\t\t\t// specular\n\n\t\t\t\t\t\t\t\"vec3 spotHalfVector = normalize( spotVector + viewPosition );\",\n\t\t\t\t\t\t\t\"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\n\t\t\t\t\t\t\t\"float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\",\n\t\t\t\t\t\t\t\"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// directional lights\n\n\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\t\t\"vec3 dirDiffuse = vec3( 0.0 );\",\n\t\t\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\",\n\n\t\t\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n\t\t\t\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\t\"float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\",\n\t\t\t\t\t\t\t\"float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\",\n\n\t\t\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\",\n\n\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\"dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\",\n\n\t\t\t\t\t\t// specular\n\n\t\t\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\n\t\t\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\n\t\t\t\t\t\t\"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\n\t\t\t\t\t\t\"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// hemisphere lights\n\n\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\n\t\t\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\" ,\n\n\t\t\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\n\t\t\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\t\t\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\n\t\t\t\t\t\t\"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\n\t\t\t\t\t\t\"hemiDiffuse += diffuse * hemiColor;\",\n\n\t\t\t\t\t\t// specular (sky light)\n\n\n\t\t\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\n\t\t\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\n\t\t\t\t\t\t\"float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\",\n\n\t\t\t\t\t\t// specular (ground light)\n\n\t\t\t\t\t\t\"vec3 lVectorGround = -lVector;\",\n\n\t\t\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\n\t\t\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\n\t\t\t\t\t\t\"float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\",\n\n\t\t\t\t\t\t\"float dotProductGround = dot( normal, lVectorGround );\",\n\n\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\n\t\t\t\t\t\t\"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\n\t\t\t\t\t\t\"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// all lights contribution summation\n\n\t\t\t\t\"vec3 totalDiffuse = vec3( 0.0 );\",\n\t\t\t\t\"vec3 totalSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\t\t\"totalDiffuse += dirDiffuse;\",\n\t\t\t\t\t\"totalSpecular += dirSpecular;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\t\t\"totalDiffuse += hemiDiffuse;\",\n\t\t\t\t\t\"totalSpecular += hemiSpecular;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\t\t\"totalDiffuse += pointDiffuse;\",\n\t\t\t\t\t\"totalSpecular += pointSpecular;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\t\t\"totalDiffuse += spotDiffuse;\",\n\t\t\t\t\t\"totalSpecular += spotSpecular;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#ifdef METAL\",\n\n\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"if ( enableReflection ) {\",\n\n\t\t\t\t\t\"vec3 vReflect;\",\n\t\t\t\t\t\"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\n\n\t\t\t\t\t\"if ( useRefract ) {\",\n\n\t\t\t\t\t\t\"vReflect = refract( cameraToVertex, normal, refractionRatio );\",\n\n\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\"vReflect = reflect( cameraToVertex, normal );\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\n\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\t\t\"cubeColor.xyz *= cubeColor.xyz;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tvertexShader: [\n\n\t\t\t\"attribute vec4 tangent;\",\n\n\t\t\t\"uniform vec2 uOffset;\",\n\t\t\t\"uniform vec2 uRepeat;\",\n\n\t\t\t\"uniform bool enableDisplacement;\",\n\n\t\t\t\"#ifdef VERTEX_TEXTURES\",\n\n\t\t\t\t\"uniform sampler2D tDisplacement;\",\n\t\t\t\t\"uniform float uDisplacementScale;\",\n\t\t\t\t\"uniform float uDisplacementBias;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"varying vec3 vTangent;\",\n\t\t\t\"varying vec3 vBinormal;\",\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\n\t\t\t\t// normal, tangent and binormal vectors\n\n\t\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\t\"vNormal = normalize( normalMatrix * skinnedNormal.xyz );\",\n\n\t\t\t\t\t\"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\",\n\t\t\t\t\t\"vTangent = normalize( normalMatrix * skinnedTangent.xyz );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\n\t\t\t\t\t\"vTangent = normalize( normalMatrix * tangent.xyz );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\",\n\n\t\t\t\t\"vUv = uv * uRepeat + uOffset;\",\n\n\t\t\t\t// displacement mapping\n\n\t\t\t\t\"vec3 displacedPosition;\",\n\n\t\t\t\t\"#ifdef VERTEX_TEXTURES\",\n\n\t\t\t\t\t\"if ( enableDisplacement ) {\",\n\n\t\t\t\t\t\t\"vec3 dv = texture2D( tDisplacement, uv ).xyz;\",\n\t\t\t\t\t\t\"float df = uDisplacementScale * dv.x + uDisplacementBias;\",\n\t\t\t\t\t\t\"displacedPosition = position + normalize( normal ) * df;\",\n\n\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\n\n\t\t\t\t\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n\t\t\t\t\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n\n\t\t\t\t\t\t\t\"displacedPosition  = skinned.xyz;\",\n\n\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\"displacedPosition = position;\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\n\n\t\t\t\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n\t\t\t\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n\n\t\t\t\t\t\t\"displacedPosition  = skinned.xyz;\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"displacedPosition = position;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t//\n\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\",\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\t//\n\n\t\t\t\t\"vWorldPosition = worldPosition.xyz;\",\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\n\n\t\t\t\t// shadows\n\n\t\t\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\t'cube': {\n\n\t\tuniforms: { \"tCube\": { type: \"t\", value: null },\n\t\t\t\t\t\"tFlip\": { type: \"f\", value: -1 } },\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\t\t\t\t\"vWorldPosition = worldPosition.xyz;\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform samplerCube tCube;\",\n\t\t\t\"uniform float tFlip;\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t// Depth encoding into RGBA texture\n\t// \tbased on SpiderGL shadow map example\n\t// \t\thttp://spidergl.org/example.php?id=6\n\t// \toriginally from\n\t//\t\thttp://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\n\t// \tsee also here:\n\t//\t\thttp://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n\n\t'depthRGBA': {\n\n\t\tuniforms: {},\n\n\t\tvertexShader: [\n\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"vec4 pack_depth( const in float depth ) {\",\n\n\t\t\t\t\"const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\n\t\t\t\t\"const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\n\t\t\t\t\"vec4 res = fract( depth * bit_shift );\",\n\t\t\t\t\"res -= res.xxyz * bit_mask;\",\n\t\t\t\t\"return res;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\",\n\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\n\t\t\t\t//\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( z );\",\n\t\t\t\t//\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t}\n\n};\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nTHREE.WebGLRenderer = function ( parameters ) {\n\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\n\n\tparameters = parameters || {};\n\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\n\n\t_precision = parameters.precision !== undefined ? parameters.precision : 'highp',\n\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n\n\t_clearColor = new THREE.Color( 0x000000 ),\n\t_clearAlpha = 0;\n\n\t// public properties\n\n\tthis.domElement = _canvas;\n\tthis.context = null;\n\tthis.devicePixelRatio = parameters.devicePixelRatio !== undefined\n\t\t\t\t? parameters.devicePixelRatio\n\t\t\t\t: self.devicePixelRatio !== undefined\n\t\t\t\t\t? self.devicePixelRatio\n\t\t\t\t\t: 1;\n\n\t// clearing\n\n\tthis.autoClear = true;\n\tthis.autoClearColor = true;\n\tthis.autoClearDepth = true;\n\tthis.autoClearStencil = true;\n\n\t// scene graph\n\n\tthis.sortObjects = true;\n\tthis.autoUpdateObjects = true;\n\n\t// physically based shading\n\n\tthis.gammaInput = false;\n\tthis.gammaOutput = false;\n\n\t// shadow map\n\n\tthis.shadowMapEnabled = false;\n\tthis.shadowMapAutoUpdate = true;\n\tthis.shadowMapType = THREE.PCFShadowMap;\n\tthis.shadowMapCullFace = THREE.CullFaceFront;\n\tthis.shadowMapDebug = false;\n\tthis.shadowMapCascade = false;\n\n\t// morphs\n\n\tthis.maxMorphTargets = 8;\n\tthis.maxMorphNormals = 4;\n\n\t// flags\n\n\tthis.autoScaleCubemaps = true;\n\n\t// custom render plugins\n\n\tthis.renderPluginsPre = [];\n\tthis.renderPluginsPost = [];\n\n\t// info\n\n\tthis.info = {\n\n\t\tmemory: {\n\n\t\t\tprograms: 0,\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\n\t\t},\n\n\t\trender: {\n\n\t\t\tcalls: 0,\n\t\t\tvertices: 0,\n\t\t\tfaces: 0,\n\t\t\tpoints: 0\n\n\t\t}\n\n\t};\n\n\t// internal properties\n\n\tvar _this = this,\n\n\t_programs = [],\n\t_programs_counter = 0,\n\n\t// internal state cache\n\n\t_currentProgram = null,\n\t_currentFramebuffer = null,\n\t_currentMaterialId = -1,\n\t_currentGeometryGroupHash = null,\n\t_currentCamera = null,\n\t_geometryGroupCounter = 0,\n\n\t_usedTextureUnits = 0,\n\n\t// GL state cache\n\n\t_oldDoubleSided = -1,\n\t_oldFlipSided = -1,\n\n\t_oldBlending = -1,\n\n\t_oldBlendEquation = -1,\n\t_oldBlendSrc = -1,\n\t_oldBlendDst = -1,\n\n\t_oldDepthTest = -1,\n\t_oldDepthWrite = -1,\n\n\t_oldPolygonOffset = null,\n\t_oldPolygonOffsetFactor = null,\n\t_oldPolygonOffsetUnits = null,\n\n\t_oldLineWidth = null,\n\n\t_viewportX = 0,\n\t_viewportY = 0,\n\t_viewportWidth = _canvas.width,\n\t_viewportHeight = _canvas.height,\n\t_currentWidth = 0,\n\t_currentHeight = 0,\n\n\t_enabledAttributes = {},\n\n\t// frustum\n\n\t_frustum = new THREE.Frustum(),\n\n\t // camera matrices cache\n\n\t_projScreenMatrix = new THREE.Matrix4(),\n\t_projScreenMatrixPS = new THREE.Matrix4(),\n\n\t_vector3 = new THREE.Vector3(),\n\n\t// light arrays cache\n\n\t_direction = new THREE.Vector3(),\n\n\t_lightsNeedUpdate = true,\n\n\t_lights = {\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tdirectional: { length: 0, colors: new Array(), positions: new Array() },\n\t\tpoint: { length: 0, colors: new Array(), positions: new Array(), distances: new Array() },\n\t\tspot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), directions: new Array(), anglesCos: new Array(), exponents: new Array() },\n\t\themi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() }\n\n\t};\n\n\t// initialize\n\n\tvar _gl;\n\n\tvar _glExtensionTextureFloat;\n\tvar _glExtensionTextureFloatLinear;\n\tvar _glExtensionStandardDerivatives;\n\tvar _glExtensionTextureFilterAnisotropic;\n\tvar _glExtensionCompressedTextureS3TC;\n\n\tinitGL();\n\n\tsetDefaultGLState();\n\n\tthis.context = _gl;\n\n\t// GPU capabilities\n\n\tvar _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );\n\tvar _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\tvar _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );\n\tvar _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\tvar _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;\n\n\tvar _supportsVertexTextures = ( _maxVertexTextures > 0 );\n\tvar _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;\n\n\tvar _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];\n\n\t//\n\n\tvar _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );\n\tvar _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );\n\tvar _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );\n\n\tvar _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );\n\tvar _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );\n\tvar _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );\n\n\tvar _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_INT );\n\tvar _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_INT );\n\tvar _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_INT );\n\n\tvar _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_INT );\n\tvar _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_INT );\n\tvar _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_INT );\n\n\t// clamp precision to maximum available\n\n\tvar highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;\n\tvar mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;\n\n\tif ( _precision === \"highp\" && ! highpAvailable ) {\n\n\t\tif ( mediumpAvailable ) {\n\n\t\t\t_precision = \"mediump\";\n\t\t\tconsole.warn( \"WebGLRenderer: highp not supported, using mediump\" );\n\n\t\t} else {\n\n\t\t\t_precision = \"lowp\";\n\t\t\tconsole.warn( \"WebGLRenderer: highp and mediump not supported, using lowp\" );\n\n\t\t}\n\n\t}\n\n\tif ( _precision === \"mediump\" && ! mediumpAvailable ) {\n\n\t\t_precision = \"lowp\";\n\t\tconsole.warn( \"WebGLRenderer: mediump not supported, using lowp\" );\n\n\t}\n\n\t// API\n\n\tthis.getContext = function () {\n\n\t\treturn _gl;\n\n\t};\n\n\tthis.supportsVertexTextures = function () {\n\n\t\treturn _supportsVertexTextures;\n\n\t};\n\n\tthis.supportsFloatTextures = function () {\n\n\t\treturn _glExtensionTextureFloat;\n\n\t};\n\n\tthis.supportsStandardDerivatives = function () {\n\n\t\treturn _glExtensionStandardDerivatives;\n\n\t};\n\n\tthis.supportsCompressedTextureS3TC = function () {\n\n\t\treturn _glExtensionCompressedTextureS3TC;\n\n\t};\n\n\tthis.getMaxAnisotropy  = function () {\n\n\t\treturn _maxAnisotropy;\n\n\t};\n\n\tthis.getPrecision = function () {\n\n\t\treturn _precision;\n\n\t};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t_canvas.width = width * this.devicePixelRatio;\n\t\t_canvas.height = height * this.devicePixelRatio;\n\n\t\tif ( this.devicePixelRatio !== 1 && updateStyle !== false ) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, _canvas.width, _canvas.height );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t_viewportX = x !== undefined ? x : 0;\n\t\t_viewportY = y !== undefined ? y : 0;\n\n\t\t_viewportWidth = width !== undefined ? width : _canvas.width;\n\t\t_viewportHeight = height !== undefined ? height : _canvas.height;\n\n\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t_gl.scissor( x, y, width, height );\n\n\t};\n\n\tthis.enableScissorTest = function ( enable ) {\n\n\t\tenable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );\n\n\t};\n\n\t// Clearing\n\n\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t_clearColor.set( color );\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.setClearColorHex = function ( hex, alpha ) {\n\n\t\tconsole.warn( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );\n\t\tthis.setClearColor( hex, alpha );\n\n\t};\n\n\tthis.getClearColor = function () {\n\n\t\treturn _clearColor;\n\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn _clearAlpha;\n\n\t};\n\n\tthis.clear = function ( color, depth, stencil ) {\n\n\t\tvar bits = 0;\n\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t_gl.clear( bits );\n\n\t};\n\n\tthis.clearColor = function () {\n\n\t\t_gl.clear( _gl.COLOR_BUFFER_BIT );\n\n\t};\n\n\tthis.clearDepth = function () {\n\n\t\t_gl.clear( _gl.DEPTH_BUFFER_BIT );\n\n\t};\n\n\tthis.clearStencil = function () {\n\n\t\t_gl.clear( _gl.STENCIL_BUFFER_BIT );\n\n\t};\n\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\t\tthis.setRenderTarget( renderTarget );\n\t\tthis.clear( color, depth, stencil );\n\n\t};\n\n\t// Plugins\n\n\tthis.addPostPlugin = function ( plugin ) {\n\n\t\tplugin.init( this );\n\t\tthis.renderPluginsPost.push( plugin );\n\n\t};\n\n\tthis.addPrePlugin = function ( plugin ) {\n\n\t\tplugin.init( this );\n\t\tthis.renderPluginsPre.push( plugin );\n\n\t};\n\n\t// Rendering\n\n\tthis.updateShadowMap = function ( scene, camera ) {\n\n\t\t_currentProgram = null;\n\t\t_oldBlending = -1;\n\t\t_oldDepthTest = -1;\n\t\t_oldDepthWrite = -1;\n\t\t_currentGeometryGroupHash = -1;\n\t\t_currentMaterialId = -1;\n\t\t_lightsNeedUpdate = true;\n\t\t_oldDoubleSided = -1;\n\t\t_oldFlipSided = -1;\n\n\t\tthis.shadowMapPlugin.update( scene, camera );\n\n\t};\n\n\t// Internal functions\n\n\t// Buffer allocation\n\n\tfunction createParticleBuffers ( geometry ) {\n\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\n\n\t\t_this.info.memory.geometries ++;\n\n\t};\n\n\tfunction createLineBuffers ( geometry ) {\n\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\n\t\tgeometry.__webglLineDistanceBuffer = _gl.createBuffer();\n\n\t\t_this.info.memory.geometries ++;\n\n\t};\n\n\tfunction createMeshBuffers ( geometryGroup ) {\n\n\t\tgeometryGroup.__webglVertexBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglNormalBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglTangentBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglColorBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglUVBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglUV2Buffer = _gl.createBuffer();\n\n\t\tgeometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();\n\n\t\tgeometryGroup.__webglFaceBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglLineBuffer = _gl.createBuffer();\n\n\t\tvar m, ml;\n\n\t\tif ( geometryGroup.numMorphTargets ) {\n\n\t\t\tgeometryGroup.__webglMorphTargetsBuffers = [];\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\n\t\t\t\tgeometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( geometryGroup.numMorphNormals ) {\n\n\t\t\tgeometryGroup.__webglMorphNormalsBuffers = [];\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\n\t\t\t\tgeometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_this.info.memory.geometries ++;\n\n\t};\n\n\t// Events\n\n\tvar onGeometryDispose = function ( event ) {\n\n\t\tvar geometry = event.target;\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdeallocateGeometry( geometry );\n\n\t};\n\n\tvar onTextureDispose = function ( event ) {\n\n\t\tvar texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\t_this.info.memory.textures --;\n\n\n\t};\n\n\tvar onRenderTargetDispose = function ( event ) {\n\n\t\tvar renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t\t_this.info.memory.textures --;\n\n\t};\n\n\tvar onMaterialDispose = function ( event ) {\n\n\t\tvar material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\tdeallocateMaterial( material );\n\n\t};\n\n\t// Buffer deallocation\n\n\tvar deleteBuffers = function ( geometry ) {\n\n\t\tif ( geometry.__webglVertexBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglVertexBuffer );\n\t\tif ( geometry.__webglNormalBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglNormalBuffer );\n\t\tif ( geometry.__webglTangentBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglTangentBuffer );\n\t\tif ( geometry.__webglColorBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglColorBuffer );\n\t\tif ( geometry.__webglUVBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglUVBuffer );\n\t\tif ( geometry.__webglUV2Buffer !== undefined ) _gl.deleteBuffer( geometry.__webglUV2Buffer );\n\n\t\tif ( geometry.__webglSkinIndicesBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );\n\t\tif ( geometry.__webglSkinWeightsBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );\n\n\t\tif ( geometry.__webglFaceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglFaceBuffer );\n\t\tif ( geometry.__webglLineBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineBuffer );\n\n\t\tif ( geometry.__webglLineDistanceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );\n\t\t// custom attributes\n\n\t\tif ( geometry.__webglCustomAttributesList !== undefined ) {\n\n\t\t\tfor ( var id in geometry.__webglCustomAttributesList ) {\n\n\t\t\t\t_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_this.info.memory.geometries --;\n\n\t};\n\n\tvar deallocateGeometry = function ( geometry ) {\n\n\t\tgeometry.__webglInit = undefined;\n\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tvar attributes = geometry.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tif ( attributes[ key ].buffer !== undefined ) {\n\n\t\t\t\t\t_gl.deleteBuffer( attributes[ key ].buffer );\n\t\t\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_this.info.memory.geometries --;\n\n\t\t} else {\n\n\t\t\tif ( geometry.geometryGroups !== undefined ) {\n\n\t\t\t\tfor ( var g in geometry.geometryGroups ) {\n\n\t\t\t\t\tvar geometryGroup = geometry.geometryGroups[ g ];\n\n\t\t\t\t\tif ( geometryGroup.numMorphTargets !== undefined ) {\n\n\t\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometryGroup.numMorphNormals !== undefined ) {\n\n\t\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdeleteBuffers( geometryGroup );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdeleteBuffers( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tvar deallocateTexture = function ( texture ) {\n\n\t\tif ( texture.image && texture.image.__webglTextureCube ) {\n\n\t\t\t// cube texture\n\n\t\t\t_gl.deleteTexture( texture.image.__webglTextureCube );\n\n\t\t} else {\n\n\t\t\t// 2D texture\n\n\t\t\tif ( ! texture.__webglInit ) return;\n\n\t\t\ttexture.__webglInit = false;\n\t\t\t_gl.deleteTexture( texture.__webglTexture );\n\n\t\t}\n\n\t};\n\n\tvar deallocateRenderTarget = function ( renderTarget ) {\n\n\t\tif ( !renderTarget || ! renderTarget.__webglTexture ) return;\n\n\t\t_gl.deleteTexture( renderTarget.__webglTexture );\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );\n\t\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );\n\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );\n\n\t\t}\n\n\t};\n\n\tvar deallocateMaterial = function ( material ) {\n\n\t\tvar program = material.program;\n\n\t\tif ( program === undefined ) return;\n\n\t\tmaterial.program = undefined;\n\n\t\t// only deallocate GL program if this was the last use of shared program\n\t\t// assumed there is only single copy of any program in the _programs list\n\t\t// (that's how it's constructed)\n\n\t\tvar i, il, programInfo;\n\t\tvar deleteProgram = false;\n\n\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\n\n\t\t\tprogramInfo = _programs[ i ];\n\n\t\t\tif ( programInfo.program === program ) {\n\n\t\t\t\tprogramInfo.usedTimes --;\n\n\t\t\t\tif ( programInfo.usedTimes === 0 ) {\n\n\t\t\t\t\tdeleteProgram = true;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( deleteProgram === true ) {\n\n\t\t\t// avoid using array.splice, this is costlier than creating new array from scratch\n\n\t\t\tvar newPrograms = [];\n\n\t\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\n\n\t\t\t\tprogramInfo = _programs[ i ];\n\n\t\t\t\tif ( programInfo.program !== program ) {\n\n\t\t\t\t\tnewPrograms.push( programInfo );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_programs = newPrograms;\n\n\t\t\t_gl.deleteProgram( program );\n\n\t\t\t_this.info.memory.programs --;\n\n\t\t}\n\n\t};\n\n\t// Buffer initialization\n\n\tfunction initCustomAttributes ( geometry, object ) {\n\n\t\tvar nvertices = geometry.vertices.length;\n\n\t\tvar material = object.material;\n\n\t\tif ( material.attributes ) {\n\n\t\t\tif ( geometry.__webglCustomAttributesList === undefined ) {\n\n\t\t\t\tgeometry.__webglCustomAttributesList = [];\n\n\t\t\t}\n\n\t\t\tfor ( var a in material.attributes ) {\n\n\t\t\t\tvar attribute = material.attributes[ a ];\n\n\t\t\t\tif ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {\n\n\t\t\t\t\tattribute.__webglInitialized = true;\n\n\t\t\t\t\tvar size = 1;\t\t// \"f\" and \"i\"\n\n\t\t\t\t\tif ( attribute.type === \"v2\" ) size = 2;\n\t\t\t\t\telse if ( attribute.type === \"v3\" ) size = 3;\n\t\t\t\t\telse if ( attribute.type === \"v4\" ) size = 4;\n\t\t\t\t\telse if ( attribute.type === \"c\"  ) size = 3;\n\n\t\t\t\t\tattribute.size = size;\n\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\n\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\n\t\t\t\t\tattribute.buffer.belongsToAttribute = a;\n\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.__webglCustomAttributesList.push( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction initParticleBuffers ( geometry, object ) {\n\n\t\tvar nvertices = geometry.vertices.length;\n\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\n\n\t\tgeometry.__sortArray = [];\n\n\t\tgeometry.__webglParticleCount = nvertices;\n\n\t\tinitCustomAttributes ( geometry, object );\n\n\t};\n\n\tfunction initLineBuffers ( geometry, object ) {\n\n\t\tvar nvertices = geometry.vertices.length;\n\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\n\t\tgeometry.__lineDistanceArray = new Float32Array( nvertices * 1 );\n\n\t\tgeometry.__webglLineCount = nvertices;\n\n\t\tinitCustomAttributes ( geometry, object );\n\n\t};\n\n\tfunction initMeshBuffers ( geometryGroup, object ) {\n\n\t\tvar geometry = object.geometry,\n\t\t\tfaces3 = geometryGroup.faces3,\n\n\t\t\tnvertices = faces3.length * 3,\n\t\t\tntris     = faces3.length * 1,\n\t\t\tnlines    = faces3.length * 3,\n\n\t\t\tmaterial = getBufferMaterial( object, geometryGroup ),\n\n\t\t\tuvType = bufferGuessUVType( material ),\n\t\t\tnormalType = bufferGuessNormalType( material ),\n\t\t\tvertexColorType = bufferGuessVertexColorType( material );\n\n\t\t// console.log( \"uvType\", uvType, \"normalType\", normalType, \"vertexColorType\", vertexColorType, object, geometryGroup, material );\n\n\t\tgeometryGroup.__vertexArray = new Float32Array( nvertices * 3 );\n\n\t\tif ( normalType ) {\n\n\t\t\tgeometryGroup.__normalArray = new Float32Array( nvertices * 3 );\n\n\t\t}\n\n\t\tif ( geometry.hasTangents ) {\n\n\t\t\tgeometryGroup.__tangentArray = new Float32Array( nvertices * 4 );\n\n\t\t}\n\n\t\tif ( vertexColorType ) {\n\n\t\t\tgeometryGroup.__colorArray = new Float32Array( nvertices * 3 );\n\n\t\t}\n\n\t\tif ( uvType ) {\n\n\t\t\tif ( geometry.faceVertexUvs.length > 0 ) {\n\n\t\t\t\tgeometryGroup.__uvArray = new Float32Array( nvertices * 2 );\n\n\t\t\t}\n\n\t\t\tif ( geometry.faceVertexUvs.length > 1 ) {\n\n\t\t\t\tgeometryGroup.__uv2Array = new Float32Array( nvertices * 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {\n\n\t\t\tgeometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );\n\t\t\tgeometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );\n\n\t\t}\n\n\t\tgeometryGroup.__faceArray = new Uint16Array( ntris * 3 );\n\t\tgeometryGroup.__lineArray = new Uint16Array( nlines * 2 );\n\n\t\tvar m, ml;\n\n\t\tif ( geometryGroup.numMorphTargets ) {\n\n\t\t\tgeometryGroup.__morphTargetsArrays = [];\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\n\t\t\t\tgeometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( geometryGroup.numMorphNormals ) {\n\n\t\t\tgeometryGroup.__morphNormalsArrays = [];\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\n\t\t\t\tgeometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometryGroup.__webglFaceCount = ntris * 3;\n\t\tgeometryGroup.__webglLineCount = nlines * 2;\n\n\n\t\t// custom attributes\n\n\t\tif ( material.attributes ) {\n\n\t\t\tif ( geometryGroup.__webglCustomAttributesList === undefined ) {\n\n\t\t\t\tgeometryGroup.__webglCustomAttributesList = [];\n\n\t\t\t}\n\n\t\t\tfor ( var a in material.attributes ) {\n\n\t\t\t\t// Do a shallow copy of the attribute object so different geometryGroup chunks use different\n\t\t\t\t// attribute buffers which are correctly indexed in the setMeshBuffers function\n\n\t\t\t\tvar originalAttribute = material.attributes[ a ];\n\n\t\t\t\tvar attribute = {};\n\n\t\t\t\tfor ( var property in originalAttribute ) {\n\n\t\t\t\t\tattribute[ property ] = originalAttribute[ property ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {\n\n\t\t\t\t\tattribute.__webglInitialized = true;\n\n\t\t\t\t\tvar size = 1;\t\t// \"f\" and \"i\"\n\n\t\t\t\t\tif( attribute.type === \"v2\" ) size = 2;\n\t\t\t\t\telse if( attribute.type === \"v3\" ) size = 3;\n\t\t\t\t\telse if( attribute.type === \"v4\" ) size = 4;\n\t\t\t\t\telse if( attribute.type === \"c\"  ) size = 3;\n\n\t\t\t\t\tattribute.size = size;\n\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\n\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\n\t\t\t\t\tattribute.buffer.belongsToAttribute = a;\n\n\t\t\t\t\toriginalAttribute.needsUpdate = true;\n\t\t\t\t\tattribute.__original = originalAttribute;\n\n\t\t\t\t}\n\n\t\t\t\tgeometryGroup.__webglCustomAttributesList.push( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometryGroup.__inittedArrays = true;\n\n\t};\n\n\tfunction getBufferMaterial( object, geometryGroup ) {\n\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\n\t\t\t? object.material.materials[ geometryGroup.materialIndex ]\n\t\t\t: object.material;\n\n\t};\n\n\tfunction materialNeedsSmoothNormals ( material ) {\n\n\t\treturn material && material.shading !== undefined && material.shading === THREE.SmoothShading;\n\n\t};\n\n\tfunction bufferGuessNormalType ( material ) {\n\n\t\t// only MeshBasicMaterial and MeshDepthMaterial don't need normals\n\n\t\tif ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( materialNeedsSmoothNormals( material ) ) {\n\n\t\t\treturn THREE.SmoothShading;\n\n\t\t} else {\n\n\t\t\treturn THREE.FlatShading;\n\n\t\t}\n\n\t};\n\n\tfunction bufferGuessVertexColorType( material ) {\n\n\t\tif ( material.vertexColors ) {\n\n\t\t\treturn material.vertexColors;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n\tfunction bufferGuessUVType( material ) {\n\n\t\t// material must use some texture to require uvs\n\n\t\tif ( material.map ||\n\t\t     material.lightMap ||\n\t\t     material.bumpMap ||\n\t\t     material.normalMap ||\n\t\t     material.specularMap ||\n\t\t     material instanceof THREE.ShaderMaterial ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n\t//\n\n\tfunction initDirectBuffers( geometry ) {\n\n\t\tvar a, attribute, type;\n\n\t\tfor ( a in geometry.attributes ) {\n\n\t\t\tif ( a === \"index\" ) {\n\n\t\t\t\ttype = _gl.ELEMENT_ARRAY_BUFFER;\n\n\t\t\t} else {\n\n\t\t\t\ttype = _gl.ARRAY_BUFFER;\n\n\t\t\t}\n\n\t\t\tattribute = geometry.attributes[ a ];\n\n\t\t\tif ( attribute.numItems === undefined ) {\n\n\t\t\t\tattribute.numItems = attribute.array.length;\n\n\t\t\t}\n\n\t\t\tattribute.buffer = _gl.createBuffer();\n\n\t\t\t_gl.bindBuffer( type, attribute.buffer );\n\t\t\t_gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );\n\n\t\t}\n\n\t};\n\n\t// Buffer setting\n\n\tfunction setParticleBuffers ( geometry, hint, object ) {\n\n\t\tvar v, c, vertex, offset, index, color,\n\n\t\tvertices = geometry.vertices,\n\t\tvl = vertices.length,\n\n\t\tcolors = geometry.colors,\n\t\tcl = colors.length,\n\n\t\tvertexArray = geometry.__vertexArray,\n\t\tcolorArray = geometry.__colorArray,\n\n\t\tsortArray = geometry.__sortArray,\n\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\t\tdirtyElements = geometry.elementsNeedUpdate,\n\t\tdirtyColors = geometry.colorsNeedUpdate,\n\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\n\t\ti, il,\n\t\ta, ca, cal, value,\n\t\tcustomAttribute;\n\n\t\tif ( object.sortParticles ) {\n\n\t\t\t_projScreenMatrixPS.copy( _projScreenMatrix );\n\t\t\t_projScreenMatrixPS.multiply( object.matrixWorld );\n\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\tvertex = vertices[ v ];\n\n\t\t\t\t_vector3.copy( vertex );\n\t\t\t\t_vector3.applyProjection( _projScreenMatrixPS );\n\n\t\t\t\tsortArray[ v ] = [ _vector3.z, v ];\n\n\t\t\t}\n\n\t\t\tsortArray.sort( numericalSort );\n\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\tvertex = vertices[ sortArray[v][1] ];\n\n\t\t\t\toffset = v * 3;\n\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\n\t\t\t\toffset = c * 3;\n\n\t\t\t\tcolor = colors[ sortArray[c][1] ];\n\n\t\t\t\tcolorArray[ offset ]     = color.r;\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\n\t\t\t}\n\n\t\t\tif ( customAttributes ) {\n\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\t\tif ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) ) continue;\n\n\t\t\t\t\toffset = 0;\n\n\t\t\t\t\tcal = customAttribute.value.length;\n\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ index ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\n\t\t\t\t\t\t\toffset += 2;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]     = value.r;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\n\t\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( dirtyVertices ) {\n\n\t\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\t\tvertex = vertices[ v ];\n\n\t\t\t\t\toffset = v * 3;\n\n\t\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\t\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\t\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( dirtyColors ) {\n\n\t\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\n\t\t\t\t\tcolor = colors[ c ];\n\n\t\t\t\t\toffset = c * 3;\n\n\t\t\t\t\tcolorArray[ offset ]     = color.r;\n\t\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\t\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( customAttributes ) {\n\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\t\tif ( customAttribute.needsUpdate &&\n\t\t\t\t\t\t ( customAttribute.boundTo === undefined ||\n\t\t\t\t\t\t   customAttribute.boundTo === \"vertices\") ) {\n\n\t\t\t\t\t\tcal = customAttribute.value.length;\n\n\t\t\t\t\t\toffset = 0;\n\n\t\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\n\t\t\t\t\t\t\t\toffset += 2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\n\t\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\n\t\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\n\t\t\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyVertices || object.sortParticles ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyColors || object.sortParticles ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\n\t\t}\n\n\t\tif ( customAttributes ) {\n\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\tif ( customAttribute.needsUpdate || object.sortParticles ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t};\n\n\tfunction setLineBuffers ( geometry, hint ) {\n\n\t\tvar v, c, d, vertex, offset, color,\n\n\t\tvertices = geometry.vertices,\n\t\tcolors = geometry.colors,\n\t\tlineDistances = geometry.lineDistances,\n\n\t\tvl = vertices.length,\n\t\tcl = colors.length,\n\t\tdl = lineDistances.length,\n\n\t\tvertexArray = geometry.__vertexArray,\n\t\tcolorArray = geometry.__colorArray,\n\t\tlineDistanceArray = geometry.__lineDistanceArray,\n\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\t\tdirtyColors = geometry.colorsNeedUpdate,\n\t\tdirtyLineDistances = geometry.lineDistancesNeedUpdate,\n\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\n\n\t\ti, il,\n\t\ta, ca, cal, value,\n\t\tcustomAttribute;\n\n\t\tif ( dirtyVertices ) {\n\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\tvertex = vertices[ v ];\n\n\t\t\t\toffset = v * 3;\n\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyColors ) {\n\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\n\t\t\t\tcolor = colors[ c ];\n\n\t\t\t\toffset = c * 3;\n\n\t\t\t\tcolorArray[ offset ]     = color.r;\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyLineDistances ) {\n\n\t\t\tfor ( d = 0; d < dl; d ++ ) {\n\n\t\t\t\tlineDistanceArray[ d ] = lineDistances[ d ];\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );\n\n\t\t}\n\n\t\tif ( customAttributes ) {\n\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\tif ( customAttribute.needsUpdate &&\n\t\t\t\t\t ( customAttribute.boundTo === undefined ||\n\t\t\t\t\t   customAttribute.boundTo === \"vertices\" ) ) {\n\n\t\t\t\t\toffset = 0;\n\n\t\t\t\t\tcal = customAttribute.value.length;\n\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\n\t\t\t\t\t\t\toffset += 2;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t = value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\n\t\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction setMeshBuffers( geometryGroup, object, hint, dispose, material ) {\n\n\t\tif ( ! geometryGroup.__inittedArrays ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar normalType = bufferGuessNormalType( material ),\n\t\tvertexColorType = bufferGuessVertexColorType( material ),\n\t\tuvType = bufferGuessUVType( material ),\n\n\t\tneedsSmoothNormals = ( normalType === THREE.SmoothShading );\n\n\t\tvar f, fl, fi, face,\n\t\tvertexNormals, faceNormal, normal,\n\t\tvertexColors, faceColor,\n\t\tvertexTangents,\n\t\tuv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,\n\t\tc1, c2, c3, c4,\n\t\tsw1, sw2, sw3, sw4,\n\t\tsi1, si2, si3, si4,\n\t\tsa1, sa2, sa3, sa4,\n\t\tsb1, sb2, sb3, sb4,\n\t\tm, ml, i, il,\n\t\tvn, uvi, uv2i,\n\t\tvk, vkl, vka,\n\t\tnka, chf, faceVertexNormals,\n\t\ta,\n\n\t\tvertexIndex = 0,\n\n\t\toffset = 0,\n\t\toffset_uv = 0,\n\t\toffset_uv2 = 0,\n\t\toffset_face = 0,\n\t\toffset_normal = 0,\n\t\toffset_tangent = 0,\n\t\toffset_line = 0,\n\t\toffset_color = 0,\n\t\toffset_skin = 0,\n\t\toffset_morphTarget = 0,\n\t\toffset_custom = 0,\n\t\toffset_customSrc = 0,\n\n\t\tvalue,\n\n\t\tvertexArray = geometryGroup.__vertexArray,\n\t\tuvArray = geometryGroup.__uvArray,\n\t\tuv2Array = geometryGroup.__uv2Array,\n\t\tnormalArray = geometryGroup.__normalArray,\n\t\ttangentArray = geometryGroup.__tangentArray,\n\t\tcolorArray = geometryGroup.__colorArray,\n\n\t\tskinIndexArray = geometryGroup.__skinIndexArray,\n\t\tskinWeightArray = geometryGroup.__skinWeightArray,\n\n\t\tmorphTargetsArrays = geometryGroup.__morphTargetsArrays,\n\t\tmorphNormalsArrays = geometryGroup.__morphNormalsArrays,\n\n\t\tcustomAttributes = geometryGroup.__webglCustomAttributesList,\n\t\tcustomAttribute,\n\n\t\tfaceArray = geometryGroup.__faceArray,\n\t\tlineArray = geometryGroup.__lineArray,\n\n\t\tgeometry = object.geometry, // this is shared for all chunks\n\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\t\tdirtyElements = geometry.elementsNeedUpdate,\n\t\tdirtyUvs = geometry.uvsNeedUpdate,\n\t\tdirtyNormals = geometry.normalsNeedUpdate,\n\t\tdirtyTangents = geometry.tangentsNeedUpdate,\n\t\tdirtyColors = geometry.colorsNeedUpdate,\n\t\tdirtyMorphTargets = geometry.morphTargetsNeedUpdate,\n\n\t\tvertices = geometry.vertices,\n\t\tchunk_faces3 = geometryGroup.faces3,\n\t\tobj_faces = geometry.faces,\n\n\t\tobj_uvs  = geometry.faceVertexUvs[ 0 ],\n\t\tobj_uvs2 = geometry.faceVertexUvs[ 1 ],\n\n\t\tobj_colors = geometry.colors,\n\n\t\tobj_skinIndices = geometry.skinIndices,\n\t\tobj_skinWeights = geometry.skinWeights,\n\n\t\tmorphTargets = geometry.morphTargets,\n\t\tmorphNormals = geometry.morphNormals;\n\n\t\tif ( dirtyVertices ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\n\n\t\t\t\tv1 = vertices[ face.a ];\n\t\t\t\tv2 = vertices[ face.b ];\n\t\t\t\tv3 = vertices[ face.c ];\n\n\t\t\t\tvertexArray[ offset ]     = v1.x;\n\t\t\t\tvertexArray[ offset + 1 ] = v1.y;\n\t\t\t\tvertexArray[ offset + 2 ] = v1.z;\n\n\t\t\t\tvertexArray[ offset + 3 ] = v2.x;\n\t\t\t\tvertexArray[ offset + 4 ] = v2.y;\n\t\t\t\tvertexArray[ offset + 5 ] = v2.z;\n\n\t\t\t\tvertexArray[ offset + 6 ] = v3.x;\n\t\t\t\tvertexArray[ offset + 7 ] = v3.y;\n\t\t\t\tvertexArray[ offset + 8 ] = v3.z;\n\n\t\t\t\toffset += 9;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyMorphTargets ) {\n\n\t\t\tfor ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {\n\n\t\t\t\toffset_morphTarget = 0;\n\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\tchf = chunk_faces3[ f ];\n\t\t\t\t\tface = obj_faces[ chf ];\n\n\t\t\t\t\t// morph positions\n\n\t\t\t\t\tv1 = morphTargets[ vk ].vertices[ face.a ];\n\t\t\t\t\tv2 = morphTargets[ vk ].vertices[ face.b ];\n\t\t\t\t\tv3 = morphTargets[ vk ].vertices[ face.c ];\n\n\t\t\t\t\tvka = morphTargetsArrays[ vk ];\n\n\t\t\t\t\tvka[ offset_morphTarget ] \t  = v1.x;\n\t\t\t\t\tvka[ offset_morphTarget + 1 ] = v1.y;\n\t\t\t\t\tvka[ offset_morphTarget + 2 ] = v1.z;\n\n\t\t\t\t\tvka[ offset_morphTarget + 3 ] = v2.x;\n\t\t\t\t\tvka[ offset_morphTarget + 4 ] = v2.y;\n\t\t\t\t\tvka[ offset_morphTarget + 5 ] = v2.z;\n\n\t\t\t\t\tvka[ offset_morphTarget + 6 ] = v3.x;\n\t\t\t\t\tvka[ offset_morphTarget + 7 ] = v3.y;\n\t\t\t\t\tvka[ offset_morphTarget + 8 ] = v3.z;\n\n\t\t\t\t\t// morph normals\n\n\t\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t\tif ( needsSmoothNormals ) {\n\n\t\t\t\t\t\t\tfaceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\n\n\t\t\t\t\t\t\tn1 = faceVertexNormals.a;\n\t\t\t\t\t\t\tn2 = faceVertexNormals.b;\n\t\t\t\t\t\t\tn3 = faceVertexNormals.c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tn1 = morphNormals[ vk ].faceNormals[ chf ];\n\t\t\t\t\t\t\tn2 = n1;\n\t\t\t\t\t\t\tn3 = n1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnka = morphNormalsArrays[ vk ];\n\n\t\t\t\t\t\tnka[ offset_morphTarget ] \t  = n1.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 1 ] = n1.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 2 ] = n1.z;\n\n\t\t\t\t\t\tnka[ offset_morphTarget + 3 ] = n2.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 4 ] = n2.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 5 ] = n2.z;\n\n\t\t\t\t\t\tnka[ offset_morphTarget + 6 ] = n3.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 7 ] = n3.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 8 ] = n3.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\toffset_morphTarget += 9;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );\n\n\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( obj_skinWeights.length ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t// weights\n\n\t\t\t\tsw1 = obj_skinWeights[ face.a ];\n\t\t\t\tsw2 = obj_skinWeights[ face.b ];\n\t\t\t\tsw3 = obj_skinWeights[ face.c ];\n\n\t\t\t\tskinWeightArray[ offset_skin ]     = sw1.x;\n\t\t\t\tskinWeightArray[ offset_skin + 1 ] = sw1.y;\n\t\t\t\tskinWeightArray[ offset_skin + 2 ] = sw1.z;\n\t\t\t\tskinWeightArray[ offset_skin + 3 ] = sw1.w;\n\n\t\t\t\tskinWeightArray[ offset_skin + 4 ] = sw2.x;\n\t\t\t\tskinWeightArray[ offset_skin + 5 ] = sw2.y;\n\t\t\t\tskinWeightArray[ offset_skin + 6 ] = sw2.z;\n\t\t\t\tskinWeightArray[ offset_skin + 7 ] = sw2.w;\n\n\t\t\t\tskinWeightArray[ offset_skin + 8 ]  = sw3.x;\n\t\t\t\tskinWeightArray[ offset_skin + 9 ]  = sw3.y;\n\t\t\t\tskinWeightArray[ offset_skin + 10 ] = sw3.z;\n\t\t\t\tskinWeightArray[ offset_skin + 11 ] = sw3.w;\n\n\t\t\t\t// indices\n\n\t\t\t\tsi1 = obj_skinIndices[ face.a ];\n\t\t\t\tsi2 = obj_skinIndices[ face.b ];\n\t\t\t\tsi3 = obj_skinIndices[ face.c ];\n\n\t\t\t\tskinIndexArray[ offset_skin ]     = si1.x;\n\t\t\t\tskinIndexArray[ offset_skin + 1 ] = si1.y;\n\t\t\t\tskinIndexArray[ offset_skin + 2 ] = si1.z;\n\t\t\t\tskinIndexArray[ offset_skin + 3 ] = si1.w;\n\n\t\t\t\tskinIndexArray[ offset_skin + 4 ] = si2.x;\n\t\t\t\tskinIndexArray[ offset_skin + 5 ] = si2.y;\n\t\t\t\tskinIndexArray[ offset_skin + 6 ] = si2.z;\n\t\t\t\tskinIndexArray[ offset_skin + 7 ] = si2.w;\n\n\t\t\t\tskinIndexArray[ offset_skin + 8 ]  = si3.x;\n\t\t\t\tskinIndexArray[ offset_skin + 9 ]  = si3.y;\n\t\t\t\tskinIndexArray[ offset_skin + 10 ] = si3.z;\n\t\t\t\tskinIndexArray[ offset_skin + 11 ] = si3.w;\n\n\t\t\t\toffset_skin += 12;\n\n\t\t\t}\n\n\t\t\tif ( offset_skin > 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyColors && vertexColorType ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\tvertexColors = face.vertexColors;\n\t\t\t\tfaceColor = face.color;\n\n\t\t\t\tif ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {\n\n\t\t\t\t\tc1 = vertexColors[ 0 ];\n\t\t\t\t\tc2 = vertexColors[ 1 ];\n\t\t\t\t\tc3 = vertexColors[ 2 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc1 = faceColor;\n\t\t\t\t\tc2 = faceColor;\n\t\t\t\t\tc3 = faceColor;\n\n\t\t\t\t}\n\n\t\t\t\tcolorArray[ offset_color ]     = c1.r;\n\t\t\t\tcolorArray[ offset_color + 1 ] = c1.g;\n\t\t\t\tcolorArray[ offset_color + 2 ] = c1.b;\n\n\t\t\t\tcolorArray[ offset_color + 3 ] = c2.r;\n\t\t\t\tcolorArray[ offset_color + 4 ] = c2.g;\n\t\t\t\tcolorArray[ offset_color + 5 ] = c2.b;\n\n\t\t\t\tcolorArray[ offset_color + 6 ] = c3.r;\n\t\t\t\tcolorArray[ offset_color + 7 ] = c3.g;\n\t\t\t\tcolorArray[ offset_color + 8 ] = c3.b;\n\n\t\t\t\toffset_color += 9;\n\n\t\t\t}\n\n\t\t\tif ( offset_color > 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyTangents && geometry.hasTangents ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\tvertexTangents = face.vertexTangents;\n\n\t\t\t\tt1 = vertexTangents[ 0 ];\n\t\t\t\tt2 = vertexTangents[ 1 ];\n\t\t\t\tt3 = vertexTangents[ 2 ];\n\n\t\t\t\ttangentArray[ offset_tangent ]     = t1.x;\n\t\t\t\ttangentArray[ offset_tangent + 1 ] = t1.y;\n\t\t\t\ttangentArray[ offset_tangent + 2 ] = t1.z;\n\t\t\t\ttangentArray[ offset_tangent + 3 ] = t1.w;\n\n\t\t\t\ttangentArray[ offset_tangent + 4 ] = t2.x;\n\t\t\t\ttangentArray[ offset_tangent + 5 ] = t2.y;\n\t\t\t\ttangentArray[ offset_tangent + 6 ] = t2.z;\n\t\t\t\ttangentArray[ offset_tangent + 7 ] = t2.w;\n\n\t\t\t\ttangentArray[ offset_tangent + 8 ]  = t3.x;\n\t\t\t\ttangentArray[ offset_tangent + 9 ]  = t3.y;\n\t\t\t\ttangentArray[ offset_tangent + 10 ] = t3.z;\n\t\t\t\ttangentArray[ offset_tangent + 11 ] = t3.w;\n\n\t\t\t\toffset_tangent += 12;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyNormals && normalType ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\tvertexNormals = face.vertexNormals;\n\t\t\t\tfaceNormal = face.normal;\n\n\t\t\t\tif ( vertexNormals.length === 3 && needsSmoothNormals ) {\n\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tvn = vertexNormals[ i ];\n\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = vn.x;\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = vn.y;\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = vn.z;\n\n\t\t\t\t\t\toffset_normal += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = faceNormal.x;\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = faceNormal.y;\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = faceNormal.z;\n\n\t\t\t\t\t\toffset_normal += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyUvs && obj_uvs && uvType ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tfi = chunk_faces3[ f ];\n\n\t\t\t\tuv = obj_uvs[ fi ];\n\n\t\t\t\tif ( uv === undefined ) continue;\n\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tuvi = uv[ i ];\n\n\t\t\t\t\tuvArray[ offset_uv ]     = uvi.x;\n\t\t\t\t\tuvArray[ offset_uv + 1 ] = uvi.y;\n\n\t\t\t\t\toffset_uv += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( offset_uv > 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyUvs && obj_uvs2 && uvType ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tfi = chunk_faces3[ f ];\n\n\t\t\t\tuv2 = obj_uvs2[ fi ];\n\n\t\t\t\tif ( uv2 === undefined ) continue;\n\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tuv2i = uv2[ i ];\n\n\t\t\t\t\tuv2Array[ offset_uv2 ]     = uv2i.x;\n\t\t\t\t\tuv2Array[ offset_uv2 + 1 ] = uv2i.y;\n\n\t\t\t\t\toffset_uv2 += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( offset_uv2 > 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyElements ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tfaceArray[ offset_face ] \t = vertexIndex;\n\t\t\t\tfaceArray[ offset_face + 1 ] = vertexIndex + 1;\n\t\t\t\tfaceArray[ offset_face + 2 ] = vertexIndex + 2;\n\n\t\t\t\toffset_face += 3;\n\n\t\t\t\tlineArray[ offset_line ]     = vertexIndex;\n\t\t\t\tlineArray[ offset_line + 1 ] = vertexIndex + 1;\n\n\t\t\t\tlineArray[ offset_line + 2 ] = vertexIndex;\n\t\t\t\tlineArray[ offset_line + 3 ] = vertexIndex + 2;\n\n\t\t\t\tlineArray[ offset_line + 4 ] = vertexIndex + 1;\n\t\t\t\tlineArray[ offset_line + 5 ] = vertexIndex + 2;\n\n\t\t\t\toffset_line += 6;\n\n\t\t\t\tvertexIndex += 3;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );\n\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );\n\n\t\t}\n\n\t\tif ( customAttributes ) {\n\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\tif ( ! customAttribute.__original.needsUpdate ) continue;\n\n\t\t\t\toffset_custom = 0;\n\t\t\t\toffset_customSrc = 0;\n\n\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\n\n\t\t\t\t\t\t\toffset_custom += 3;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = value;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = value;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = value;\n\n\t\t\t\t\t\t\toffset_custom += 3;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\n\n\t\t\t\t\t\t\toffset_custom += 6;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\n\n\t\t\t\t\t\t\toffset_custom += 6;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\tvar pp;\n\n\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\tpp = [ \"r\", \"g\", \"b\" ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpp = [ \"x\", \"y\", \"z\" ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 9;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 9;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faceVertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value[ 0 ];\n\t\t\t\t\t\t\tv2 = value[ 1 ];\n\t\t\t\t\t\t\tv3 = value[ 2 ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 9;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faceVertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value[ 0 ];\n\t\t\t\t\t\t\tv2 = value[ 1 ];\n\t\t\t\t\t\t\tv3 = value[ 2 ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dispose ) {\n\n\t\t\tdelete geometryGroup.__inittedArrays;\n\t\t\tdelete geometryGroup.__colorArray;\n\t\t\tdelete geometryGroup.__normalArray;\n\t\t\tdelete geometryGroup.__tangentArray;\n\t\t\tdelete geometryGroup.__uvArray;\n\t\t\tdelete geometryGroup.__uv2Array;\n\t\t\tdelete geometryGroup.__faceArray;\n\t\t\tdelete geometryGroup.__vertexArray;\n\t\t\tdelete geometryGroup.__lineArray;\n\t\t\tdelete geometryGroup.__skinIndexArray;\n\t\t\tdelete geometryGroup.__skinWeightArray;\n\n\t\t}\n\n\t};\n\n\tfunction setDirectBuffers ( geometry, hint, dispose ) {\n\n\t\tvar attributes = geometry.attributes;\n\n\t\tvar attributeName, attributeItem;\n\n\t\tfor ( attributeName in attributes ) {\n\n\t\t\tattributeItem = attributes[ attributeName ];\n\n\t\t\tif ( attributeItem.needsUpdate ) {\n\n\t\t\t\tif ( attributeName === 'index' ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.buffer );\n\t\t\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.array, hint );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, attributeItem.array, hint );\n\n\t\t\t\t}\n\n\t\t\t\tattributeItem.needsUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( dispose && ! attributeItem.dynamic ) {\n\n\t\t\t\tattributeItem.array = null;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Buffer rendering\n\n\tthis.renderBufferImmediate = function ( object, program, material ) {\n\n\t\tif ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();\n\t\tif ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();\n\t\tif ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();\n\t\tif ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();\n\n\t\tif ( object.hasPositions ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\t\t\t_gl.enableVertexAttribArray( program.attributes.position );\n\t\t\t_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasNormals ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );\n\n\t\t\tif ( material.shading === THREE.FlatShading ) {\n\n\t\t\t\tvar nx, ny, nz,\n\t\t\t\t\tnax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,\n\t\t\t\t\tnormalArray,\n\t\t\t\t\ti, il = object.count * 3;\n\n\t\t\t\tfor( i = 0; i < il; i += 9 ) {\n\n\t\t\t\t\tnormalArray = object.normalArray;\n\n\t\t\t\t\tnax  = normalArray[ i ];\n\t\t\t\t\tnay  = normalArray[ i + 1 ];\n\t\t\t\t\tnaz  = normalArray[ i + 2 ];\n\n\t\t\t\t\tnbx  = normalArray[ i + 3 ];\n\t\t\t\t\tnby  = normalArray[ i + 4 ];\n\t\t\t\t\tnbz  = normalArray[ i + 5 ];\n\n\t\t\t\t\tncx  = normalArray[ i + 6 ];\n\t\t\t\t\tncy  = normalArray[ i + 7 ];\n\t\t\t\t\tncz  = normalArray[ i + 8 ];\n\n\t\t\t\t\tnx = ( nax + nbx + ncx ) / 3;\n\t\t\t\t\tny = ( nay + nby + ncy ) / 3;\n\t\t\t\t\tnz = ( naz + nbz + ncz ) / 3;\n\n\t\t\t\t\tnormalArray[ i ] \t = nx;\n\t\t\t\t\tnormalArray[ i + 1 ] = ny;\n\t\t\t\t\tnormalArray[ i + 2 ] = nz;\n\n\t\t\t\t\tnormalArray[ i + 3 ] = nx;\n\t\t\t\t\tnormalArray[ i + 4 ] = ny;\n\t\t\t\t\tnormalArray[ i + 5 ] = nz;\n\n\t\t\t\t\tnormalArray[ i + 6 ] = nx;\n\t\t\t\t\tnormalArray[ i + 7 ] = ny;\n\t\t\t\t\tnormalArray[ i + 8 ] = nz;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\t\t\t_gl.enableVertexAttribArray( program.attributes.normal );\n\t\t\t_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasUvs && material.map ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\t\t\t_gl.enableVertexAttribArray( program.attributes.uv );\n\t\t\t_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\t\t\t_gl.enableVertexAttribArray( program.attributes.color );\n\t\t\t_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n\t\tobject.count = 0;\n\n\t};\n\n\tthis.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {\n\n\t\tif ( material.visible === false ) return;\n\n\t\tvar linewidth, a, attribute;\n\t\tvar attributeItem, attributeName, attributePointer, attributeSize;\n\n\t\tvar program = setProgram( camera, lights, fog, material, object );\n\n\t\tvar programAttributes = program.attributes;\n\t\tvar geometryAttributes = geometry.attributes;\n\n\t\tvar updateBuffers = false,\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\n\t\t\tgeometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;\n\n\t\tif ( geometryHash !== _currentGeometryGroupHash ) {\n\n\t\t\t_currentGeometryGroupHash = geometryHash;\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tdisableAttributes();\n\n\t\t}\n\n\t\t// render mesh\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tvar index = geometryAttributes[ \"index\" ];\n\n\t\t\t// indexed triangles\n\n\t\t\tif ( index ) {\n\n\t\t\t\tvar offsets = geometry.offsets;\n\n\t\t\t\t// if there is more than 1 chunk\n\t\t\t\t// must set attribute pointers to use new offsets for each chunk\n\t\t\t\t// even if geometry and materials didn't change\n\n\t\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\n\n\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar startIndex = offsets[ i ].index;\n\n\t\t\t\t\tif ( updateBuffers ) {\n\n\t\t\t\t\t\tfor ( attributeName in programAttributes ) {\n\n\t\t\t\t\t\t\tattributePointer = programAttributes[ attributeName ];\n\t\t\t\t\t\t\tattributeItem = geometryAttributes[ attributeName ];\n\n\t\t\t\t\t\t\tif ( attributePointer >= 0 ) {\n\n\t\t\t\t\t\t\t\tif ( attributeItem ) {\n\n\t\t\t\t\t\t\t\t\tattributeSize = attributeItem.itemSize;\n\t\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\n\t\t\t\t\t\t\t\t\tenableAttribute( attributePointer );\n\t\t\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, startIndex * attributeSize * 4 ); // 4 bytes per Float32\n\n\t\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues ) {\n\n\t\t\t\t\t\t\t\t\tif ( material.defaultAttributeValues[ attributeName ].length === 2 ) {\n\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\n\t\t\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// indices\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// render indexed triangles\n\n\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16\n\n\t\t\t\t\t_this.info.render.calls ++;\n\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\n\t\t\t\t\t_this.info.render.faces += offsets[ i ].count / 3;\n\n\t\t\t\t}\n\n\t\t\t// non-indexed triangles\n\n\t\t\t} else {\n\n\t\t\t\tif ( updateBuffers ) {\n\n\t\t\t\t\tfor ( attributeName in programAttributes ) {\n\n\t\t\t\t\t\tif ( attributeName === 'index') continue;\n\n\t\t\t\t\t\tattributePointer = programAttributes[ attributeName ];\n\t\t\t\t\t\tattributeItem = geometryAttributes[ attributeName ];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( attributePointer >= 0 ) {\n\n\t\t\t\t\t\t\tif ( attributeItem ) {\n\n\t\t\t\t\t\t\t\tattributeSize = attributeItem.itemSize;\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\n\t\t\t\t\t\t\t\tenableAttribute( attributePointer );\n\t\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {\n\n\t\t\t\t\t\t\t\tif ( material.defaultAttributeValues[ attributeName ].length === 2 ) {\n\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\n\t\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {\n\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar position = geometry.attributes[ \"position\" ];\n\n\t\t\t\t// render non-indexed triangles\n\n\t\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, position.numItems / 3 );\n\n\t\t\t\t_this.info.render.calls ++;\n\t\t\t\t_this.info.render.vertices += position.numItems / 3;\n\t\t\t\t_this.info.render.faces += position.numItems / 3 / 3;\n\n\t\t\t}\n\n\t\t// render particles\n\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\tfor ( attributeName in programAttributes ) {\n\n\t\t\t\t\tattributePointer = programAttributes[ attributeName ];\n\t\t\t\t\tattributeItem = geometryAttributes[ attributeName ];\n\t\t\t\t\t\n\t\t\t\t\tif ( attributePointer >= 0 ) {\n\n\t\t\t\t\t\tif ( attributeItem ) {\n\n\t\t\t\t\t\t\tattributeSize = attributeItem.itemSize;\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\n\t\t\t\t\t\t\tenableAttribute( attributePointer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t\t} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {\n\n\t\t\t\t\t\t\tif ( material.defaultAttributeValues[ attributeName ].length === 2 ) {\n\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\n\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {\n\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar position = geometryAttributes[ \"position\" ];\n\n\t\t\t// render particles\n\n\t\t\t_gl.drawArrays( _gl.POINTS, 0, position.numItems / 3 );\n\n\t\t\t_this.info.render.calls ++;\n\t\t\t_this.info.render.points += position.numItems / 3;\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\tfor ( attributeName in programAttributes ) {\n\n\t\t\t\t\tattributePointer = programAttributes[ attributeName ];\n\t\t\t\t\tattributeItem = geometryAttributes[ attributeName ];\n\t\t\t\t\t\n\t\t\t\t\tif ( attributePointer >= 0 ) {\n\n\t\t\t\t\t\tif ( attributeItem ) {\n\n\t\t\t\t\t\t\tattributeSize = attributeItem.itemSize;\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\n\t\t\t\t\t\t\tenableAttribute( attributePointer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t\t} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {\n\n\t\t\t\t\t\t\tif ( material.defaultAttributeValues[ attributeName ].length === 2 ) {\n\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\n\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {\n\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// render lines\n\n\t\t\tvar primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\n\n\t\t\tsetLineWidth( material.linewidth );\n\n\t\t\tvar position = geometryAttributes[ \"position\" ];\n\n\t\t\t_gl.drawArrays( primitives, 0, position.numItems / 3 );\n\n\t\t\t_this.info.render.calls ++;\n\t\t\t_this.info.render.points += position.numItems;\n\n\t\t}\n\n\t};\n\n\tthis.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {\n\n\t\tif ( material.visible === false ) return;\n\n\t\tvar linewidth, a, attribute, i, il;\n\n\t\tvar program = setProgram( camera, lights, fog, material, object );\n\n\t\tvar attributes = program.attributes;\n\n\t\tvar updateBuffers = false,\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\n\t\t\tgeometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;\n\n\t\tif ( geometryGroupHash !== _currentGeometryGroupHash ) {\n\n\t\t\t_currentGeometryGroupHash = geometryGroupHash;\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tdisableAttributes();\n\n\t\t}\n\n\t\t// vertices\n\n\t\tif ( !material.morphTargets && attributes.position >= 0 ) {\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\n\t\t\t\tenableAttribute( attributes.position );\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( object.morphTargetBase ) {\n\n\t\t\t\tsetupMorphTargets( material, geometryGroup, object );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tif ( updateBuffers ) {\n\n\t\t\t// custom attributes\n\n\t\t\t// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers\n\n\t\t\tif ( geometryGroup.__webglCustomAttributesList ) {\n\n\t\t\t\tfor ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {\n\n\t\t\t\t\tattribute = geometryGroup.__webglCustomAttributesList[ i ];\n\n\t\t\t\t\tif ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );\n\t\t\t\t\t\tenableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// colors\n\n\t\t\tif ( attributes.color >= 0 ) {\n\n\t\t\t\tif ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\n\t\t\t\t\tenableAttribute( attributes.color );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t} else if ( material.defaultAttributeValues ) {\n\n\n\t\t\t\t\t_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normals\n\n\t\t\tif ( attributes.normal >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\n\t\t\t\tenableAttribute( attributes.normal );\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\t// tangents\n\n\t\t\tif ( attributes.tangent >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\n\t\t\t\tenableAttribute( attributes.tangent );\n\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tif ( attributes.uv >= 0 ) {\n\n\t\t\t\tif ( object.geometry.faceVertexUvs[0] ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\n\t\t\t\t\tenableAttribute( attributes.uv );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t} else if ( material.defaultAttributeValues ) {\n\n\n\t\t\t\t\t_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( attributes.uv2 >= 0 ) {\n\n\t\t\t\tif ( object.geometry.faceVertexUvs[1] ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\n\t\t\t\t\tenableAttribute( attributes.uv2 );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t} else if ( material.defaultAttributeValues ) {\n\n\n\t\t\t\t\t_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.skinning &&\n\t\t\t\t attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\n\t\t\t\tenableAttribute( attributes.skinIndex );\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\n\t\t\t\tenableAttribute( attributes.skinWeight );\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\t// line distances\n\n\t\t\tif ( attributes.lineDistance >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );\n\t\t\t\tenableAttribute( attributes.lineDistance );\n\t\t\t\t_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// render mesh\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t// wireframe\n\n\t\t\tif ( material.wireframe ) {\n\n\t\t\t\tsetLineWidth( material.wireframeLinewidth );\n\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\n\t\t\t\t_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t// triangles\n\n\t\t\t} else {\n\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t}\n\n\t\t\t_this.info.render.calls ++;\n\t\t\t_this.info.render.vertices += geometryGroup.__webglFaceCount;\n\t\t\t_this.info.render.faces += geometryGroup.__webglFaceCount / 3;\n\n\t\t// render lines\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tvar primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\n\n\t\t\tsetLineWidth( material.linewidth );\n\n\t\t\t_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );\n\n\t\t\t_this.info.render.calls ++;\n\n\t\t// render particles\n\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\t_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );\n\n\t\t\t_this.info.render.calls ++;\n\t\t\t_this.info.render.points += geometryGroup.__webglParticleCount;\n\n\t\t}\n\n\t};\n\n\tfunction enableAttribute( attribute ) {\n\n\t\tif ( ! _enabledAttributes[ attribute ] ) {\n\n\t\t\t_gl.enableVertexAttribArray( attribute );\n\t\t\t_enabledAttributes[ attribute ] = true;\n\n\t\t}\n\n\t};\n\n\tfunction disableAttributes() {\n\n\t\tfor ( var attribute in _enabledAttributes ) {\n\n\t\t\tif ( _enabledAttributes[ attribute ] ) {\n\n\t\t\t\t_gl.disableVertexAttribArray( attribute );\n\t\t\t\t_enabledAttributes[ attribute ] = false;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction setupMorphTargets ( material, geometryGroup, object ) {\n\n\t\t// set base\n\n\t\tvar attributes = material.program.attributes;\n\n\t\tif ( object.morphTargetBase !== -1 && attributes.position >= 0 ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );\n\t\t\tenableAttribute( attributes.position );\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t} else if ( attributes.position >= 0 ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\n\t\t\tenableAttribute( attributes.position );\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.morphTargetForcedOrder.length ) {\n\n\t\t\t// set forced order\n\n\t\t\tvar m = 0;\n\t\t\tvar order = object.morphTargetForcedOrder;\n\t\t\tvar influences = object.morphTargetInfluences;\n\n\t\t\twhile ( m < material.numSupportedMorphTargets && m < order.length ) {\n\n\t\t\t\tif ( attributes[ \"morphTarget\" + m ] >= 0 ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );\n\t\t\t\t\tenableAttribute( attributes[ \"morphTarget\" + m ] );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( attributes[ \"morphNormal\" + m ] >= 0 && material.morphNormals ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );\n\t\t\t\t\tenableAttribute( attributes[ \"morphNormal\" + m ] );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];\n\n\t\t\t\tm ++;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// find the most influencing\n\n\t\t\tvar influence, activeInfluenceIndices = [];\n\t\t\tvar influences = object.morphTargetInfluences;\n\t\t\tvar i, il = influences.length;\n\n\t\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\t\tinfluence = influences[ i ];\n\n\t\t\t\tif ( influence > 0 ) {\n\n\t\t\t\t\tactiveInfluenceIndices.push( [ influence, i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {\n\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\n\t\t\t\tactiveInfluenceIndices.length = material.numSupportedMorphTargets;\n\n\t\t\t} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {\n\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\n\n\t\t\t} else if ( activeInfluenceIndices.length === 0 ) {\n\n\t\t\t\tactiveInfluenceIndices.push( [ 0, 0 ] );\n\n\t\t\t};\n\n\t\t\tvar influenceIndex, m = 0;\n\n\t\t\twhile ( m < material.numSupportedMorphTargets ) {\n\n\t\t\t\tif ( activeInfluenceIndices[ m ] ) {\n\n\t\t\t\t\tinfluenceIndex = activeInfluenceIndices[ m ][ 1 ];\n\n\t\t\t\t\tif ( attributes[ \"morphTarget\" + m ] >= 0 ) {\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );\n\t\t\t\t\t\tenableAttribute( attributes[ \"morphTarget\" + m ] );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes[ \"morphNormal\" + m ] >= 0 && material.morphNormals ) {\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );\n\t\t\t\t\t\tenableAttribute( attributes[ \"morphNormal\" + m ] );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t/*\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tm ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// load updated influences uniform\n\n\t\tif ( material.program.uniforms.morphTargetInfluences !== null ) {\n\n\t\t\t_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );\n\n\t\t}\n\n\t};\n\n\t// Sorting\n\n\tfunction painterSortStable ( a, b ) {\n\n\t\tif ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn a.id - b.id;\n\n\t\t}\n\n\t};\n\n\tfunction numericalSort ( a, b ) {\n\n\t\treturn b[ 0 ] - a[ 0 ];\n\n\t};\n\n\n\t// Rendering\n\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\tif ( camera instanceof THREE.Camera === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar i, il,\n\n\t\twebglObject, object,\n\t\trenderList,\n\n\t\tlights = scene.__lights,\n\t\tfog = scene.fog;\n\n\t\t// reset caching for this frame\n\n\t\t_currentMaterialId = -1;\n\t\t_lightsNeedUpdate = true;\n\n\t\t// update scene graph\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t// update WebGL objects\n\n\t\tif ( this.autoUpdateObjects ) this.initWebGLObjects( scene );\n\n\t\t// custom render plugins (pre pass)\n\n\t\trenderPlugins( this.renderPluginsPre, scene, camera );\n\n\t\t//\n\n\t\t_this.info.render.calls = 0;\n\t\t_this.info.render.vertices = 0;\n\t\t_this.info.render.faces = 0;\n\t\t_this.info.render.points = 0;\n\n\t\tthis.setRenderTarget( renderTarget );\n\n\t\tif ( this.autoClear || forceClear ) {\n\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\n\t\t}\n\n\t\t// set matrices for regular objects (frustum culled)\n\n\t\trenderList = scene.__webglObjects;\n\n\t\tfor ( i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\twebglObject = renderList[ i ];\n\t\t\tobject = webglObject.object;\n\n\t\t\twebglObject.id = i;\n\t\t\twebglObject.render = false;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\tsetupMatrices( object, camera );\n\n\t\t\t\t\tunrollBufferMaterial( webglObject );\n\n\t\t\t\t\twebglObject.render = true;\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\tif ( object.renderDepth !== null ) {\n\n\t\t\t\t\t\t\twebglObject.z = object.renderDepth;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t\t\twebglObject.z = _vector3.z;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.sortObjects ) {\n\n\t\t\trenderList.sort( painterSortStable );\n\n\t\t}\n\n\t\t// set matrices for immediate objects\n\n\t\trenderList = scene.__webglObjectsImmediate;\n\n\t\tfor ( i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\twebglObject = renderList[ i ];\n\t\t\tobject = webglObject.object;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tsetupMatrices( object, camera );\n\n\t\t\t\tunrollImmediateBufferMaterial( webglObject );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( scene.overrideMaterial ) {\n\n\t\t\tvar material = scene.overrideMaterial;\n\n\t\t\tthis.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\tthis.setDepthTest( material.depthTest );\n\t\t\tthis.setDepthWrite( material.depthWrite );\n\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t\trenderObjects( scene.__webglObjects, false, \"\", camera, lights, fog, true, material );\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"\", camera, lights, fog, false, material );\n\n\t\t} else {\n\n\t\t\tvar material = null;\n\n\t\t\t// opaque pass (front-to-back order)\n\n\t\t\tthis.setBlending( THREE.NoBlending );\n\n\t\t\trenderObjects( scene.__webglObjects, true, \"opaque\", camera, lights, fog, false, material );\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"opaque\", camera, lights, fog, false, material );\n\n\t\t\t// transparent pass (back-to-front order)\n\n\t\t\trenderObjects( scene.__webglObjects, false, \"transparent\", camera, lights, fog, true, material );\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"transparent\", camera, lights, fog, true, material );\n\n\t\t}\n\n\t\t// custom render plugins (post pass)\n\n\t\trenderPlugins( this.renderPluginsPost, scene, camera );\n\n\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\tif ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {\n\n\t\t\tupdateRenderTargetMipmap( renderTarget );\n\n\t\t}\n\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\tthis.setDepthTest( true );\n\t\tthis.setDepthWrite( true );\n\n\t\t// _gl.finish();\n\n\t};\n\n\tfunction renderPlugins( plugins, scene, camera ) {\n\n\t\tif ( ! plugins.length ) return;\n\n\t\tfor ( var i = 0, il = plugins.length; i < il; i ++ ) {\n\n\t\t\t// reset state for plugin (to start from clean slate)\n\n\t\t\t_currentProgram = null;\n\t\t\t_currentCamera = null;\n\n\t\t\t_oldBlending = -1;\n\t\t\t_oldDepthTest = -1;\n\t\t\t_oldDepthWrite = -1;\n\t\t\t_oldDoubleSided = -1;\n\t\t\t_oldFlipSided = -1;\n\t\t\t_currentGeometryGroupHash = -1;\n\t\t\t_currentMaterialId = -1;\n\n\t\t\t_lightsNeedUpdate = true;\n\n\t\t\tplugins[ i ].render( scene, camera, _currentWidth, _currentHeight );\n\n\t\t\t// reset state after plugin (anything could have changed)\n\n\t\t\t_currentProgram = null;\n\t\t\t_currentCamera = null;\n\n\t\t\t_oldBlending = -1;\n\t\t\t_oldDepthTest = -1;\n\t\t\t_oldDepthWrite = -1;\n\t\t\t_oldDoubleSided = -1;\n\t\t\t_oldFlipSided = -1;\n\t\t\t_currentGeometryGroupHash = -1;\n\t\t\t_currentMaterialId = -1;\n\n\t\t\t_lightsNeedUpdate = true;\n\n\t\t}\n\n\t};\n\n\tfunction renderObjects ( renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\n\n\t\tvar webglObject, object, buffer, material, start, end, delta;\n\n\t\tif ( reverse ) {\n\n\t\t\tstart = renderList.length - 1;\n\t\t\tend = -1;\n\t\t\tdelta = -1;\n\n\t\t} else {\n\n\t\t\tstart = 0;\n\t\t\tend = renderList.length;\n\t\t\tdelta = 1;\n\t\t}\n\n\t\tfor ( var i = start; i !== end; i += delta ) {\n\n\t\t\twebglObject = renderList[ i ];\n\n\t\t\tif ( webglObject.render ) {\n\n\t\t\t\tobject = webglObject.object;\n\t\t\t\tbuffer = webglObject.buffer;\n\n\t\t\t\tif ( overrideMaterial ) {\n\n\t\t\t\t\tmaterial = overrideMaterial;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial = webglObject[ materialType ];\n\n\t\t\t\t\tif ( ! material ) continue;\n\n\t\t\t\t\tif ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\n\t\t\t\t\t_this.setDepthTest( material.depthTest );\n\t\t\t\t\t_this.setDepthWrite( material.depthWrite );\n\t\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t\t\t}\n\n\t\t\t\t_this.setMaterialFaces( material );\n\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t_this.renderBufferDirect( camera, lights, fog, material, buffer, object );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_this.renderBuffer( camera, lights, fog, material, buffer, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\n\n\t\tvar webglObject, object, material, program;\n\n\t\tfor ( var i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\twebglObject = renderList[ i ];\n\t\t\tobject = webglObject.object;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tif ( overrideMaterial ) {\n\n\t\t\t\t\tmaterial = overrideMaterial;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial = webglObject[ materialType ];\n\n\t\t\t\t\tif ( ! material ) continue;\n\n\t\t\t\t\tif ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\n\t\t\t\t\t_this.setDepthTest( material.depthTest );\n\t\t\t\t\t_this.setDepthWrite( material.depthWrite );\n\t\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t\t\t}\n\n\t\t\t\t_this.renderImmediateObject( camera, lights, fog, material, object );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.renderImmediateObject = function ( camera, lights, fog, material, object ) {\n\n\t\tvar program = setProgram( camera, lights, fog, material, object );\n\n\t\t_currentGeometryGroupHash = -1;\n\n\t\t_this.setMaterialFaces( material );\n\n\t\tif ( object.immediateRenderCallback ) {\n\n\t\t\tobject.immediateRenderCallback( program, _gl, _frustum );\n\n\t\t} else {\n\n\t\t\tobject.render( function( object ) { _this.renderBufferImmediate( object, program, material ); } );\n\n\t\t}\n\n\t};\n\n\tfunction unrollImmediateBufferMaterial ( globject ) {\n\n\t\tvar object = globject.object,\n\t\t\tmaterial = object.material;\n\n\t\tif ( material.transparent ) {\n\n\t\t\tglobject.transparent = material;\n\t\t\tglobject.opaque = null;\n\n\t\t} else {\n\n\t\t\tglobject.opaque = material;\n\t\t\tglobject.transparent = null;\n\n\t\t}\n\n\t};\n\n\tfunction unrollBufferMaterial ( globject ) {\n\n\t\tvar object = globject.object,\n\t\t\tbuffer = globject.buffer,\n\t\t\tmaterial, materialIndex, meshMaterial;\n\n\t\tmeshMaterial = object.material;\n\n\t\tif ( meshMaterial instanceof THREE.MeshFaceMaterial ) {\n\n\t\t\tmaterialIndex = buffer.materialIndex;\n\n\t\t\tmaterial = meshMaterial.materials[ materialIndex ];\n\n\t\t\tif ( material.transparent ) {\n\n\t\t\t\tglobject.transparent = material;\n\t\t\t\tglobject.opaque = null;\n\n\t\t\t} else {\n\n\t\t\t\tglobject.opaque = material;\n\t\t\t\tglobject.transparent = null;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmaterial = meshMaterial;\n\n\t\t\tif ( material ) {\n\n\t\t\t\tif ( material.transparent ) {\n\n\t\t\t\t\tglobject.transparent = material;\n\t\t\t\t\tglobject.opaque = null;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tglobject.opaque = material;\n\t\t\t\t\tglobject.transparent = null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Geometry splitting\n\n\tfunction sortFacesByMaterial ( geometry, material ) {\n\n\t\tvar f, fl, face, materialIndex, vertices,\n\t\t\tgroupHash, hash_map = {};\n\n\t\tvar numMorphTargets = geometry.morphTargets.length;\n\t\tvar numMorphNormals = geometry.morphNormals.length;\n\n\t\tvar usesFaceMaterial = material instanceof THREE.MeshFaceMaterial;\n\n\t\tgeometry.geometryGroups = {};\n\n\t\tfor ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = geometry.faces[ f ];\n\t\t\tmaterialIndex = usesFaceMaterial ? face.materialIndex : 0;\n\n\t\t\tif ( hash_map[ materialIndex ] === undefined ) {\n\n\t\t\t\thash_map[ materialIndex ] = { 'hash': materialIndex, 'counter': 0 };\n\n\t\t\t}\n\n\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\n\n\t\t\tif ( geometry.geometryGroups[ groupHash ] === undefined ) {\n\n\t\t\t\tgeometry.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };\n\n\t\t\t}\n\n\t\t\tvertices = 3;\n\n\t\t\tif ( geometry.geometryGroups[ groupHash ].vertices + vertices > 65535 ) {\n\n\t\t\t\thash_map[ materialIndex ].counter += 1;\n\t\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\n\n\t\t\t\tif ( geometry.geometryGroups[ groupHash ] === undefined ) {\n\n\t\t\t\t\tgeometry.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.geometryGroups[ groupHash ].faces3.push( f );\n\t\t\tgeometry.geometryGroups[ groupHash ].vertices += vertices;\n\n\t\t}\n\n\t\tgeometry.geometryGroupsList = [];\n\n\t\tfor ( var g in geometry.geometryGroups ) {\n\n\t\t\tgeometry.geometryGroups[ g ].id = _geometryGroupCounter ++;\n\n\t\t\tgeometry.geometryGroupsList.push( geometry.geometryGroups[ g ] );\n\n\t\t}\n\n\t};\n\n\t// Objects refresh\n\n\tthis.initWebGLObjects = function ( scene ) {\n\n\t\tif ( !scene.__webglObjects ) {\n\n\t\t\tscene.__webglObjects = [];\n\t\t\tscene.__webglObjectsImmediate = [];\n\t\t\tscene.__webglSprites = [];\n\t\t\tscene.__webglFlares = [];\n\n\t\t}\n\n\t\twhile ( scene.__objectsAdded.length ) {\n\n\t\t\taddObject( scene.__objectsAdded[ 0 ], scene );\n\t\t\tscene.__objectsAdded.splice( 0, 1 );\n\n\t\t}\n\n\t\twhile ( scene.__objectsRemoved.length ) {\n\n\t\t\tremoveObject( scene.__objectsRemoved[ 0 ], scene );\n\t\t\tscene.__objectsRemoved.splice( 0, 1 );\n\n\t\t}\n\n\t\t// update must be called after objects adding / removal\n\n\t\tfor ( var o = 0, ol = scene.__webglObjects.length; o < ol; o ++ ) {\n\n\t\t\tvar object = scene.__webglObjects[ o ].object;\n\n\t\t\t// TODO: Remove this hack (WebGLRenderer refactoring)\n\n\t\t\tif ( object.__webglInit === undefined ) {\n\n\t\t\t\tif ( object.__webglActive !== undefined ) {\n\n\t\t\t\t\tremoveObject( object, scene );\n\n\t\t\t\t}\n\n\t\t\t\taddObject( object, scene );\n\n\t\t\t}\n\n\t\t\tupdateObject( object );\n\n\t\t}\n\n\t};\n\n\t// Objects adding\n\n\tfunction addObject( object, scene ) {\n\n\t\tvar g, geometry, material, geometryGroup;\n\n\t\tif ( object.__webglInit === undefined ) {\n\n\t\t\tobject.__webglInit = true;\n\n\t\t\tobject._modelViewMatrix = new THREE.Matrix4();\n\t\t\tobject._normalMatrix = new THREE.Matrix3();\n\n\t\t\tif ( object.geometry !== undefined && object.geometry.__webglInit === undefined ) {\n\n\t\t\t\tobject.geometry.__webglInit = true;\n\t\t\t\tobject.geometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\t\t}\n\n\t\t\tgeometry = object.geometry;\n\n\t\t\tif ( geometry === undefined ) {\n\n\t\t\t\t// fail silently for now\n\n\t\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tinitDirectBuffers( geometry );\n\n\t\t\t} else if ( object instanceof THREE.Mesh ) {\n\n\t\t\t\tmaterial = object.material;\n\n\t\t\t\tif ( geometry.geometryGroups === undefined ) {\n\n\t\t\t\t\tsortFacesByMaterial( geometry, material );\n\n\t\t\t\t}\n\n\t\t\t\t// create separate VBOs per geometry chunk\n\n\t\t\t\tfor ( g in geometry.geometryGroups ) {\n\n\t\t\t\t\tgeometryGroup = geometry.geometryGroups[ g ];\n\n\t\t\t\t\t// initialise VBO on the first access\n\n\t\t\t\t\tif ( ! geometryGroup.__webglVertexBuffer ) {\n\n\t\t\t\t\t\tcreateMeshBuffers( geometryGroup );\n\t\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\n\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\t\tgeometry.morphTargetsNeedUpdate = true;\n\t\t\t\t\t\tgeometry.elementsNeedUpdate = true;\n\t\t\t\t\t\tgeometry.uvsNeedUpdate = true;\n\t\t\t\t\t\tgeometry.normalsNeedUpdate = true;\n\t\t\t\t\t\tgeometry.tangentsNeedUpdate = true;\n\t\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\n\n\t\t\t\t\tcreateLineBuffers( geometry );\n\t\t\t\t\tinitLineBuffers( geometry, object );\n\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\t\t\t\t\tgeometry.lineDistancesNeedUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\n\n\t\t\t\t\tcreateParticleBuffers( geometry );\n\t\t\t\t\tinitParticleBuffers( geometry, object );\n\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.__webglActive === undefined ) {\n\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t\tgeometry = object.geometry;\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\taddBuffer( scene.__webglObjects, geometry, object );\n\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\tfor ( g in geometry.geometryGroups ) {\n\n\t\t\t\t\t\tgeometryGroup = geometry.geometryGroups[ g ];\n\n\t\t\t\t\t\taddBuffer( scene.__webglObjects, geometryGroup, object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Line ||\n\t\t\t\t\t\tobject instanceof THREE.ParticleSystem ) {\n\n\t\t\t\tgeometry = object.geometry;\n\t\t\t\taddBuffer( scene.__webglObjects, geometry, object );\n\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\n\n\t\t\t\taddBufferImmediate( scene.__webglObjectsImmediate, object );\n\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t\tscene.__webglSprites.push( object );\n\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\n\n\t\t\t\tscene.__webglFlares.push( object );\n\n\t\t\t}\n\n\t\t\tobject.__webglActive = true;\n\n\t\t}\n\n\t};\n\n\tfunction addBuffer( objlist, buffer, object ) {\n\n\t\tobjlist.push(\n\t\t\t{\n\t\t\t\tid: null,\n\t\t\t\tbuffer: buffer,\n\t\t\t\tobject: object,\n\t\t\t\topaque: null,\n\t\t\t\ttransparent: null,\n\t\t\t\tz: 0\n\t\t\t}\n\t\t);\n\n\t};\n\n\tfunction addBufferImmediate( objlist, object ) {\n\n\t\tobjlist.push(\n\t\t\t{\n\t\t\t\tid: null,\n\t\t\t\tobject: object,\n\t\t\t\topaque: null,\n\t\t\t\ttransparent: null,\n\t\t\t\tz: 0\n\t\t\t}\n\t\t);\n\n\t};\n\n\t// Objects updates\n\n\tfunction updateObject( object ) {\n\n\t\tvar geometry = object.geometry,\n\t\t\tgeometryGroup, customAttributesDirty, material;\n\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tsetDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );\n\n\t\t} else if ( object instanceof THREE.Mesh ) {\n\n\t\t\t// check all geometry groups\n\n\t\t\tfor( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {\n\n\t\t\t\tgeometryGroup = geometry.geometryGroupsList[ i ];\n\n\t\t\t\tmaterial = getBufferMaterial( object, geometryGroup );\n\n\t\t\t\tif ( geometry.buffersNeedUpdate ) {\n\n\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\n\n\t\t\t\t}\n\n\t\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||\n\t\t\t\t\t geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\n\t\t\t\t\t geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {\n\n\t\t\t\t\tsetMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.morphTargetsNeedUpdate = false;\n\t\t\tgeometry.elementsNeedUpdate = false;\n\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\tgeometry.tangentsNeedUpdate = false;\n\n\t\t\tgeometry.buffersNeedUpdate = false;\n\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tmaterial = getBufferMaterial( object, geometry );\n\n\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\n\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {\n\n\t\t\t\tsetLineBuffers( geometry, _gl.DYNAMIC_DRAW );\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\n\n\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\tmaterial = getBufferMaterial( object, geometry );\n\n\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\n\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {\n\n\t\t\t\tsetParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\n\n\t\t}\n\n\t};\n\n\t// Objects updates - custom attributes check\n\n\tfunction areCustomAttributesDirty( material ) {\n\n\t\tfor ( var a in material.attributes ) {\n\n\t\t\tif ( material.attributes[ a ].needsUpdate ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n\tfunction clearCustomAttributes( material ) {\n\n\t\tfor ( var a in material.attributes ) {\n\n\t\t\tmaterial.attributes[ a ].needsUpdate = false;\n\n\t\t}\n\n\t};\n\n\t// Objects removal\n\n\tfunction removeObject( object, scene ) {\n\n\t\tif ( object instanceof THREE.Mesh  ||\n\t\t\t object instanceof THREE.ParticleSystem ||\n\t\t\t object instanceof THREE.Line ) {\n\n\t\t\tremoveInstances( scene.__webglObjects, object );\n\n\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\tremoveInstancesDirect( scene.__webglSprites, object );\n\n\t\t} else if ( object instanceof THREE.LensFlare ) {\n\n\t\t\tremoveInstancesDirect( scene.__webglFlares, object );\n\n\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\n\n\t\t\tremoveInstances( scene.__webglObjectsImmediate, object );\n\n\t\t}\n\n\t\tdelete object.__webglActive;\n\n\t};\n\n\tfunction removeInstances( objlist, object ) {\n\n\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\n\n\t\t\tif ( objlist[ o ].object === object ) {\n\n\t\t\t\tobjlist.splice( o, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction removeInstancesDirect( objlist, object ) {\n\n\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\n\n\t\t\tif ( objlist[ o ] === object ) {\n\n\t\t\t\tobjlist.splice( o, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Materials\n\n\tthis.initMaterial = function ( material, lights, fog, object ) {\n\n\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\tvar u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;\n\n\t\tif ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\tshaderID = 'depth';\n\n\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\tshaderID = 'normal';\n\n\t\t} else if ( material instanceof THREE.MeshBasicMaterial ) {\n\n\t\t\tshaderID = 'basic';\n\n\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\tshaderID = 'lambert';\n\n\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\tshaderID = 'phong';\n\n\t\t} else if ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\tshaderID = 'basic';\n\n\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\n\t\t\tshaderID = 'dashed';\n\n\t\t} else if ( material instanceof THREE.ParticleSystemMaterial ) {\n\n\t\t\tshaderID = 'particle_basic';\n\n\t\t}\n\n\t\tif ( shaderID ) {\n\n\t\t\tsetMaterialShaders( material, THREE.ShaderLib[ shaderID ] );\n\n\t\t}\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tmaxLightCount = allocateLights( lights );\n\n\t\tmaxShadows = allocateShadows( lights );\n\n\t\tmaxBones = allocateBones( object );\n\n\t\tparameters = {\n\n\t\t\tmap: !!material.map,\n\t\t\tenvMap: !!material.envMap,\n\t\t\tlightMap: !!material.lightMap,\n\t\t\tbumpMap: !!material.bumpMap,\n\t\t\tnormalMap: !!material.normalMap,\n\t\t\tspecularMap: !!material.specularMap,\n\n\t\t\tvertexColors: material.vertexColors,\n\n\t\t\tfog: fog,\n\t\t\tuseFog: material.fog,\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation,\n\n\t\t\tskinning: material.skinning,\n\t\t\tmaxBones: maxBones,\n\t\t\tuseVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,\n\n\t\t\tmorphTargets: material.morphTargets,\n\t\t\tmorphNormals: material.morphNormals,\n\t\t\tmaxMorphTargets: this.maxMorphTargets,\n\t\t\tmaxMorphNormals: this.maxMorphNormals,\n\n\t\t\tmaxDirLights: maxLightCount.directional,\n\t\t\tmaxPointLights: maxLightCount.point,\n\t\t\tmaxSpotLights: maxLightCount.spot,\n\t\t\tmaxHemiLights: maxLightCount.hemi,\n\n\t\t\tmaxShadows: maxShadows,\n\t\t\tshadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,\n\t\t\tshadowMapType: this.shadowMapType,\n\t\t\tshadowMapDebug: this.shadowMapDebug,\n\t\t\tshadowMapCascade: this.shadowMapCascade,\n\n\t\t\talphaTest: material.alphaTest,\n\t\t\tmetal: material.metal,\n\t\t\tperPixel: material.perPixel,\n\t\t\twrapAround: material.wrapAround,\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\n\t\t\tflipSided: material.side === THREE.BackSide\n\n\t\t};\n\n\t\tmaterial.program = buildProgram( shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters, material.index0AttributeName );\n\n\t\tvar attributes = material.program.attributes;\n\n\t\tif ( material.morphTargets ) {\n\n\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\tvar id, base = \"morphTarget\";\n\n\t\t\tfor ( i = 0; i < this.maxMorphTargets; i ++ ) {\n\n\t\t\t\tid = base + i;\n\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.morphNormals ) {\n\n\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\tvar id, base = \"morphNormal\";\n\n\t\t\tfor ( i = 0; i < this.maxMorphNormals; i ++ ) {\n\n\t\t\t\tid = base + i;\n\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tmaterial.uniformsList = [];\n\n\t\tfor ( u in material.uniforms ) {\n\n\t\t\tmaterial.uniformsList.push( [ material.uniforms[ u ], u ] );\n\n\t\t}\n\n\t};\n\n\tfunction setMaterialShaders( material, shaders ) {\n\n\t\tmaterial.uniforms = THREE.UniformsUtils.clone( shaders.uniforms );\n\t\tmaterial.vertexShader = shaders.vertexShader;\n\t\tmaterial.fragmentShader = shaders.fragmentShader;\n\n\t};\n\n\tfunction setProgram( camera, lights, fog, material, object ) {\n\n\t\t_usedTextureUnits = 0;\n\n\t\tif ( material.needsUpdate ) {\n\n\t\t\tif ( material.program ) deallocateMaterial( material );\n\n\t\t\t_this.initMaterial( material, lights, fog, object );\n\t\t\tmaterial.needsUpdate = false;\n\n\t\t}\n\n\t\tif ( material.morphTargets ) {\n\n\t\t\tif ( ! object.__webglMorphTargetInfluences ) {\n\n\t\t\t\tobject.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar refreshMaterial = false;\n\n\t\tvar program = material.program,\n\t\t\tp_uniforms = program.uniforms,\n\t\t\tm_uniforms = material.uniforms;\n\n\t\tif ( program !== _currentProgram ) {\n\n\t\t\t_gl.useProgram( program );\n\t\t\t_currentProgram = program;\n\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t_currentMaterialId = material.id;\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( refreshMaterial || camera !== _currentCamera ) {\n\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\t\tif ( camera !== _currentCamera ) _currentCamera = camera;\n\n\t\t}\n\n\t\t// skinning uniforms must be set even if material didn't change\n\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t// not sure why, but otherwise weird things happen\n\n\t\tif ( material.skinning ) {\n\n\t\t\tif ( _supportsBoneTextures && object.useVertexTexture ) {\n\n\t\t\t\tif ( p_uniforms.boneTexture !== null ) {\n\n\t\t\t\t\tvar textureUnit = getTextureUnit();\n\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\n\t\t\t\t\t_this.setTexture( object.boneTexture, textureUnit );\n\n\t\t\t\t}\n\n\t\t\t\tif ( p_uniforms.boneTextureWidth !== null ) {\n\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureWidth, object.boneTextureWidth );\n\n\t\t\t\t}\n\n\t\t\t\tif ( p_uniforms.boneTextureHeight !== null ) {\n\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureHeight, object.boneTextureHeight );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( p_uniforms.boneGlobalMatrices !== null ) {\n\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( refreshMaterial ) {\n\n\t\t\t// refresh uniforms common to several materials\n\n\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material.lights ) {\n\n\t\t\t\tif ( _lightsNeedUpdate ) {\n\n\t\t\t\t\tsetupLights( program, lights );\n\t\t\t\t\t_lightsNeedUpdate = false;\n\n\t\t\t\t}\n\n\t\t\t\trefreshUniformsLights( m_uniforms, _lights );\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t}\n\n\t\t\t// refresh single material specific uniforms\n\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.ParticleSystemMaterial ) {\n\n\t\t\t\trefreshUniformsParticle( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\tm_uniforms.mNear.value = camera.near;\n\t\t\t\tm_uniforms.mFar.value = camera.far;\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t}\n\n\t\t\tif ( object.receiveShadow && ! material._shadowPass ) {\n\n\t\t\t\trefreshUniformsShadow( m_uniforms, lights );\n\n\t\t\t}\n\n\t\t\t// load common uniforms\n\n\t\t\tloadUniformsGeneric( program, material.uniformsList );\n\n\t\t\t// load material specific uniforms\n\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material.envMap ) {\n\n\t\t\t\tif ( p_uniforms.cameraPosition !== null ) {\n\n\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\t_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material.skinning ) {\n\n\t\t\t\tif ( p_uniforms.viewMatrix !== null ) {\n\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tloadUniformsMatrices( p_uniforms, object );\n\n\t\tif ( p_uniforms.modelMatrix !== null ) {\n\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\n\n\t\t}\n\n\t\treturn program;\n\n\t};\n\n\t// Uniforms (refresh uniforms objects)\n\n\tfunction refreshUniformsCommon ( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tif ( _this.gammaInput ) {\n\n\t\t\tuniforms.diffuse.value.copyGammaToLinear( material.color );\n\n\t\t} else {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\n\t\t}\n\n\t\tuniforms.map.value = material.map;\n\t\tuniforms.lightMap.value = material.lightMap;\n\t\tuniforms.specularMap.value = material.specularMap;\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t//\t1. color map\n\t\t//\t2. specular map\n\t\t//\t3. normal map\n\t\t//\t4. bump map\n\n\t\tvar uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.specularMap ) {\n\n\t\t\tuvScaleMap = material.specularMap;\n\n\t\t} else if ( material.normalMap ) {\n\n\t\t\tuvScaleMap = material.normalMap;\n\n\t\t} else if ( material.bumpMap ) {\n\n\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\tvar offset = uvScaleMap.offset;\n\t\t\tvar repeat = uvScaleMap.repeat;\n\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t}\n\n\t\tuniforms.envMap.value = material.envMap;\n\t\tuniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;\n\n\t\tif ( _this.gammaInput ) {\n\n\t\t\t//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\n\t\t} else {\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\n\t\t}\n\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\t\tuniforms.combine.value = material.combine;\n\t\tuniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;\n\n\t};\n\n\tfunction refreshUniformsLine ( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\n\t};\n\n\tfunction refreshUniformsDash ( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t};\n\n\tfunction refreshUniformsParticle ( uniforms, material ) {\n\n\t\tuniforms.psColor.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size;\n\t\tuniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.\n\n\t\tuniforms.map.value = material.map;\n\n\t};\n\n\tfunction refreshUniformsFog ( uniforms, fog ) {\n\n\t\tuniforms.fogColor.value = fog.color;\n\n\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t};\n\n\tfunction refreshUniformsPhong ( uniforms, material ) {\n\n\t\tuniforms.shininess.value = material.shininess;\n\n\t\tif ( _this.gammaInput ) {\n\n\t\t\tuniforms.ambient.value.copyGammaToLinear( material.ambient );\n\t\t\tuniforms.emissive.value.copyGammaToLinear( material.emissive );\n\t\t\tuniforms.specular.value.copyGammaToLinear( material.specular );\n\n\t\t} else {\n\n\t\t\tuniforms.ambient.value = material.ambient;\n\t\t\tuniforms.emissive.value = material.emissive;\n\t\t\tuniforms.specular.value = material.specular;\n\n\t\t}\n\n\t\tif ( material.wrapAround ) {\n\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\n\n\t\t}\n\n\t};\n\n\tfunction refreshUniformsLambert ( uniforms, material ) {\n\n\t\tif ( _this.gammaInput ) {\n\n\t\t\tuniforms.ambient.value.copyGammaToLinear( material.ambient );\n\t\t\tuniforms.emissive.value.copyGammaToLinear( material.emissive );\n\n\t\t} else {\n\n\t\t\tuniforms.ambient.value = material.ambient;\n\t\t\tuniforms.emissive.value = material.emissive;\n\n\t\t}\n\n\t\tif ( material.wrapAround ) {\n\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\n\n\t\t}\n\n\t};\n\n\tfunction refreshUniformsLights ( uniforms, lights ) {\n\n\t\tuniforms.ambientLightColor.value = lights.ambient;\n\n\t\tuniforms.directionalLightColor.value = lights.directional.colors;\n\t\tuniforms.directionalLightDirection.value = lights.directional.positions;\n\n\t\tuniforms.pointLightColor.value = lights.point.colors;\n\t\tuniforms.pointLightPosition.value = lights.point.positions;\n\t\tuniforms.pointLightDistance.value = lights.point.distances;\n\n\t\tuniforms.spotLightColor.value = lights.spot.colors;\n\t\tuniforms.spotLightPosition.value = lights.spot.positions;\n\t\tuniforms.spotLightDistance.value = lights.spot.distances;\n\t\tuniforms.spotLightDirection.value = lights.spot.directions;\n\t\tuniforms.spotLightAngleCos.value = lights.spot.anglesCos;\n\t\tuniforms.spotLightExponent.value = lights.spot.exponents;\n\n\t\tuniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;\n\t\tuniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;\n\t\tuniforms.hemisphereLightDirection.value = lights.hemi.positions;\n\n\t};\n\n\tfunction refreshUniformsShadow ( uniforms, lights ) {\n\n\t\tif ( uniforms.shadowMatrix ) {\n\n\t\t\tvar j = 0;\n\n\t\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\t\tvar light = lights[ i ];\n\n\t\t\t\tif ( ! light.castShadow ) continue;\n\n\t\t\t\tif ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {\n\n\t\t\t\t\tuniforms.shadowMap.value[ j ] = light.shadowMap;\n\t\t\t\t\tuniforms.shadowMapSize.value[ j ] = light.shadowMapSize;\n\n\t\t\t\t\tuniforms.shadowMatrix.value[ j ] = light.shadowMatrix;\n\n\t\t\t\t\tuniforms.shadowDarkness.value[ j ] = light.shadowDarkness;\n\t\t\t\t\tuniforms.shadowBias.value[ j ] = light.shadowBias;\n\n\t\t\t\t\tj ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Uniforms (load to GPU)\n\n\tfunction loadUniformsMatrices ( uniforms, object ) {\n\n\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );\n\n\t\tif ( uniforms.normalMatrix ) {\n\n\t\t\t_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );\n\n\t\t}\n\n\t};\n\n\tfunction getTextureUnit() {\n\n\t\tvar textureUnit = _usedTextureUnits;\n\n\t\tif ( textureUnit >= _maxTextures ) {\n\n\t\t\tconsole.warn( \"WebGLRenderer: trying to use \" + textureUnit + \" texture units while this GPU supports only \" + _maxTextures );\n\n\t\t}\n\n\t\t_usedTextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t};\n\n\tfunction loadUniformsGeneric ( program, uniforms ) {\n\n\t\tvar uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;\n\n\t\tfor ( j = 0, jl = uniforms.length; j < jl; j ++ ) {\n\n\t\t\tlocation = program.uniforms[ uniforms[ j ][ 1 ] ];\n\t\t\tif ( !location ) continue;\n\n\t\t\tuniform = uniforms[ j ][ 0 ];\n\n\t\t\ttype = uniform.type;\n\t\t\tvalue = uniform.value;\n\n\t\t\tif ( type === \"i\" ) { // single integer\n\n\t\t\t\t_gl.uniform1i( location, value );\n\n\t\t\t} else if ( type === \"f\" ) { // single float\n\n\t\t\t\t_gl.uniform1f( location, value );\n\n\t\t\t} else if ( type === \"v2\" ) { // single THREE.Vector2\n\n\t\t\t\t_gl.uniform2f( location, value.x, value.y );\n\n\t\t\t} else if ( type === \"v3\" ) { // single THREE.Vector3\n\n\t\t\t\t_gl.uniform3f( location, value.x, value.y, value.z );\n\n\t\t\t} else if ( type === \"v4\" ) { // single THREE.Vector4\n\n\t\t\t\t_gl.uniform4f( location, value.x, value.y, value.z, value.w );\n\n\t\t\t} else if ( type === \"c\" ) { // single THREE.Color\n\n\t\t\t\t_gl.uniform3f( location, value.r, value.g, value.b );\n\n\t\t\t} else if ( type === \"iv1\" ) { // flat array of integers (JS or typed array)\n\n\t\t\t\t_gl.uniform1iv( location, value );\n\n\t\t\t} else if ( type === \"iv\" ) { // flat array of integers with 3 x N size (JS or typed array)\n\n\t\t\t\t_gl.uniform3iv( location, value );\n\n\t\t\t} else if ( type === \"fv1\" ) { // flat array of floats (JS or typed array)\n\n\t\t\t\t_gl.uniform1fv( location, value );\n\n\t\t\t} else if ( type === \"fv\" ) { // flat array of floats with 3 x N size (JS or typed array)\n\n\t\t\t\t_gl.uniform3fv( location, value );\n\n\t\t\t} else if ( type === \"v2v\" ) { // array of THREE.Vector2\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 2 * value.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\n\t\t\t\t\toffset = i * 2;\n\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniform2fv( location, uniform._array );\n\n\t\t\t} else if ( type === \"v3v\" ) { // array of THREE.Vector3\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 3 * value.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\n\t\t\t\t\toffset = i * 3;\n\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\n\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniform3fv( location, uniform._array );\n\n\t\t\t} else if ( type === \"v4v\" ) { // array of THREE.Vector4\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 4 * value.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\n\t\t\t\t\toffset = i * 4;\n\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\n\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\n\t\t\t\t\tuniform._array[ offset + 3 ] = value[ i ].w;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniform4fv( location, uniform._array );\n\n\t\t\t} else if ( type === \"m4\") { // single THREE.Matrix4\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 16 );\n\n\t\t\t\t}\n\n\t\t\t\tvalue.flattenToArray( uniform._array );\n\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\n\n\t\t\t} else if ( type === \"m4v\" ) { // array of THREE.Matrix4\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 16 * value.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\n\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 16 );\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\n\n\t\t\t} else if ( type === \"t\" ) { // single THREE.Texture (2d or cube)\n\n\t\t\t\ttexture = value;\n\t\t\t\ttextureUnit = getTextureUnit();\n\n\t\t\t\t_gl.uniform1i( location, textureUnit );\n\n\t\t\t\tif ( !texture ) continue;\n\n\t\t\t\tif ( texture.image instanceof Array && texture.image.length === 6 ) {\n\n\t\t\t\t\tsetCubeTexture( texture, textureUnit );\n\n\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\t\t\tsetCubeTextureDynamic( texture, textureUnit );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_this.setTexture( texture, textureUnit );\n\n\t\t\t\t}\n\n\t\t\t} else if ( type === \"tv\" ) { // array of THREE.Texture (2d)\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = [];\n\n\t\t\t\t}\n\n\t\t\t\tfor( i = 0, il = uniform.value.length; i < il; i ++ ) {\n\n\t\t\t\t\tuniform._array[ i ] = getTextureUnit();\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniform1iv( location, uniform._array );\n\n\t\t\t\tfor( i = 0, il = uniform.value.length; i < il; i ++ ) {\n\n\t\t\t\t\ttexture = uniform.value[ i ];\n\t\t\t\t\ttextureUnit = uniform._array[ i ];\n\n\t\t\t\t\tif ( !texture ) continue;\n\n\t\t\t\t\t_this.setTexture( texture, textureUnit );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction setupMatrices ( object, camera ) {\n\n\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\tobject._normalMatrix.getNormalMatrix( object._modelViewMatrix );\n\n\t};\n\n\t//\n\n\tfunction setColorGamma( array, offset, color, intensitySq ) {\n\n\t\tarray[ offset ]     = color.r * color.r * intensitySq;\n\t\tarray[ offset + 1 ] = color.g * color.g * intensitySq;\n\t\tarray[ offset + 2 ] = color.b * color.b * intensitySq;\n\n\t};\n\n\tfunction setColorLinear( array, offset, color, intensity ) {\n\n\t\tarray[ offset ]     = color.r * intensity;\n\t\tarray[ offset + 1 ] = color.g * intensity;\n\t\tarray[ offset + 2 ] = color.b * intensity;\n\n\t};\n\n\tfunction setupLights ( program, lights ) {\n\n\t\tvar l, ll, light, n,\n\t\tr = 0, g = 0, b = 0,\n\t\tcolor, skyColor, groundColor,\n\t\tintensity,  intensitySq,\n\t\tposition,\n\t\tdistance,\n\n\t\tzlights = _lights,\n\n\t\tdirColors = zlights.directional.colors,\n\t\tdirPositions = zlights.directional.positions,\n\n\t\tpointColors = zlights.point.colors,\n\t\tpointPositions = zlights.point.positions,\n\t\tpointDistances = zlights.point.distances,\n\n\t\tspotColors = zlights.spot.colors,\n\t\tspotPositions = zlights.spot.positions,\n\t\tspotDistances = zlights.spot.distances,\n\t\tspotDirections = zlights.spot.directions,\n\t\tspotAnglesCos = zlights.spot.anglesCos,\n\t\tspotExponents = zlights.spot.exponents,\n\n\t\themiSkyColors = zlights.hemi.skyColors,\n\t\themiGroundColors = zlights.hemi.groundColors,\n\t\themiPositions = zlights.hemi.positions,\n\n\t\tdirLength = 0,\n\t\tpointLength = 0,\n\t\tspotLength = 0,\n\t\themiLength = 0,\n\n\t\tdirCount = 0,\n\t\tpointCount = 0,\n\t\tspotCount = 0,\n\t\themiCount = 0,\n\n\t\tdirOffset = 0,\n\t\tpointOffset = 0,\n\t\tspotOffset = 0,\n\t\themiOffset = 0;\n\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\tlight = lights[ l ];\n\n\t\t\tif ( light.onlyShadow ) continue;\n\n\t\t\tcolor = light.color;\n\t\t\tintensity = light.intensity;\n\t\t\tdistance = light.distance;\n\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\n\t\t\t\tif ( ! light.visible ) continue;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tr += color.r * color.r;\n\t\t\t\t\tg += color.g * color.g;\n\t\t\t\t\tb += color.b * color.b;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tr += color.r;\n\t\t\t\t\tg += color.g;\n\t\t\t\t\tb += color.b;\n\n\t\t\t\t}\n\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\tdirCount += 1;\n\n\t\t\t\tif ( ! light.visible ) continue;\n\n\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t_direction.sub( _vector3 );\n\t\t\t\t_direction.normalize();\n\n\t\t\t\t// skip lights with undefined direction\n\t\t\t\t// these create troubles in OpenGL (making pixel black)\n\n\t\t\t\tif ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;\n\n\t\t\t\tdirOffset = dirLength * 3;\n\n\t\t\t\tdirPositions[ dirOffset ]     = _direction.x;\n\t\t\t\tdirPositions[ dirOffset + 1 ] = _direction.y;\n\t\t\t\tdirPositions[ dirOffset + 2 ] = _direction.z;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tsetColorGamma( dirColors, dirOffset, color, intensity * intensity );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetColorLinear( dirColors, dirOffset, color, intensity );\n\n\t\t\t\t}\n\n\t\t\t\tdirLength += 1;\n\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tpointCount += 1;\n\n\t\t\t\tif ( ! light.visible ) continue;\n\n\t\t\t\tpointOffset = pointLength * 3;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tsetColorGamma( pointColors, pointOffset, color, intensity * intensity );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetColorLinear( pointColors, pointOffset, color, intensity );\n\n\t\t\t\t}\n\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld );\n\n\t\t\t\tpointPositions[ pointOffset ]     = _vector3.x;\n\t\t\t\tpointPositions[ pointOffset + 1 ] = _vector3.y;\n\t\t\t\tpointPositions[ pointOffset + 2 ] = _vector3.z;\n\n\t\t\t\tpointDistances[ pointLength ] = distance;\n\n\t\t\t\tpointLength += 1;\n\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\n\n\t\t\t\tspotCount += 1;\n\n\t\t\t\tif ( ! light.visible ) continue;\n\n\t\t\t\tspotOffset = spotLength * 3;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tsetColorGamma( spotColors, spotOffset, color, intensity * intensity );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetColorLinear( spotColors, spotOffset, color, intensity );\n\n\t\t\t\t}\n\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld );\n\n\t\t\t\tspotPositions[ spotOffset ]     = _vector3.x;\n\t\t\t\tspotPositions[ spotOffset + 1 ] = _vector3.y;\n\t\t\t\tspotPositions[ spotOffset + 2 ] = _vector3.z;\n\n\t\t\t\tspotDistances[ spotLength ] = distance;\n\n\t\t\t\t_direction.copy( _vector3 );\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t_direction.sub( _vector3 );\n\t\t\t\t_direction.normalize();\n\n\t\t\t\tspotDirections[ spotOffset ]     = _direction.x;\n\t\t\t\tspotDirections[ spotOffset + 1 ] = _direction.y;\n\t\t\t\tspotDirections[ spotOffset + 2 ] = _direction.z;\n\n\t\t\t\tspotAnglesCos[ spotLength ] = Math.cos( light.angle );\n\t\t\t\tspotExponents[ spotLength ] = light.exponent;\n\n\t\t\t\tspotLength += 1;\n\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\n\n\t\t\t\themiCount += 1;\n\n\t\t\t\tif ( ! light.visible ) continue;\n\n\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t_direction.normalize();\n\n\t\t\t\t// skip lights with undefined direction\n\t\t\t\t// these create troubles in OpenGL (making pixel black)\n\n\t\t\t\tif ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;\n\n\t\t\t\themiOffset = hemiLength * 3;\n\n\t\t\t\themiPositions[ hemiOffset ]     = _direction.x;\n\t\t\t\themiPositions[ hemiOffset + 1 ] = _direction.y;\n\t\t\t\themiPositions[ hemiOffset + 2 ] = _direction.z;\n\n\t\t\t\tskyColor = light.color;\n\t\t\t\tgroundColor = light.groundColor;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tintensitySq = intensity * intensity;\n\n\t\t\t\t\tsetColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );\n\t\t\t\t\tsetColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );\n\t\t\t\t\tsetColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );\n\n\t\t\t\t}\n\n\t\t\t\themiLength += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// null eventual remains from removed lights\n\t\t// (this is to avoid if in shader)\n\n\t\tfor ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;\n\t\tfor ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;\n\t\tfor ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;\n\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;\n\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;\n\n\t\tzlights.directional.length = dirLength;\n\t\tzlights.point.length = pointLength;\n\t\tzlights.spot.length = spotLength;\n\t\tzlights.hemi.length = hemiLength;\n\n\t\tzlights.ambient[ 0 ] = r;\n\t\tzlights.ambient[ 1 ] = g;\n\t\tzlights.ambient[ 2 ] = b;\n\n\t};\n\n\t// GL state setting\n\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\n\t\tif ( cullFace === THREE.CullFaceNone ) {\n\n\t\t\t_gl.disable( _gl.CULL_FACE );\n\n\t\t} else {\n\n\t\t\tif ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\n\n\t\t\t\t_gl.frontFace( _gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.frontFace( _gl.CCW );\n\n\t\t\t}\n\n\t\t\tif ( cullFace === THREE.CullFaceBack ) {\n\n\t\t\t\t_gl.cullFace( _gl.BACK );\n\n\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\n\n\t\t\t\t_gl.cullFace( _gl.FRONT );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.cullFace( _gl.FRONT_AND_BACK );\n\n\t\t\t}\n\n\t\t\t_gl.enable( _gl.CULL_FACE );\n\n\t\t}\n\n\t};\n\n\tthis.setMaterialFaces = function ( material ) {\n\n\t\tvar doubleSided = material.side === THREE.DoubleSide;\n\t\tvar flipSided = material.side === THREE.BackSide;\n\n\t\tif ( _oldDoubleSided !== doubleSided ) {\n\n\t\t\tif ( doubleSided ) {\n\n\t\t\t\t_gl.disable( _gl.CULL_FACE );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.enable( _gl.CULL_FACE );\n\n\t\t\t}\n\n\t\t\t_oldDoubleSided = doubleSided;\n\n\t\t}\n\n\t\tif ( _oldFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\t_gl.frontFace( _gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.frontFace( _gl.CCW );\n\n\t\t\t}\n\n\t\t\t_oldFlipSided = flipSided;\n\n\t\t}\n\n\t};\n\n\tthis.setDepthTest = function ( depthTest ) {\n\n\t\tif ( _oldDepthTest !== depthTest ) {\n\n\t\t\tif ( depthTest ) {\n\n\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\n\n\t\t\t}\n\n\t\t\t_oldDepthTest = depthTest;\n\n\t\t}\n\n\t};\n\n\tthis.setDepthWrite = function ( depthWrite ) {\n\n\t\tif ( _oldDepthWrite !== depthWrite ) {\n\n\t\t\t_gl.depthMask( depthWrite );\n\t\t\t_oldDepthWrite = depthWrite;\n\n\t\t}\n\n\t};\n\n\tfunction setLineWidth ( width ) {\n\n\t\tif ( width !== _oldLineWidth ) {\n\n\t\t\t_gl.lineWidth( width );\n\n\t\t\t_oldLineWidth = width;\n\n\t\t}\n\n\t};\n\n\tfunction setPolygonOffset ( polygonoffset, factor, units ) {\n\n\t\tif ( _oldPolygonOffset !== polygonoffset ) {\n\n\t\t\tif ( polygonoffset ) {\n\n\t\t\t\t_gl.enable( _gl.POLYGON_OFFSET_FILL );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.disable( _gl.POLYGON_OFFSET_FILL );\n\n\t\t\t}\n\n\t\t\t_oldPolygonOffset = polygonoffset;\n\n\t\t}\n\n\t\tif ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {\n\n\t\t\t_gl.polygonOffset( factor, units );\n\n\t\t\t_oldPolygonOffsetFactor = factor;\n\t\t\t_oldPolygonOffsetUnits = units;\n\n\t\t}\n\n\t};\n\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {\n\n\t\tif ( blending !== _oldBlending ) {\n\n\t\t\tif ( blending === THREE.NoBlending ) {\n\n\t\t\t\t_gl.disable( _gl.BLEND );\n\n\t\t\t} else if ( blending === THREE.AdditiveBlending ) {\n\n\t\t\t\t_gl.enable( _gl.BLEND );\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\t\t\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );\n\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\n\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\n\t\t\t\t_gl.enable( _gl.BLEND );\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\t\t\t\t_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );\n\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\n\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\n\t\t\t\t_gl.enable( _gl.BLEND );\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\t\t\t\t_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );\n\n\t\t\t} else if ( blending === THREE.CustomBlending ) {\n\n\t\t\t\t_gl.enable( _gl.BLEND );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.enable( _gl.BLEND );\n\t\t\t\t_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );\n\t\t\t\t_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t}\n\n\t\t\t_oldBlending = blending;\n\n\t\t}\n\n\t\tif ( blending === THREE.CustomBlending ) {\n\n\t\t\tif ( blendEquation !== _oldBlendEquation ) {\n\n\t\t\t\t_gl.blendEquation( paramThreeToGL( blendEquation ) );\n\n\t\t\t\t_oldBlendEquation = blendEquation;\n\n\t\t\t}\n\n\t\t\tif ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {\n\n\t\t\t\t_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );\n\n\t\t\t\t_oldBlendSrc = blendSrc;\n\t\t\t\t_oldBlendDst = blendDst;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_oldBlendEquation = null;\n\t\t\t_oldBlendSrc = null;\n\t\t\t_oldBlendDst = null;\n\n\t\t}\n\n\t};\n\n\t// Defines\n\n\tfunction generateDefines ( defines ) {\n\n\t\tvar value, chunk, chunks = [];\n\n\t\tfor ( var d in defines ) {\n\n\t\t\tvalue = defines[ d ];\n\t\t\tif ( value === false ) continue;\n\n\t\t\tchunk = \"#define \" + d + \" \" + value;\n\t\t\tchunks.push( chunk );\n\n\t\t}\n\n\t\treturn chunks.join( \"\\n\" );\n\n\t};\n\n\t// Shaders\n\n\tfunction buildProgram ( shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters, index0AttributeName ) {\n\n\t\tvar p, pl, d, program, code;\n\t\tvar chunks = [];\n\n\t\t// Generate code\n\n\t\tif ( shaderID ) {\n\n\t\t\tchunks.push( shaderID );\n\n\t\t} else {\n\n\t\t\tchunks.push( fragmentShader );\n\t\t\tchunks.push( vertexShader );\n\n\t\t}\n\n\t\tfor ( d in defines ) {\n\n\t\t\tchunks.push( d );\n\t\t\tchunks.push( defines[ d ] );\n\n\t\t}\n\n\t\tfor ( p in parameters ) {\n\n\t\t\tchunks.push( p );\n\t\t\tchunks.push( parameters[ p ] );\n\n\t\t}\n\n\t\tcode = chunks.join();\n\n\t\t// Check if code has been already compiled\n\n\t\tfor ( p = 0, pl = _programs.length; p < pl; p ++ ) {\n\n\t\t\tvar programInfo = _programs[ p ];\n\n\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\t// console.log( \"Code already compiled.\" /*: \\n\\n\" + code*/ );\n\n\t\t\t\tprogramInfo.usedTimes ++;\n\n\t\t\t\treturn programInfo.program;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar shadowMapTypeDefine = \"SHADOWMAP_TYPE_BASIC\";\n\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF\";\n\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF_SOFT\";\n\n\t\t}\n\n\t\t// console.log( \"building new program \" );\n\n\t\t//\n\n\t\tvar customDefines = generateDefines( defines );\n\n\t\t//\n\n\t\tprogram = _gl.createProgram();\n\n\t\tvar prefix_vertex = [\n\n\t\t\t\"precision \" + _precision + \" float;\",\n\t\t\t\"precision \" + _precision + \" int;\",\n\n\t\t\tcustomDefines,\n\n\t\t\t_supportsVertexTextures ? \"#define VERTEX_TEXTURES\" : \"\",\n\n\t\t\t_this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\n\t\t\t_this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\n\n\t\t\t\"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\n\t\t\t\"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\n\t\t\t\"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\n\t\t\t\"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\n\n\t\t\t\"#define MAX_SHADOWS \" + parameters.maxShadows,\n\n\t\t\t\"#define MAX_BONES \" + parameters.maxBones,\n\n\t\t\tparameters.map ? \"#define USE_MAP\" : \"\",\n\t\t\tparameters.envMap ? \"#define USE_ENVMAP\" : \"\",\n\t\t\tparameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n\t\t\tparameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n\t\t\tparameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n\t\t\tparameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n\t\t\tparameters.vertexColors ? \"#define USE_COLOR\" : \"\",\n\n\t\t\tparameters.skinning ? \"#define USE_SKINNING\" : \"\",\n\t\t\tparameters.useVertexTexture ? \"#define BONE_TEXTURE\" : \"\",\n\n\t\t\tparameters.morphTargets ? \"#define USE_MORPHTARGETS\" : \"\",\n\t\t\tparameters.morphNormals ? \"#define USE_MORPHNORMALS\" : \"\",\n\t\t\tparameters.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\",\n\t\t\tparameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\n\t\t\tparameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n\t\t\tparameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n\n\t\t\tparameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n\t\t\tparameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\n\t\t\tparameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\n\t\t\tparameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\n\n\t\t\tparameters.sizeAttenuation ? \"#define USE_SIZEATTENUATION\" : \"\",\n\n\t\t\t\"uniform mat4 modelMatrix;\",\n\t\t\t\"uniform mat4 modelViewMatrix;\",\n\t\t\t\"uniform mat4 projectionMatrix;\",\n\t\t\t\"uniform mat4 viewMatrix;\",\n\t\t\t\"uniform mat3 normalMatrix;\",\n\t\t\t\"uniform vec3 cameraPosition;\",\n\n\t\t\t\"attribute vec3 position;\",\n\t\t\t\"attribute vec3 normal;\",\n\t\t\t\"attribute vec2 uv;\",\n\t\t\t\"attribute vec2 uv2;\",\n\n\t\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\t\"attribute vec3 color;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef USE_MORPHTARGETS\",\n\n\t\t\t\t\"attribute vec3 morphTarget0;\",\n\t\t\t\t\"attribute vec3 morphTarget1;\",\n\t\t\t\t\"attribute vec3 morphTarget2;\",\n\t\t\t\t\"attribute vec3 morphTarget3;\",\n\n\t\t\t\t\"#ifdef USE_MORPHNORMALS\",\n\n\t\t\t\t\t\"attribute vec3 morphNormal0;\",\n\t\t\t\t\t\"attribute vec3 morphNormal1;\",\n\t\t\t\t\t\"attribute vec3 morphNormal2;\",\n\t\t\t\t\t\"attribute vec3 morphNormal3;\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"attribute vec3 morphTarget4;\",\n\t\t\t\t\t\"attribute vec3 morphTarget5;\",\n\t\t\t\t\t\"attribute vec3 morphTarget6;\",\n\t\t\t\t\t\"attribute vec3 morphTarget7;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\"attribute vec4 skinIndex;\",\n\t\t\t\t\"attribute vec4 skinWeight;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"\"\n\n\t\t].join(\"\\n\");\n\n\t\tvar prefix_fragment = [\n\n\t\t\t\"precision \" + _precision + \" float;\",\n\t\t\t\"precision \" + _precision + \" int;\",\n\n\t\t\t( parameters.bumpMap || parameters.normalMap ) ? \"#extension GL_OES_standard_derivatives : enable\" : \"\",\n\n\t\t\tcustomDefines,\n\n\t\t\t\"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\n\t\t\t\"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\n\t\t\t\"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\n\t\t\t\"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\n\n\t\t\t\"#define MAX_SHADOWS \" + parameters.maxShadows,\n\n\t\t\tparameters.alphaTest ? \"#define ALPHATEST \" + parameters.alphaTest: \"\",\n\n\t\t\t_this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\n\t\t\t_this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\n\n\t\t\t( parameters.useFog && parameters.fog ) ? \"#define USE_FOG\" : \"\",\n\t\t\t( parameters.useFog && parameters.fogExp ) ? \"#define FOG_EXP2\" : \"\",\n\n\t\t\tparameters.map ? \"#define USE_MAP\" : \"\",\n\t\t\tparameters.envMap ? \"#define USE_ENVMAP\" : \"\",\n\t\t\tparameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n\t\t\tparameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n\t\t\tparameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n\t\t\tparameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n\t\t\tparameters.vertexColors ? \"#define USE_COLOR\" : \"\",\n\n\t\t\tparameters.metal ? \"#define METAL\" : \"\",\n\t\t\tparameters.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\",\n\t\t\tparameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\n\t\t\tparameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n\t\t\tparameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n\n\t\t\tparameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n\t\t\tparameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\n\t\t\tparameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\n\t\t\tparameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\n\n\t\t\t\"uniform mat4 viewMatrix;\",\n\t\t\t\"uniform vec3 cameraPosition;\",\n\t\t\t\"\"\n\n\t\t].join(\"\\n\");\n\n\t\tvar glVertexShader = getShader( \"vertex\", prefix_vertex + vertexShader );\n\t\tvar glFragmentShader = getShader( \"fragment\", prefix_fragment + fragmentShader );\n\n\t\t_gl.attachShader( program, glVertexShader );\n\t\t_gl.attachShader( program, glFragmentShader );\n\n\t\t//Force a particular attribute to index 0.\n\t\t// because potentially expensive emulation is done by browser if attribute 0 is disabled.\n\t\t//And, color, for example is often automatically bound to index 0 so disabling it\n\t\tif ( index0AttributeName ) {\n\t\t\t_gl.bindAttribLocation( program, 0, index0AttributeName );\n\t\t}\n\n\t\t_gl.linkProgram( program );\n\n\t\tif ( !_gl.getProgramParameter( program, _gl.LINK_STATUS ) ) {\n\n\t\t\tconsole.error( \"Could not initialise shader\\n\" + \"VALIDATE_STATUS: \" + _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) + \", gl error [\" + _gl.getError() + \"]\" );\n\t\t\tconsole.error( \"Program Info Log: \" + _gl.getProgramInfoLog( program ) );\n\t\t}\n\n\t\t// clean up\n\n\t\t_gl.deleteShader( glFragmentShader );\n\t\t_gl.deleteShader( glVertexShader );\n\n\t\t// console.log( prefix_fragment + fragmentShader );\n\t\t// console.log( prefix_vertex + vertexShader );\n\n\t\tprogram.uniforms = {};\n\t\tprogram.attributes = {};\n\n\t\tvar identifiers, u, a, i;\n\n\t\t// cache uniform locations\n\n\t\tidentifiers = [\n\n\t\t\t'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',\n\t\t\t'morphTargetInfluences'\n\n\t\t];\n\n\t\tif ( parameters.useVertexTexture ) {\n\n\t\t\tidentifiers.push( 'boneTexture' );\n\t\t\tidentifiers.push( 'boneTextureWidth' );\n\t\t\tidentifiers.push( 'boneTextureHeight' );\n\n\t\t} else {\n\n\t\t\tidentifiers.push( 'boneGlobalMatrices' );\n\n\t\t}\n\n\t\tfor ( u in uniforms ) {\n\n\t\t\tidentifiers.push( u );\n\n\t\t}\n\n\t\tcacheUniformLocations( program, identifiers );\n\n\t\t// cache attributes locations\n\n\t\tidentifiers = [\n\n\t\t\t\"position\", \"normal\", \"uv\", \"uv2\", \"tangent\", \"color\",\n\t\t\t\"skinIndex\", \"skinWeight\", \"lineDistance\"\n\n\t\t];\n\n\t\tfor ( i = 0; i < parameters.maxMorphTargets; i ++ ) {\n\n\t\t\tidentifiers.push( \"morphTarget\" + i );\n\n\t\t}\n\n\t\tfor ( i = 0; i < parameters.maxMorphNormals; i ++ ) {\n\n\t\t\tidentifiers.push( \"morphNormal\" + i );\n\n\t\t}\n\n\t\tfor ( a in attributes ) {\n\n\t\t\tidentifiers.push( a );\n\n\t\t}\n\n\t\tcacheAttributeLocations( program, identifiers );\n\n\t\tprogram.id = _programs_counter ++;\n\n\t\t_programs.push( { program: program, code: code, usedTimes: 1 } );\n\n\t\t_this.info.memory.programs = _programs.length;\n\n\t\treturn program;\n\n\t};\n\n\t// Shader parameters cache\n\n\tfunction cacheUniformLocations ( program, identifiers ) {\n\n\t\tvar i, l, id;\n\n\t\tfor( i = 0, l = identifiers.length; i < l; i ++ ) {\n\n\t\t\tid = identifiers[ i ];\n\t\t\tprogram.uniforms[ id ] = _gl.getUniformLocation( program, id );\n\n\t\t}\n\n\t};\n\n\tfunction cacheAttributeLocations ( program, identifiers ) {\n\n\t\tvar i, l, id;\n\n\t\tfor( i = 0, l = identifiers.length; i < l; i ++ ) {\n\n\t\t\tid = identifiers[ i ];\n\t\t\tprogram.attributes[ id ] = _gl.getAttribLocation( program, id );\n\n\t\t}\n\n\t};\n\n\tfunction addLineNumbers ( string ) {\n\n\t\tvar chunks = string.split( \"\\n\" );\n\n\t\tfor ( var i = 0, il = chunks.length; i < il; i ++ ) {\n\n\t\t\t// Chrome reports shader errors on lines\n\t\t\t// starting counting from 1\n\n\t\t\tchunks[ i ] = ( i + 1 ) + \": \" + chunks[ i ];\n\n\t\t}\n\n\t\treturn chunks.join( \"\\n\" );\n\n\t};\n\n\tfunction getShader ( type, string ) {\n\n\t\tvar shader;\n\n\t\tif ( type === \"fragment\" ) {\n\n\t\t\tshader = _gl.createShader( _gl.FRAGMENT_SHADER );\n\n\t\t} else if ( type === \"vertex\" ) {\n\n\t\t\tshader = _gl.createShader( _gl.VERTEX_SHADER );\n\n\t\t}\n\n\t\t_gl.shaderSource( shader, string );\n\t\t_gl.compileShader( shader );\n\n\t\tif ( !_gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {\n\n\t\t\tconsole.error( _gl.getShaderInfoLog( shader ) );\n\t\t\tconsole.error( addLineNumbers( string ) );\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn shader;\n\n\t};\n\n\t// Textures\n\n\n\tfunction isPowerOfTwo ( value ) {\n\n\t\treturn ( value & ( value - 1 ) ) === 0;\n\n\t};\n\n\tfunction setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {\n\n\t\tif ( isImagePowerOfTwo ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\n\t\t} else {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t}\n\n\t\tif ( _glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType ) {\n\n\t\t\tif ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {\n\n\t\t\t\t_gl.texParameterf( textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _maxAnisotropy ) );\n\t\t\t\ttexture.__oldAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.setTexture = function ( texture, slot ) {\n\n\t\tif ( texture.needsUpdate ) {\n\n\t\t\tif ( ! texture.__webglInit ) {\n\n\t\t\t\ttexture.__webglInit = true;\n\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\ttexture.__webglTexture = _gl.createTexture();\n\n\t\t\t\t_this.info.memory.textures ++;\n\n\t\t\t}\n\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\n\t\t\tvar image = texture.image,\n\t\t\tisImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),\n\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );\n\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\t\tif ( texture instanceof THREE.DataTexture ) {\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\n\n\t\t\t\tfor( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tif ( texture.format!==THREE.RGBAFormat ) {\n\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else { // regular Texture (image, video, canvas)\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\ttexture.needsUpdate = false;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate();\n\n\t\t} else {\n\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\n\n\t\t}\n\n\t};\n\n\tfunction clampToMaxSize ( image, maxSize ) {\n\n\t\tif ( image.width <= maxSize && image.height <= maxSize ) {\n\n\t\t\treturn image;\n\n\t\t}\n\n\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t// premultiplied alpha.\n\n\t\tvar maxDimension = Math.max( image.width, image.height );\n\t\tvar newWidth = Math.floor( image.width * maxSize / maxDimension );\n\t\tvar newHeight = Math.floor( image.height * maxSize / maxDimension );\n\n\t\tvar canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = newWidth;\n\t\tcanvas.height = newHeight;\n\n\t\tvar ctx = canvas.getContext( \"2d\" );\n\t\tctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );\n\n\t\treturn canvas;\n\n\t}\n\n\tfunction setCubeTexture ( texture, slot ) {\n\n\t\tif ( texture.image.length === 6 ) {\n\n\t\t\tif ( texture.needsUpdate ) {\n\n\t\t\t\tif ( ! texture.image.__webglTextureCube ) {\n\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\ttexture.image.__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t\t_this.info.memory.textures ++;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\n\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\n\n\t\t\t\tvar cubeImage = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed ) {\n\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcubeImage[ i ] = texture.image[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\tisImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif( !isCompressed ) {\n\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\tfor( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\t\t\t\t\t\t\tif ( texture.format!==THREE.RGBAFormat ) {\n\n\t\t\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) {\n\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.needsUpdate = false;\n\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate();\n\n\t\t\t} else {\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction setCubeTextureDynamic ( texture, slot ) {\n\n\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );\n\n\t};\n\n\t// Render targets\n\n\tfunction setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {\n\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );\n\n\t};\n\n\tfunction setupRenderBuffer ( renderbuffer, renderTarget  ) {\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t/* For some reason this is not working. Defaulting to RGBA4.\n\t\t} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\t*/\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n\t\t}\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\n\t\tif ( renderTarget && ! renderTarget.__webglFramebuffer ) {\n\n\t\t\tif ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;\n\t\t\tif ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;\n\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\t\trenderTarget.__webglTexture = _gl.createTexture();\n\n\t\t\t_this.info.memory.textures ++;\n\n\t\t\t// Setup texture, create render and frame buffers\n\n\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget.width ) && isPowerOfTwo( renderTarget.height ),\n\t\t\t\tglFormat = paramThreeToGL( renderTarget.format ),\n\t\t\t\tglType = paramThreeToGL( renderTarget.type );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTarget.__webglFramebuffer = [];\n\t\t\t\trenderTarget.__webglRenderbuffer = [];\n\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\trenderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\t\t\t\t\trenderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();\n\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\n\t\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t} else {\n\n\t\t\t\trenderTarget.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\t\tif ( renderTarget.shareDepthFrom ) {\n\n\t\t\t\t\trenderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderTarget.__webglRenderbuffer = _gl.createRenderbuffer();\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );\n\n\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\n\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );\n\n\t\t\t\tif ( renderTarget.shareDepthFrom ) {\n\n\t\t\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\n\n\t\t\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\t}\n\n\t\t\t// Release everything\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t\t}\n\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t}\n\n\t\tvar framebuffer, width, height, vx, vy;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer;\n\n\t\t\t}\n\n\t\t\twidth = renderTarget.width;\n\t\t\theight = renderTarget.height;\n\n\t\t\tvx = 0;\n\t\t\tvy = 0;\n\n\t\t} else {\n\n\t\t\tframebuffer = null;\n\n\t\t\twidth = _viewportWidth;\n\t\t\theight = _viewportHeight;\n\n\t\t\tvx = _viewportX;\n\t\t\tvy = _viewportY;\n\n\t\t}\n\n\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_gl.viewport( vx, vy, width, height );\n\n\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t}\n\n\t\t_currentWidth = width;\n\t\t_currentHeight = height;\n\n\t};\n\n\tfunction updateRenderTargetMipmap ( renderTarget ) {\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t} else {\n\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t}\n\n\t};\n\n\t// Fallback filters for non-power-of-2 textures\n\n\tfunction filterFallback ( f ) {\n\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\n\n\t\t\treturn _gl.NEAREST;\n\n\t\t}\n\n\t\treturn _gl.LINEAR;\n\n\t};\n\n\t// Map three.js constants to WebGL constants\n\n\tfunction paramThreeToGL ( p ) {\n\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\tif ( p === THREE.IntType ) return _gl.INT;\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\n\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\n\t\tif ( _glExtensionCompressedTextureS3TC !== undefined ) {\n\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t}\n\n\t\treturn 0;\n\n\t};\n\n\t// Allocations\n\n\tfunction allocateBones ( object ) {\n\n\t\tif ( _supportsBoneTextures && object && object.useVertexTexture ) {\n\n\t\t\treturn 1024;\n\n\t\t} else {\n\n\t\t\t// default for when object is not specified\n\t\t\t// ( for example when prebuilding shader\n\t\t\t//   to be used with multiple objects )\n\t\t\t//\n\t\t\t// \t- leave some extra space for other uniforms\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t//    (up to 54 should be safe)\n\n\t\t\tvar nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\tvar maxBones = nVertexMatrices;\n\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\tmaxBones = Math.min( object.bones.length, maxBones );\n\n\t\t\t\tif ( maxBones < object.bones.length ) {\n\n\t\t\t\t\tconsole.warn( \"WebGLRenderer: too many bones - \" + object.bones.length + \", this GPU supports just \" + maxBones + \" (try OpenGL instead of ANGLE)\" );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn maxBones;\n\n\t\t}\n\n\t};\n\n\tfunction allocateLights( lights ) {\n\n\t\tvar dirLights = 0;\n\t\tvar pointLights = 0;\n\t\tvar spotLights = 0;\n\t\tvar hemiLights = 0;\n\n\t\tfor ( var l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\tvar light = lights[ l ];\n\n\t\t\tif ( light.onlyShadow ) continue;\n\n\t\t\tif ( light instanceof THREE.DirectionalLight ) dirLights ++;\n\t\t\tif ( light instanceof THREE.PointLight ) pointLights ++;\n\t\t\tif ( light instanceof THREE.SpotLight ) spotLights ++;\n\t\t\tif ( light instanceof THREE.HemisphereLight ) hemiLights ++;\n\n\t\t}\n\n\t\treturn { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi': hemiLights };\n\n\t};\n\n\tfunction allocateShadows( lights ) {\n\n\t\tvar maxShadows = 0;\n\n\t\tfor ( var l = 0, ll = lights.length; l < ll; l++ ) {\n\n\t\t\tvar light = lights[ l ];\n\n\t\t\tif ( ! light.castShadow ) continue;\n\n\t\t\tif ( light instanceof THREE.SpotLight ) maxShadows ++;\n\t\t\tif ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;\n\n\t\t}\n\n\t\treturn maxShadows;\n\n\t};\n\n\t// Initialization\n\n\tfunction initGL() {\n\n\t\ttry {\n\n\t\t\tvar attributes = {\n\t\t\t\talpha: _alpha,\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\tantialias: _antialias,\n\t\t\t\tstencil: _stencil,\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t\t};\n\n\t\t\t_gl = _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\n\t\t\tif ( _gl === null ) {\n\n\t\t\t\tthrow 'Error creating WebGL context.';\n\n\t\t\t}\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( error );\n\n\t\t}\n\n\t\t_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );\n\t\t_glExtensionTextureFloatLinear = _gl.getExtension( 'OES_texture_float_linear' );\n\t\t_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );\n\n\t\t_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\n\t\t_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\n\t\tif ( ! _glExtensionTextureFloat ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Float textures not supported.' );\n\n\t\t}\n\n\t\tif ( ! _glExtensionStandardDerivatives ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Standard derivatives not supported.' );\n\n\t\t}\n\n\t\tif ( ! _glExtensionTextureFilterAnisotropic ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );\n\n\t\t}\n\n\t\tif ( ! _glExtensionCompressedTextureS3TC ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );\n\n\t\t}\n\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t_gl.getShaderPrecisionFormat = function() {\n\n\t\t\t\treturn {\n\t\t\t\t\t\"rangeMin\"  : 1,\n\t\t\t\t\t\"rangeMax\"  : 1,\n\t\t\t\t\t\"precision\" : 1\n\t\t\t\t};\n\n\t\t\t}\n\t\t}\n\n\t};\n\n\tfunction setDefaultGLState () {\n\n\t\t_gl.clearColor( 0, 0, 0, 1 );\n\t\t_gl.clearDepth( 1 );\n\t\t_gl.clearStencil( 0 );\n\n\t\t_gl.enable( _gl.DEPTH_TEST );\n\t\t_gl.depthFunc( _gl.LEQUAL );\n\n\t\t_gl.frontFace( _gl.CCW );\n\t\t_gl.cullFace( _gl.BACK );\n\t\t_gl.enable( _gl.CULL_FACE );\n\n\t\t_gl.enable( _gl.BLEND );\n\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\n\t\t\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\t// default plugins (order is important)\n\n\tthis.shadowMapPlugin = new THREE.ShadowMapPlugin();\n\tthis.addPrePlugin( this.shadowMapPlugin );\n\n\tthis.addPostPlugin( new THREE.SpritePlugin() );\n\tthis.addPostPlugin( new THREE.LensFlarePlugin() );\n\n};\n\n/**\n * @author szimek / https://github.com/szimek/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\n\n\tthis.width = width;\n\tthis.height = height;\n\n\toptions = options || {};\n\n\tthis.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;\n\tthis.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;\n\n\tthis.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;\n\tthis.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;\n\n\tthis.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;\n\n\tthis.offset = new THREE.Vector2( 0, 0 );\n\tthis.repeat = new THREE.Vector2( 1, 1 );\n\n\tthis.format = options.format !== undefined ? options.format : THREE.RGBAFormat;\n\tthis.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;\n\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\n\tthis.generateMipmaps = true;\n\n\tthis.shareDepthFrom = null;\n\n};\n\nTHREE.WebGLRenderTarget.prototype = {\n\n\tconstructor: THREE.WebGLRenderTarget,\n\n\tclone: function () {\n\n\t\tvar tmp = new THREE.WebGLRenderTarget( this.width, this.height );\n\n\t\ttmp.wrapS = this.wrapS;\n\t\ttmp.wrapT = this.wrapT;\n\n\t\ttmp.magFilter = this.magFilter;\n\t\ttmp.minFilter = this.minFilter;\n\n\t\ttmp.anisotropy = this.anisotropy;\n\n\t\ttmp.offset.copy( this.offset );\n\t\ttmp.repeat.copy( this.repeat );\n\n\t\ttmp.format = this.format;\n\t\ttmp.type = this.type;\n\n\t\ttmp.depthBuffer = this.depthBuffer;\n\t\ttmp.stencilBuffer = this.stencilBuffer;\n\n\t\ttmp.generateMipmaps = this.generateMipmaps;\n\n\t\ttmp.shareDepthFrom = this.shareDepthFrom;\n\n\t\treturn tmp;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nTHREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );\n\n/**\n * @author alteredq / http://alteredqualia.com\n */\n\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\n\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\n\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\n};\n\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableVertex = function () {\n\n\tthis.position = new THREE.Vector3();\n\tthis.positionWorld = new THREE.Vector3();\n\tthis.positionScreen = new THREE.Vector4();\n\n\tthis.visible = true;\n\n};\n\nTHREE.RenderableVertex.prototype.copy = function ( vertex ) {\n\n\tthis.positionWorld.copy( vertex.positionWorld );\n\tthis.positionScreen.copy( vertex.positionScreen );\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableFace3 = function () {\n\n\tthis.id = 0;\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\tthis.v3 = new THREE.RenderableVertex();\n\n\tthis.centroidModel = new THREE.Vector3();\n\n\tthis.normalModel = new THREE.Vector3();\n\tthis.normalModelView = new THREE.Vector3();\n\n\tthis.vertexNormalsLength = 0;\n\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\tthis.vertexNormalsModelView = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\n\tthis.color = null;\n\tthis.material = null;\n\tthis.uvs = [[]];\n\n\tthis.z = 0;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableObject = function () {\n\n\tthis.id = 0;\n\n\tthis.object = null;\n\tthis.z = 0;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableSprite = function () {\n\n\tthis.id = 0;\n\n\tthis.object = null;\n\n\tthis.x = 0;\n\tthis.y = 0;\n\tthis.z = 0;\n\n\tthis.rotation = 0;\n\tthis.scale = new THREE.Vector2();\n\n\tthis.material = null;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableLine = function () {\n\n\tthis.id = 0;\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\n\tthis.vertexColors = [ new THREE.Color(), new THREE.Color() ];\n\tthis.material = null;\n\n\tthis.z = 0;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.GeometryUtils = {\n\n\t// Merge two geometries or geometry and geometry from object (using object's transform)\n\n\tmerge: function ( geometry1, object2 /* mesh | geometry */, materialIndexOffset ) {\n\n\t\tvar matrix, normalMatrix,\n\t\tvertexOffset = geometry1.vertices.length,\n\t\tuvPosition = geometry1.faceVertexUvs[ 0 ].length,\n\t\tgeometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2,\n\t\tvertices1 = geometry1.vertices,\n\t\tvertices2 = geometry2.vertices,\n\t\tfaces1 = geometry1.faces,\n\t\tfaces2 = geometry2.faces,\n\t\tuvs1 = geometry1.faceVertexUvs[ 0 ],\n\t\tuvs2 = geometry2.faceVertexUvs[ 0 ];\n\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\tif ( object2 instanceof THREE.Mesh ) {\n\n\t\t\tobject2.matrixAutoUpdate && object2.updateMatrix();\n\n\t\t\tmatrix = object2.matrix;\n\n\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\tfaceCopy.centroid.copy( face.centroid );\n\n\t\t\tif ( matrix ) {\n\n\t\t\t\tfaceCopy.centroid.applyMatrix4( matrix );\n\n\t\t\t}\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );\n\n\t\t\t}\n\n\t\t\tuvs1.push( uvCopy );\n\n\t\t}\n\n\t},\n\n\t// Get random point in triangle (via barycentric coordinates)\n\t// \t(uniform distribution)\n\t// \thttp://www.cgafaq.info/wiki/Random_Point_In_Triangle\n\n\trandomPointInTriangle: function () {\n\n\t\tvar vector = new THREE.Vector3();\n\n\t\treturn function ( vectorA, vectorB, vectorC ) {\n\n\t\t\tvar point = new THREE.Vector3();\n\n\t\t\tvar a = THREE.Math.random16();\n\t\t\tvar b = THREE.Math.random16();\n\n\t\t\tif ( ( a + b ) > 1 ) {\n\n\t\t\t\ta = 1 - a;\n\t\t\t\tb = 1 - b;\n\n\t\t\t}\n\n\t\t\tvar c = 1 - a - b;\n\n\t\t\tpoint.copy( vectorA );\n\t\t\tpoint.multiplyScalar( a );\n\n\t\t\tvector.copy( vectorB );\n\t\t\tvector.multiplyScalar( b );\n\n\t\t\tpoint.add( vector );\n\n\t\t\tvector.copy( vectorC );\n\t\t\tvector.multiplyScalar( c );\n\n\t\t\tpoint.add( vector );\n\n\t\t\treturn point;\n\n\t\t};\n\n\t}(),\n\n\t// Get random point in face (triangle / quad)\n\t// (uniform distribution)\n\n\trandomPointInFace: function ( face, geometry, useCachedAreas ) {\n\n\t\tvar vA, vB, vC, vD;\n\n\t\tvA = geometry.vertices[ face.a ];\n\t\tvB = geometry.vertices[ face.b ];\n\t\tvC = geometry.vertices[ face.c ];\n\n\t\treturn THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );\n\n\t},\n\n\t// Get uniformly distributed random points in mesh\n\t// \t- create array with cumulative sums of face areas\n\t//  - pick random number from 0 to total area\n\t//  - find corresponding place in area array by binary search\n\t//\t- get random point in face\n\n\trandomPointsInGeometry: function ( geometry, n ) {\n\n\t\tvar face, i,\n\t\t\tfaces = geometry.faces,\n\t\t\tvertices = geometry.vertices,\n\t\t\til = faces.length,\n\t\t\ttotalArea = 0,\n\t\t\tcumulativeAreas = [],\n\t\t\tvA, vB, vC, vD;\n\n\t\t// precompute face areas\n\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tface = faces[ i ];\n\n\t\t\tvA = vertices[ face.a ];\n\t\t\tvB = vertices[ face.b ];\n\t\t\tvC = vertices[ face.c ];\n\n\t\t\tface._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );\n\n\t\t\ttotalArea += face._area;\n\n\t\t\tcumulativeAreas[ i ] = totalArea;\n\n\t\t}\n\n\t\t// binary search cumulative areas array\n\n\t\tfunction binarySearchIndices( value ) {\n\n\t\t\tfunction binarySearch( start, end ) {\n\n\t\t\t\t// return closest larger index\n\t\t\t\t// if exact number is not found\n\n\t\t\t\tif ( end < start )\n\t\t\t\t\treturn start;\n\n\t\t\t\tvar mid = start + Math.floor( ( end - start ) / 2 );\n\n\t\t\t\tif ( cumulativeAreas[ mid ] > value ) {\n\n\t\t\t\t\treturn binarySearch( start, mid - 1 );\n\n\t\t\t\t} else if ( cumulativeAreas[ mid ] < value ) {\n\n\t\t\t\t\treturn binarySearch( mid + 1, end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn mid;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar result = binarySearch( 0, cumulativeAreas.length - 1 )\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// pick random face weighted by face area\n\n\t\tvar r, index,\n\t\t\tresult = [];\n\n\t\tvar stats = {};\n\n\t\tfor ( i = 0; i < n; i ++ ) {\n\n\t\t\tr = THREE.Math.random16() * totalArea;\n\n\t\t\tindex = binarySearchIndices( r );\n\n\t\t\tresult[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );\n\n\t\t\tif ( ! stats[ index ] ) {\n\n\t\t\t\tstats[ index ] = 1;\n\n\t\t\t} else {\n\n\t\t\t\tstats[ index ] += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// Get triangle area (half of parallelogram)\n\t//\thttp://mathworld.wolfram.com/TriangleArea.html\n\n\ttriangleArea: function () {\n\n\t\tvar vector1 = new THREE.Vector3();\n\t\tvar vector2 = new THREE.Vector3();\n\n\t\treturn function ( vectorA, vectorB, vectorC ) {\n\n\t\t\tvector1.subVectors( vectorB, vectorA );\n\t\t\tvector2.subVectors( vectorC, vectorA );\n\t\t\tvector1.cross( vector2 );\n\n\t\t\treturn 0.5 * vector1.length();\n\n\t\t};\n\n\t}(),\n\n\t// Center geometry so that 0,0,0 is in center of bounding box\n\n\tcenter: function ( geometry ) {\n\n\t\tgeometry.computeBoundingBox();\n\n\t\tvar bb = geometry.boundingBox;\n\n\t\tvar offset = new THREE.Vector3();\n\n\t\toffset.addVectors( bb.min, bb.max );\n\t\toffset.multiplyScalar( -0.5 );\n\n\t\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );\n\t\tgeometry.computeBoundingBox();\n\n\t\treturn offset;\n\n\t},\n\n\ttriangulateQuads: function ( geometry ) {\n\n\t\tvar i, il, j, jl;\n\n\t\tvar faces = [];\n\t\tvar faceVertexUvs = [];\n\n\t\tfor ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tfaceVertexUvs[ i ] = [];\n\n\t\t}\n\n\t\tfor ( i = 0, il = geometry.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = geometry.faces[ i ];\n\n\t\t\tfaces.push( face );\n\n\t\t\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tfaceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.faces = faces;\n\t\tgeometry.faceVertexUvs = faceVertexUvs;\n\n\t\tgeometry.computeCentroids();\n\t\tgeometry.computeFaceNormals();\n\t\tgeometry.computeVertexNormals();\n\n\t\tif ( geometry.hasTangents ) geometry.computeTangents();\n\n\t}\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ImageUtils = {\n\n\tcrossOrigin: undefined,\n\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tvar loader = new THREE.ImageLoader();\n\t\tloader.crossOrigin = this.crossOrigin;\n\n\t\tvar texture = new THREE.Texture( undefined, mapping );\n\n\t\tvar image = loader.load( url, function () {\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t} );\n\n\t\ttexture.image = image;\n\t\ttexture.sourceFile = url;\n\n\t\treturn texture;\n\n\t},\n\n\tloadCompressedTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tvar texture = new THREE.CompressedTexture();\n\t\ttexture.mapping = mapping;\n\n\t\tvar request = new XMLHttpRequest();\n\n\t\trequest.onload = function () {\n\n\t\t\tvar buffer = request.response;\n\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\n\n\t\t\ttexture.format = dds.format;\n\n\t\t\ttexture.mipmaps = dds.mipmaps;\n\t\t\ttexture.image.width = dds.width;\n\t\t\ttexture.image.height = dds.height;\n\n\t\t\t// gl.generateMipmap fails for compressed textures\n\t\t\t// mipmaps must be embedded in the DDS file\n\t\t\t// or texture filters must not use mipmapping\n\n\t\t\ttexture.generateMipmaps = false;\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t}\n\n\t\trequest.onerror = onError;\n\n\t\trequest.open( 'GET', url, true );\n\t\trequest.responseType = \"arraybuffer\";\n\t\trequest.send( null );\n\n\t\treturn texture;\n\n\t},\n\n\tloadTextureCube: function ( array, mapping, onLoad, onError ) {\n\n\t\tvar images = [];\n\t\timages.loadCount = 0;\n\n\t\tvar texture = new THREE.Texture();\n\t\ttexture.image = images;\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\t// no flipping needed for cube textures\n\n\t\ttexture.flipY = false;\n\n\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\n\n\t\t\tvar cubeImage = new Image();\n\t\t\timages[ i ] = cubeImage;\n\n\t\t\tcubeImage.onload = function () {\n\n\t\t\t\timages.loadCount += 1;\n\n\t\t\t\tif ( images.loadCount === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tcubeImage.onerror = onError;\n\n\t\t\tcubeImage.crossOrigin = this.crossOrigin;\n\t\t\tcubeImage.src = array[ i ];\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tloadCompressedTextureCube: function ( array, mapping, onLoad, onError ) {\n\n\t\tvar images = [];\n\t\timages.loadCount = 0;\n\n\t\tvar texture = new THREE.CompressedTexture();\n\t\ttexture.image = images;\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\ttexture.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\ttexture.generateMipmaps = false;\n\n\t\tvar generateCubeFaceCallback = function ( rq, img ) {\n\n\t\t\treturn function () {\n\n\t\t\t\tvar buffer = rq.response;\n\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\n\n\t\t\t\timg.format = dds.format;\n\n\t\t\t\timg.mipmaps = dds.mipmaps;\n\t\t\t\timg.width = dds.width;\n\t\t\t\timg.height = dds.height;\n\n\t\t\t\timages.loadCount += 1;\n\n\t\t\t\tif ( images.loadCount === 6 ) {\n\n\t\t\t\t\ttexture.format = dds.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compressed cubemap textures as 6 separate DDS files\n\n\t\tif ( array instanceof Array ) {\n\n\t\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\n\n\t\t\t\tvar cubeImage = {};\n\t\t\t\timages[ i ] = cubeImage;\n\n\t\t\t\tvar request = new XMLHttpRequest();\n\n\t\t\t\trequest.onload = generateCubeFaceCallback( request, cubeImage );\n\t\t\t\trequest.onerror = onError;\n\n\t\t\t\tvar url = array[ i ];\n\n\t\t\t\trequest.open( 'GET', url, true );\n\t\t\t\trequest.responseType = \"arraybuffer\";\n\t\t\t\trequest.send( null );\n\n\t\t\t}\n\n\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t} else {\n\n\t\t\tvar url = array;\n\t\t\tvar request = new XMLHttpRequest();\n\n\t\t\trequest.onload = function( ) {\n\n\t\t\t\tvar buffer = request.response;\n\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\n\n\t\t\t\tif ( dds.isCubemap ) {\n\n\t\t\t\t\tvar faces = dds.mipmaps.length / dds.mipmapCount;\n\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\n\t\t\t\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = dds.format;\n\t\t\t\t\t\t\timages[ f ].width = dds.width;\n\t\t\t\t\t\t\timages[ f ].height = dds.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.format = dds.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\trequest.onerror = onError;\n\n\t\t\trequest.open( 'GET', url, true );\n\t\t\trequest.responseType = \"arraybuffer\";\n\t\t\trequest.send( null );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tloadDDSTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tvar images = [];\n\t\timages.loadCount = 0;\n\n\t\tvar texture = new THREE.CompressedTexture();\n\t\ttexture.image = images;\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\ttexture.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\ttexture.generateMipmaps = false;\n\n\t\t{\n\t\t\tvar request = new XMLHttpRequest();\n\n\t\t\trequest.onload = function( ) {\n\n\t\t\t\tvar buffer = request.response;\n\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\n\n\t\t\t\tif ( dds.isCubemap ) {\n\n\t\t\t\t\tvar faces = dds.mipmaps.length / dds.mipmapCount;\n\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\n\t\t\t\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = dds.format;\n\t\t\t\t\t\t\timages[ f ].width = dds.width;\n\t\t\t\t\t\t\timages[ f ].height = dds.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else {\n\t\t\t\t\ttexture.image.width = dds.width;\n\t\t\t\t\ttexture.image.height = dds.height;\n\t\t\t\t\ttexture.mipmaps = dds.mipmaps;\n\t\t\t\t}\n\n\t\t\t\ttexture.format = dds.format;\n\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}\n\n\t\t\trequest.onerror = onError;\n\n\t\t\trequest.open( 'GET', url, true );\n\t\t\trequest.responseType = \"arraybuffer\";\n\t\t\trequest.send( null );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tparseDDS: function ( buffer, loadMipmaps ) {\n\n\t\tvar dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\n\n\t\t// Adapted from @toji's DDS utils\n\t\t//\thttps://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n\t\t// All values and structures referenced from:\n\t\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n\t\tvar DDS_MAGIC = 0x20534444;\n\n\t\tvar DDSD_CAPS = 0x1,\n\t\t\tDDSD_HEIGHT = 0x2,\n\t\t\tDDSD_WIDTH = 0x4,\n\t\t\tDDSD_PITCH = 0x8,\n\t\t\tDDSD_PIXELFORMAT = 0x1000,\n\t\t\tDDSD_MIPMAPCOUNT = 0x20000,\n\t\t\tDDSD_LINEARSIZE = 0x80000,\n\t\t\tDDSD_DEPTH = 0x800000;\n\n\t\tvar DDSCAPS_COMPLEX = 0x8,\n\t\t\tDDSCAPS_MIPMAP = 0x400000,\n\t\t\tDDSCAPS_TEXTURE = 0x1000;\n\n\t\tvar DDSCAPS2_CUBEMAP = 0x200,\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n\t\t\tDDSCAPS2_VOLUME = 0x200000;\n\n\t\tvar DDPF_ALPHAPIXELS = 0x1,\n\t\t\tDDPF_ALPHA = 0x2,\n\t\t\tDDPF_FOURCC = 0x4,\n\t\t\tDDPF_RGB = 0x40,\n\t\t\tDDPF_YUV = 0x200,\n\t\t\tDDPF_LUMINANCE = 0x20000;\n\n\t\tfunction fourCCToInt32( value ) {\n\n\t\t\treturn value.charCodeAt(0) +\n\t\t\t\t(value.charCodeAt(1) << 8) +\n\t\t\t\t(value.charCodeAt(2) << 16) +\n\t\t\t\t(value.charCodeAt(3) << 24);\n\n\t\t}\n\n\t\tfunction int32ToFourCC( value ) {\n\n\t\t\treturn String.fromCharCode(\n\t\t\t\tvalue & 0xff,\n\t\t\t\t(value >> 8) & 0xff,\n\t\t\t\t(value >> 16) & 0xff,\n\t\t\t\t(value >> 24) & 0xff\n\t\t\t);\n\t\t}\n\n\t\tfunction loadARGBMip( buffer, dataOffset, width, height ) {\n\t\t\tvar dataLength = width*height*4;\n\t\t\tvar srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );\n\t\t\tvar byteArray = new Uint8Array( dataLength );\n\t\t\tvar dst = 0;\n\t\t\tvar src = 0;\n\t\t\tfor ( var y = 0; y < height; y++ ) {\n\t\t\t\tfor ( var x = 0; x < width; x++ ) {\n\t\t\t\t\tvar b = srcBuffer[src]; src++;\n\t\t\t\t\tvar g = srcBuffer[src]; src++;\n\t\t\t\t\tvar r = srcBuffer[src]; src++;\n\t\t\t\t\tvar a = srcBuffer[src]; src++;\n\t\t\t\t\tbyteArray[dst] = r; dst++;\t//r\n\t\t\t\t\tbyteArray[dst] = g; dst++;\t//g\n\t\t\t\t\tbyteArray[dst] = b; dst++;\t//b\n\t\t\t\t\tbyteArray[dst] = a; dst++;\t//a\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn byteArray;\n\t\t}\n\n\t\tvar FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\n\t\tvar FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\n\t\tvar FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\n\n\t\tvar headerLengthInt = 31; // The header length in 32 bit ints\n\n\t\t// Offsets into the header array\n\n\t\tvar off_magic = 0;\n\n\t\tvar off_size = 1;\n\t\tvar off_flags = 2;\n\t\tvar off_height = 3;\n\t\tvar off_width = 4;\n\n\t\tvar off_mipmapCount = 7;\n\n\t\tvar off_pfFlags = 20;\n\t\tvar off_pfFourCC = 21;\n\t\tvar off_RGBBitCount = 22;\n\t\tvar off_RBitMask = 23;\n\t\tvar off_GBitMask = 24;\n\t\tvar off_BBitMask = 25;\n\t\tvar off_ABitMask = 26;\n\n\t\tvar off_caps = 27;\n\t\tvar off_caps2 = 28;\n\t\tvar off_caps3 = 29;\n\t\tvar off_caps4 = 30;\n\n\t\t// Parse header\n\n\t\tvar header = new Int32Array( buffer, 0, headerLengthInt );\n\n\t\tif ( header[ off_magic ] !== DDS_MAGIC ) {\n\n\t\t\tconsole.error( \"ImageUtils.parseDDS(): Invalid magic number in DDS header\" );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tif ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {\n\n\t\t\tconsole.error( \"ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code\" );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tvar blockBytes;\n\n\t\tvar fourCC = header[ off_pfFourCC ];\n\n\t\tvar isRGBAUncompressed = false;\n\n\t\tswitch ( fourCC ) {\n\n\t\t\tcase FOURCC_DXT1:\n\n\t\t\t\tblockBytes = 8;\n\t\t\t\tdds.format = THREE.RGB_S3TC_DXT1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DXT3:\n\n\t\t\t\tblockBytes = 16;\n\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT3_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DXT5:\n\n\t\t\t\tblockBytes = 16;\n\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT5_Format;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tif( header[off_RGBBitCount] ==32 \n\t\t\t\t\t&& header[off_RBitMask]&0xff0000\n\t\t\t\t\t&& header[off_GBitMask]&0xff00 \n\t\t\t\t\t&& header[off_BBitMask]&0xff\n\t\t\t\t\t&& header[off_ABitMask]&0xff000000  ) {\n\t\t\t\t\tisRGBAUncompressed = true;\n\t\t\t\t\tblockBytes = 64;\n\t\t\t\t\tdds.format = THREE.RGBAFormat;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error( \"ImageUtils.parseDDS(): Unsupported FourCC code: \", int32ToFourCC( fourCC ) );\n\t\t\t\t\treturn dds;\n\t\t\t\t}\n\t\t}\n\n\t\tdds.mipmapCount = 1;\n\n\t\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\n\n\t\t\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\n\n\t\t}\n\n\t\t//TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.\n\n\t\tdds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;\n\n\t\tdds.width = header[ off_width ];\n\t\tdds.height = header[ off_height ];\n\n\t\tvar dataOffset = header[ off_size ] + 4;\n\n\t\t// Extract mipmaps buffers\n\n\t\tvar width = dds.width;\n\t\tvar height = dds.height;\n\n\t\tvar faces = dds.isCubemap ? 6 : 1;\n\n\t\tfor ( var face = 0; face < faces; face ++ ) {\n\n\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\t\tif( isRGBAUncompressed ) {\n\t\t\t\t\tvar byteArray = loadARGBMip( buffer, dataOffset, width, height );\n\t\t\t\t\tvar dataLength = byteArray.length;\n\t\t\t\t} else {\n\t\t\t\t\tvar dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\n\t\t\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataLength );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar mipmap = { \"data\": byteArray, \"width\": width, \"height\": height };\n\t\t\t\tdds.mipmaps.push( mipmap );\n\n\t\t\t\tdataOffset += dataLength;\n\n\t\t\t\twidth = Math.max( width * 0.5, 1 );\n\t\t\t\theight = Math.max( height * 0.5, 1 );\n\n\t\t\t}\n\n\t\t\twidth = dds.width;\n\t\t\theight = dds.height;\n\n\t\t}\n\n\t\treturn dds;\n\n\t},\n\n\tgetNormalMap: function ( image, depth ) {\n\n\t\t// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/\n\n\t\tvar cross = function ( a, b ) {\n\n\t\t\treturn [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];\n\n\t\t}\n\n\t\tvar subtract = function ( a, b ) {\n\n\t\t\treturn [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];\n\n\t\t}\n\n\t\tvar normalize = function ( a ) {\n\n\t\t\tvar l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );\n\t\t\treturn [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];\n\n\t\t}\n\n\t\tdepth = depth | 1;\n\n\t\tvar width = image.width;\n\t\tvar height = image.height;\n\n\t\tvar canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tcontext.drawImage( image, 0, 0 );\n\n\t\tvar data = context.getImageData( 0, 0, width, height ).data;\n\t\tvar imageData = context.createImageData( width, height );\n\t\tvar output = imageData.data;\n\n\t\tfor ( var x = 0; x < width; x ++ ) {\n\n\t\t\tfor ( var y = 0; y < height; y ++ ) {\n\n\t\t\t\tvar ly = y - 1 < 0 ? 0 : y - 1;\n\t\t\t\tvar uy = y + 1 > height - 1 ? height - 1 : y + 1;\n\t\t\t\tvar lx = x - 1 < 0 ? 0 : x - 1;\n\t\t\t\tvar ux = x + 1 > width - 1 ? width - 1 : x + 1;\n\n\t\t\t\tvar points = [];\n\t\t\t\tvar origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];\n\t\t\t\tpoints.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );\n\n\t\t\t\tvar normals = [];\n\t\t\t\tvar num_points = points.length;\n\n\t\t\t\tfor ( var i = 0; i < num_points; i ++ ) {\n\n\t\t\t\t\tvar v1 = points[ i ];\n\t\t\t\t\tvar v2 = points[ ( i + 1 ) % num_points ];\n\t\t\t\t\tv1 = subtract( v1, origin );\n\t\t\t\t\tv2 = subtract( v2, origin );\n\t\t\t\t\tnormals.push( normalize( cross( v1, v2 ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tvar normal = [ 0, 0, 0 ];\n\n\t\t\t\tfor ( var i = 0; i < normals.length; i ++ ) {\n\n\t\t\t\t\tnormal[ 0 ] += normals[ i ][ 0 ];\n\t\t\t\t\tnormal[ 1 ] += normals[ i ][ 1 ];\n\t\t\t\t\tnormal[ 2 ] += normals[ i ][ 2 ];\n\n\t\t\t\t}\n\n\t\t\t\tnormal[ 0 ] /= normals.length;\n\t\t\t\tnormal[ 1 ] /= normals.length;\n\t\t\t\tnormal[ 2 ] /= normals.length;\n\n\t\t\t\tvar idx = ( y * width + x ) * 4;\n\n\t\t\t\toutput[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;\n\t\t\t\toutput[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;\n\t\t\t\toutput[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;\n\t\t\t\toutput[ idx + 3 ] = 255;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\treturn canvas;\n\n\t},\n\n\tgenerateDataTexture: function ( width, height, color ) {\n\n\t\tvar size = width * height;\n\t\tvar data = new Uint8Array( 3 * size );\n\n\t\tvar r = Math.floor( color.r * 255 );\n\t\tvar g = Math.floor( color.g * 255 );\n\t\tvar b = Math.floor( color.b * 255 );\n\n\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\tdata[ i * 3 ] \t  = r;\n\t\t\tdata[ i * 3 + 1 ] = g;\n\t\t\tdata[ i * 3 + 2 ] = b;\n\n\t\t}\n\n\t\tvar texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SceneUtils = {\n\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\n\t\tvar group = new THREE.Object3D();\n\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t},\n\n\tdetach : function ( child, parent, scene ) {\n\n\t\tchild.applyMatrix( parent.matrixWorld );\n\t\tparent.remove( child );\n\t\tscene.add( child );\n\n\t},\n\n\tattach: function ( child, scene, parent ) {\n\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\tchild.applyMatrix( matrixWorldInverse );\n\n\t\tscene.remove( child );\n\t\tparent.add( child );\n\n\t}\n\n};\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * For Text operations in three.js (See TextGeometry)\n *\n * It uses techniques used in:\n *\n * \ttypeface.js and canvastext\n * \t\tFor converting fonts and rendering with javascript\n *\t\thttp://typeface.neocracy.org\n *\n *\tTriangulation ported from AS3\n *\t\tSimple Polygon Triangulation\n *\t\thttp://actionsnippet.com/?p=1462\n *\n * \tA Method to triangulate shapes with holes\n *\t\thttp://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/\n *\n */\n\nTHREE.FontUtils = {\n\n\tfaces : {},\n\n\t// Just for now. face[weight][style]\n\n\tface : \"helvetiker\",\n\tweight: \"normal\",\n\tstyle : \"normal\",\n\tsize : 150,\n\tdivisions : 10,\n\n\tgetFace : function() {\n\n\t\treturn this.faces[ this.face ][ this.weight ][ this.style ];\n\n\t},\n\n\tloadFace : function( data ) {\n\n\t\tvar family = data.familyName.toLowerCase();\n\n\t\tvar ThreeFont = this;\n\n\t\tThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};\n\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\n\n\t\tvar face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\n\n\t\treturn data;\n\n\t},\n\n\tdrawText : function( text ) {\n\n\t\tvar characterPts = [], allPts = [];\n\n\t\t// RenderText\n\n\t\tvar i, p,\n\t\t\tface = this.getFace(),\n\t\t\tscale = this.size / face.resolution,\n\t\t\toffset = 0,\n\t\t\tchars = String( text ).split( '' ),\n\t\t\tlength = chars.length;\n\n\t\tvar fontPaths = [];\n\n\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\tvar path = new THREE.Path();\n\n\t\t\tvar ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );\n\t\t\toffset += ret.offset;\n\n\t\t\tfontPaths.push( ret.path );\n\n\t\t}\n\n\t\t// get the width\n\n\t\tvar width = offset / 2;\n\t\t//\n\t\t// for ( p = 0; p < allPts.length; p++ ) {\n\t\t//\n\t\t// \tallPts[ p ].x -= width;\n\t\t//\n\t\t// }\n\n\t\t//var extract = this.extractPoints( allPts, characterPts );\n\t\t//extract.contour = allPts;\n\n\t\t//extract.paths = fontPaths;\n\t\t//extract.offset = width;\n\n\t\treturn { paths : fontPaths, offset : width };\n\n\t},\n\n\n\n\n\textractGlyphPoints : function( c, face, scale, offset, path ) {\n\n\t\tvar pts = [];\n\n\t\tvar i, i2, divisions,\n\t\t\toutline, action, length,\n\t\t\tscaleX, scaleY,\n\t\t\tx, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,\n\t\t\tlaste,\n\t\t\tglyph = face.glyphs[ c ] || face.glyphs[ '?' ];\n\n\t\tif ( !glyph ) return;\n\n\t\tif ( glyph.o ) {\n\n\t\t\toutline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\t\t\tlength = outline.length;\n\n\t\t\tscaleX = scale;\n\t\t\tscaleY = scale;\n\n\t\t\tfor ( i = 0; i < length; ) {\n\n\t\t\t\taction = outline[ i ++ ];\n\n\t\t\t\t//console.log( action );\n\n\t\t\t\tswitch( action ) {\n\n\t\t\t\tcase 'm':\n\n\t\t\t\t\t// Move To\n\n\t\t\t\t\tx = outline[ i++ ] * scaleX + offset;\n\t\t\t\t\ty = outline[ i++ ] * scaleY;\n\n\t\t\t\t\tpath.moveTo( x, y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'l':\n\n\t\t\t\t\t// Line To\n\n\t\t\t\t\tx = outline[ i++ ] * scaleX + offset;\n\t\t\t\t\ty = outline[ i++ ] * scaleY;\n\t\t\t\t\tpath.lineTo(x,y);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'q':\n\n\t\t\t\t\t// QuadraticCurveTo\n\n\t\t\t\t\tcpx  = outline[ i++ ] * scaleX + offset;\n\t\t\t\t\tcpy  = outline[ i++ ] * scaleY;\n\t\t\t\t\tcpx1 = outline[ i++ ] * scaleX + offset;\n\t\t\t\t\tcpy1 = outline[ i++ ] * scaleY;\n\n\t\t\t\t\tpath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\tvar tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\tvar ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\n\t\t\t\t\t  }\n\n\t\t\t\t  }\n\n\t\t\t\t  break;\n\n\t\t\t\tcase 'b':\n\n\t\t\t\t\t// Cubic Bezier Curve\n\n\t\t\t\t\tcpx  = outline[ i++ ] *  scaleX + offset;\n\t\t\t\t\tcpy  = outline[ i++ ] *  scaleY;\n\t\t\t\t\tcpx1 = outline[ i++ ] *  scaleX + offset;\n\t\t\t\t\tcpy1 = outline[ i++ ] * -scaleY;\n\t\t\t\t\tcpx2 = outline[ i++ ] *  scaleX + offset;\n\t\t\t\t\tcpy2 = outline[ i++ ] * -scaleY;\n\n\t\t\t\t\tpath.bezierCurveTo( cpx, cpy, cpx1, cpy1, cpx2, cpy2 );\n\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\tvar tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\tvar ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\n\n\t\treturn { offset: glyph.ha*scale, path:path};\n\t}\n\n};\n\n\nTHREE.FontUtils.generateShapes = function( text, parameters ) {\n\n\t// Parameters \n\n\tparameters = parameters || {};\n\n\tvar size = parameters.size !== undefined ? parameters.size : 100;\n\tvar curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments: 4;\n\n\tvar font = parameters.font !== undefined ? parameters.font : \"helvetiker\";\n\tvar weight = parameters.weight !== undefined ? parameters.weight : \"normal\";\n\tvar style = parameters.style !== undefined ? parameters.style : \"normal\";\n\n\tTHREE.FontUtils.size = size;\n\tTHREE.FontUtils.divisions = curveSegments;\n\n\tTHREE.FontUtils.face = font;\n\tTHREE.FontUtils.weight = weight;\n\tTHREE.FontUtils.style = style;\n\n\t// Get a Font data json object\n\n\tvar data = THREE.FontUtils.drawText( text );\n\n\tvar paths = data.paths;\n\tvar shapes = [];\n\n\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t}\n\n\treturn shapes;\n\n};\n\n\n/**\n * This code is a quick port of code written in C++ which was submitted to\n * flipcode.com by John W. Ratcliff  // July 22, 2000\n * See original code and more information here:\n * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n *\n * ported to actionscript by Zevan Rosser\n * www.actionsnippet.com\n *\n * ported to javascript by Joshua Koo\n * http://www.lab4games.net/zz85/blog\n *\n */\n\n\n( function( namespace ) {\n\n\tvar EPSILON = 0.0000000001;\n\n\t// takes in an contour array and returns\n\n\tvar process = function( contour, indices ) {\n\n\t\tvar n = contour.length;\n\n\t\tif ( n < 3 ) return null;\n\n\t\tvar result = [],\n\t\t\tverts = [],\n\t\t\tvertIndices = [];\n\n\t\t/* we want a counter-clockwise polygon in verts */\n\n\t\tvar u, v, w;\n\n\t\tif ( area( contour ) > 0.0 ) {\n\n\t\t\tfor ( v = 0; v < n; v++ ) verts[ v ] = v;\n\n\t\t} else {\n\n\t\t\tfor ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;\n\n\t\t}\n\n\t\tvar nv = n;\n\n\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\n\t\tvar count = 2 * nv;   /* error detection */\n\n\t\tfor( v = nv - 1; nv > 2; ) {\n\n\t\t\t/* if we loop, it is probably a non-simple polygon */\n\n\t\t\tif ( ( count-- ) <= 0 ) {\n\n\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\n\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t//return null;\n\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\tconsole.log( \"Warning, unable to triangulate polygon!\" );\n\n\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\n\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\n\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\n\t\t\t\tvar a, b, c, s, t;\n\n\t\t\t\t/* true names of the vertices */\n\n\t\t\t\ta = verts[ u ];\n\t\t\t\tb = verts[ v ];\n\t\t\t\tc = verts[ w ];\n\n\t\t\t\t/* output Triangle */\n\n\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\tcontour[ b ],\n\t\t\t\t\tcontour[ c ] ] );\n\n\n\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\n\t\t\t\t/* remove v from the remaining polygon */\n\n\t\t\t\tfor( s = v, t = v + 1; t < nv; s++, t++ ) {\n\n\t\t\t\t\tverts[ s ] = verts[ t ];\n\n\t\t\t\t}\n\n\t\t\t\tnv--;\n\n\t\t\t\t/* reset error detection counter */\n\n\t\t\t\tcount = 2 * nv;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( indices ) return vertIndices;\n\t\treturn result;\n\n\t};\n\n\t// calculate area of the contour polygon\n\n\tvar area = function ( contour ) {\n\n\t\tvar n = contour.length;\n\t\tvar a = 0.0;\n\n\t\tfor( var p = n - 1, q = 0; q < n; p = q++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t};\n\n\tvar snip = function ( contour, u, v, w, n, verts ) {\n\n\t\tvar p;\n\t\tvar ax, ay, bx, by;\n\t\tvar cx, cy, px, py;\n\n\t\tax = contour[ verts[ u ] ].x;\n\t\tay = contour[ verts[ u ] ].y;\n\n\t\tbx = contour[ verts[ v ] ].x;\n\t\tby = contour[ verts[ v ] ].y;\n\n\t\tcx = contour[ verts[ w ] ].x;\n\t\tcy = contour[ verts[ w ] ].y;\n\n\t\tif ( EPSILON > (((bx-ax)*(cy-ay)) - ((by-ay)*(cx-ax))) ) return false;\n\n\t\tvar aX, aY, bX, bY, cX, cY;\n\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\n\t\taX = cx - bx;  aY = cy - by;\n\t\tbX = ax - cx;  bY = ay - cy;\n\t\tcX = bx - ax;  cY = by - ay;\n\n\t\tfor ( p = 0; p < n; p++ ) {\n\n\t\t\tif( (p === u) || (p === v) || (p === w) ) continue;\n\n\t\t\tpx = contour[ verts[ p ] ].x\n\t\t\tpy = contour[ verts[ p ] ].y\n\n\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\tcpx = px - cx;  cpy = py - cy;\n\n\t\t\t// see if p is inside triangle abc\n\n\t\t\taCROSSbp = aX*bpy - aY*bpx;\n\t\t\tcCROSSap = cX*apy - cY*apx;\n\t\t\tbCROSScp = bX*cpy - bY*cpx;\n\n\t\t\tif ( (aCROSSbp >= -EPSILON) && (bCROSScp >= -EPSILON) && (cCROSSap >= -EPSILON) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n\n\tnamespace.Triangulate = process;\n\tnamespace.Triangulate.area = area;\n\n\treturn namespace;\n\n})(THREE.FontUtils);\n\n// To use the typeface.js face files, hook up the API\nself._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };\nTHREE.typeface_js = self._typeface_js;\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Extensible curve object\n *\n * Some common of Curve methods\n * .getPoint(t), getTangent(t)\n * .getPointAt(u), getTagentAt(u)\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following classes subclasses THREE.Curve:\n *\n * -- 2d classes --\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.CubicBezierCurve\n * THREE.SplineCurve\n * THREE.ArcCurve\n * THREE.EllipseCurve\n *\n * -- 3d classes --\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n * THREE.CubicBezierCurve3\n * THREE.SplineCurve3\n * THREE.ClosedSplineCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath\n *\n **/\n\n/**************************************************************\n *\tAbstract Curve base class\n **************************************************************/\n\nTHREE.Curve = function () {\n\n};\n\n// Virtual base class method to overwrite and implement in subclasses\n//\t- t [0 .. 1]\n\nTHREE.Curve.prototype.getPoint = function ( t ) {\n\n\tconsole.log( \"Warning, getPoint() not implemented!\" );\n\treturn null;\n\n};\n\n// Get point at relative position in curve according to arc length\n// - u [0 .. 1]\n\nTHREE.Curve.prototype.getPointAt = function ( u ) {\n\n\tvar t = this.getUtoTmapping( u );\n\treturn this.getPoint( t );\n\n};\n\n// Get sequence of points using getPoint( t )\n\nTHREE.Curve.prototype.getPoints = function ( divisions ) {\n\n\tif ( !divisions ) divisions = 5;\n\n\tvar d, pts = [];\n\n\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\tpts.push( this.getPoint( d / divisions ) );\n\n\t}\n\n\treturn pts;\n\n};\n\n// Get sequence of points using getPointAt( u )\n\nTHREE.Curve.prototype.getSpacedPoints = function ( divisions ) {\n\n\tif ( !divisions ) divisions = 5;\n\n\tvar d, pts = [];\n\n\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\tpts.push( this.getPointAt( d / divisions ) );\n\n\t}\n\n\treturn pts;\n\n};\n\n// Get total curve arc length\n\nTHREE.Curve.prototype.getLength = function () {\n\n\tvar lengths = this.getLengths();\n\treturn lengths[ lengths.length - 1 ];\n\n};\n\n// Get list of cumulative segment lengths\n\nTHREE.Curve.prototype.getLengths = function ( divisions ) {\n\n\tif ( !divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;\n\n\tif ( this.cacheArcLengths\n\t\t&& ( this.cacheArcLengths.length == divisions + 1 )\n\t\t&& !this.needsUpdate) {\n\n\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\treturn this.cacheArcLengths;\n\n\t}\n\n\tthis.needsUpdate = false;\n\n\tvar cache = [];\n\tvar current, last = this.getPoint( 0 );\n\tvar p, sum = 0;\n\n\tcache.push( 0 );\n\n\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\tcurrent = this.getPoint ( p / divisions );\n\t\tsum += current.distanceTo( last );\n\t\tcache.push( sum );\n\t\tlast = current;\n\n\t}\n\n\tthis.cacheArcLengths = cache;\n\n\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\n};\n\n\nTHREE.Curve.prototype.updateArcLengths = function() {\n\tthis.needsUpdate = true;\n\tthis.getLengths();\n};\n\n// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance\n\nTHREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {\n\n\tvar arcLengths = this.getLengths();\n\n\tvar i = 0, il = arcLengths.length;\n\n\tvar targetArcLength; // The targeted u distance value to get\n\n\tif ( distance ) {\n\n\t\ttargetArcLength = distance;\n\n\t} else {\n\n\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t}\n\n\t//var time = Date.now();\n\n\t// binary search for the index with largest value smaller than target u distance\n\n\tvar low = 0, high = il - 1, comparison;\n\n\twhile ( low <= high ) {\n\n\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\tif ( comparison < 0 ) {\n\n\t\t\tlow = i + 1;\n\t\t\tcontinue;\n\n\t\t} else if ( comparison > 0 ) {\n\n\t\t\thigh = i - 1;\n\t\t\tcontinue;\n\n\t\t} else {\n\n\t\t\thigh = i;\n\t\t\tbreak;\n\n\t\t\t// DONE\n\n\t\t}\n\n\t}\n\n\ti = high;\n\n\t//console.log('b' , i, low, high, Date.now()- time);\n\n\tif ( arcLengths[ i ] == targetArcLength ) {\n\n\t\tvar t = i / ( il - 1 );\n\t\treturn t;\n\n\t}\n\n\t// we could get finer grain at lengths, or use simple interpolatation between two points\n\n\tvar lengthBefore = arcLengths[ i ];\n    var lengthAfter = arcLengths[ i + 1 ];\n\n    var segmentLength = lengthAfter - lengthBefore;\n\n    // determine where we are between the 'before' and 'after' points\n\n    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n    // add that fractional amount to t\n\n    var t = ( i + segmentFraction ) / ( il -1 );\n\n\treturn t;\n\n};\n\n// Returns a unit vector tangent at t\n// In case any sub curve does not implement its tangent derivation,\n// 2 points a small delta apart will be used to find its gradient\n// which seems to give a reasonable approximation\n\nTHREE.Curve.prototype.getTangent = function( t ) {\n\n\tvar delta = 0.0001;\n\tvar t1 = t - delta;\n\tvar t2 = t + delta;\n\n\t// Capping in case of danger\n\n\tif ( t1 < 0 ) t1 = 0;\n\tif ( t2 > 1 ) t2 = 1;\n\n\tvar pt1 = this.getPoint( t1 );\n\tvar pt2 = this.getPoint( t2 );\n\n\tvar vec = pt2.clone().sub(pt1);\n\treturn vec.normalize();\n\n};\n\n\nTHREE.Curve.prototype.getTangentAt = function ( u ) {\n\n\tvar t = this.getUtoTmapping( u );\n\treturn this.getTangent( t );\n\n};\n\n\n\n\n\n/**************************************************************\n *\tUtils\n **************************************************************/\n\nTHREE.Curve.Utils = {\n\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\n\t},\n\n\t// Puay Bing, thanks for helping with this derivative!\n\n\ttangentCubicBezier: function (t, p0, p1, p2, p3 ) {\n\n\t\treturn -3 * p0 * (1 - t) * (1 - t)  +\n\t\t\t3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +\n\t\t\t6 * t *  p2 * (1-t) - 3 * t * t * p2 +\n\t\t\t3 * t * t * p3;\n\t},\n\n\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\n\t\t// To check if my formulas are correct\n\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3  3t^2 + 1\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t\n\t\tvar h01 = -6 * t * t + 6 * t; \t//  2t3 + 3t2\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3  t2\n\n\t\treturn h00 + h10 + h01 + h11;\n\n\t},\n\n\t// Catmull-Rom\n\n\tinterpolate: function( p0, p1, p2, p3, t ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\tvar t2 = t * t;\n\t\tvar t3 = t * t2;\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n};\n\n\n// TODO: Transformation for Curves?\n\n/**************************************************************\n *\t3D Curves\n **************************************************************/\n\n// A Factory method for creating new curve subclasses\n\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\n\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\n\tconstructor.prototype.getPoint = getPointFunc;\n\n\treturn constructor;\n\n};\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n **/\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nTHREE.CurvePath = function () {\n\n\tthis.curves = [];\n\tthis.bends = [];\n\t\n\tthis.autoClose = false; // Automatically closes the path\n};\n\nTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.CurvePath.prototype.add = function ( curve ) {\n\n\tthis.curves.push( curve );\n\n};\n\nTHREE.CurvePath.prototype.checkConnection = function() {\n\t// TODO\n\t// If the ending of curve is not connected to the starting\n\t// or the next curve, then, this is not a real path\n};\n\nTHREE.CurvePath.prototype.closePath = function() {\n\t// TODO Test\n\t// and verify for vector3 (needs to implement equals)\n\t// Add a line curve if start and end of lines are not connected\n\tvar startPoint = this.curves[0].getPoint(0);\n\tvar endPoint = this.curves[this.curves.length-1].getPoint(1);\n\t\n\tif (!startPoint.equals(endPoint)) {\n\t\tthis.curves.push( new THREE.LineCurve(endPoint, startPoint) );\n\t}\n\t\n};\n\n// To get accurate point with reference to\n// entire path distance at time t,\n// following has to be done:\n\n// 1. Length of each sub path have to be known\n// 2. Locate and identify type of curve\n// 3. Get t for the curve\n// 4. Return curve.getPointAt(t')\n\nTHREE.CurvePath.prototype.getPoint = function( t ) {\n\n\tvar d = t * this.getLength();\n\tvar curveLengths = this.getCurveLengths();\n\tvar i = 0, diff, curve;\n\n\t// To think about boundaries points.\n\n\twhile ( i < curveLengths.length ) {\n\n\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\tdiff = curveLengths[ i ] - d;\n\t\t\tcurve = this.curves[ i ];\n\n\t\t\tvar u = 1 - diff / curve.getLength();\n\n\t\t\treturn curve.getPointAt( u );\n\n\t\t\tbreak;\n\t\t}\n\n\t\ti ++;\n\n\t}\n\n\treturn null;\n\n\t// loop where sum != 0, sum > d , sum+1 <d\n\n};\n\n/*\nTHREE.CurvePath.prototype.getTangent = function( t ) {\n};*/\n\n\n// We cannot use the default THREE.Curve getPoint() with getLength() because in\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n// getPoint() depends on getLength\n\nTHREE.CurvePath.prototype.getLength = function() {\n\n\tvar lens = this.getCurveLengths();\n\treturn lens[ lens.length - 1 ];\n\n};\n\n// Compute lengths and cache them\n// We cannot overwrite getLengths() because UtoT mapping uses it.\n\nTHREE.CurvePath.prototype.getCurveLengths = function() {\n\n\t// We use cache values if curves and cache array are same length\n\n\tif ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {\n\n\t\treturn this.cacheLengths;\n\n\t};\n\n\t// Get length of subsurve\n\t// Push sums into cached array\n\n\tvar lengths = [], sums = 0;\n\tvar i, il = this.curves.length;\n\n\tfor ( i = 0; i < il; i ++ ) {\n\n\t\tsums += this.curves[ i ].getLength();\n\t\tlengths.push( sums );\n\n\t}\n\n\tthis.cacheLengths = lengths;\n\n\treturn lengths;\n\n};\n\n\n\n// Returns min and max coordinates, as well as centroid\n\nTHREE.CurvePath.prototype.getBoundingBox = function () {\n\n\tvar points = this.getPoints();\n\n\tvar maxX, maxY, maxZ;\n\tvar minX, minY, minZ;\n\n\tmaxX = maxY = Number.NEGATIVE_INFINITY;\n\tminX = minY = Number.POSITIVE_INFINITY;\n\n\tvar p, i, il, sum;\n\n\tvar v3 = points[0] instanceof THREE.Vector3;\n\n\tsum = v3 ? new THREE.Vector3() : new THREE.Vector2();\n\n\tfor ( i = 0, il = points.length; i < il; i ++ ) {\n\n\t\tp = points[ i ];\n\n\t\tif ( p.x > maxX ) maxX = p.x;\n\t\telse if ( p.x < minX ) minX = p.x;\n\n\t\tif ( p.y > maxY ) maxY = p.y;\n\t\telse if ( p.y < minY ) minY = p.y;\n\n\t\tif ( v3 ) {\n\n\t\t\tif ( p.z > maxZ ) maxZ = p.z;\n\t\t\telse if ( p.z < minZ ) minZ = p.z;\n\n\t\t}\n\n\t\tsum.add( p );\n\n\t}\n\n\tvar ret = {\n\n\t\tminX: minX,\n\t\tminY: minY,\n\t\tmaxX: maxX,\n\t\tmaxY: maxY,\n\t\tcentroid: sum.divideScalar( il )\n\n\t};\n\n\tif ( v3 ) {\n\n\t\tret.maxZ = maxZ;\n\t\tret.minZ = minZ;\n\n\t}\n\n\treturn ret;\n\n};\n\n/**************************************************************\n *\tCreate Geometries Helpers\n **************************************************************/\n\n/// Generate geometry from path points (for Line or ParticleSystem objects)\n\nTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\n\n\tvar pts = this.getPoints( divisions, true );\n\treturn this.createGeometry( pts );\n\n};\n\n// Generate geometry from equidistance sampling along the path\n\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\n\n\tvar pts = this.getSpacedPoints( divisions, true );\n\treturn this.createGeometry( pts );\n\n};\n\nTHREE.CurvePath.prototype.createGeometry = function( points ) {\n\n\tvar geometry = new THREE.Geometry();\n\n\tfor ( var i = 0; i < points.length; i ++ ) {\n\n\t\tgeometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );\n\n\t}\n\n\treturn geometry;\n\n};\n\n\n/**************************************************************\n *\tBend / Wrap Helper Methods\n **************************************************************/\n\n// Wrap path / Bend modifiers?\n\nTHREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {\n\n\tthis.bends.push( bendpath );\n\n};\n\nTHREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {\n\n\tvar oldPts = this.getPoints( segments ); // getPoints getSpacedPoints\n\tvar i, il;\n\n\tif ( !bends ) {\n\n\t\tbends = this.bends;\n\n\t}\n\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\n\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\n\n\t}\n\n\treturn oldPts;\n\n};\n\nTHREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {\n\n\tvar oldPts = this.getSpacedPoints( segments );\n\n\tvar i, il;\n\n\tif ( !bends ) {\n\n\t\tbends = this.bends;\n\n\t}\n\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\n\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\n\n\t}\n\n\treturn oldPts;\n\n};\n\n// This returns getPoints() bend/wrapped around the contour of a path.\n// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html\n\nTHREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {\n\n\tvar bounds = this.getBoundingBox();\n\n\tvar i, il, p, oldX, oldY, xNorm;\n\n\tfor ( i = 0, il = oldPts.length; i < il; i ++ ) {\n\n\t\tp = oldPts[ i ];\n\n\t\toldX = p.x;\n\t\toldY = p.y;\n\n\t\txNorm = oldX / bounds.maxX;\n\n\t\t// If using actual distance, for length > path, requires line extrusions\n\t\t//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance\n\n\t\txNorm = path.getUtoTmapping( xNorm, oldX );\n\n\t\t// check for out of bounds?\n\n\t\tvar pathPt = path.getPoint( xNorm );\n\t\tvar normal = path.getTangent( xNorm );\n\t\tnormal.set( -normal.y, normal.x ).multiplyScalar( oldY );\n\n\t\tp.x = pathPt.x + normal.x;\n\t\tp.y = pathPt.y + normal.y;\n\n\t}\n\n\treturn oldPts;\n\n};\n\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Gyroscope = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n};\r\n\r\nTHREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Gyroscope.prototype.updateMatrixWorld = function ( force ) {\r\n\r\n\tthis.matrixAutoUpdate && this.updateMatrix();\r\n\r\n\t// update matrixWorld\r\n\r\n\tif ( this.matrixWorldNeedsUpdate || force ) {\r\n\r\n\t\tif ( this.parent ) {\r\n\r\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\tthis.matrixWorld.decompose( this.translationWorld, this.quaternionWorld, this.scaleWorld );\r\n\t\t\tthis.matrix.decompose( this.translationObject, this.quaternionObject, this.scaleObject );\r\n\r\n\t\t\tthis.matrixWorld.compose( this.translationWorld, this.quaternionObject, this.scaleWorld );\r\n\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t}\r\n\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\tforce = true;\r\n\r\n\t}\r\n\r\n\t// update children\r\n\r\n\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();\r\nTHREE.Gyroscope.prototype.translationObject = new THREE.Vector3();\r\nTHREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion();\r\nTHREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion();\r\nTHREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();\r\nTHREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();\r\n\r\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Creates free form 2d path using series of points, lines or curves.\n *\n **/\n\nTHREE.Path = function ( points ) {\n\n\tTHREE.CurvePath.call(this);\n\n\tthis.actions = [];\n\n\tif ( points ) {\n\n\t\tthis.fromPoints( points );\n\n\t}\n\n};\n\nTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\n\nTHREE.PathActions = {\n\n\tMOVE_TO: 'moveTo',\n\tLINE_TO: 'lineTo',\n\tQUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve\n\tBEZIER_CURVE_TO: 'bezierCurveTo', \t\t// Bezier cubic curve\n\tCSPLINE_THRU: 'splineThru',\t\t\t\t// Catmull-rom spline\n\tARC: 'arc',\t\t\t\t\t\t\t\t// Circle\n\tELLIPSE: 'ellipse'\n};\n\n// TODO Clean up PATH API\n\n// Create path using straight lines to connect all points\n// - vectors: array of Vector2\n\nTHREE.Path.prototype.fromPoints = function ( vectors ) {\n\n\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\n\tfor ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {\n\n\t\tthis.lineTo( vectors[ v ].x, vectors[ v ].y );\n\n\t};\n\n};\n\n// startPath() endPath()?\n\nTHREE.Path.prototype.moveTo = function ( x, y ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\tthis.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );\n\n};\n\nTHREE.Path.prototype.lineTo = function ( x, y ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\n\tthis.curves.push( curve );\n\n\tthis.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );\n\n};\n\nTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tvar curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCPx, aCPy ),\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\n\tthis.curves.push( curve );\n\n\tthis.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );\n\n};\n\nTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,\n\t\t\t\t\t\t\t\t\t\t\t   aCP2x, aCP2y,\n\t\t\t\t\t\t\t\t\t\t\t   aX, aY ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tvar curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\n\tthis.curves.push( curve );\n\n\tthis.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );\n\n};\n\nTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n//---\n\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\n\tArray.prototype.push.apply( npts, pts );\n\n\tvar curve = new THREE.SplineCurve( npts );\n\tthis.curves.push( curve );\n\n\tthis.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );\n\n};\n\n// FUTURE: Change the API or follow canvas API?\n\nTHREE.Path.prototype.arc = function ( aX, aY, aRadius,\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tthis.absarc(aX + x0, aY + y0, aRadius,\n\t\taStartAngle, aEndAngle, aClockwise );\n\n };\n\n THREE.Path.prototype.absarc = function ( aX, aY, aRadius,\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n };\n\nTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius,\n\t\taStartAngle, aEndAngle, aClockwise );\n\n };\n\n\nTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,\n\t\t\t\t\t\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\tthis.curves.push( curve );\n\n\tvar lastPoint = curve.getPoint(1);\n\targs.push(lastPoint.x);\n\targs.push(lastPoint.y);\n\n\tthis.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );\n\n };\n\nTHREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {\n\n\tif ( ! divisions ) divisions = 40;\n\n\tvar points = [];\n\n\tfor ( var i = 0; i < divisions; i ++ ) {\n\n\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t//if( !this.getPoint( i / divisions ) ) throw \"DIE\";\n\n\t}\n\n\t// if ( closedPath ) {\n\t//\n\t// \tpoints.push( points[ 0 ] );\n\t//\n\t// }\n\n\treturn points;\n\n};\n\n/* Return an array of vectors based on contour of the path */\n\nTHREE.Path.prototype.getPoints = function( divisions, closedPath ) {\n\n\tif (this.useSpacedPoints) {\n\t\tconsole.log('tata');\n\t\treturn this.getSpacedPoints( divisions, closedPath );\n\t}\n\n\tdivisions = divisions || 12;\n\n\tvar points = [];\n\n\tvar i, il, item, action, args;\n\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\n\t\tlaste, j,\n\t\tt, tx, ty;\n\n\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\n\n\t\titem = this.actions[ i ];\n\n\t\taction = item.action;\n\t\targs = item.args;\n\n\t\tswitch( action ) {\n\n\t\tcase THREE.PathActions.MOVE_TO:\n\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.LINE_TO:\n\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.QUADRATIC_CURVE_TO:\n\n\t\t\tcpx  = args[ 2 ];\n\t\t\tcpy  = args[ 3 ];\n\n\t\t\tcpx1 = args[ 0 ];\n\t\t\tcpy1 = args[ 1 ];\n\n\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\tcpx0 = laste.x;\n\t\t\t\tcpy0 = laste.y;\n\n\t\t\t} else {\n\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t}\n\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\tt = j / divisions;\n\n\t\t\t\ttx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\n\t\t\t\tty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\n\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.BEZIER_CURVE_TO:\n\n\t\t\tcpx  = args[ 4 ];\n\t\t\tcpy  = args[ 5 ];\n\n\t\t\tcpx1 = args[ 0 ];\n\t\t\tcpy1 = args[ 1 ];\n\n\t\t\tcpx2 = args[ 2 ];\n\t\t\tcpy2 = args[ 3 ];\n\n\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\tcpx0 = laste.x;\n\t\t\t\tcpy0 = laste.y;\n\n\t\t\t} else {\n\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t}\n\n\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\tt = j / divisions;\n\n\t\t\t\ttx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\tty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.CSPLINE_THRU:\n\n\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\n\t\t\tvar spts = [ last ];\n\n\t\t\tvar n = divisions * args[ 0 ].length;\n\n\t\t\tspts = spts.concat( args[ 0 ] );\n\n\t\t\tvar spline = new THREE.SplineCurve( spts );\n\n\t\t\tfor ( j = 1; j <= n; j ++ ) {\n\n\t\t\t\tpoints.push( spline.getPointAt( j / n ) ) ;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.ARC:\n\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\taRadius = args[ 2 ],\n\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\n\t\t\t\taClockwise = !!args[ 5 ];\n\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\tvar angle;\n\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\tt = j / tdivisions;\n\n\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t}\n\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\ttx = aX + aRadius * Math.cos( angle );\n\t\t\t\tty = aY + aRadius * Math.sin( angle );\n\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t}\n\n\t\t\t//console.log(points);\n\n\t\t  break;\n\t\t  \n\t\tcase THREE.PathActions.ELLIPSE:\n\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\txRadius = args[ 2 ],\n\t\t\t\tyRadius = args[ 3 ],\n\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\n\t\t\t\taClockwise = !!args[ 6 ];\n\n\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\tvar angle;\n\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\tt = j / tdivisions;\n\n\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t}\n\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\ttx = aX + xRadius * Math.cos( angle );\n\t\t\t\tty = aY + yRadius * Math.sin( angle );\n\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t}\n\n\t\t\t//console.log(points);\n\n\t\t  break;\n\n\t\t} // end switch\n\n\t}\n\n\n\n\t// Normalize to remove the closing point by default.\n\tvar lastPoint = points[ points.length - 1];\n\tvar EPSILON = 0.0000000001;\n\tif ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&\n\t\t\t Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)\n\t\tpoints.splice( points.length - 1, 1);\n\tif ( closedPath ) {\n\n\t\tpoints.push( points[ 0 ] );\n\n\t}\n\n\treturn points;\n\n};\n\n// Breaks path into shapes\n\nTHREE.Path.prototype.toShapes = function( isCCW ) {\n\n\tvar i, il, item, action, args;\n\n\tvar subPaths = [], lastPath = new THREE.Path();\n\n\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\n\n\t\titem = this.actions[ i ];\n\n\t\targs = item.args;\n\t\taction = item.action;\n\n\t\tif ( action == THREE.PathActions.MOVE_TO ) {\n\n\t\t\tif ( lastPath.actions.length != 0 ) {\n\n\t\t\t\tsubPaths.push( lastPath );\n\t\t\t\tlastPath = new THREE.Path();\n\n\t\t\t}\n\n\t\t}\n\n\t\tlastPath[ action ].apply( lastPath, args );\n\n\t}\n\n\tif ( lastPath.actions.length != 0 ) {\n\n\t\tsubPaths.push( lastPath );\n\n\t}\n\n\t// console.log(subPaths);\n\n\tif ( subPaths.length == 0 ) return [];\n\n\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\tif ( subPaths.length == 1) {\n\n\t\ttmpPath = subPaths[0];\n\t\ttmpShape = new THREE.Shape();\n\t\ttmpShape.actions = tmpPath.actions;\n\t\ttmpShape.curves = tmpPath.curves;\n\t\tshapes.push( tmpShape );\n\t\treturn shapes;\n\n\t}\n\n\tvar holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );\n\tholesFirst = isCCW ? !holesFirst : holesFirst;\n\n\t// console.log(\"Holes first\", holesFirst);\n\n\tif ( holesFirst ) {\n\n\t\ttmpShape = new THREE.Shape();\n\n\t\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\tsolid = THREE.Shape.Utils.isClockWise( tmpPath.getPoints() );\n\t\t\tsolid = isCCW ? !solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\ttmpShape = new THREE.Shape();\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\ttmpShape.holes.push( tmpPath );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// Shapes first\n\t\ttmpShape = undefined;\n\n\t\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\tsolid = THREE.Shape.Utils.isClockWise( tmpPath.getPoints() );\n\t\t\tsolid = isCCW ? !solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( tmpShape ) shapes.push( tmpShape );\n\n\t\t\t\ttmpShape = new THREE.Shape();\n\t\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t} else {\n\n\t\t\t\ttmpShape.holes.push( tmpPath );\n\n\t\t\t}\n\n\t\t}\n\n\t\tshapes.push( tmpShape );\n\n\t}\n\n\t//console.log(\"shape\", shapes);\n\n\treturn shapes;\n\n};\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Defines a 2d shape plane using paths.\n **/\n\n// STEP 1 Create a path.\n// STEP 2 Turn path into shape.\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n// STEP 3a - Extract points from each shape, turn to vertices\n// STEP 3b - Triangulate each shape, add faces.\n\nTHREE.Shape = function () {\n\n\tTHREE.Path.apply( this, arguments );\n\tthis.holes = [];\n\n};\n\nTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\n\n// Convenience method to return ExtrudeGeometry\n\nTHREE.Shape.prototype.extrude = function ( options ) {\n\n\tvar extruded = new THREE.ExtrudeGeometry( this, options );\n\treturn extruded;\n\n};\n\n// Convenience method to return ShapeGeometry\n\nTHREE.Shape.prototype.makeGeometry = function ( options ) {\n\n\tvar geometry = new THREE.ShapeGeometry( this, options );\n\treturn geometry;\n\n};\n\n// Get points of holes\n\nTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\n\n\tvar i, il = this.holes.length, holesPts = [];\n\n\tfor ( i = 0; i < il; i ++ ) {\n\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );\n\n\t}\n\n\treturn holesPts;\n\n};\n\n// Get points of holes (spaced by regular distance)\n\nTHREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {\n\n\tvar i, il = this.holes.length, holesPts = [];\n\n\tfor ( i = 0; i < il; i ++ ) {\n\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );\n\n\t}\n\n\treturn holesPts;\n\n};\n\n\n// Get points of shape and holes (keypoints based on segments parameter)\n\nTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\n\n\treturn {\n\n\t\tshape: this.getTransformedPoints( divisions ),\n\t\tholes: this.getPointsHoles( divisions )\n\n\t};\n\n};\n\nTHREE.Shape.prototype.extractPoints = function ( divisions ) {\n\n\tif (this.useSpacedPoints) {\n\t\treturn this.extractAllSpacedPoints(divisions);\n\t}\n\n\treturn this.extractAllPoints(divisions);\n\n};\n\n//\n// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {\n//\n// \treturn {\n//\n// \t\tshape: this.transform( bend, divisions ),\n// \t\tholes: this.getPointsHoles( divisions, bend )\n//\n// \t};\n//\n// };\n\n// Get points of shape and holes (spaced by regular distance)\n\nTHREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {\n\n\treturn {\n\n\t\tshape: this.getTransformedSpacedPoints( divisions ),\n\t\tholes: this.getSpacedPointsHoles( divisions )\n\n\t};\n\n};\n\n/**************************************************************\n *\tUtils\n **************************************************************/\n\nTHREE.Shape.Utils = {\n\n\t/*\n\t\tcontour - array of vector2 for contour\n\t\tholes   - array of array of vector2\n\t*/\n\n\tremoveHoles: function ( contour, holes ) {\n\n\t\tvar shape = contour.concat(); // work on this shape\n\t\tvar allpoints = shape.concat();\n\n\t\t/* For each isolated shape, find the closest points and break to the hole to allow triangulation */\n\n\n\t\tvar prevShapeVert, nextShapeVert,\n\t\t\tprevHoleVert, nextHoleVert,\n\t\t\tholeIndex, shapeIndex,\n\t\t\tshapeId, shapeGroup,\n\t\t\th, h2,\n\t\t\thole, shortest, d,\n\t\t\tp, pts1, pts2,\n\t\t\ttmpShape1, tmpShape2,\n\t\t\ttmpHole1, tmpHole2,\n\t\t\tverts = [];\n\n\t\tfor ( h = 0; h < holes.length; h ++ ) {\n\n\t\t\thole = holes[ h ];\n\n\t\t\t/*\n\t\t\tshapeholes[ h ].concat(); // preserves original\n\t\t\tholes.push( hole );\n\t\t\t*/\n\n\t\t\tArray.prototype.push.apply( allpoints, hole );\n\n\t\t\tshortest = Number.POSITIVE_INFINITY;\n\n\n\t\t\t// Find the shortest pair of pts between shape and hole\n\n\t\t\t// Note: Actually, I'm not sure now if we could optimize this to be faster than O(m*n)\n\t\t\t// Using distanceToSquared() intead of distanceTo() should speed a little\n\t\t\t// since running square roots operations are reduced.\n\n\t\t\tfor ( h2 = 0; h2 < hole.length; h2 ++ ) {\n\n\t\t\t\tpts1 = hole[ h2 ];\n\t\t\t\tvar dist = [];\n\n\t\t\t\tfor ( p = 0; p < shape.length; p++ ) {\n\n\t\t\t\t\tpts2 = shape[ p ];\n\t\t\t\t\td = pts1.distanceToSquared( pts2 );\n\t\t\t\t\tdist.push( d );\n\n\t\t\t\t\tif ( d < shortest ) {\n\n\t\t\t\t\t\tshortest = d;\n\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\tshapeIndex = p;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//console.log(\"shortest\", shortest, dist);\n\n\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\n\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\n\n\t\t\tvar areaapts = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\tshape[ shapeIndex ],\n\t\t\t\tshape[ prevShapeVert ]\n\n\t\t\t];\n\n\t\t\tvar areaa = THREE.FontUtils.Triangulate.area( areaapts );\n\n\t\t\tvar areabpts = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\thole[ prevHoleVert ],\n\t\t\t\tshape[ shapeIndex ]\n\n\t\t\t];\n\n\t\t\tvar areab = THREE.FontUtils.Triangulate.area( areabpts );\n\n\t\t\tvar shapeOffset = 1;\n\t\t\tvar holeOffset = -1;\n\n\t\t\tvar oldShapeIndex = shapeIndex, oldHoleIndex = holeIndex;\n\t\t\tshapeIndex += shapeOffset;\n\t\t\tholeIndex += holeOffset;\n\n\t\t\tif ( shapeIndex < 0 ) { shapeIndex += shape.length;  }\n\t\t\tshapeIndex %= shape.length;\n\n\t\t\tif ( holeIndex < 0 ) { holeIndex += hole.length;  }\n\t\t\tholeIndex %= hole.length;\n\n\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\n\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\n\n\t\t\tareaapts = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\tshape[ shapeIndex ],\n\t\t\t\tshape[ prevShapeVert ]\n\n\t\t\t];\n\n\t\t\tvar areaa2 = THREE.FontUtils.Triangulate.area( areaapts );\n\n\t\t\tareabpts = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\thole[ prevHoleVert ],\n\t\t\t\tshape[ shapeIndex ]\n\n\t\t\t];\n\n\t\t\tvar areab2 = THREE.FontUtils.Triangulate.area( areabpts );\n\t\t\t//console.log(areaa,areab ,areaa2,areab2, ( areaa + areab ),  ( areaa2 + areab2 ));\n\n\t\t\tif ( ( areaa + areab ) > ( areaa2 + areab2 ) ) {\n\n\t\t\t\t// In case areas are not correct.\n\t\t\t\t//console.log(\"USE THIS\");\n\n\t\t\t\tshapeIndex = oldShapeIndex;\n\t\t\t\tholeIndex = oldHoleIndex ;\n\n\t\t\t\tif ( shapeIndex < 0 ) { shapeIndex += shape.length;  }\n\t\t\t\tshapeIndex %= shape.length;\n\n\t\t\t\tif ( holeIndex < 0 ) { holeIndex += hole.length;  }\n\t\t\t\tholeIndex %= hole.length;\n\n\t\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\n\t\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log(\"USE THAT \")\n\n\t\t\t}\n\n\t\t\ttmpShape1 = shape.slice( 0, shapeIndex );\n\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\ttmpHole2 = hole.slice( 0, holeIndex );\n\n\t\t\t// Should check orders here again?\n\n\t\t\tvar trianglea = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\tshape[ shapeIndex ],\n\t\t\t\tshape[ prevShapeVert ]\n\n\t\t\t];\n\n\t\t\tvar triangleb = [\n\n\t\t\t\thole[ holeIndex ] ,\n\t\t\t\thole[ prevHoleVert ],\n\t\t\t\tshape[ shapeIndex ]\n\n\t\t\t];\n\n\t\t\tverts.push( trianglea );\n\t\t\tverts.push( triangleb );\n\n\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tshape:shape, \t\t/* shape with no holes */\n\t\t\tisolatedPts: verts, /* isolated faces */\n\t\t\tallpoints: allpoints\n\n\t\t}\n\n\n\t},\n\n\ttriangulateShape: function ( contour, holes ) {\n\n\t\tvar shapeWithoutHoles = THREE.Shape.Utils.removeHoles( contour, holes );\n\n\t\tvar shape = shapeWithoutHoles.shape,\n\t\t\tallpoints = shapeWithoutHoles.allpoints,\n\t\t\tisolatedPts = shapeWithoutHoles.isolatedPts;\n\n\t\tvar triangles = THREE.FontUtils.Triangulate( shape, false ); // True returns indices for points of spooled shape\n\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n\t\t//console.log( \"triangles\",triangles, triangles.length );\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\n\t\tvar i, il, f, face,\n\t\t\tkey, index,\n\t\t\tallPointsMap = {},\n\t\t\tisolatedPointsMap = {};\n\n\t\t// prepare all points map\n\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\n\t\t\t\tconsole.log( \"Duplicate point\", key );\n\n\t\t\t}\n\n\t\t\tallPointsMap[ key ] = i;\n\n\t\t}\n\n\t\t// check all face vertices against all points map\n\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\n\t\t\tface = triangles[ i ];\n\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check isolated points vertices against all points map\n\n\t\tfor ( i = 0, il = isolatedPts.length; i < il; i ++ ) {\n\n\t\t\tface = isolatedPts[ i ];\n\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn triangles.concat( isolatedPts );\n\n\t}, // end triangulate shapes\n\n\t/*\n\ttriangulate2 : function( pts, holes ) {\n\n\t\t// For use with Poly2Tri.js\n\n\t\tvar allpts = pts.concat();\n\t\tvar shape = [];\n\t\tfor (var p in pts) {\n\t\t\tshape.push(new js.poly2tri.Point(pts[p].x, pts[p].y));\n\t\t}\n\n\t\tvar swctx = new js.poly2tri.SweepContext(shape);\n\n\t\tfor (var h in holes) {\n\t\t\tvar aHole = holes[h];\n\t\t\tvar newHole = []\n\t\t\tfor (i in aHole) {\n\t\t\t\tnewHole.push(new js.poly2tri.Point(aHole[i].x, aHole[i].y));\n\t\t\t\tallpts.push(aHole[i]);\n\t\t\t}\n\t\t\tswctx.AddHole(newHole);\n\t\t}\n\n\t\tvar find;\n\t\tvar findIndexForPt = function (pt) {\n\t\t\tfind = new THREE.Vector2(pt.x, pt.y);\n\t\t\tvar p;\n\t\t\tfor (p=0, pl = allpts.length; p<pl; p++) {\n\t\t\t\tif (allpts[p].equals(find)) return p;\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\n\t\t// triangulate\n\t\tjs.poly2tri.sweep.Triangulate(swctx);\n\n\t\tvar triangles =  swctx.GetTriangles();\n\t\tvar tr ;\n\t\tvar facesPts = [];\n\t\tfor (var t in triangles) {\n\t\t\ttr =  triangles[t];\n\t\t\tfacesPts.push([\n\t\t\t\tfindIndexForPt(tr.GetPoint(0)),\n\t\t\t\tfindIndexForPt(tr.GetPoint(1)),\n\t\t\t\tfindIndexForPt(tr.GetPoint(2))\n\t\t\t\t\t]);\n\t\t}\n\n\n\t//\tconsole.log(facesPts);\n\t//\tconsole.log(\"triangles\", triangles.length, triangles);\n\n\t\t// Returns array of faces with 3 element each\n\treturn facesPts;\n\t},\n*/\n\n\tisClockWise: function ( pts ) {\n\n\t\treturn THREE.FontUtils.Triangulate.area( pts ) < 0;\n\n\t},\n\n\t// Bezier Curves formulas obtained from\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n\t// Quad Bezier Functions\n\n\tb2p0: function ( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn k * k * p;\n\n\t},\n\n\tb2p1: function ( t, p ) {\n\n\t\treturn 2 * ( 1 - t ) * t * p;\n\n\t},\n\n\tb2p2: function ( t, p ) {\n\n\t\treturn t * t * p;\n\n\t},\n\n\tb2: function ( t, p0, p1, p2 ) {\n\n\t\treturn this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );\n\n\t},\n\n\t// Cubic Bezier Functions\n\n\tb3p0: function ( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn k * k * k * p;\n\n\t},\n\n\tb3p1: function ( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn 3 * k * k * t * p;\n\n\t},\n\n\tb3p2: function ( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn 3 * k * t * t * p;\n\n\t},\n\n\tb3p3: function ( t, p ) {\n\n\t\treturn t * t * t * p;\n\n\t},\n\n\tb3: function ( t, p0, p1, p2, p3 ) {\n\n\t\treturn this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );\n\n\t}\n\n};\n\n\n/**************************************************************\n *\tLine\n **************************************************************/\n\nTHREE.LineCurve = function ( v1, v2 ) {\n\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\n\n\tvar point = this.v2.clone().sub(this.v1);\n\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\treturn point;\n\n};\n\n// Line curve is linear, so we can overwrite default getPointAt\n\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\n\n\treturn this.getPoint( u );\n\n};\n\nTHREE.LineCurve.prototype.getTangent = function( t ) {\n\n\tvar tangent = this.v2.clone().sub(this.v1);\n\n\treturn tangent.normalize();\n\n};\n/**************************************************************\n *\tQuadratic Bezier curve\n **************************************************************/\n\n\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\n\n\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar tx, ty;\n\n\ttx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\n\tty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\n\n\treturn new THREE.Vector2( tx, ty );\n\n};\n\n\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tx, ty;\n\n\ttx = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );\n\tty = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );\n\n\t// returns unit vector\n\n\tvar tangent = new THREE.Vector2( tx, ty );\n\ttangent.normalize();\n\n\treturn tangent;\n\n};\n/**************************************************************\n *\tCubic Bezier curve\n **************************************************************/\n\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\tthis.v3 = v3;\n\n};\n\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar tx, ty;\n\n\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\n\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\n\n\treturn new THREE.Vector2( tx, ty );\n\n};\n\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tx, ty;\n\n\ttx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\n\tty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\n\n\tvar tangent = new THREE.Vector2( tx, ty );\n\ttangent.normalize();\n\n\treturn tangent;\n\n};\n/**************************************************************\n *\tSpline curve\n **************************************************************/\n\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\n\n\tthis.points = (points == undefined) ? [] : points;\n\n};\n\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\n\n\tvar v = new THREE.Vector2();\n\tvar c = [];\n\tvar points = this.points, point, intPoint, weight;\n\tpoint = ( points.length - 1 ) * t;\n\n\tintPoint = Math.floor( point );\n\tweight = point - intPoint;\n\n\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\n\tc[ 1 ] = intPoint;\n\tc[ 2 ] = intPoint  > points.length - 2 ? points.length -1 : intPoint + 1;\n\tc[ 3 ] = intPoint  > points.length - 3 ? points.length -1 : intPoint + 2;\n\n\tv.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );\n\tv.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );\n\n\treturn v;\n\n};\n/**************************************************************\n *\tEllipse curve\n **************************************************************/\n\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\tthis.aX = aX;\n\tthis.aY = aY;\n\n\tthis.xRadius = xRadius;\n\tthis.yRadius = yRadius;\n\n\tthis.aStartAngle = aStartAngle;\n\tthis.aEndAngle = aEndAngle;\n\n\tthis.aClockwise = aClockwise;\n\n};\n\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\n\n\tvar angle;\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\n\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\n\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\n\n\tif ( this.aClockwise === true ) {\n\n\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\n\n\t} else {\n\n\t\tangle = this.aStartAngle + t * deltaAngle;\n\n\t}\n\n\tvar tx = this.aX + this.xRadius * Math.cos( angle );\n\tvar ty = this.aY + this.yRadius * Math.sin( angle );\n\n\treturn new THREE.Vector2( tx, ty );\n\n};\n\n/**************************************************************\n *\tArc curve\n **************************************************************/\n\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n};\n\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\n/**************************************************************\n *\tLine3D\n **************************************************************/\n\nTHREE.LineCurve3 = THREE.Curve.create(\n\n\tfunction ( v1, v2 ) {\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar r = new THREE.Vector3();\n\n\n\t\tr.subVectors( this.v2, this.v1 ); // diff\n\t\tr.multiplyScalar( t );\n\t\tr.add( this.v1 );\n\n\t\treturn r;\n\n\t}\n\n);\n\n/**************************************************************\n *\tQuadratic Bezier 3D curve\n **************************************************************/\n\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar tx, ty, tz;\n\n\t\ttx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\n\t\tty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\n\t\ttz = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );\n\n\t\treturn new THREE.Vector3( tx, ty, tz );\n\n\t}\n\n);\n/**************************************************************\n *\tCubic Bezier 3D curve\n **************************************************************/\n\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2, v3 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar tx, ty, tz;\n\n\t\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\n\t\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\n\t\ttz = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );\n\n\t\treturn new THREE.Vector3( tx, ty, tz );\n\n\t}\n\n);\n/**************************************************************\n *\tSpline 3D curve\n **************************************************************/\n\n\nTHREE.SplineCurve3 = THREE.Curve.create(\n\n\tfunction ( points /* array of Vector3 */) {\n\n\t\tthis.points = (points == undefined) ? [] : points;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar v = new THREE.Vector3();\n\t\tvar c = [];\n\t\tvar points = this.points, point, intPoint, weight;\n\t\tpoint = ( points.length - 1 ) * t;\n\n\t\tintPoint = Math.floor( point );\n\t\tweight = point - intPoint;\n\n\t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\n\t\tc[ 1 ] = intPoint;\n\t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\n\t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\n\n\t\tvar pt0 = points[ c[0] ],\n\t\t\tpt1 = points[ c[1] ],\n\t\t\tpt2 = points[ c[2] ],\n\t\t\tpt3 = points[ c[3] ];\n\n\t\tv.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);\n\t\tv.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);\n\t\tv.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);\n\n\t\treturn v;\n\n\t}\n\n);\n\n\n// THREE.SplineCurve3.prototype.getTangent = function(t) {\n// \t\tvar v = new THREE.Vector3();\n// \t\tvar c = [];\n// \t\tvar points = this.points, point, intPoint, weight;\n// \t\tpoint = ( points.length - 1 ) * t;\n\n// \t\tintPoint = Math.floor( point );\n// \t\tweight = point - intPoint;\n\n// \t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\n// \t\tc[ 1 ] = intPoint;\n// \t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\n// \t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\n\n// \t\tvar pt0 = points[ c[0] ],\n// \t\t\tpt1 = points[ c[1] ],\n// \t\t\tpt2 = points[ c[2] ],\n// \t\t\tpt3 = points[ c[3] ];\n\n// \t// t = weight;\n// \tv.x = THREE.Curve.Utils.tangentSpline( t, pt0.x, pt1.x, pt2.x, pt3.x );\n// \tv.y = THREE.Curve.Utils.tangentSpline( t, pt0.y, pt1.y, pt2.y, pt3.y );\n// \tv.z = THREE.Curve.Utils.tangentSpline( t, pt0.z, pt1.z, pt2.z, pt3.z );\n\n// \treturn v;\n\n// }\n/**************************************************************\n *\tClosed Spline 3D curve\n **************************************************************/\n\n\nTHREE.ClosedSplineCurve3 = THREE.Curve.create(\n\n\tfunction ( points /* array of Vector3 */) {\n\n\t\tthis.points = (points == undefined) ? [] : points;\n\n\t},\n\n    function ( t ) {\n\n        var v = new THREE.Vector3();\n        var c = [];\n        var points = this.points, point, intPoint, weight;\n        point = ( points.length - 0 ) * t;\n            // This needs to be from 0-length +1\n\n        intPoint = Math.floor( point );\n        weight = point - intPoint;\n\n        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n        c[ 0 ] = ( intPoint - 1 ) % points.length;\n        c[ 1 ] = ( intPoint ) % points.length;\n        c[ 2 ] = ( intPoint + 1 ) % points.length;\n        c[ 3 ] = ( intPoint + 2 ) % points.length;\n\n        v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );\n        v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );\n        v.z = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].z, points[ c[ 1 ] ].z, points[ c[ 2 ] ].z, points[ c[ 3 ] ].z, weight );\n\n        return v;\n\n    }\n\n);\n/**\n * @author mikael emtinger / http://gomo.se/\n */\n\nTHREE.AnimationHandler = (function() {\n\n\tvar playing = [];\n\tvar library = {};\n\tvar that    = {};\n\n\n\t//--- update ---\n\n\tthat.update = function( deltaTimeMS ) {\n\n\t\tfor( var i = 0; i < playing.length; i ++ )\n\t\t\tplaying[ i ].update( deltaTimeMS );\n\n\t};\n\n\n\t//--- add ---\n\n\tthat.addToUpdate = function( animation ) {\n\n\t\tif ( playing.indexOf( animation ) === -1 )\n\t\t\tplaying.push( animation );\n\n\t};\n\n\n\t//--- remove ---\n\n\tthat.removeFromUpdate = function( animation ) {\n\n\t\tvar index = playing.indexOf( animation );\n\n\t\tif( index !== -1 )\n\t\t\tplaying.splice( index, 1 );\n\n\t};\n\n\n\t//--- add ---\n\n\tthat.add = function( data ) {\n\n\t\tif ( library[ data.name ] !== undefined )\n\t\t\tconsole.log( \"THREE.AnimationHandler.add: Warning! \" + data.name + \" already exists in library. Overwriting.\" );\n\n\t\tlibrary[ data.name ] = data;\n\t\tinitData( data );\n\n\t};\n\n\n\t//--- get ---\n\n\tthat.get = function( name ) {\n\n\t\tif ( typeof name === \"string\" ) {\n\n\t\t\tif ( library[ name ] ) {\n\n\t\t\t\treturn library[ name ];\n\n\t\t\t} else {\n\n\t\t\t\tconsole.log( \"THREE.AnimationHandler.get: Couldn't find animation \" + name );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// todo: add simple tween library\n\n\t\t}\n\n\t};\n\n\t//--- parse ---\n\n\tthat.parse = function( root ) {\n\n\t\t// setup hierarchy\n\n\t\tvar hierarchy = [];\n\n\t\tif ( root instanceof THREE.SkinnedMesh ) {\n\n\t\t\tfor( var b = 0; b < root.bones.length; b++ ) {\n\n\t\t\t\thierarchy.push( root.bones[ b ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tparseRecurseHierarchy( root, hierarchy );\n\n\t\t}\n\n\t\treturn hierarchy;\n\n\t};\n\n\tvar parseRecurseHierarchy = function( root, hierarchy ) {\n\n\t\thierarchy.push( root );\n\n\t\tfor( var c = 0; c < root.children.length; c++ )\n\t\t\tparseRecurseHierarchy( root.children[ c ], hierarchy );\n\n\t}\n\n\n\t//--- init data ---\n\n\tvar initData = function( data ) {\n\n\t\tif( data.initialized === true )\n\t\t\treturn;\n\n\n\t\t// loop through all keys\n\n\t\tfor( var h = 0; h < data.hierarchy.length; h ++ ) {\n\n\t\t\tfor( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\t// remove minus times\n\n\t\t\t\tif( data.hierarchy[ h ].keys[ k ].time < 0 )\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].time = 0;\n\n\n\t\t\t\t// create quaternions\n\n\t\t\t\tif( data.hierarchy[ h ].keys[ k ].rot !== undefined &&\n\t\t\t\t !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {\n\n\t\t\t\t\tvar quat = data.hierarchy[ h ].keys[ k ].rot;\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion( quat[0], quat[1], quat[2], quat[3] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// prepare morph target keys\n\n\t\t\tif( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {\n\n\t\t\t\t// get all used\n\n\t\t\t\tvar usedMorphTargets = {};\n\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\tvar morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];\n\t\t\t\t\t\tusedMorphTargets[ morphTargetName ] = -1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tdata.hierarchy[ h ].usedMorphTargets = usedMorphTargets;\n\n\n\t\t\t\t// set all used on all frames\n\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\t\tvar influences = {};\n\n\t\t\t\t\tfor ( var morphTargetName in usedMorphTargets ) {\n\n\t\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {\n\n\t\t\t\t\t\t\t\tinfluences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {\n\n\t\t\t\t\t\t\tinfluences[ morphTargetName ] = 0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// remove all keys that are on the same time\n\n\t\t\tfor ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {\n\n\t\t\t\t\tdata.hierarchy[ h ].keys.splice( k, 1 );\n\t\t\t\t\tk --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// set index\n\n\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\tdata.hierarchy[ h ].keys[ k ].index = k;\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// JIT\n\n\t\tvar lengthInFrames = parseInt( data.length * data.fps, 10 );\n\n\t\tdata.JIT = {};\n\t\tdata.JIT.hierarchy = [];\n\n\t\tfor( var h = 0; h < data.hierarchy.length; h ++ )\n\t\t\tdata.JIT.hierarchy.push( new Array( lengthInFrames ) );\n\n\n\t\t// done\n\n\t\tdata.initialized = true;\n\n\t};\n\n\n\t// interpolation types\n\n\tthat.LINEAR = 0;\n\tthat.CATMULLROM = 1;\n\tthat.CATMULLROM_FORWARD = 2;\n\n\treturn that;\n\n}());\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Animation = function ( root, name, interpolationType ) {\n\n\tthis.root = root;\n\tthis.data = THREE.AnimationHandler.get( name );\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\n\n\tthis.currentTime = 0;\n\tthis.timeScale = 1;\n\n\tthis.isPlaying = false;\n\tthis.isPaused = true;\n\tthis.loop = true;\n\n\tthis.interpolationType = interpolationType !== undefined ? interpolationType : THREE.AnimationHandler.LINEAR;\n\n\tthis.points = [];\n\tthis.target = new THREE.Vector3();\n\n};\n\nTHREE.Animation.prototype.play = function ( loop, startTimeMS ) {\n\n\tif ( this.isPlaying === false ) {\n\n\t\tthis.isPlaying = true;\n\t\tthis.loop = loop !== undefined ? loop : true;\n\t\tthis.currentTime = startTimeMS !== undefined ? startTimeMS : 0;\n\n\t\t// reset key cache\n\n\t\tvar h, hl = this.hierarchy.length,\n\t\t\tobject;\n\n\t\tfor ( h = 0; h < hl; h ++ ) {\n\n\t\t\tobject = this.hierarchy[ h ];\n\n\t\t\tobject.matrixAutoUpdate = true;\n\n\t\t\tif ( object.animationCache === undefined ) {\n\n\t\t\t\tobject.animationCache = {};\n\t\t\t\tobject.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 };\n\t\t\t\tobject.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 };\n\t\t\t\tobject.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\n\n\t\t\t}\n\n\t\t\tvar prevKey = object.animationCache.prevKey;\n\t\t\tvar nextKey = object.animationCache.nextKey;\n\n\t\t\tprevKey.pos = this.data.hierarchy[ h ].keys[ 0 ];\n\t\t\tprevKey.rot = this.data.hierarchy[ h ].keys[ 0 ];\n\t\t\tprevKey.scl = this.data.hierarchy[ h ].keys[ 0 ];\n\n\t\t\tnextKey.pos = this.getNextKeyWith( \"pos\", h, 1 );\n\t\t\tnextKey.rot = this.getNextKeyWith( \"rot\", h, 1 );\n\t\t\tnextKey.scl = this.getNextKeyWith( \"scl\", h, 1 );\n\n\t\t}\n\n\t\tthis.update( 0 );\n\n\t}\n\n\tthis.isPaused = false;\n\n\tTHREE.AnimationHandler.addToUpdate( this );\n\n};\n\n\nTHREE.Animation.prototype.pause = function() {\n\n\tif ( this.isPaused === true ) {\n\n\t\tTHREE.AnimationHandler.addToUpdate( this );\n\n\t} else {\n\n\t\tTHREE.AnimationHandler.removeFromUpdate( this );\n\n\t}\n\n\tthis.isPaused = !this.isPaused;\n\n};\n\n\nTHREE.Animation.prototype.stop = function() {\n\n\tthis.isPlaying = false;\n\tthis.isPaused  = false;\n\tTHREE.AnimationHandler.removeFromUpdate( this );\n\n};\n\n\nTHREE.Animation.prototype.update = function ( deltaTimeMS ) {\n\n\t// early out\n\n\tif ( this.isPlaying === false ) return;\n\n\n\t// vars\n\n\tvar types = [ \"pos\", \"rot\", \"scl\" ];\n\tvar type;\n\tvar scale;\n\tvar vector;\n\tvar prevXYZ, nextXYZ;\n\tvar prevKey, nextKey;\n\tvar object;\n\tvar animationCache;\n\tvar frame;\n\tvar JIThierarchy = this.data.JIT.hierarchy;\n\tvar currentTime, unloopedCurrentTime;\n\tvar currentPoint, forwardPoint, angle;\n\n\n\tthis.currentTime += deltaTimeMS * this.timeScale;\n\n\tunloopedCurrentTime = this.currentTime;\n\n\t// Mod operation fails on floats\n\t// was this supposed to be in frames?\n\twhile ( this.currentTime > this.data.length ) {\n\n\t\tthis.currentTime -= this.data.length;\n\n\t}\n\n\tcurrentTime = this.currentTime = this.currentTime % this.data.length;\n\n\t\n\tframe = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );\n\n\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\n\n\t\tobject = this.hierarchy[ h ];\n\t\tanimationCache = object.animationCache;\n\n\t\t// loop through pos/rot/scl\n\n\t\tfor ( var t = 0; t < 3; t ++ ) {\n\n\t\t\t// get keys\n\n\t\t\ttype    = types[ t ];\n\t\t\tprevKey = animationCache.prevKey[ type ];\n\t\t\tnextKey = animationCache.nextKey[ type ];\n\n\t\t\t// switch keys?\n\t\t\t\n\t\t\tif ( nextKey.time <= unloopedCurrentTime ) {\n\n\t\t\t\t// did we loop?\n\n\t\t\t\tif ( currentTime <= unloopedCurrentTime ) {\n\n\t\t\t\t\tif ( this.loop ) {\n\n\t\t\t\t\t\tprevKey = this.data.hierarchy[ h ].keys[ 0 ];\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, 1 );\n\n\t\t\t\t\t\t// if ( nextKey.index < prevKey.index ) then we have wrapped over the end, and nextKey.time < currentTime will loop forever\n\t\t\t\t\t\twhile ( nextKey !== null && nextKey.time < currentTime && nextKey.index > prevKey.index) {\n\n\t\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\n\n\t\t\t\t\t} while ( nextKey !== null && nextKey.time < currentTime && nextKey.index > prevKey.index )\n\t\t\t\t\t// if ( nextKey.index < prevKey.index ) then we have wrapped over the end, and nextKey.time < currentTime will loop forever\n\n\t\t\t\t}\n\n\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\n\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\n\n\t\t\t}\n\n\n\t\t\tobject.matrixAutoUpdate = true;\n\t\t\tobject.matrixWorldNeedsUpdate = true;\n\n\t\t\tscale = ( currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );\n\t\t\tprevXYZ = prevKey[ type ];\n\t\t\tnextXYZ = nextKey[ type ];\n\n\n\t\t\t// check scale error\n\n\t\t\tif ( scale < 0 || scale > 1 ) {\n\n\t\t\t\tconsole.log( \"THREE.Animation.update: Warning! Scale out of bounds:\" + scale + \" on bone \" + h );\n\t\t\t\tscale = scale < 0 ? 0 : 1;\n\n\t\t\t}\n\n\t\t\t// interpolate\n\n\t\t\tif ( type === \"pos\" ) {\n\n\t\t\t\tvector = object.position;\n\n\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {\n\n\t\t\t\t\tvector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\n\t\t\t\t\tvector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\n\t\t\t\t\tvector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\n\n\t\t\t\t} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\t\t\t\t\t\t    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\t\t\t\tthis.points[ 0 ] = this.getPrevKeyWith( \"pos\", h, prevKey.index - 1 )[ \"pos\" ];\n\t\t\t\t\tthis.points[ 1 ] = prevXYZ;\n\t\t\t\t\tthis.points[ 2 ] = nextXYZ;\n\t\t\t\t\tthis.points[ 3 ] = this.getNextKeyWith( \"pos\", h, nextKey.index + 1 )[ \"pos\" ];\n\n\t\t\t\t\tscale = scale * 0.33 + 0.33;\n\n\t\t\t\t\tcurrentPoint = this.interpolateCatmullRom( this.points, scale );\n\n\t\t\t\t\tvector.x = currentPoint[ 0 ];\n\t\t\t\t\tvector.y = currentPoint[ 1 ];\n\t\t\t\t\tvector.z = currentPoint[ 2 ];\n\n\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\t\t\t\t\tforwardPoint = this.interpolateCatmullRom( this.points, scale * 1.01 );\n\n\t\t\t\t\t\tthis.target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );\n\t\t\t\t\t\tthis.target.sub( vector );\n\t\t\t\t\t\tthis.target.y = 0;\n\t\t\t\t\t\tthis.target.normalize();\n\n\t\t\t\t\t\tangle = Math.atan2( this.target.x, this.target.z );\n\t\t\t\t\t\tobject.rotation.set( 0, angle, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( type === \"rot\" ) {\n\n\t\t\t\tTHREE.Quaternion.slerp( prevXYZ, nextXYZ, object.quaternion, scale );\n\n\t\t\t} else if ( type === \"scl\" ) {\n\n\t\t\t\tvector = object.scale;\n\n\t\t\t\tvector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\n\t\t\t\tvector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\n\t\t\t\tvector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n// Catmull-Rom spline\n\nTHREE.Animation.prototype.interpolateCatmullRom = function ( points, scale ) {\n\n\tvar c = [], v3 = [],\n\tpoint, intPoint, weight, w2, w3,\n\tpa, pb, pc, pd;\n\n\tpoint = ( points.length - 1 ) * scale;\n\tintPoint = Math.floor( point );\n\tweight = point - intPoint;\n\n\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\tc[ 1 ] = intPoint;\n\tc[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\n\tc[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\n\n\tpa = points[ c[ 0 ] ];\n\tpb = points[ c[ 1 ] ];\n\tpc = points[ c[ 2 ] ];\n\tpd = points[ c[ 3 ] ];\n\n\tw2 = weight * weight;\n\tw3 = weight * w2;\n\n\tv3[ 0 ] = this.interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );\n\tv3[ 1 ] = this.interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );\n\tv3[ 2 ] = this.interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );\n\n\treturn v3;\n\n};\n\nTHREE.Animation.prototype.interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {\n\n\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n};\n\n\n\n// Get next key with\n\nTHREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {\n\n\tvar keys = this.data.hierarchy[ h ].keys;\n\n\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\tkey = key < keys.length - 1 ? key : keys.length - 1;\n\n\t} else {\n\n\t\tkey = key % keys.length;\n\n\t}\n\n\tfor ( ; key < keys.length; key++ ) {\n\n\t\tif ( keys[ key ][ type ] !== undefined ) {\n\n\t\t\treturn keys[ key ];\n\n\t\t}\n\n\t}\n\n\treturn this.data.hierarchy[ h ].keys[ 0 ];\n\n};\n\n// Get previous key with\n\nTHREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {\n\n\tvar keys = this.data.hierarchy[ h ].keys;\n\n\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\tkey = key > 0 ? key : 0;\n\n\t} else {\n\n\t\tkey = key >= 0 ? key : key + keys.length;\n\n\t}\n\n\n\tfor ( ; key >= 0; key -- ) {\n\n\t\tif ( keys[ key ][ type ] !== undefined ) {\n\n\t\t\treturn keys[ key ];\n\n\t\t}\n\n\t}\n\n\treturn this.data.hierarchy[ h ].keys[ keys.length - 1 ];\n\n};\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author khang duong\n * @author erik kitson\n */\n\nTHREE.KeyFrameAnimation = function( root, data, JITCompile ) {\n\n\tthis.root = root;\n\tthis.data = THREE.AnimationHandler.get( data );\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\n\tthis.currentTime = 0;\n\tthis.timeScale = 0.001;\n\tthis.isPlaying = false;\n\tthis.isPaused = true;\n\tthis.loop = true;\n\tthis.JITCompile = JITCompile !== undefined ? JITCompile : true;\n\n\t// initialize to first keyframes\n\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\n\n\t\tvar keys = this.data.hierarchy[h].keys,\n\t\t\tsids = this.data.hierarchy[h].sids,\n\t\t\tobj = this.hierarchy[h];\n\n\t\tif ( keys.length && sids ) {\n\n\t\t\tfor ( var s = 0; s < sids.length; s++ ) {\n\n\t\t\t\tvar sid = sids[ s ],\n\t\t\t\t\tnext = this.getNextKeyWith( sid, h, 0 );\n\n\t\t\t\tif ( next ) {\n\n\t\t\t\t\tnext.apply( sid );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tobj.matrixAutoUpdate = false;\n\t\t\tthis.data.hierarchy[h].node.updateMatrix();\n\t\t\tobj.matrixWorldNeedsUpdate = true;\n\n\t\t}\n\n\t}\n\n};\n\n// Play\n\nTHREE.KeyFrameAnimation.prototype.play = function( loop, startTimeMS ) {\n\n\tif( !this.isPlaying ) {\n\n\t\tthis.isPlaying = true;\n\t\tthis.loop = loop !== undefined ? loop : true;\n\t\tthis.currentTime = startTimeMS !== undefined ? startTimeMS : 0;\n\t\tthis.startTimeMs = startTimeMS;\n\t\tthis.startTime = 10000000;\n\t\tthis.endTime = -this.startTime;\n\n\n\t\t// reset key cache\n\n\t\tvar h, hl = this.hierarchy.length,\n\t\t\tobject,\n\t\t\tnode;\n\n\t\tfor ( h = 0; h < hl; h++ ) {\n\n\t\t\tobject = this.hierarchy[ h ];\n\t\t\tnode = this.data.hierarchy[ h ];\n\n\t\t\tif ( node.animationCache === undefined ) {\n\n\t\t\t\tnode.animationCache = {};\n\t\t\t\tnode.animationCache.prevKey = null;\n\t\t\t\tnode.animationCache.nextKey = null;\n\t\t\t\tnode.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\n\n\t\t\t}\n\n\t\t\tvar keys = this.data.hierarchy[h].keys;\n\n\t\t\tif (keys.length) {\n\n\t\t\t\tnode.animationCache.prevKey = keys[ 0 ];\n\t\t\t\tnode.animationCache.nextKey = keys[ 1 ];\n\n\t\t\t\tthis.startTime = Math.min( keys[0].time, this.startTime );\n\t\t\t\tthis.endTime = Math.max( keys[keys.length - 1].time, this.endTime );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.update( 0 );\n\n\t}\n\n\tthis.isPaused = false;\n\n\tTHREE.AnimationHandler.addToUpdate( this );\n\n};\n\n\n\n// Pause\n\nTHREE.KeyFrameAnimation.prototype.pause = function() {\n\n\tif( this.isPaused ) {\n\n\t\tTHREE.AnimationHandler.addToUpdate( this );\n\n\t} else {\n\n\t\tTHREE.AnimationHandler.removeFromUpdate( this );\n\n\t}\n\n\tthis.isPaused = !this.isPaused;\n\n};\n\n\n// Stop\n\nTHREE.KeyFrameAnimation.prototype.stop = function() {\n\n\tthis.isPlaying = false;\n\tthis.isPaused  = false;\n\tTHREE.AnimationHandler.removeFromUpdate( this );\n\n\n\t// reset JIT matrix and remove cache\n\n\tfor ( var h = 0; h < this.data.hierarchy.length; h++ ) {\n        \n        var obj = this.hierarchy[ h ];\n\t\tvar node = this.data.hierarchy[ h ];\n\n\t\tif ( node.animationCache !== undefined ) {\n\n\t\t\tvar original = node.animationCache.originalMatrix;\n\n\t\t\tif( obj instanceof THREE.Bone ) {\n\n\t\t\t\toriginal.copy( obj.skinMatrix );\n\t\t\t\tobj.skinMatrix = original;\n\n\t\t\t} else {\n\n\t\t\t\toriginal.copy( obj.matrix );\n\t\t\t\tobj.matrix = original;\n\n\t\t\t}\n\n\t\t\tdelete node.animationCache;\n\n\t\t}\n\n\t}\n\n};\n\n\n// Update\n\nTHREE.KeyFrameAnimation.prototype.update = function( deltaTimeMS ) {\n\n\t// early out\n\n\tif( !this.isPlaying ) return;\n\n\n\t// vars\n\n\tvar prevKey, nextKey;\n\tvar object;\n\tvar node;\n\tvar frame;\n\tvar JIThierarchy = this.data.JIT.hierarchy;\n\tvar currentTime, unloopedCurrentTime;\n\tvar looped;\n\n\n\t// update\n\n\tthis.currentTime += deltaTimeMS * this.timeScale;\n\n\tunloopedCurrentTime = this.currentTime;\n\tcurrentTime         = this.currentTime = this.currentTime % this.data.length;\n\n\t// if looped around, the current time should be based on the startTime\n\tif ( currentTime < this.startTimeMs ) {\n\n\t\tcurrentTime = this.currentTime = this.startTimeMs + currentTime;\n\n\t}\n\n\tframe               = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );\n\tlooped \t\t\t\t= currentTime < unloopedCurrentTime;\n\n\tif ( looped && !this.loop ) {\n\n\t\t// Set the animation to the last keyframes and stop\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\n\n\t\t\tvar keys = this.data.hierarchy[h].keys,\n\t\t\t\tsids = this.data.hierarchy[h].sids,\n\t\t\t\tend = keys.length-1,\n\t\t\t\tobj = this.hierarchy[h];\n\n\t\t\tif ( keys.length ) {\n\n\t\t\t\tfor ( var s = 0; s < sids.length; s++ ) {\n\n\t\t\t\t\tvar sid = sids[ s ],\n\t\t\t\t\t\tprev = this.getPrevKeyWith( sid, h, end );\n\n\t\t\t\t\tif ( prev ) {\n\t\t\t\t\t\tprev.apply( sid );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.data.hierarchy[h].node.updateMatrix();\n\t\t\t\tobj.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.stop();\n\t\treturn;\n\n\t}\n\n\t// check pre-infinity\n\tif ( currentTime < this.startTime ) {\n\n\t\treturn;\n\n\t}\n\n\t// update\n\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\n\n\t\tobject = this.hierarchy[ h ];\n\t\tnode = this.data.hierarchy[ h ];\n\n\t\tvar keys = node.keys,\n\t\t\tanimationCache = node.animationCache;\n\n\t\t// use JIT?\n\n\t\tif ( this.JITCompile && JIThierarchy[ h ][ frame ] !== undefined ) {\n\n\t\t\tif( object instanceof THREE.Bone ) {\n\n\t\t\t\tobject.skinMatrix = JIThierarchy[ h ][ frame ];\n\t\t\t\tobject.matrixWorldNeedsUpdate = false;\n\n\t\t\t} else {\n\n\t\t\t\tobject.matrix = JIThierarchy[ h ][ frame ];\n\t\t\t\tobject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t// use interpolation\n\n\t\t} else if ( keys.length ) {\n\n\t\t\t// make sure so original matrix and not JIT matrix is set\n\n\t\t\tif ( this.JITCompile && animationCache ) {\n\n\t\t\t\tif( object instanceof THREE.Bone ) {\n\n\t\t\t\t\tobject.skinMatrix = animationCache.originalMatrix;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject.matrix = animationCache.originalMatrix;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tprevKey = animationCache.prevKey;\n\t\t\tnextKey = animationCache.nextKey;\n\n\t\t\tif ( prevKey && nextKey ) {\n\n\t\t\t\t// switch keys?\n\n\t\t\t\tif ( nextKey.time <= unloopedCurrentTime ) {\n\n\t\t\t\t\t// did we loop?\n\n\t\t\t\t\tif ( looped && this.loop ) {\n\n\t\t\t\t\t\tprevKey = keys[ 0 ];\n\t\t\t\t\t\tnextKey = keys[ 1 ];\n\n\t\t\t\t\t\twhile ( nextKey.time < currentTime ) {\n\n\t\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( !looped ) {\n\n\t\t\t\t\t\tvar lastIndex = keys.length - 1;\n\n\t\t\t\t\t\twhile ( nextKey.time < currentTime && nextKey.index !== lastIndex ) {\n\n\t\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationCache.prevKey = prevKey;\n\t\t\t\t\tanimationCache.nextKey = nextKey;\n\n\t\t\t\t}\n                if(nextKey.time >= currentTime)\n                    prevKey.interpolate( nextKey, currentTime );\n                else\n                    prevKey.interpolate( nextKey, nextKey.time);\n\n\t\t\t}\n\n\t\t\tthis.data.hierarchy[h].node.updateMatrix();\n\t\t\tobject.matrixWorldNeedsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t// update JIT?\n\n\tif ( this.JITCompile ) {\n\n\t\tif ( JIThierarchy[ 0 ][ frame ] === undefined ) {\n\n\t\t\tthis.hierarchy[ 0 ].updateMatrixWorld( true );\n\n\t\t\tfor ( var h = 0; h < this.hierarchy.length; h++ ) {\n\n\t\t\t\tif( this.hierarchy[ h ] instanceof THREE.Bone ) {\n\n\t\t\t\t\tJIThierarchy[ h ][ frame ] = this.hierarchy[ h ].skinMatrix.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tJIThierarchy[ h ][ frame ] = this.hierarchy[ h ].matrix.clone();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n// Get next key with\n\nTHREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {\n\n\tvar keys = this.data.hierarchy[ h ].keys;\n\tkey = key % keys.length;\n\n\tfor ( ; key < keys.length; key++ ) {\n\n\t\tif ( keys[ key ].hasTarget( sid ) ) {\n\n\t\t\treturn keys[ key ];\n\n\t\t}\n\n\t}\n\n\treturn keys[ 0 ];\n\n};\n\n// Get previous key with\n\nTHREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {\n\n\tvar keys = this.data.hierarchy[ h ].keys;\n\tkey = key >= 0 ? key : key + keys.length;\n\n\tfor ( ; key >= 0; key-- ) {\n\n\t\tif ( keys[ key ].hasTarget( sid ) ) {\n\n\t\t\treturn keys[ key ];\n\n\t\t}\n\n\t}\n\n\treturn keys[ keys.length - 1 ];\n\n};\n\n/**\n * Camera for rendering cube maps\n *\t- renders scene into axis-aligned cube\n *\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\n\n\tTHREE.Object3D.call( this );\n\n\tvar fov = 90, aspect = 1;\n\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPX.up.set( 0, -1, 0 );\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\n\tthis.add( cameraPX );\n\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNX.up.set( 0, -1, 0 );\n\tcameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );\n\tthis.add( cameraNX );\n\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPY.up.set( 0, 0, 1 );\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\n\tthis.add( cameraPY );\n\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNY.up.set( 0, 0, -1 );\n\tcameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );\n\tthis.add( cameraNY );\n\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPZ.up.set( 0, -1, 0 );\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\n\tthis.add( cameraPZ );\n\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNZ.up.set( 0, -1, 0 );\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );\n\tthis.add( cameraNZ );\n\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );\n\n\tthis.updateCubeMap = function ( renderer, scene ) {\n\n\t\tvar renderTarget = this.renderTarget;\n\t\tvar generateMipmaps = renderTarget.generateMipmaps;\n\n\t\trenderTarget.generateMipmaps = false;\n\n\t\trenderTarget.activeCubeFace = 0;\n\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 1;\n\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 2;\n\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 3;\n\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 4;\n\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\trenderTarget.generateMipmaps = generateMipmaps;\n\n\t\trenderTarget.activeCubeFace = 5;\n\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t};\n\n};\n\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\n\n/**\n *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n *\n *\tA general perpose camera, for setting FOV, Lens Focal Length,\n *\t\tand switching between perspective and orthographic views easily.\n *\t\tUse this only if you do not wish to manage\n *\t\tboth a Orthographic and Perspective Camera\n *\n */\n\n\nTHREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.fov = fov;\n\n\tthis.left = -width / 2;\n\tthis.right = width / 2\n\tthis.top = height / 2;\n\tthis.bottom = -height / 2;\n\n\t// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects\n\n\tthis.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, \torthoNear, orthoFar );\n\tthis.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );\n\n\tthis.zoom = 1;\n\n\tthis.toPerspective();\n\n\tvar aspect = width/height;\n\n};\n\nTHREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );\n\nTHREE.CombinedCamera.prototype.toPerspective = function () {\n\n\t// Switches to the Perspective Camera\n\n\tthis.near = this.cameraP.near;\n\tthis.far = this.cameraP.far;\n\n\tthis.cameraP.fov =  this.fov / this.zoom ;\n\n\tthis.cameraP.updateProjectionMatrix();\n\n\tthis.projectionMatrix = this.cameraP.projectionMatrix;\n\n\tthis.inPerspectiveMode = true;\n\tthis.inOrthographicMode = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toOrthographic = function () {\n\n\t// Switches to the Orthographic camera estimating viewport from Perspective\n\n\tvar fov = this.fov;\n\tvar aspect = this.cameraP.aspect;\n\tvar near = this.cameraP.near;\n\tvar far = this.cameraP.far;\n\n\t// The size that we set is the mid plane of the viewing frustum\n\n\tvar hyperfocus = ( near + far ) / 2;\n\n\tvar halfHeight = Math.tan( fov / 2 ) * hyperfocus;\n\tvar planeHeight = 2 * halfHeight;\n\tvar planeWidth = planeHeight * aspect;\n\tvar halfWidth = planeWidth / 2;\n\n\thalfHeight /= this.zoom;\n\thalfWidth /= this.zoom;\n\n\tthis.cameraO.left = -halfWidth;\n\tthis.cameraO.right = halfWidth;\n\tthis.cameraO.top = halfHeight;\n\tthis.cameraO.bottom = -halfHeight;\n\n\t// this.cameraO.left = -farHalfWidth;\n\t// this.cameraO.right = farHalfWidth;\n\t// this.cameraO.top = farHalfHeight;\n\t// this.cameraO.bottom = -farHalfHeight;\n\n\t// this.cameraO.left = this.left / this.zoom;\n\t// this.cameraO.right = this.right / this.zoom;\n\t// this.cameraO.top = this.top / this.zoom;\n\t// this.cameraO.bottom = this.bottom / this.zoom;\n\n\tthis.cameraO.updateProjectionMatrix();\n\n\tthis.near = this.cameraO.near;\n\tthis.far = this.cameraO.far;\n\tthis.projectionMatrix = this.cameraO.projectionMatrix;\n\n\tthis.inPerspectiveMode = false;\n\tthis.inOrthographicMode = true;\n\n};\n\n\nTHREE.CombinedCamera.prototype.setSize = function( width, height ) {\n\n\tthis.cameraP.aspect = width / height;\n\tthis.left = -width / 2;\n\tthis.right = width / 2\n\tthis.top = height / 2;\n\tthis.bottom = -height / 2;\n\n};\n\n\nTHREE.CombinedCamera.prototype.setFov = function( fov ) {\n\n\tthis.fov = fov;\n\n\tif ( this.inPerspectiveMode ) {\n\n\t\tthis.toPerspective();\n\n\t} else {\n\n\t\tthis.toOrthographic();\n\n\t}\n\n};\n\n// For mantaining similar API with PerspectiveCamera\n\nTHREE.CombinedCamera.prototype.updateProjectionMatrix = function() {\n\n\tif ( this.inPerspectiveMode ) {\n\n\t\tthis.toPerspective();\n\n\t} else {\n\n\t\tthis.toPerspective();\n\t\tthis.toOrthographic();\n\n\t}\n\n};\n\n/*\n* Uses Focal Length (in mm) to estimate and set FOV\n* 35mm (fullframe) camera is used if frame size is not specified;\n* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\n*/\nTHREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {\n\n\tif ( frameHeight === undefined ) frameHeight = 24;\n\n\tvar fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\n\n\tthis.setFov( fov );\n\n\treturn fov;\n};\n\n\nTHREE.CombinedCamera.prototype.setZoom = function( zoom ) {\n\n\tthis.zoom = zoom;\n\n\tif ( this.inPerspectiveMode ) {\n\n\t\tthis.toPerspective();\n\n\t} else {\n\n\t\tthis.toOrthographic();\n\n\t}\n\n};\n\nTHREE.CombinedCamera.prototype.toFrontView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = 0;\n\tthis.rotation.z = 0;\n\n\t// should we be modifing the matrix instead?\n\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toBackView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = Math.PI;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toLeftView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = - Math.PI / 2;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toRightView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = Math.PI / 2;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toTopView = function() {\n\n\tthis.rotation.x = - Math.PI / 2;\n\tthis.rotation.y = 0;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toBottomView = function() {\n\n\tthis.rotation.x = Math.PI / 2;\n\tthis.rotation.y = 0;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\n/**\n * @author hughes\n */\n\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.radius = radius = radius || 50;\n\tthis.segments = segments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\tthis.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthis.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tvar i, uvs = [],\n\tcenter = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );\n\n\tthis.vertices.push(center);\n\tuvs.push( centerUV );\n\n\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\tvar vertex = new THREE.Vector3();\n\t\tvar segment = thetaStart + i / segments * thetaLength;\n\n\t\tvertex.x = radius * Math.cos( segment );\n\t\tvertex.y = radius * Math.sin( segment );\n\n\t\tthis.vertices.push( vertex );\n\t\tuvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );\n\n\t}\n\n\tvar n = new THREE.Vector3( 0, 0, 1 );\n\n\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\tvar v1 = i;\n\t\tvar v2 = i + 1 ;\n\t\tvar v3 = 0;\n\n\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\n\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n */\n\nTHREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar scope = this;\n\n\tthis.width = width;\n\tthis.height = height;\n\tthis.depth = depth;\n\n\tthis.widthSegments = widthSegments || 1;\n\tthis.heightSegments = heightSegments || 1;\n\tthis.depthSegments = depthSegments || 1;\n\n\tvar width_half = this.width / 2;\n\tvar height_half = this.height / 2;\n\tvar depth_half = this.depth / 2;\n\n\tbuildPlane( 'z', 'y', - 1, - 1, this.depth, this.height, width_half, 0 ); // px\n\tbuildPlane( 'z', 'y',   1, - 1, this.depth, this.height, - width_half, 1 ); // nx\n\tbuildPlane( 'x', 'z',   1,   1, this.width, this.depth, height_half, 2 ); // py\n\tbuildPlane( 'x', 'z',   1, - 1, this.width, this.depth, - height_half, 3 ); // ny\n\tbuildPlane( 'x', 'y',   1, - 1, this.width, this.height, depth_half, 4 ); // pz\n\tbuildPlane( 'x', 'y', - 1, - 1, this.width, this.height, - depth_half, 5 ); // nz\n\n\tfunction buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {\n\n\t\tvar w, ix, iy,\n\t\tgridX = scope.widthSegments,\n\t\tgridY = scope.heightSegments,\n\t\twidth_half = width / 2,\n\t\theight_half = height / 2,\n\t\toffset = scope.vertices.length;\n\n\t\tif ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {\n\n\t\t\tw = 'z';\n\n\t\t} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {\n\n\t\t\tw = 'y';\n\t\t\tgridY = scope.depthSegments;\n\n\t\t} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {\n\n\t\t\tw = 'x';\n\t\t\tgridX = scope.depthSegments;\n\n\t\t}\n\n\t\tvar gridX1 = gridX + 1,\n\t\tgridY1 = gridY + 1,\n\t\tsegment_width = width / gridX,\n\t\tsegment_height = height / gridY,\n\t\tnormal = new THREE.Vector3();\n\n\t\tnormal[ w ] = depth > 0 ? 1 : - 1;\n\n\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar vector = new THREE.Vector3();\n\t\t\t\tvector[ u ] = ( ix * segment_width - width_half ) * udir;\n\t\t\t\tvector[ v ] = ( iy * segment_height - height_half ) * vdir;\n\t\t\t\tvector[ w ] = depth;\n\n\t\t\t\tscope.vertices.push( vector );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( iy = 0; iy < gridY; iy++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX; ix++ ) {\n\n\t\t\t\tvar a = ix + gridX1 * iy;\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tvar uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );\n\t\t\t\tvar uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );\n\t\t\t\tvar uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );\n\t\t\t\tvar uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );\n\n\t\t\t\tvar face = new THREE.Face3( a + offset, b + offset, d + offset );\n\t\t\t\tface.normal.copy( normal );\n\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\n\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\tscope.faces.push( face );\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\n\t\t\t\tface = new THREE.Face3( b + offset, c + offset, d + offset );\n\t\t\t\tface.normal.copy( normal );\n\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\n\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\tscope.faces.push( face );\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.mergeVertices();\n\n};\n\nTHREE.CubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.radiusTop = radiusTop = radiusTop !== undefined ? radiusTop : 20;\n\tthis.radiusBottom = radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\tthis.height = height = height !== undefined ? height : 100;\n\n\tthis.radialSegments = radialSegments = radialSegments || 8;\n\tthis.heightSegments = heightSegments = heightSegments || 1;\n\n\tthis.openEnded = openEnded = openEnded !== undefined ? openEnded : false;\n\n\tvar heightHalf = height / 2;\n\n\tvar x, y, vertices = [], uvs = [];\n\n\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\tvar verticesRow = [];\n\t\tvar uvsRow = [];\n\n\t\tvar v = y / heightSegments;\n\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\tvar u = x / radialSegments;\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvertex.x = radius * Math.sin( u * Math.PI * 2 );\n\t\t\tvertex.y = - v * height + heightHalf;\n\t\t\tvertex.z = radius * Math.cos( u * Math.PI * 2 );\n\n\t\t\tthis.vertices.push( vertex );\n\n\t\t\tverticesRow.push( this.vertices.length - 1 );\n\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\n\n\t\t}\n\n\t\tvertices.push( verticesRow );\n\t\tuvs.push( uvsRow );\n\n\t}\n\n\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\n\tvar na, nb;\n\n\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\tif ( radiusTop !== 0 ) {\n\n\t\t\tna = this.vertices[ vertices[ 0 ][ x ] ].clone();\n\t\t\tnb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();\n\n\t\t} else {\n\n\t\t\tna = this.vertices[ vertices[ 1 ][ x ] ].clone();\n\t\t\tnb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();\n\n\t\t}\n\n\t\tna.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();\n\t\tnb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();\n\n\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x ];\n\t\t\tvar v2 = vertices[ y + 1 ][ x ];\n\t\t\tvar v3 = vertices[ y + 1 ][ x + 1 ];\n\t\t\tvar v4 = vertices[ y ][ x + 1 ];\n\n\t\t\tvar n1 = na.clone();\n\t\t\tvar n2 = na.clone();\n\t\t\tvar n3 = nb.clone();\n\t\t\tvar n4 = nb.clone();\n\n\t\t\tvar uv1 = uvs[ y ][ x ].clone();\n\t\t\tvar uv2 = uvs[ y + 1 ][ x ].clone();\n\t\t\tvar uv3 = uvs[ y + 1 ][ x + 1 ].clone();\n\t\t\tvar uv4 = uvs[ y ][ x + 1 ].clone();\n\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\n\n\t\t\tthis.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\n\n\t\t}\n\n\t}\n\n\t// top cap\n\n\tif ( openEnded === false && radiusTop > 0 ) {\n\n\t\tthis.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tvar v1 = vertices[ 0 ][ x ];\n\t\t\tvar v2 = vertices[ 0 ][ x + 1 ];\n\t\t\tvar v3 = this.vertices.length - 1;\n\n\t\t\tvar n1 = new THREE.Vector3( 0, 1, 0 );\n\t\t\tvar n2 = new THREE.Vector3( 0, 1, 0 );\n\t\t\tvar n3 = new THREE.Vector3( 0, 1, 0 );\n\n\t\t\tvar uv1 = uvs[ 0 ][ x ].clone();\n\t\t\tvar uv2 = uvs[ 0 ][ x + 1 ].clone();\n\t\t\tvar uv3 = new THREE.Vector2( uv2.x, 0 );\n\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\n\n\t\t}\n\n\t}\n\n\t// bottom cap\n\n\tif ( openEnded === false && radiusBottom > 0 ) {\n\n\t\tthis.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\tvar v3 = this.vertices.length - 1;\n\n\t\t\tvar n1 = new THREE.Vector3( 0, - 1, 0 );\n\t\t\tvar n2 = new THREE.Vector3( 0, - 1, 0 );\n\t\t\tvar n3 = new THREE.Vector3( 0, - 1, 0 );\n\n\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\n\t\t\tvar uv2 = uvs[ y ][ x ].clone();\n\t\t\tvar uv3 = new THREE.Vector2( uv2.x, 1 );\n\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n}\n\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too\n *  amount: <int>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline is bevel\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\n *\n *  material: <int> // material index for front and back faces\n *  extrudeMaterial: <int> // material index for extrusion and beveled faces\n *  uvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\n\n\tif ( typeof( shapes ) === \"undefined\" ) {\n\t\tshapes = [];\n\t\treturn;\n\t}\n\n\tTHREE.Geometry.call( this );\n\n\tshapes = shapes instanceof Array ? shapes : [ shapes ];\n\n\tthis.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n\t// can't really use automatic vertex normals\n\t// as then front and back sides get smoothed too\n\t// should do separate smoothing just for sides\n\n\t//this.computeVertexNormals();\n\n\t//console.log( \"took\", ( Date.now() - startTime ) );\n\n};\n\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\tvar sl = shapes.length;\n\n\tfor ( var s = 0; s < sl; s ++ ) {\n\t\tvar shape = shapes[ s ];\n\t\tthis.addShape( shape, options );\n\t}\n};\n\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tvar amount = options.amount !== undefined ? options.amount : 100;\n\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar steps = options.steps !== undefined ? options.steps : 1;\n\n\tvar extrudePath = options.extrudePath;\n\tvar extrudePts, extrudeByPath = false;\n\n\tvar material = options.material;\n\tvar extrudeMaterial = options.extrudeMaterial;\n\n\t// Use default WorldUVGenerator if no UV generators are specified.\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\n\n\tvar shapebb = this.shapebb;\n\t//shapebb = shape.getBoundingBox();\n\n\n\n\tvar splineTube, binormal, normal, position2;\n\tif ( extrudePath ) {\n\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\textrudeByPath = true;\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t// SETUP TNB variables\n\n\t\t// Reuse TNB from TubeGeomtry for now.\n\t\t// TODO1 - have a .isClosed in spline?\n\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);\n\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\tbinormal = new THREE.Vector3();\n\t\tnormal = new THREE.Vector3();\n\t\tposition2 = new THREE.Vector3();\n\n\t}\n\n\t// Safeguards if bevels are not enabled\n\n\tif ( ! bevelEnabled ) {\n\n\t\tbevelSegments = 0;\n\t\tbevelThickness = 0;\n\t\tbevelSize = 0;\n\n\t}\n\n\t// Variables initalization\n\n\tvar ahole, h, hl; // looping of holes\n\tvar scope = this;\n\tvar bevelPoints = [];\n\n\tvar shapesOffset = this.vertices.length;\n\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = !THREE.Shape.Utils.isClockWise( vertices ) ;\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tif ( THREE.Shape.Utils.isClockWise( ahole ) ) {\n\n\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n\t}\n\n\n\tvar faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );\n\n\t/* Vertices */\n\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\tfor ( h = 0, hl = holes.length;  h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\tvertices = vertices.concat( ahole );\n\n\t}\n\n\n\tfunction scalePt2 ( pt, vec, size ) {\n\n\t\tif ( !vec ) console.log( \"die\" );\n\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t}\n\n\tvar b, bs, t, z,\n\t\tvert, vlen = vertices.length,\n\t\tface, flen = faces.length,\n\t\tcont, clen = contour.length;\n\n\n\t// Find directions for point movement\n\n\tvar RAD_TO_DEGREES = 180 / Math.PI;\n\n\n\tfunction getBevelVec( pt_i, pt_j, pt_k ) {\n\n\t\t// Algorithm 2\n\n\t\treturn getBevelVec2( pt_i, pt_j, pt_k );\n\n\t}\n\n\tfunction getBevelVec1( pt_i, pt_j, pt_k ) {\n\n\t\tvar anglea = Math.atan2( pt_j.y - pt_i.y, pt_j.x - pt_i.x );\n\t\tvar angleb = Math.atan2( pt_k.y - pt_i.y, pt_k.x - pt_i.x );\n\n\t\tif ( anglea > angleb ) {\n\n\t\t\tangleb += Math.PI * 2;\n\n\t\t}\n\n\t\tvar anglec = ( anglea + angleb ) / 2;\n\n\n\t\t//console.log('angle1', anglea * RAD_TO_DEGREES,'angle2', angleb * RAD_TO_DEGREES, 'anglec', anglec *RAD_TO_DEGREES);\n\n\t\tvar x = - Math.cos( anglec );\n\t\tvar y = - Math.sin( anglec );\n\n\t\tvar vec = new THREE.Vector2( x, y ); //.normalize();\n\n\t\treturn vec;\n\n\t}\n\n\tfunction getBevelVec2( pt_i, pt_j, pt_k ) {\n\n\t\tvar a = THREE.ExtrudeGeometry.__v1,\n\t\t\tb = THREE.ExtrudeGeometry.__v2,\n\t\t\tv_hat = THREE.ExtrudeGeometry.__v3,\n\t\t\tw_hat = THREE.ExtrudeGeometry.__v4,\n\t\t\tp = THREE.ExtrudeGeometry.__v5,\n\t\t\tq = THREE.ExtrudeGeometry.__v6,\n\t\t\tv, w,\n\t\t\tv_dot_w_hat, q_sub_p_dot_w_hat,\n\t\t\ts, intersection;\n\n\t\t// good reading for line-line intersection\n\t\t// http://sputsoft.com/blog/2010/03/line-line-intersection.html\n\n\t\t// define a as vector j->i\n\t\t// define b as vectot k->i\n\n\t\ta.set( pt_i.x - pt_j.x, pt_i.y - pt_j.y );\n\t\tb.set( pt_i.x - pt_k.x, pt_i.y - pt_k.y );\n\n\t\t// get unit vectors\n\n\t\tv = a.normalize();\n\t\tw = b.normalize();\n\n\t\t// normals from pt i\n\n\t\tv_hat.set( -v.y, v.x );\n\t\tw_hat.set( w.y, -w.x );\n\n\t\t// pts from i\n\n\t\tp.copy( pt_i ).add( v_hat );\n\t\tq.copy( pt_i ).add( w_hat );\n\n\t\tif ( p.equals( q ) ) {\n\n\t\t\t//console.log(\"Warning: lines are straight\");\n\t\t\treturn w_hat.clone();\n\n\t\t}\n\n\t\t// Points from j, k. helps prevents points cross overover most of the time\n\n\t\tp.copy( pt_j ).add( v_hat );\n\t\tq.copy( pt_k ).add( w_hat );\n\n\t\tv_dot_w_hat = v.dot( w_hat );\n\t\tq_sub_p_dot_w_hat = q.sub( p ).dot( w_hat );\n\n\t\t// We should not reach these conditions\n\n\t\tif ( v_dot_w_hat === 0 ) {\n\n\t\t\tconsole.log( \"Either infinite or no solutions!\" );\n\n\t\t\tif ( q_sub_p_dot_w_hat === 0 ) {\n\n\t\t\t\tconsole.log( \"Its finite solutions.\" );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.log( \"Too bad, no solutions.\" );\n\n\t\t\t}\n\n\t\t}\n\n\t\ts = q_sub_p_dot_w_hat / v_dot_w_hat;\n\n\t\tif ( s < 0 ) {\n\n\t\t\t// in case of emergecy, revert to algorithm 1.\n\n\t\t\treturn getBevelVec1( pt_i, pt_j, pt_k );\n\n\t\t}\n\n\t\tintersection = v.multiplyScalar( s ).add( p );\n\n\t\treturn intersection.sub( pt_i ).clone(); // Don't normalize!, otherwise sharp corners become ugly\n\n\t}\n\n\tvar contourMovements = [];\n\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\tif ( j === il ) j = 0;\n\t\tif ( k === il ) k = 0;\n\n\t\t//  (j)---(i)---(k)\n\t\t// console.log('i,j,k', i, j , k)\n\n\t\tvar pt_i = contour[ i ];\n\t\tvar pt_j = contour[ j ];\n\t\tvar pt_k = contour[ k ];\n\n\t\tcontourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t}\n\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\toneHoleMovements = [];\n\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\toneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t}\n\n\t\tholesMovements.push( oneHoleMovements );\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t}\n\n\n\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\n\t\t//z = bevelThickness * t;\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved\n\t\t//bs = bevelSize * t ; // linear\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t//vert = scalePt( contour[ i ], contourCentroid, bs, false );\n\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\t\t\t\t//vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );\n\n\t\t\t\tv( vert.x, vert.y,  -z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tbs = bevelSize;\n\n\t// Back facing vertices\n\n\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\tif ( !extrudeByPath ) {\n\n\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t} else {\n\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\tnormal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);\n\t\t\tbinormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);\n\n\t\t\tposition2.copy( extrudePts[0] ).add(normal).add(binormal);\n\n\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t}\n\n\t}\n\n\t// Add stepped vertices...\n\t// Including front facing vertices\n\n\tvar s;\n\n\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( !extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[s] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Add bevel segments planes\n\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\n\t\tbs = bevelSize * Math.sin ( t * Math.PI/2 ) ;\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\tif ( !extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Faces */\n\n\t// Top and bottom faces\n\n\tbuildLidFaces();\n\n\t// Sides faces\n\n\tbuildSideFaces();\n\n\n\t/////  Internal functions\n\n\tfunction buildLidFaces() {\n\n\t\tif ( bevelEnabled ) {\n\n\t\t\tvar layer = 0 ; // steps + 1\n\t\t\tvar offset = vlen * layer;\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset, true );\n\n\t\t\t}\n\n\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\toffset = vlen * layer;\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset, false );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ], true );\n\n\t\t\t}\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps, false );\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// Create faces for the z-sides of the shape\n\n\tfunction buildSideFaces() {\n\n\t\tvar layeroffset = 0;\n\t\tsidewalls( contour, layeroffset );\n\t\tlayeroffset += contour.length;\n\n\t\tfor ( h = 0, hl = holes.length;  h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t//, true\n\t\t\tlayeroffset += ahole.length;\n\n\t\t}\n\n\t}\n\n\tfunction sidewalls( contour, layeroffset ) {\n\n\t\tvar j, k;\n\t\ti = contour.length;\n\n\t\twhile ( --i >= 0 ) {\n\n\t\t\tj = i;\n\t\t\tk = i - 1;\n\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\tfunction v( x, y, z ) {\n\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\n\n\t}\n\n\tfunction f3( a, b, c, isBottom ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\n\t\t// normal, color, material\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\n\t\tvar uvs = isBottom ? uvgen.generateBottomUV( scope, shape, options, a, b, c ) : uvgen.generateTopUV( scope, shape, options, a, b, c );\n\n \t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t}\n\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\t\td += shapesOffset;\n\n \t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );\n \t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );\n\n \t\tvar uvs = uvgen.generateSideWallUV( scope, shape, wallContour, options, a, b, c, d,\n \t\t                                    stepIndex, stepsLength, contourIndex1, contourIndex2 );\n\n \t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n \t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\n\t}\n\n};\n\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\n\n\tgenerateTopUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {\n\t\tvar ax = geometry.vertices[ indexA ].x,\n\t\t\tay = geometry.vertices[ indexA ].y,\n\n\t\t\tbx = geometry.vertices[ indexB ].x,\n\t\t\tby = geometry.vertices[ indexB ].y,\n\n\t\t\tcx = geometry.vertices[ indexC ].x,\n\t\t\tcy = geometry.vertices[ indexC ].y;\n\n\t\treturn [\n\t\t\tnew THREE.Vector2( ax, ay ),\n\t\t\tnew THREE.Vector2( bx, by ),\n\t\t\tnew THREE.Vector2( cx, cy )\n\t\t];\n\n\t},\n\n\tgenerateBottomUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {\n\n\t\treturn this.generateTopUV( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC );\n\n\t},\n\n\tgenerateSideWallUV: function( geometry, extrudedShape, wallContour, extrudeOptions,\n\t                              indexA, indexB, indexC, indexD, stepIndex, stepsLength,\n\t                              contourIndex1, contourIndex2 ) {\n\n\t\tvar ax = geometry.vertices[ indexA ].x,\n\t\t\tay = geometry.vertices[ indexA ].y,\n\t\t\taz = geometry.vertices[ indexA ].z,\n\n\t\t\tbx = geometry.vertices[ indexB ].x,\n\t\t\tby = geometry.vertices[ indexB ].y,\n\t\t\tbz = geometry.vertices[ indexB ].z,\n\n\t\t\tcx = geometry.vertices[ indexC ].x,\n\t\t\tcy = geometry.vertices[ indexC ].y,\n\t\t\tcz = geometry.vertices[ indexC ].z,\n\n\t\t\tdx = geometry.vertices[ indexD ].x,\n\t\t\tdy = geometry.vertices[ indexD ].y,\n\t\t\tdz = geometry.vertices[ indexD ].z;\n\n\t\tif ( Math.abs( ay - by ) < 0.01 ) {\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( ax, 1 - az ),\n\t\t\t\tnew THREE.Vector2( bx, 1 - bz ),\n\t\t\t\tnew THREE.Vector2( cx, 1 - cz ),\n\t\t\t\tnew THREE.Vector2( dx, 1 - dz )\n\t\t\t];\n\t\t} else {\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( ay, 1 - az ),\n\t\t\t\tnew THREE.Vector2( by, 1 - bz ),\n\t\t\t\tnew THREE.Vector2( cy, 1 - cz ),\n\t\t\t\tnew THREE.Vector2( dy, 1 - dz )\n\t\t\t];\n\t\t}\n\t}\n};\n\nTHREE.ExtrudeGeometry.__v1 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v2 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v3 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v4 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v5 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v6 = new THREE.Vector2();\n\n/**\n * @author jonobr1 / http://jonobr1.com\n *\n * Creates a one-sided polygonal geometry from a path shape. Similar to\n * ExtrudeGeometry.\n *\n * parameters = {\n *\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n *\n *\tmaterial: <int> // material index for front and back faces\n *\tuvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ShapeGeometry = function ( shapes, options ) {\n\n\tTHREE.Geometry.call( this );\n\n\tif ( shapes instanceof Array === false ) shapes = [ shapes ];\n\n\tthis.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n};\n\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * Add an array of shapes to THREE.ShapeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\tfor ( var i = 0, l = shapes.length; i < l; i++ ) {\n\n\t\tthis.addShape( shapes[ i ], options );\n\n\t}\n\n\treturn this;\n\n};\n\n/**\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tif ( options === undefined ) options = {};\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar material = options.material;\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\n\tvar shapebb = this.shapebb;\n\n\t//\n\n\tvar i, l, hole, s;\n\n\tvar shapesOffset = this.vertices.length;\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = !THREE.Shape.Utils.isClockWise( vertices );\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\n\t\tfor ( i = 0, l = holes.length; i < l; i++ ) {\n\n\t\t\thole = holes[ i ];\n\n\t\t\tif ( THREE.Shape.Utils.isClockWise( hole ) ) {\n\n\t\t\t\tholes[ i ] = hole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false;\n\n\t}\n\n\tvar faces = THREE.Shape.Utils.triangulateShape( vertices, holes );\n\n\t// Vertices\n\n\tvar contour = vertices;\n\n\tfor ( i = 0, l = holes.length; i < l; i++ ) {\n\n\t\thole = holes[ i ];\n\t\tvertices = vertices.concat( hole );\n\n\t}\n\n\t//\n\n\tvar vert, vlen = vertices.length;\n\tvar face, flen = faces.length;\n\tvar cont, clen = contour.length;\n\n\tfor ( i = 0; i < vlen; i++ ) {\n\n\t\tvert = vertices[ i ];\n\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\n\n\t}\n\n\tfor ( i = 0; i < flen; i++ ) {\n\n\t\tface = faces[ i ];\n\n\t\tvar a = face[ 0 ] + shapesOffset;\n\t\tvar b = face[ 1 ] + shapesOffset;\n\t\tvar c = face[ 2 ] + shapesOffset;\n\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateBottomUV( this, shape, options, a, b, c ) );\n\n\t}\n\n};\n\n/**\n * @author astrodud / http://astrodud.isgreat.org/\n * @author zz85 / https://github.com/zz85\n * @author bhouston / http://exocortex.com\n */\n\n// points - to create a closed torus, one must use a set of points \n//    like so: [ a, b, c, d, a ], see first is the same as last.\n// segments - the number of circumference segments to create\n// phiStart - the starting radian\n// phiLength - the radian (0 to 2*PI) range of the lathed section\n//    2*pi is a closed lathe, less than 2PI is a portion.\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tsegments = segments || 12;\n\tphiStart = phiStart || 0;\n\tphiLength = phiLength || 2 * Math.PI;\n\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\n\tvar inverseSegments = 1.0 / segments;\n\n\tfor ( var i = 0, il = segments; i <= il; i ++ ) {\n\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\tvar c = Math.cos( phi ),\n\t\t\ts = Math.sin( phi );\n\n\t\tfor ( var j = 0, jl = points.length; j < jl; j ++ ) {\n\n\t\t\tvar pt = points[ j ];\n\n\t\t\tvar vertex = new THREE.Vector3();\n\n\t\t\tvertex.x = c * pt.x - s * pt.y;\n\t\t\tvertex.y = s * pt.x + c * pt.y;\n\t\t\tvertex.z = pt.z;\n\n\t\t\tthis.vertices.push( vertex );\n\n\t\t}\n\n\t}\n\n\tvar np = points.length;\n\n\tfor ( var i = 0, il = segments; i < il; i ++ ) {\n\n\t\tfor ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {\n\n\t\t\tvar base = j + np * i;\n\t\t\tvar a = base;\n\t\t\tvar b = base + np;\n\t\t\tvar c = base + 1 + np;\n\t\t\tvar d = base + 1;\n\n\t\t\tvar u0 = i * inverseSegments;\n\t\t\tvar v0 = j * inversePointLength;\n\t\t\tvar u1 = u0 + inverseSegments;\n\t\t\tvar v1 = v0 + inversePointLength;\n\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\n\n\t\t\t\tnew THREE.Vector2( u0, v0 ),\n\t\t\t\tnew THREE.Vector2( u1, v0 ),\n\t\t\t\tnew THREE.Vector2( u0, v1 )\n\n\t\t\t] );\n\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\n\n\t\t\t\tnew THREE.Vector2( u1, v0 ),\n\t\t\t\tnew THREE.Vector2( u1, v1 ),\n\t\t\t\tnew THREE.Vector2( u0, v1 )\n\n\t\t\t] );\n\n\n\t\t}\n\n\t}\n\n\tthis.mergeVertices();\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */\n\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.widthSegments = widthSegments || 1;\n\tthis.heightSegments = heightSegments || 1;\n\n\tvar ix, iz;\n\tvar width_half = width / 2;\n\tvar height_half = height / 2;\n\n\tvar gridX = this.widthSegments;\n\tvar gridZ = this.heightSegments;\n\n\tvar gridX1 = gridX + 1;\n\tvar gridZ1 = gridZ + 1;\n\n\tvar segment_width = this.width / gridX;\n\tvar segment_height = this.height / gridZ;\n\n\tvar normal = new THREE.Vector3( 0, 0, 1 );\n\n\tfor ( iz = 0; iz < gridZ1; iz ++ ) {\n\n\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\tvar x = ix * segment_width - width_half;\n\t\t\tvar y = iz * segment_height - height_half;\n\n\t\t\tthis.vertices.push( new THREE.Vector3( x, - y, 0 ) );\n\n\t\t}\n\n\t}\n\n\tfor ( iz = 0; iz < gridZ; iz ++ ) {\n\n\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\tvar a = ix + gridX1 * iz;\n\t\t\tvar b = ix + gridX1 * ( iz + 1 );\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iz + 1 );\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iz;\n\n\t\t\tvar uva = new THREE.Vector2( ix / gridX, 1 - iz / gridZ );\n\t\t\tvar uvb = new THREE.Vector2( ix / gridX, 1 - ( iz + 1 ) / gridZ );\n\t\t\tvar uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iz + 1 ) / gridZ );\n\t\t\tvar uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iz / gridZ );\n\n\t\t\tvar face = new THREE.Face3( a, b, d );\n\t\t\tface.normal.copy( normal );\n\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\n\n\t\t\tthis.faces.push( face );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\n\t\t\tface = new THREE.Face3( b, c, d );\n\t\t\tface.normal.copy( normal );\n\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\n\n\t\t\tthis.faces.push( face );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\n};\n\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author Kaleb Murphy\n */\n\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tinnerRadius = innerRadius || 0;\n\touterRadius = outerRadius || 50;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\tphiSegments = phiSegments !== undefined ? Math.max( 3, phiSegments ) : 8;\n\n\tvar i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\n\tfor ( i = 0; i <= phiSegments; i ++ ) { // concentric circles inside ring\n\n\t\tfor ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvar segment = thetaStart + o / thetaSegments * thetaLength;\n\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\tthis.vertices.push( vertex );\n\t\t\tuvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );\n\t\t}\n\n\t\tradius += radiusStep;\n\n\t}\n\n\tvar n = new THREE.Vector3( 0, 0, 1 );\n\n\tfor ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring\n\n\t\tvar thetaSegment = i * thetaSegments;\n\n\t\tfor ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle\n\n\t\t\tvar segment = o + thetaSegment;\n\n\t\t\tvar v1 = segment + i;\n\t\t\tvar v2 = segment + thetaSegments + i;\n\t\t\tvar v3 = segment + thetaSegments + 1 + i;\n\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);\n\n\t\t\tv1 = segment + i;\n\t\t\tv2 = segment + thetaSegments + 1 + i;\n\t\t\tv3 = segment + 1 + i;\n\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);\n\n\t\t}\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.radius = radius = radius || 50;\n\n\tthis.widthSegments = widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\tthis.heightSegments = heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\tthis.phiStart = phiStart = phiStart !== undefined ? phiStart : 0;\n\tthis.phiLength = phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\tthis.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthis.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\tvar x, y, vertices = [], uvs = [];\n\n\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\tvar verticesRow = [];\n\t\tvar uvsRow = [];\n\n\t\tfor ( x = 0; x <= widthSegments; x ++ ) {\n\n\t\t\tvar u = x / widthSegments;\n\t\t\tvar v = y / heightSegments;\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\tthis.vertices.push( vertex );\n\n\t\t\tverticesRow.push( this.vertices.length - 1 );\n\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\n\n\t\t}\n\n\t\tvertices.push( verticesRow );\n\t\tuvs.push( uvsRow );\n\n\t}\n\n\tfor ( y = 0; y < this.heightSegments; y ++ ) {\n\n\t\tfor ( x = 0; x < this.widthSegments; x ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\n\t\t\tvar n1 = this.vertices[ v1 ].clone().normalize();\n\t\t\tvar n2 = this.vertices[ v2 ].clone().normalize();\n\t\t\tvar n3 = this.vertices[ v3 ].clone().normalize();\n\t\t\tvar n4 = this.vertices[ v4 ].clone().normalize();\n\n\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\n\t\t\tvar uv2 = uvs[ y ][ x ].clone();\n\t\t\tvar uv3 = uvs[ y + 1 ][ x ].clone();\n\t\t\tvar uv4 = uvs[ y + 1 ][ x + 1 ].clone();\n\n\t\t\tif ( Math.abs( this.vertices[ v1 ].y ) === this.radius ) {\n\n\t\t\t\tuv1.x = ( uv1.x + uv2.x ) / 2;\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );\n\n\t\t\t} else if ( Math.abs( this.vertices[ v3 ].y ) === this.radius ) {\n\n\t\t\t\tuv3.x = ( uv3.x + uv4.x ) / 2;\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\n\n\t\t\t} else {\n\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\n\n\t\t\t\tthis.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * For creating 3D text geometry in three.js\n *\n * Text = 3D Text\n *\n * parameters = {\n *  size: \t\t\t<float>, \t// size of the text\n *  height: \t\t<float>, \t// thickness to extrude text\n *  curveSegments: \t<int>,\t\t// number of points on the curves\n *\n *  font: \t\t\t<string>,\t\t// font name\n *  weight: \t\t<string>,\t\t// font weight (normal, bold)\n *  style: \t\t\t<string>,\t\t// font style  (normal, italics)\n *\n *  bevelEnabled:\t<bool>,\t\t\t// turn on bevel\n *  bevelThickness: <float>, \t\t// how deep into text bevel goes\n *  bevelSize:\t\t<float>, \t\t// how far from text outline is bevel\n *  }\n *\n */\n\n/*\tUsage Examples\n\n\t// TextGeometry wrapper\n\n\tvar text3d = new TextGeometry( text, options );\n\n\t// Complete manner\n\n\tvar textShapes = THREE.FontUtils.generateShapes( text, options );\n\tvar text3d = new ExtrudeGeometry( textShapes, options );\n\n*/\n\n\nTHREE.TextGeometry = function ( text, parameters ) {\n\n\tparameters = parameters || {};\n\n\tvar textShapes = THREE.FontUtils.generateShapes( text, parameters );\n\n\t// translate parameters to ExtrudeGeometry API\n\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n\t// defaults\n\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\tTHREE.ExtrudeGeometry.call( this, textShapes, parameters );\n\n};\n\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\n\n/**\n * @author oosmoxiecode\n * @author mrdoob / http://mrdoob.com/\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n */\n\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar scope = this;\n\n\tthis.radius = radius || 100;\n\tthis.tube = tube || 40;\n\tthis.radialSegments = radialSegments || 8;\n\tthis.tubularSegments = tubularSegments || 6;\n\tthis.arc = arc || Math.PI * 2;\n\n\tvar center = new THREE.Vector3(), uvs = [], normals = [];\n\n\tfor ( var j = 0; j <= this.radialSegments; j ++ ) {\n\n\t\tfor ( var i = 0; i <= this.tubularSegments; i ++ ) {\n\n\t\t\tvar u = i / this.tubularSegments * this.arc;\n\t\t\tvar v = j / this.radialSegments * Math.PI * 2;\n\n\t\t\tcenter.x = this.radius * Math.cos( u );\n\t\t\tcenter.y = this.radius * Math.sin( u );\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvertex.x = ( this.radius + this.tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\tvertex.y = ( this.radius + this.tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\tvertex.z = this.tube * Math.sin( v );\n\n\t\t\tthis.vertices.push( vertex );\n\n\t\t\tuvs.push( new THREE.Vector2( i / this.tubularSegments, j / this.radialSegments ) );\n\t\t\tnormals.push( vertex.clone().sub( center ).normalize() );\n\n\t\t}\n\n\t}\n\n\n\tfor ( var j = 1; j <= this.radialSegments; j ++ ) {\n\n\t\tfor ( var i = 1; i <= this.tubularSegments; i ++ ) {\n\n\t\t\tvar a = ( this.tubularSegments + 1 ) * j + i - 1;\n\t\t\tvar b = ( this.tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\tvar c = ( this.tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\tvar d = ( this.tubularSegments + 1 ) * j + i;\n\n\t\t\tvar face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );\n\t\t\tthis.faces.push( face );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );\n\n\t\t\tface = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );\n\t\t\tthis.faces.push( face );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n};\n\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author oosmoxiecode\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n */\n\nTHREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar scope = this;\n\n\tthis.radius = radius || 100;\n\tthis.tube = tube || 40;\n\tthis.radialSegments = radialSegments || 64;\n\tthis.tubularSegments = tubularSegments || 8;\n\tthis.p = p || 2;\n\tthis.q = q || 3;\n\tthis.heightScale = heightScale || 1;\n\tthis.grid = new Array( this.radialSegments );\n\n\tvar tang = new THREE.Vector3();\n\tvar n = new THREE.Vector3();\n\tvar bitan = new THREE.Vector3();\n\n\tfor ( var i = 0; i < this.radialSegments; ++ i ) {\n\n\t\tthis.grid[ i ] = new Array( this.tubularSegments );\n\t\tvar u = i / this.radialSegments * 2 * this.p * Math.PI;\n\t\tvar p1 = getPos( u, this.q, this.p, this.radius, this.heightScale );\n\t\tvar p2 = getPos( u + 0.01, this.q, this.p, this.radius, this.heightScale );\n\t\ttang.subVectors( p2, p1 );\n\t\tn.addVectors( p2, p1 );\n\n\t\tbitan.crossVectors( tang, n );\n\t\tn.crossVectors( bitan, tang );\n\t\tbitan.normalize();\n\t\tn.normalize();\n\n\t\tfor ( var j = 0; j < this.tubularSegments; ++ j ) {\n\n\t\t\tvar v = j / this.tubularSegments * 2 * Math.PI;\n\t\t\tvar cx = - this.tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\t\t\tvar cy = this.tube * Math.sin( v );\n\n\t\t\tvar pos = new THREE.Vector3();\n\t\t\tpos.x = p1.x + cx * n.x + cy * bitan.x;\n\t\t\tpos.y = p1.y + cx * n.y + cy * bitan.y;\n\t\t\tpos.z = p1.z + cx * n.z + cy * bitan.z;\n\n\t\t\tthis.grid[ i ][ j ] = scope.vertices.push( pos ) - 1;\n\n\t\t}\n\n\t}\n\n\tfor ( var i = 0; i < this.radialSegments; ++ i ) {\n\n\t\tfor ( var j = 0; j < this.tubularSegments; ++ j ) {\n\n\t\t\tvar ip = ( i + 1 ) % this.radialSegments;\n\t\t\tvar jp = ( j + 1 ) % this.tubularSegments;\n\n\t\t\tvar a = this.grid[ i ][ j ];\n\t\t\tvar b = this.grid[ ip ][ j ];\n\t\t\tvar c = this.grid[ ip ][ jp ];\n\t\t\tvar d = this.grid[ i ][ jp ];\n\n\t\t\tvar uva = new THREE.Vector2( i / this.radialSegments, j / this.tubularSegments );\n\t\t\tvar uvb = new THREE.Vector2( ( i + 1 ) / this.radialSegments, j / this.tubularSegments );\n\t\t\tvar uvc = new THREE.Vector2( ( i + 1 ) / this.radialSegments, ( j + 1 ) / this.tubularSegments );\n\t\t\tvar uvd = new THREE.Vector2( i / this.radialSegments, ( j + 1 ) / this.tubularSegments );\n\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n\tfunction getPos( u, in_q, in_p, radius, heightScale ) {\n\n\t\tvar cu = Math.cos( u );\n\t\tvar su = Math.sin( u );\n\t\tvar quOverP = in_q / in_p * u;\n\t\tvar cs = Math.cos( quOverP );\n\n\t\tvar tx = radius * ( 2 + cs ) * 0.5 * cu;\n\t\tvar ty = radius * ( 2 + cs ) * su * 0.5;\n\t\tvar tz = heightScale * radius * Math.sin( quOverP ) * 0.5;\n\n\t\treturn new THREE.Vector3( tx, ty, tz );\n\n\t}\n\n};\n\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author WestLangley / https://github.com/WestLangley\n * @author zz85 / https://github.com/zz85\n * @author miningold / https://github.com/miningold\n *\n * Modified from the TorusKnotGeometry by @oosmoxiecode\n *\n * Creates a tube which extrudes along a 3d spline\n *\n * Uses parallel transport frames as described in\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n */\n\nTHREE.TubeGeometry = function( path, segments, radius, radialSegments, closed ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.path = path;\n\tthis.segments = segments || 64;\n\tthis.radius = radius || 1;\n\tthis.radialSegments = radialSegments || 8;\n\tthis.closed = closed || false;\n\n\tthis.grid = [];\n\n\tvar scope = this,\n\n\t\ttangent,\n\t\tnormal,\n\t\tbinormal,\n\n\t\tnumpoints = this.segments + 1,\n\n\t\tx, y, z,\n\t\ttx, ty, tz,\n\t\tu, v,\n\n\t\tcx, cy,\n\t\tpos, pos2 = new THREE.Vector3(),\n\t\ti, j,\n\t\tip, jp,\n\t\ta, b, c, d,\n\t\tuva, uvb, uvc, uvd;\n\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( this.path, this.segments, this.closed ),\n\t\ttangents = frames.tangents,\n\t\tnormals = frames.normals,\n\t\tbinormals = frames.binormals;\n\n\t// proxy internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\tfunction vert( x, y, z ) {\n\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\n\n\t}\n\n\n\t// consruct the grid\n\n\tfor ( i = 0; i < numpoints; i++ ) {\n\n\t\tthis.grid[ i ] = [];\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\tpos = path.getPointAt( u );\n\n\t\ttangent = tangents[ i ];\n\t\tnormal = normals[ i ];\n\t\tbinormal = binormals[ i ];\n\n\t\tfor ( j = 0; j < this.radialSegments; j++ ) {\n\n\t\t\tv = j / this.radialSegments * 2 * Math.PI;\n\n\t\t\tcx = -this.radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\t\t\tcy = this.radius * Math.sin( v );\n\n\t\t\tpos2.copy( pos );\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\n\n\t\t\tthis.grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\n\n\t\t}\n\t}\n\n\n\t// construct the mesh\n\n\tfor ( i = 0; i < this.segments; i++ ) {\n\n\t\tfor ( j = 0; j < this.radialSegments; j++ ) {\n\n\t\t\tip = ( this.closed ) ? (i + 1) % this.segments : i + 1;\n\t\t\tjp = (j + 1) % this.radialSegments;\n\n\t\t\ta = this.grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\n\t\t\tb = this.grid[ ip ][ j ];\n\t\t\tc = this.grid[ ip ][ jp ];\n\t\t\td = this.grid[ i ][ jp ];\n\n\t\t\tuva = new THREE.Vector2( i / this.segments, j / this.radialSegments );\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / this.segments, j / this.radialSegments );\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / this.segments, ( j + 1 ) / this.radialSegments );\n\t\t\tuvd = new THREE.Vector2( i / this.segments, ( j + 1 ) / this.radialSegments );\n\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\nTHREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {\n\n\tvar\ttangent = new THREE.Vector3(),\n\t\tnormal = new THREE.Vector3(),\n\t\tbinormal = new THREE.Vector3(),\n\n\t\ttangents = [],\n\t\tnormals = [],\n\t\tbinormals = [],\n\n\t\tvec = new THREE.Vector3(),\n\t\tmat = new THREE.Matrix4(),\n\n\t\tnumpoints = segments + 1,\n\t\ttheta,\n\t\tepsilon = 0.0001,\n\t\tsmallest,\n\n\t\ttx, ty, tz,\n\t\ti, u, v;\n\n\n\t// expose internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\t// compute the tangent vectors for each segment on the path\n\n\tfor ( i = 0; i < numpoints; i++ ) {\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\ttangents[ i ] = path.getTangentAt( u );\n\t\ttangents[ i ].normalize();\n\n\t}\n\n\tinitialNormal3();\n\n\tfunction initialNormal1(lastBinormal) {\n\t\t// fixed start binormal. Has dangers of 0 vectors\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\t}\n\n\tfunction initialNormal2() {\n\n\t\t// This uses the Frenet-Serret formula for deriving binormal\n\t\tvar t2 = path.getTangentAt( epsilon );\n\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\n\t}\n\n\tfunction initialNormal3() {\n\t\t// select an initial normal vector perpenicular to the first tangent vector,\n\t\t// and in the direction of the smallest tangent xyz component\n\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tsmallest = Number.MAX_VALUE;\n\t\ttx = Math.abs( tangents[ 0 ].x );\n\t\tty = Math.abs( tangents[ 0 ].y );\n\t\ttz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= smallest ) {\n\t\t\tsmallest = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\t\t}\n\n\t\tif ( ty <= smallest ) {\n\t\t\tsmallest = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\t\t}\n\n\t\tif ( tz <= smallest ) {\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\t}\n\n\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\n\n\tfor ( i = 1; i < numpoints; i++ ) {\n\n\t\tnormals[ i ] = normals[ i-1 ].clone();\n\n\t\tbinormals[ i ] = binormals[ i-1 ].clone();\n\n\t\tvec.crossVectors( tangents[ i-1 ], tangents[ i ] );\n\n\t\tif ( vec.length() > epsilon ) {\n\n\t\t\tvec.normalize();\n\n\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i-1 ].dot( tangents[ i ] ), -1, 1 ) ); // clamp for floating pt errors\n\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t}\n\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t}\n\n\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\tif ( closed ) {\n\n\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints-1 ] ), -1, 1 ) );\n\t\ttheta /= ( numpoints - 1 );\n\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {\n\n\t\t\ttheta = -theta;\n\n\t\t}\n\n\t\tfor ( i = 1; i < numpoints; i++ ) {\n\n\t\t\t// twist a little...\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t}\n};\n\n/**\n * @author clockworkgeek / https://github.com/clockworkgeek\n * @author timothypratley / https://github.com/timothypratley\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.PolyhedronGeometry = function ( vertices, faces, radius, detail ) {\n\n\tTHREE.Geometry.call( this );\n\n\tradius = radius || 1;\n\tdetail = detail || 0;\n\n\tvar that = this;\n\n\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\tprepare( new THREE.Vector3( vertices[ i ][ 0 ], vertices[ i ][ 1 ], vertices[ i ][ 2 ] ) );\n\n\t}\n\n\tvar midpoints = [], p = this.vertices;\n\n\tvar f = [];\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar v1 = p[ faces[ i ][ 0 ] ];\n\t\tvar v2 = p[ faces[ i ][ 1 ] ];\n\t\tvar v3 = p[ faces[ i ][ 2 ] ];\n\n\t\tf[ i ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\n\t}\n\n\tfor ( var i = 0, l = f.length; i < l; i ++ ) {\n\n\t\tsubdivide(f[ i ], detail);\n\n\t}\n\n\n\t// Handle case when face straddles the seam\n\n\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\n\n\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\tvar x0 = uvs[ 0 ].x;\n\t\tvar x1 = uvs[ 1 ].x;\n\t\tvar x2 = uvs[ 2 ].x;\n\n\t\tvar max = Math.max( x0, Math.max( x1, x2 ) );\n\t\tvar min = Math.min( x0, Math.min( x1, x2 ) );\n\n\t\tif ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary\n\n\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\n\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\n\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\n\n\t\t}\n\n\t}\n\n\n\t// Apply radius\n\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\tthis.vertices[ i ].multiplyScalar( radius );\n\n\t}\n\n\n\t// Merge vertices\n\n\tthis.mergeVertices();\n\n\tthis.computeCentroids();\n\n\tthis.computeFaceNormals();\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n\n\t// Project vector onto sphere's surface\n\n\tfunction prepare( vector ) {\n\n\t\tvar vertex = vector.normalize().clone();\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\n\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\n\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\n\n\t\treturn vertex;\n\n\t}\n\n\n\t// Approximate a curved face with recursively sub-divided triangles.\n\n\tfunction make( v1, v2, v3 ) {\n\n\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\t\tface.centroid.add( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\n\t\tthat.faces.push( face );\n\n\t\tvar azi = azimuth( face.centroid );\n\n\t\tthat.faceVertexUvs[ 0 ].push( [\n\t\t\tcorrectUV( v1.uv, v1, azi ),\n\t\t\tcorrectUV( v2.uv, v2, azi ),\n\t\t\tcorrectUV( v3.uv, v3, azi )\n\t\t] );\n\n\t}\n\n\n\t// Analytically subdivide a face to the required detail level.\n\n\tfunction subdivide(face, detail ) {\n\n\t\tvar cols = Math.pow(2, detail);\n\t\tvar cells = Math.pow(4, detail);\n\t\tvar a = prepare( that.vertices[ face.a ] );\n\t\tvar b = prepare( that.vertices[ face.b ] );\n\t\tvar c = prepare( that.vertices[ face.c ] );\n\t\tvar v = [];\n\n\t\t// Construct all of the vertices for this subdivision.\n\n\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\n\n\t\t\tv[ i ] = [];\n\n\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\n\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\n\t\t\tvar rows = cols - i;\n\n\t\t\tfor ( var j = 0; j <= rows; j ++) {\n\n\t\t\t\tif ( j == 0 && i == cols ) {\n\n\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Construct all of the faces.\n\n\t\tfor ( var i = 0; i < cols ; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {\n\n\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\tif ( j % 2 == 0 ) {\n\n\t\t\t\t\tmake(\n\t\t\t\t\t\tv[ i ][ k + 1],\n\t\t\t\t\t\tv[ i + 1 ][ k ],\n\t\t\t\t\t\tv[ i ][ k ]\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmake(\n\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1][ k + 1],\n\t\t\t\t\t\tv[ i + 1 ][ k ]\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\tfunction azimuth( vector ) {\n\n\t\treturn Math.atan2( vector.z, -vector.x );\n\n\t}\n\n\n\t// Angle above the XZ plane.\n\n\tfunction inclination( vector ) {\n\n\t\treturn Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t}\n\n\n\t// Texture fixing helper. Spheres have some odd behaviours.\n\n\tfunction correctUV( uv, vector, azimuth ) {\n\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\n\t\treturn uv.clone();\n\n\t}\n\n\n};\n\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\n\n\tthis.radius = radius;\n\tthis.detail = detail;\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\tvar vertices = [\n\t\t[ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],\n\t\t[  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],\n\t\t[  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]\n\t];\n\n\tvar faces = [\n\t\t[ 0, 11,  5 ], [ 0,  5,  1 ], [  0,  1,  7 ], [  0,  7, 10 ], [  0, 10, 11 ],\n\t\t[ 1,  5,  9 ], [ 5, 11,  4 ], [ 11, 10,  2 ], [ 10,  7,  6 ], [  7,  1,  8 ],\n\t\t[ 3,  9,  4 ], [ 3,  4,  2 ], [  3,  2,  6 ], [  3,  6,  8 ], [  3,  8,  9 ],\n\t\t[ 4,  9,  5 ], [ 2,  4, 11 ], [  6,  2, 10 ], [  8,  6,  7 ], [  9,  8,  1 ]\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\n\n};\n\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.OctahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t[ 1, 0, 0 ], [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 0, 0, 1 ], [ 0, 0, -1 ]\n\t];\n\n\tvar faces = [\n\t\t[ 0, 2, 4 ], [ 0, 4, 3 ], [ 0, 3, 5 ], [ 0, 5, 2 ], [ 1, 2, 5 ], [ 1, 5, 3 ], [ 1, 3, 4 ], [ 1, 4, 2 ]\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\n};\n\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t[ 1,  1,  1 ], [ -1, -1, 1 ], [ -1, 1, -1 ], [ 1, -1, -1 ]\n\t];\n\n\tvar faces = [\n\t\t[ 2, 1, 0 ], [ 0, 3, 2 ], [ 1, 3, 0 ], [ 2, 3, 1 ]\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\n\n};\n\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author zz85 / https://github.com/zz85\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n *\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\n *\n */\n\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar verts = this.vertices;\n\tvar faces = this.faces;\n\tvar uvs = this.faceVertexUvs[ 0 ];\n\n\tvar i, il, j, p;\n\tvar u, v;\n\n\tvar stackCount = stacks + 1;\n\tvar sliceCount = slices + 1;\n\n\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\tv = i / stacks;\n\n\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\tu = j / slices;\n\n\t\t\tp = func( u, v );\n\t\t\tverts.push( p );\n\n\t\t}\n\t}\n\n\tvar a, b, c, d;\n\tvar uva, uvb, uvc, uvd;\n\n\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\ta = i * sliceCount + j;\n\t\t\tb = i * sliceCount + j + 1;\n\t\t\tc = (i + 1) * sliceCount + j + 1;\n\t\t\td = (i + 1) * sliceCount + j;\n\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\n\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\n\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\n\n\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\n\t\t\tuvs.push( [ uva, uvb, uvd ] );\n\n\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\n\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\n\t}\n\n\t// console.log(this);\n\n\t// magic bullet\n\t// var diff = this.mergeVertices();\n\t// console.log('removed ', diff, ' vertices by merging');\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author sroucheray / http://sroucheray.org/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AxisHelper = function ( size ) {\n\n\tsize = size || 1;\n\n\tvar geometry = new THREE.Geometry();\n\n\tgeometry.vertices.push(\n\t\tnew THREE.Vector3(), new THREE.Vector3( size, 0, 0 ),\n\t\tnew THREE.Vector3(), new THREE.Vector3( 0, size, 0 ),\n\t\tnew THREE.Vector3(), new THREE.Vector3( 0, 0, size )\n\t);\n\n\tgeometry.colors.push(\n\t\tnew THREE.Color( 0xff0000 ), new THREE.Color( 0xffaa00 ),\n\t\tnew THREE.Color( 0x00ff00 ), new THREE.Color( 0xaaff00 ),\n\t\tnew THREE.Color( 0x0000ff ), new THREE.Color( 0x00aaff )\n\t);\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\n\n};\n\nTHREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @author zz85 / http://github.com/zz85\n * @author bhouston / http://exocortex.com\n *\n * Creates an arrow for visualizing directions\n *\n * Parameters:\n *  dir - Vector3\n *  origin - Vector3\n *  length - Number\n *  hex - color in hex value\n *  headLength - Number\n *  headWidth - Number\n */\n\nTHREE.ArrowHelper = function ( dir, origin, length, hex, headLength, headWidth ) {\n\n\t// dir is assumed to be normalized\n\n\tTHREE.Object3D.call( this );\n\n\tif ( hex === undefined ) hex = 0xffff00;\n\tif ( length === undefined ) length = 1;\n\tif ( headLength === undefined ) headLength = 0.2 * length;\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\tthis.position = origin;\n\n\tvar lineGeometry = new THREE.Geometry();\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 1, 0 ) );\n\n\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: hex } ) );\n\tthis.line.matrixAutoUpdate = false;\n\tthis.add( this.line );\n\n\tvar coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );\n\tconeGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );\n\n\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: hex } ) );\n\tthis.cone.matrixAutoUpdate = false;\n\tthis.add( this.cone );\n\n\tthis.setDirection( dir );\n\tthis.setLength( length, headLength, headWidth );\n\n};\n\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.ArrowHelper.prototype.setDirection = function () {\n\n\tvar axis = new THREE.Vector3();\n\tvar radians;\n\n\treturn function ( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tradians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\n\t\t}\n\n\t};\n\n}();\n\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n\tif ( headLength === undefined ) headLength = 0.2 * length;\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\tthis.line.scale.set( 1, length, 1 );\n\tthis.line.updateMatrix();\n\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\tthis.cone.position.y = length;\n\tthis.cone.updateMatrix();\n\n};\n\nTHREE.ArrowHelper.prototype.setColor = function ( hex ) {\n\n\tthis.line.material.color.setHex( hex );\n\tthis.cone.material.color.setHex( hex );\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BoxHelper = function ( object ) {\n\n\t//   5____4\n\t// 1/___0/|\n\t// | 6__|_7\n\t// 2/___3/\n\n\tvar vertices = [\n\t\tnew THREE.Vector3(   1,   1,   1 ),\n\t\tnew THREE.Vector3( - 1,   1,   1 ),\n\t\tnew THREE.Vector3( - 1, - 1,   1 ),\n\t\tnew THREE.Vector3(   1, - 1,   1 ),\n\n\t\tnew THREE.Vector3(   1,   1, - 1 ),\n\t\tnew THREE.Vector3( - 1,   1, - 1 ),\n\t\tnew THREE.Vector3( - 1, - 1, - 1 ),\n\t\tnew THREE.Vector3(   1, - 1, - 1 )\n\t];\n\n\tthis.vertices = vertices;\n\n\t// TODO: Wouldn't be nice if Line had .segments?\n\n\tvar geometry = new THREE.Geometry();\n\tgeometry.vertices.push(\n\t\tvertices[ 0 ], vertices[ 1 ],\n\t\tvertices[ 1 ], vertices[ 2 ],\n\t\tvertices[ 2 ], vertices[ 3 ],\n\t\tvertices[ 3 ], vertices[ 0 ],\n\n\t\tvertices[ 4 ], vertices[ 5 ],\n\t\tvertices[ 5 ], vertices[ 6 ],\n\t\tvertices[ 6 ], vertices[ 7 ],\n\t\tvertices[ 7 ], vertices[ 4 ],\n\n\t\tvertices[ 0 ], vertices[ 4 ],\n\t\tvertices[ 1 ], vertices[ 5 ],\n\t\tvertices[ 2 ], vertices[ 6 ],\n\t\tvertices[ 3 ], vertices[ 7 ]\n\t);\n\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );\n\n\tif ( object !== undefined ) {\n\n\t\tthis.update( object );\n\n\t}\n\n};\n\nTHREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );\n\nTHREE.BoxHelper.prototype.update = function ( object ) {\n\n\tvar geometry = object.geometry;\n\n\tif ( geometry.boundingBox === null ) {\n\n\t\tgeometry.computeBoundingBox();\n\n\t}\n\n\tvar min = geometry.boundingBox.min;\n\tvar max = geometry.boundingBox.max;\n\tvar vertices = this.vertices;\n\n\tvertices[ 0 ].set( max.x, max.y, max.z );\n\tvertices[ 1 ].set( min.x, max.y, max.z );\n\tvertices[ 2 ].set( min.x, min.y, max.z );\n\tvertices[ 3 ].set( max.x, min.y, max.z );\n\tvertices[ 4 ].set( max.x, max.y, min.z );\n\tvertices[ 5 ].set( min.x, max.y, min.z );\n\tvertices[ 6 ].set( min.x, min.y, min.z );\n\tvertices[ 7 ].set( max.x, min.y, min.z );\n\n\tthis.geometry.computeBoundingSphere();\n\tthis.geometry.verticesNeedUpdate = true;\n\n\tthis.matrixAutoUpdate = false;\n\tthis.matrixWorld = object.matrixWorld;\n\n};\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\n// a helper to show the world-axis-aligned bounding box for an object\n\nTHREE.BoundingBoxHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\n\tthis.object = object;\n\n\tthis.box = new THREE.Box3();\n\n\tTHREE.Mesh.call( this, new THREE.CubeGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\n\n};\n\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\n\nTHREE.BoundingBoxHelper.prototype.update = function () {\n\n\tthis.box.setFromObject( this.object );\n\n\tthis.box.size( this.scale );\n\n\tthis.box.center( this.position );\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n */\n\nTHREE.CameraHelper = function ( camera ) {\n\n\tvar geometry = new THREE.Geometry();\n\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\n\n\tvar pointMap = {};\n\n\t// colors\n\n\tvar hexFrustum = 0xffaa00;\n\tvar hexCone = 0xff0000;\n\tvar hexUp = 0x00aaff;\n\tvar hexTarget = 0xffffff;\n\tvar hexCross = 0x333333;\n\n\t// near\n\n\taddLine( \"n1\", \"n2\", hexFrustum );\n\taddLine( \"n2\", \"n4\", hexFrustum );\n\taddLine( \"n4\", \"n3\", hexFrustum );\n\taddLine( \"n3\", \"n1\", hexFrustum );\n\n\t// far\n\n\taddLine( \"f1\", \"f2\", hexFrustum );\n\taddLine( \"f2\", \"f4\", hexFrustum );\n\taddLine( \"f4\", \"f3\", hexFrustum );\n\taddLine( \"f3\", \"f1\", hexFrustum );\n\n\t// sides\n\n\taddLine( \"n1\", \"f1\", hexFrustum );\n\taddLine( \"n2\", \"f2\", hexFrustum );\n\taddLine( \"n3\", \"f3\", hexFrustum );\n\taddLine( \"n4\", \"f4\", hexFrustum );\n\n\t// cone\n\n\taddLine( \"p\", \"n1\", hexCone );\n\taddLine( \"p\", \"n2\", hexCone );\n\taddLine( \"p\", \"n3\", hexCone );\n\taddLine( \"p\", \"n4\", hexCone );\n\n\t// up\n\n\taddLine( \"u1\", \"u2\", hexUp );\n\taddLine( \"u2\", \"u3\", hexUp );\n\taddLine( \"u3\", \"u1\", hexUp );\n\n\t// target\n\n\taddLine( \"c\", \"t\", hexTarget );\n\taddLine( \"p\", \"c\", hexCross );\n\n\t// cross\n\n\taddLine( \"cn1\", \"cn2\", hexCross );\n\taddLine( \"cn3\", \"cn4\", hexCross );\n\n\taddLine( \"cf1\", \"cf2\", hexCross );\n\taddLine( \"cf3\", \"cf4\", hexCross );\n\n\tfunction addLine( a, b, hex ) {\n\n\t\taddPoint( a, hex );\n\t\taddPoint( b, hex );\n\n\t}\n\n\tfunction addPoint( id, hex ) {\n\n\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\tgeometry.colors.push( new THREE.Color( hex ) );\n\n\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\tpointMap[ id ] = [];\n\n\t\t}\n\n\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\n\t}\n\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\n\n\tthis.camera = camera;\n\tthis.matrixWorld = camera.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.pointMap = pointMap;\n\n\tthis.update();\n\n};\n\nTHREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );\n\nTHREE.CameraHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\tvar camera = new THREE.Camera();\n\tvar projector = new THREE.Projector();\n\n\treturn function () {\n\n\t\tvar scope = this;\n\n\t\tvar w = 1, h = 1;\n\n\t\t// we need just camera projection matrix\n\t\t// world matrix must be identity\n\n\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\t// center / target\n\n\t\tsetPoint( \"c\", 0, 0, -1 );\n\t\tsetPoint( \"t\", 0, 0,  1 );\n\n\t\t// near\n\n\t\tsetPoint( \"n1\", -w, -h, -1 );\n\t\tsetPoint( \"n2\",  w, -h, -1 );\n\t\tsetPoint( \"n3\", -w,  h, -1 );\n\t\tsetPoint( \"n4\",  w,  h, -1 );\n\n\t\t// far\n\n\t\tsetPoint( \"f1\", -w, -h, 1 );\n\t\tsetPoint( \"f2\",  w, -h, 1 );\n\t\tsetPoint( \"f3\", -w,  h, 1 );\n\t\tsetPoint( \"f4\",  w,  h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( \"u1\",  w * 0.7, h * 1.1, -1 );\n\t\tsetPoint( \"u2\", -w * 0.7, h * 1.1, -1 );\n\t\tsetPoint( \"u3\",        0, h * 2,   -1 );\n\n\t\t// cross\n\n\t\tsetPoint( \"cf1\", -w,  0, 1 );\n\t\tsetPoint( \"cf2\",  w,  0, 1 );\n\t\tsetPoint( \"cf3\",  0, -h, 1 );\n\t\tsetPoint( \"cf4\",  0,  h, 1 );\n\n\t\tsetPoint( \"cn1\", -w,  0, -1 );\n\t\tsetPoint( \"cn2\",  w,  0, -1 );\n\t\tsetPoint( \"cn3\",  0, -h, -1 );\n\t\tsetPoint( \"cn4\",  0,  h, -1 );\n\n\t\tfunction setPoint( point, x, y, z ) {\n\n\t\t\tvector.set( x, y, z );\n\t\t\tprojector.unprojectVector( vector, camera );\n\n\t\t\tvar points = scope.pointMap[ point ];\n\n\t\t\tif ( points !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\t\tscope.geometry.vertices[ points[ i ] ].copy( vector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.geometry.verticesNeedUpdate = true;\n\n\t};\n\n}();\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.DirectionalLightHelper = function ( light, size ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrixWorld = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tsize = size || 1;\n\tvar geometry = new THREE.PlaneGeometry( size, size );\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\tthis.lightPlane = new THREE.Mesh( geometry, material );\n\tthis.add( this.lightPlane );\n\n\tgeometry = new THREE.Geometry();\n\tgeometry.vertices.push( new THREE.Vector3() );\n\tgeometry.vertices.push( new THREE.Vector3() );\n\n\tmaterial = new THREE.LineBasicMaterial( { fog: false } );\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\tthis.targetLine = new THREE.Line( geometry, material );\n\tthis.add( this.targetLine );\n\n\tthis.update();\n\n};\n\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\n\t\n\tthis.lightPlane.geometry.dispose();\n\tthis.lightPlane.material.dispose();\n\tthis.targetLine.geometry.dispose();\n\tthis.targetLine.material.dispose();\n};\n\nTHREE.DirectionalLightHelper.prototype.update = function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar v3 = new THREE.Vector3();\n\n\treturn function () {\n\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\tv3.subVectors( v2, v1 );\n\n\t\tthis.lightPlane.lookAt( v3 );\n\t\tthis.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\tthis.targetLine.geometry.vertices[ 1 ].copy( v3 );\n\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\n\t\tthis.targetLine.material.color.copy( this.lightPlane.material.color );\n\n\t}\n\n}();\n\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.EdgesHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\n\tvar edge = [ 0, 0 ], hash = {};\n\tvar sortFunction = function ( a, b ) { return a - b };\n\n\tvar keys = [ 'a', 'b', 'c' ];\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar geometry2 = object.geometry.clone();\n\n\tgeometry2.mergeVertices();\n\tgeometry2.computeFaceNormals();\n\n\tvar vertices = geometry2.vertices;\n\tvar faces = geometry2.faces;\n\tvar numEdges = 0;\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar face = faces[ i ];\n\n\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\tedge.sort( sortFunction );\n\n\t\t\tvar key = edge.toString();\n\n\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\t\t\t\tnumEdges ++;\n\n\t\t\t} else {\n\n\t\t\t\thash[ key ].face2 = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgeometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );\n\n\tvar coords = geometry.attributes.position.array;\n\n\tvar index = 0;\n\n\tfor ( var key in hash ) {\n\n\t\tvar h = hash[ key ];\n\n\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) < 0.9999 ) { // hardwired const OK\n\n\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\tcoords[ index ++ ] = vertex.x;\n\t\t\tcoords[ index ++ ] = vertex.y;\n\t\t\tcoords[ index ++ ] = vertex.z;\n\n\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\tcoords[ index ++ ] = vertex.x;\n\t\t\tcoords[ index ++ ] = vertex.y;\n\t\t\tcoords[ index ++ ] = vertex.z;\n\n\t\t}\n\n\t}\n\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );\n\n\tthis.matrixAutoUpdate = false;\n\tthis.matrixWorld = object.matrixWorld;\n\n};\n\nTHREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\tvar geometry = new THREE.Geometry();\n\n\tvar faces = this.object.geometry.faces;\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\tgeometry.vertices.push( new THREE.Vector3() );\n\n\t}\n\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.normalMatrix = new THREE.Matrix3();\n\n\tthis.update();\n\n};\n\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );\n\nTHREE.FaceNormalsHelper.prototype.update = ( function ( object ) {\n\n\tvar v1 = new THREE.Vector3();\n\n\treturn function ( object ) {\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tthis.normalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar vertices = this.geometry.vertices;\n\n\t\tvar faces = this.object.geometry.faces;\n\n\t\tvar worldMatrix = this.object.matrixWorld;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tv1.copy( face.normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );\n\n\t\t\tvar idx = 2 * i;\n\n\t\t\tvertices[ idx ].copy( face.centroid ).applyMatrix4( worldMatrix );\n\n\t\t\tvertices[ idx + 1 ].addVectors( vertices[ idx ], v1 );\n\n\t\t}\n\n\t\tthis.geometry.verticesNeedUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n}());\n\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.GridHelper = function ( size, step ) {\n\n\tvar geometry = new THREE.Geometry();\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tthis.color1 = new THREE.Color( 0x444444 );\n\tthis.color2 = new THREE.Color( 0x888888 );\n\n\tfor ( var i = - size; i <= size; i += step ) {\n\n\t\tgeometry.vertices.push(\n\t\t\tnew THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),\n\t\t\tnew THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )\n\t\t);\n\n\t\tvar color = i === 0 ? this.color1 : this.color2;\n\n\t\tgeometry.colors.push( color, color, color, color );\n\n\t}\n\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\n\n};\n\nTHREE.GridHelper.prototype = Object.create( THREE.Line.prototype );\n\nTHREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {\n\n\tthis.color1.set( colorCenterLine );\n\tthis.color2.set( colorGrid );\n\n\tthis.geometry.colorsNeedUpdate = true;\n\n}\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrixWorld = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\n\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\n\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\n\n\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\n\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\n\t}\n\n\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\n\n\tthis.lightSphere = new THREE.Mesh( geometry, material );\n\tthis.add( this.lightSphere );\n\n\tthis.update();\n\n};\n\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\n\tthis.lightSphere.geometry.dispose();\n\tthis.lightSphere.material.dispose();\n};\n\nTHREE.HemisphereLightHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\n\treturn function () {\n\n\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\n\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\n\t}\n\n}();\n\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PointLightHelper = function ( light, sphereSize ) {\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.matrixWorld = this.light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\t/*\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tvar d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n};\n\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\n\nTHREE.PointLightHelper.prototype.dispose = function () {\n\t\n\tthis.geometry.dispose();\n\tthis.material.dispose();\n};\n\nTHREE.PointLightHelper.prototype.update = function () {\n\n\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t/*\n\tvar d = this.light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.visible = true;\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\t*/\n\n};\n\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.SpotLightHelper = function ( light ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrixWorld = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tvar geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );\n\n\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, -0.5, 0 ) );\n\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\n\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\t\n\tthis.cone = new THREE.Mesh( geometry, material );\n\tthis.add( this.cone );\n\n\tthis.update();\n\n};\n\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.SpotLightHelper.prototype.dispose = function () {\n\tthis.cone.geometry.dispose();\n\tthis.cone.material.dispose();\n};\n\nTHREE.SpotLightHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\tvar vector2 = new THREE.Vector3();\n\n\treturn function () {\n\n\t\tvar coneLength = this.light.distance ? this.light.distance : 10000;\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\n\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t};\n\n}();\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\tvar geometry = new THREE.Geometry();\n\n\tvar vertices = object.geometry.vertices;\n\n\tvar faces = object.geometry.faces;\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar face = faces[ i ];\n\n\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\n\t\t}\n\n\t}\n\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.normalMatrix = new THREE.Matrix3();\n\n\tthis.update();\n\n};\n\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );\n\nTHREE.VertexNormalsHelper.prototype.update = ( function ( object ) {\n\n\tvar v1 = new THREE.Vector3();\n\n\treturn function( object ) {\n\n\t\tvar keys = [ 'a', 'b', 'c', 'd' ];\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tthis.normalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar vertices = this.geometry.vertices;\n\n\t\tvar verts = this.object.geometry.vertices;\n\n\t\tvar faces = this.object.geometry.faces;\n\n\t\tvar worldMatrix = this.object.matrixWorld;\n\n\t\tvar idx = 0;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tvar vertexId = face[ keys[ j ] ];\n\t\t\t\tvar vertex = verts[ vertexId ];\n\n\t\t\t\tvar normal = face.vertexNormals[ j ];\n\n\t\t\t\tvertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\n\n\t\t\t\tv1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );\n\n\t\t\t\tv1.add( vertices[ idx ] );\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tvertices[ idx ].copy( v1 );\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.geometry.verticesNeedUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n}());\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0x0000ff;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\tvar geometry = new THREE.Geometry();\n\n\tvar vertices = object.geometry.vertices;\n\n\tvar faces = object.geometry.faces;\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar face = faces[ i ];\n\n\t\tfor ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\n\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\n\t\t}\n\n\t}\n\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n};\n\nTHREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );\n\nTHREE.VertexTangentsHelper.prototype.update = ( function ( object ) {\n\n\tvar v1 = new THREE.Vector3();\n\n\treturn function( object ) {\n\n\t\tvar keys = [ 'a', 'b', 'c', 'd' ];\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tvar vertices = this.geometry.vertices;\n\n\t\tvar verts = this.object.geometry.vertices;\n\n\t\tvar faces = this.object.geometry.faces;\n\n\t\tvar worldMatrix = this.object.matrixWorld;\n\n\t\tvar idx = 0;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\n\n\t\t\t\tvar vertexId = face[ keys[ j ] ];\n\t\t\t\tvar vertex = verts[ vertexId ];\n\n\t\t\t\tvar tangent = face.vertexTangents[ j ];\n\n\t\t\t\tvertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\n\n\t\t\t\tv1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );\n\n\t\t\t\tv1.add( vertices[ idx ] );\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tvertices[ idx ].copy( v1 );\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.geometry.verticesNeedUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n}());\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WireframeHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\n\tvar edge = [ 0, 0 ], hash = {};\n\tvar sortFunction = function ( a, b ) { return a - b };\n\n\tvar keys = [ 'a', 'b', 'c' ];\n\tvar geometry = new THREE.BufferGeometry();\n\n\tif ( object.geometry instanceof THREE.Geometry ) {\n\n\t\tvar vertices = object.geometry.vertices;\n\t\tvar faces = object.geometry.faces;\n\t\tvar numEdges = 0;\n\n\t\t// allocate maximal size\n\t\tvar edges = new Uint32Array( 6 * faces.length );\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\tvar key = edge.toString();\n\n\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );\n\n\t\tvar coords = geometry.attributes.position.array;\n\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j] ];\n\n\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t} else if ( object.geometry instanceof THREE.BufferGeometry && object.geometry.attributes.index !== undefined ) { // indexed BufferGeometry\n\n\t\tvar vertices = object.geometry.attributes.position.array;\n\t\tvar indices = object.geometry.attributes.index.array;\n\t\tvar offsets = object.geometry.offsets;\n\t\tvar numEdges = 0;\n\n\t\t// allocate maximal size\n\t\tvar edges = new Uint32Array( 2 * indices.length );\n\n\t\tfor ( var o = 0, ol = offsets.length; o < ol; ++ o ) {\n\n\t\t\tvar start = offsets[ o ].start;\n\t\t\tvar count = offsets[ o ].count;\n\t\t\tvar index = offsets[ o ].index;\n\n\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tedge[ 0 ] = index + indices[ i + j ];\n\t\t\t\t\tedge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );\n\n\t\tvar coords = geometry.attributes.position.array;\n\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\tvar index2 = 3 * edges[ 2 * i + j];\n\t\t\t\tcoords[ index + 0 ] = vertices[ index2 ];\n\t\t\t\tcoords[ index + 1 ] = vertices[ index2 + 1 ];\n\t\t\t\tcoords[ index + 2 ] = vertices[ index2 + 2 ];\n\n\t\t\t}\n\n\t\t}\n\n\t} else if ( object.geometry instanceof THREE.BufferGeometry\t) { // non-indexed BufferGeometry\n\n\t\tvar vertices = object.geometry.attributes.position.array;\n\t\tvar numEdges = vertices.length / 3;\n\t\tvar numTris = numEdges / 3;\n\n\t\tgeometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );\n\n\t\tvar coords = geometry.attributes.position.array;\n\n\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tvar index = 18 * i + 6 * j;\n\n\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\n\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );\n\n\tthis.matrixAutoUpdate = false;\n\tthis.matrixWorld = object.matrixWorld;\n\n};\n\nTHREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ImmediateRenderObject = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.render = function ( renderCallback ) { };\n\n};\n\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.lensFlares = [];\n\n\tthis.positionScreen = new THREE.Vector3();\n\tthis.customUpdateCallback = undefined;\n\n\tif( texture !== undefined ) {\n\n\t\tthis.add( texture, size, distance, blending, color );\n\n\t}\n\n};\n\nTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\n\n\n/*\n * Add: adds another flare\n */\n\nTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\n\n\tif( size === undefined ) size = -1;\n\tif( distance === undefined ) distance = 0;\n\tif( opacity === undefined ) opacity = 1;\n\tif( color === undefined ) color = new THREE.Color( 0xffffff );\n\tif( blending === undefined ) blending = THREE.NormalBlending;\n\n\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\n\tthis.lensFlares.push( { texture: texture, \t\t\t// THREE.Texture\n\t\t                    size: size, \t\t\t\t// size in pixels (-1 = use texture.width)\n\t\t                    distance: distance, \t\t// distance (0-1) from light source (0=at light source)\n\t\t                    x: 0, y: 0, z: 0,\t\t\t// screen position (-1 => 1) z = 0 is ontop z = 1 is back\n\t\t                    scale: 1, \t\t\t\t\t// scale\n\t\t                    rotation: 1, \t\t\t\t// rotation\n\t\t                    opacity: opacity,\t\t\t// opacity\n\t\t\t\t\t\t\tcolor: color,\t\t\t\t// color\n\t\t                    blending: blending } );\t\t// blending\n\n};\n\n\n/*\n * Update lens flares update positions on all flares based on the screen position\n * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n */\n\nTHREE.LensFlare.prototype.updateLensFlares = function () {\n\n\tvar f, fl = this.lensFlares.length;\n\tvar flare;\n\tvar vecX = -this.positionScreen.x * 2;\n\tvar vecY = -this.positionScreen.y * 2;\n\n\tfor( f = 0; f < fl; f ++ ) {\n\n\t\tflare = this.lensFlares[ f ];\n\n\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\n\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\n\t}\n\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.animationsMap = {};\r\n\tthis.animationsList = [];\r\n\r\n\t// prepare default animation\r\n\t// (all frames played together in 1 second)\r\n\r\n\tvar numFrames = this.geometry.morphTargets.length;\r\n\r\n\tvar name = \"__default\";\r\n\r\n\tvar startFrame = 0;\r\n\tvar endFrame = numFrames - 1;\r\n\r\n\tvar fps = numFrames / 1;\r\n\r\n\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\tthis.setAnimationWeight( name, 1 );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\r\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n\tvar animation = {\r\n\r\n\t\tstartFrame: start,\r\n\t\tendFrame: end,\r\n\r\n\t\tlength: end - start + 1,\r\n\r\n\t\tfps: fps,\r\n\t\tduration: ( end - start ) / fps,\r\n\r\n\t\tlastFrame: 0,\r\n\t\tcurrentFrame: 0,\r\n\r\n\t\tactive: false,\r\n\r\n\t\ttime: 0,\r\n\t\tdirection: 1,\r\n\t\tweight: 1,\r\n\r\n\t\tdirectionBackwards: false,\r\n\t\tmirroredLoop: false\r\n\r\n\t};\r\n\r\n\tthis.animationsMap[ name ] = animation;\r\n\tthis.animationsList.push( animation );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n\tvar pattern = /([a-z]+)(\\d+)/;\r\n\r\n\tvar firstAnimation, frameRanges = {};\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\tvar chunks = morph.name.match( pattern );\r\n\r\n\t\tif ( chunks && chunks.length > 1 ) {\r\n\r\n\t\t\tvar name = chunks[ 1 ];\r\n\t\t\tvar num = chunks[ 2 ];\r\n\r\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: -Infinity };\r\n\r\n\t\t\tvar range = frameRanges[ name ];\r\n\r\n\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\tif ( i > range.end ) range.end = i;\r\n\r\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var name in frameRanges ) {\r\n\r\n\t\tvar range = frameRanges[ name ];\r\n\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\r\n\t}\r\n\r\n\tthis.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = 1;\r\n\t\tanimation.directionBackwards = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = -1;\r\n\t\tanimation.directionBackwards = true;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.fps = fps;\r\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.duration = duration;\r\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.weight = weight;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = time;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n\tvar time = 0;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\ttime = animation.time;\r\n\r\n\t}\r\n\r\n\treturn time;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n\tvar duration = -1;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tduration = animation.duration;\r\n\r\n\t}\r\n\r\n\treturn duration;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = 0;\r\n\t\tanimation.active = true;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"animation[\" + name + \"] undefined\" );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.active = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n\t\tvar animation = this.animationsList[ i ];\r\n\r\n\t\tif ( ! animation.active ) continue;\r\n\r\n\t\tvar frameTime = animation.duration / animation.length;\r\n\r\n\t\tanimation.time += animation.direction * delta;\r\n\r\n\t\tif ( animation.mirroredLoop ) {\r\n\r\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n\t\t\t\tanimation.direction *= -1;\r\n\r\n\t\t\t\tif ( animation.time > animation.duration ) {\r\n\r\n\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( animation.time < 0 ) {\r\n\r\n\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tanimation.time = animation.time % animation.duration;\r\n\r\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n\t\t}\r\n\r\n\t\tvar keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\tvar weight = animation.weight;\r\n\r\n\t\tif ( keyframe !== animation.currentFrame ) {\r\n\r\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\tanimation.currentFrame = keyframe;\r\n\r\n\t\t}\r\n\r\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n\t}\r\n\r\n};\r\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlarePlugin = function () {\n\n\tvar _gl, _renderer, _precision, _lensFlare = {};\n\n\tthis.init = function ( renderer ) {\n\n\t\t_gl = renderer.context;\n\t\t_renderer = renderer;\n\n\t\t_precision = renderer.getPrecision();\n\n\t\t_lensFlare.vertices = new Float32Array( 8 + 8 );\n\t\t_lensFlare.faces = new Uint16Array( 6 );\n\n\t\tvar i = 0;\n\t\t_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = -1;\t// vertex\n\t\t_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 0;\t// uv... etc.\n\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = -1;\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 0;\n\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;\n\n\t\t_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = 1;\n\t\t_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 1;\n\n\t\ti = 0;\n\t\t_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 1; _lensFlare.faces[ i++ ] = 2;\n\t\t_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 2; _lensFlare.faces[ i++ ] = 3;\n\n\t\t// buffers\n\n\t\t_lensFlare.vertexBuffer     = _gl.createBuffer();\n\t\t_lensFlare.elementBuffer    = _gl.createBuffer();\n\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );\n\t\t_gl.bufferData( _gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW );\n\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );\n\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW );\n\n\t\t// textures\n\n\t\t_lensFlare.tempTexture      = _gl.createTexture();\n\t\t_lensFlare.occlusionTexture = _gl.createTexture();\n\n\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\n\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );\n\n\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );\n\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );\n\n\t\tif ( _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) <= 0 ) {\n\n\t\t\t_lensFlare.hasVertexTexture = false;\n\t\t\t_lensFlare.program = createProgram( THREE.ShaderFlares[ \"lensFlare\" ], _precision );\n\n\t\t} else {\n\n\t\t\t_lensFlare.hasVertexTexture = true;\n\t\t\t_lensFlare.program = createProgram( THREE.ShaderFlares[ \"lensFlareVertexTexture\" ], _precision );\n\n\t\t}\n\n\t\t_lensFlare.attributes = {};\n\t\t_lensFlare.uniforms = {};\n\n\t\t_lensFlare.attributes.vertex       = _gl.getAttribLocation ( _lensFlare.program, \"position\" );\n\t\t_lensFlare.attributes.uv           = _gl.getAttribLocation ( _lensFlare.program, \"uv\" );\n\n\t\t_lensFlare.uniforms.renderType     = _gl.getUniformLocation( _lensFlare.program, \"renderType\" );\n\t\t_lensFlare.uniforms.map            = _gl.getUniformLocation( _lensFlare.program, \"map\" );\n\t\t_lensFlare.uniforms.occlusionMap   = _gl.getUniformLocation( _lensFlare.program, \"occlusionMap\" );\n\t\t_lensFlare.uniforms.opacity        = _gl.getUniformLocation( _lensFlare.program, \"opacity\" );\n\t\t_lensFlare.uniforms.color          = _gl.getUniformLocation( _lensFlare.program, \"color\" );\n\t\t_lensFlare.uniforms.scale          = _gl.getUniformLocation( _lensFlare.program, \"scale\" );\n\t\t_lensFlare.uniforms.rotation       = _gl.getUniformLocation( _lensFlare.program, \"rotation\" );\n\t\t_lensFlare.uniforms.screenPosition = _gl.getUniformLocation( _lensFlare.program, \"screenPosition\" );\n\n\t};\n\n\n\t/*\n\t * Render lens flares\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t *         reads these back and calculates occlusion.\n\t *         Then _lensFlare.update_lensFlares() is called to re-position and\n\t *         update transparency of flares. Then they are rendered.\n\t *\n\t */\n\n\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\n\n\t\tvar flares = scene.__webglFlares,\n\t\t\tnFlares = flares.length;\n\n\t\tif ( ! nFlares ) return;\n\n\t\tvar tempPosition = new THREE.Vector3();\n\n\t\tvar invAspect = viewportHeight / viewportWidth,\n\t\t\thalfViewportWidth = viewportWidth * 0.5,\n\t\t\thalfViewportHeight = viewportHeight * 0.5;\n\n\t\tvar size = 16 / viewportHeight,\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\n\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\n\n\t\tvar uniforms = _lensFlare.uniforms,\n\t\t\tattributes = _lensFlare.attributes;\n\n\t\t// set _lensFlare program and reset blending\n\n\t\t_gl.useProgram( _lensFlare.program );\n\n\t\t_gl.enableVertexAttribArray( _lensFlare.attributes.vertex );\n\t\t_gl.enableVertexAttribArray( _lensFlare.attributes.uv );\n\n\t\t// loop through all lens flares to update their occlusion and positions\n\t\t// setup gl and common used attribs/unforms\n\n\t\t_gl.uniform1i( uniforms.occlusionMap, 0 );\n\t\t_gl.uniform1i( uniforms.map, 1 );\n\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );\n\t\t_gl.vertexAttribPointer( attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0 );\n\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );\n\n\t\t_gl.disable( _gl.CULL_FACE );\n\t\t_gl.depthMask( false );\n\n\t\tvar i, j, jl, flare, sprite;\n\n\t\tfor ( i = 0; i < nFlares; i ++ ) {\n\n\t\t\tsize = 16 / viewportHeight;\n\t\t\tscale.set( size * invAspect, size );\n\n\t\t\t// calc object screen position\n\n\t\t\tflare = flares[ i ];\n\n\t\t\ttempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );\n\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\n\t\t\t// setup arrays for gl programs\n\n\t\t\tscreenPosition.copy( tempPosition )\n\n\t\t\tscreenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\n\t\t\tscreenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\n\n\t\t\t// screen cull\n\n\t\t\tif ( _lensFlare.hasVertexTexture || (\n\t\t\t\tscreenPositionPixels.x > 0 &&\n\t\t\t\tscreenPositionPixels.x < viewportWidth &&\n\t\t\t\tscreenPositionPixels.y > 0 &&\n\t\t\t\tscreenPositionPixels.y < viewportHeight ) ) {\n\n\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE1 );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\n\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\n\n\n\t\t\t\t// render pink quad\n\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\t_gl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\n\t\t\t\t_gl.disable( _gl.BLEND );\n\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\n\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );\n\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\n\n\n\t\t\t\t// restore graphics\n\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE1 );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// update object positions\n\n\t\t\t\tflare.positionScreen.copy( screenPosition )\n\n\t\t\t\tif ( flare.customUpdateCallback ) {\n\n\t\t\t\t\tflare.customUpdateCallback( flare );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tflare.updateLensFlares();\n\n\t\t\t\t}\n\n\t\t\t\t// render flares\n\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\t_gl.enable( _gl.BLEND );\n\n\t\t\t\tfor ( j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\n\t\t\t\t\tsprite = flare.lensFlares[ j ];\n\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewportHeight;\n\n\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\tscale.y = size;\n\n\t\t\t\t\t\t_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\t_gl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\t_gl.uniform1f( uniforms.rotation, sprite.rotation );\n\n\t\t\t\t\t\t_gl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\t_gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n\t\t\t\t\t\t_renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\t_renderer.setTexture( sprite.texture, 1 );\n\n\t\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore gl\n\n\t\t_gl.enable( _gl.CULL_FACE );\n\t\t_gl.enable( _gl.DEPTH_TEST );\n\t\t_gl.depthMask( true );\n\n\t};\n\n\tfunction createProgram ( shader, precision ) {\n\n\t\tvar program = _gl.createProgram();\n\n\t\tvar fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );\n\t\tvar vertexShader = _gl.createShader( _gl.VERTEX_SHADER );\n\n\t\tvar prefix = \"precision \" + precision + \" float;\\n\";\n\n\t\t_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\t_gl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\n\t\t_gl.compileShader( fragmentShader );\n\t\t_gl.compileShader( vertexShader );\n\n\t\t_gl.attachShader( program, fragmentShader );\n\t\t_gl.attachShader( program, vertexShader );\n\n\t\t_gl.linkProgram( program );\n\n\t\treturn program;\n\n\t};\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ShadowMapPlugin = function () {\n\n\tvar _gl,\n\t_renderer,\n\t_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\n\n\t_frustum = new THREE.Frustum(),\n\t_projScreenMatrix = new THREE.Matrix4(),\n\n\t_min = new THREE.Vector3(),\n\t_max = new THREE.Vector3(),\n\n\t_matrixPosition = new THREE.Vector3();\n\n\tthis.init = function ( renderer ) {\n\n\t\t_gl = renderer.context;\n\t\t_renderer = renderer;\n\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\n\n\t\t_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\n\t\t_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );\n\t\t_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );\n\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );\n\n\t\t_depthMaterial._shadowPass = true;\n\t\t_depthMaterialMorph._shadowPass = true;\n\t\t_depthMaterialSkin._shadowPass = true;\n\t\t_depthMaterialMorphSkin._shadowPass = true;\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( ! ( _renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate ) ) return;\n\n\t\tthis.update( scene, camera );\n\n\t};\n\n\tthis.update = function ( scene, camera ) {\n\n\t\tvar i, il, j, jl, n,\n\n\t\tshadowMap, shadowMatrix, shadowCamera,\n\t\tprogram, buffer, material,\n\t\twebglObject, object, light,\n\t\trenderList,\n\n\t\tlights = [],\n\t\tk = 0,\n\n\t\tfog = null;\n\n\t\t// set GL state for depth map\n\n\t\t_gl.clearColor( 1, 1, 1, 1 );\n\t\t_gl.disable( _gl.BLEND );\n\n\t\t_gl.enable( _gl.CULL_FACE );\n\t\t_gl.frontFace( _gl.CCW );\n\n\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\n\n\t\t\t_gl.cullFace( _gl.FRONT );\n\n\t\t} else {\n\n\t\t\t_gl.cullFace( _gl.BACK );\n\n\t\t}\n\n\t\t_renderer.setDepthTest( true );\n\n\t\t// preprocess lights\n\t\t// \t- skip lights that are not casting shadows\n\t\t//\t- create virtual lights for cascaded shadow maps\n\n\t\tfor ( i = 0, il = scene.__lights.length; i < il; i ++ ) {\n\n\t\t\tlight = scene.__lights[ i ];\n\n\t\t\tif ( ! light.castShadow ) continue;\n\n\t\t\tif ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {\n\n\t\t\t\tfor ( n = 0; n < light.shadowCascadeCount; n ++ ) {\n\n\t\t\t\t\tvar virtualLight;\n\n\t\t\t\t\tif ( ! light.shadowCascadeArray[ n ] ) {\n\n\t\t\t\t\t\tvirtualLight = createVirtualLight( light, n );\n\t\t\t\t\t\tvirtualLight.originalCamera = camera;\n\n\t\t\t\t\t\tvar gyro = new THREE.Gyroscope();\n\t\t\t\t\t\tgyro.position = light.shadowCascadeOffset;\n\n\t\t\t\t\t\tgyro.add( virtualLight );\n\t\t\t\t\t\tgyro.add( virtualLight.target );\n\n\t\t\t\t\t\tcamera.add( gyro );\n\n\t\t\t\t\t\tlight.shadowCascadeArray[ n ] = virtualLight;\n\n\t\t\t\t\t\tconsole.log( \"Created virtualLight\", virtualLight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvirtualLight = light.shadowCascadeArray[ n ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tupdateVirtualLight( light, n );\n\n\t\t\t\t\tlights[ k ] = virtualLight;\n\t\t\t\t\tk ++;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tlights[ k ] = light;\n\t\t\t\tk ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// render depth map\n\n\t\tfor ( i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\tlight = lights[ i ];\n\n\t\t\tif ( ! light.shadowMap ) {\n\n\t\t\t\tvar shadowFilter = THREE.LinearFilter;\n\n\t\t\t\tif ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {\n\n\t\t\t\t\tshadowFilter = THREE.NearestFilter;\n\n\t\t\t\t}\n\n\t\t\t\tvar pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };\n\n\t\t\t\tlight.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );\n\t\t\t\tlight.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );\n\n\t\t\t\tlight.shadowMatrix = new THREE.Matrix4();\n\n\t\t\t}\n\n\t\t\tif ( ! light.shadowCamera ) {\n\n\t\t\t\tif ( light instanceof THREE.SpotLight ) {\n\n\t\t\t\t\tlight.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );\n\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\t\tlight.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( \"Unsupported light type for shadow\" );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( light.shadowCamera );\n\n\t\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\tif ( light.shadowCameraVisible && ! light.cameraHelper ) {\n\n\t\t\t\tlight.cameraHelper = new THREE.CameraHelper( light.shadowCamera );\n\t\t\t\tlight.shadowCamera.add( light.cameraHelper );\n\n\t\t\t}\n\n\t\t\tif ( light.isVirtual && virtualLight.originalCamera == camera ) {\n\n\t\t\t\tupdateShadowCamera( camera, light );\n\n\t\t\t}\n\n\t\t\tshadowMap = light.shadowMap;\n\t\t\tshadowMatrix = light.shadowMatrix;\n\t\t\tshadowCamera = light.shadowCamera;\n\n\t\t\tshadowCamera.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\tshadowCamera.lookAt( _matrixPosition );\n\t\t\tshadowCamera.updateMatrixWorld();\n\n\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\n\t\t\tif ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;\n\t\t\tif ( light.shadowCameraVisible ) light.cameraHelper.update();\n\n\t\t\t// compute shadow matrix\n\n\t\t\tshadowMatrix.set( 0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t\t  0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t\t  0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t\t  0.0, 0.0, 0.0, 1.0 );\n\n\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t// update camera matrices and frustum\n\n\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t// render shadow map\n\n\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t_renderer.clear();\n\n\t\t\t// set object matrices & frustum culling\n\n\t\t\trenderList = scene.__webglObjects;\n\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\t\twebglObject = renderList[ j ];\n\t\t\t\tobject = webglObject.object;\n\n\t\t\t\twebglObject.render = false;\n\n\t\t\t\tif ( object.visible && object.castShadow ) {\n\n\t\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\t\t\twebglObject.render = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// render regular objects\n\n\t\t\tvar objectMaterial, useMorphing, useSkinning;\n\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\t\twebglObject = renderList[ j ];\n\n\t\t\t\tif ( webglObject.render ) {\n\n\t\t\t\t\tobject = webglObject.object;\n\t\t\t\t\tbuffer = webglObject.buffer;\n\n\t\t\t\t\t// culling is overriden globally for all objects\n\t\t\t\t\t// while rendering depth map\n\n\t\t\t\t\t// need to deal with MeshFaceMaterial somehow\n\t\t\t\t\t// in that case just use the first of material.materials for now\n\t\t\t\t\t// (proper solution would require to break objects by materials\n\t\t\t\t\t//  similarly to regular rendering and then set corresponding\n\t\t\t\t\t//  depth materials per each chunk instead of just once per object)\n\n\t\t\t\t\tobjectMaterial = getObjectMaterial( object );\n\n\t\t\t\t\tuseMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\n\t\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\n\n\t\t\t\t\tif ( object.customDepthMaterial ) {\n\n\t\t\t\t\t\tmaterial = object.customDepthMaterial;\n\n\t\t\t\t\t} else if ( useSkinning ) {\n\n\t\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\n\n\t\t\t\t\t} else if ( useMorphing ) {\n\n\t\t\t\t\t\tmaterial = _depthMaterialMorph;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterial = _depthMaterial;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, scene.__lights, fog, material, buffer, object );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_renderer.renderBuffer( shadowCamera, scene.__lights, fog, material, buffer, object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// set matrices and render immediate objects\n\n\t\t\trenderList = scene.__webglObjectsImmediate;\n\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\t\twebglObject = renderList[ j ];\n\t\t\t\tobject = webglObject.object;\n\n\t\t\t\tif ( object.visible && object.castShadow ) {\n\n\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\t\t_renderer.renderImmediateObject( shadowCamera, scene.__lights, fog, _depthMaterial, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore GL state\n\n\t\tvar clearColor = _renderer.getClearColor(),\n\t\tclearAlpha = _renderer.getClearAlpha();\n\n\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\n\t\t_gl.enable( _gl.BLEND );\n\n\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\n\n\t\t\t_gl.cullFace( _gl.BACK );\n\n\t\t}\n\n\t};\n\n\tfunction createVirtualLight( light, cascade ) {\n\n\t\tvar virtualLight = new THREE.DirectionalLight();\n\n\t\tvirtualLight.isVirtual = true;\n\n\t\tvirtualLight.onlyShadow = true;\n\t\tvirtualLight.castShadow = true;\n\n\t\tvirtualLight.shadowCameraNear = light.shadowCameraNear;\n\t\tvirtualLight.shadowCameraFar = light.shadowCameraFar;\n\n\t\tvirtualLight.shadowCameraLeft = light.shadowCameraLeft;\n\t\tvirtualLight.shadowCameraRight = light.shadowCameraRight;\n\t\tvirtualLight.shadowCameraBottom = light.shadowCameraBottom;\n\t\tvirtualLight.shadowCameraTop = light.shadowCameraTop;\n\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\n\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\n\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\n\t\tvirtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];\n\t\tvirtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];\n\n\t\tvirtualLight.pointsWorld = [];\n\t\tvirtualLight.pointsFrustum = [];\n\n\t\tvar pointsWorld = virtualLight.pointsWorld,\n\t\t\tpointsFrustum = virtualLight.pointsFrustum;\n\n\t\tfor ( var i = 0; i < 8; i ++ ) {\n\n\t\t\tpointsWorld[ i ] = new THREE.Vector3();\n\t\t\tpointsFrustum[ i ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\n\n\t\tpointsFrustum[ 0 ].set( -1, -1, nearZ );\n\t\tpointsFrustum[ 1 ].set(  1, -1, nearZ );\n\t\tpointsFrustum[ 2 ].set( -1,  1, nearZ );\n\t\tpointsFrustum[ 3 ].set(  1,  1, nearZ );\n\n\t\tpointsFrustum[ 4 ].set( -1, -1, farZ );\n\t\tpointsFrustum[ 5 ].set(  1, -1, farZ );\n\t\tpointsFrustum[ 6 ].set( -1,  1, farZ );\n\t\tpointsFrustum[ 7 ].set(  1,  1, farZ );\n\n\t\treturn virtualLight;\n\n\t}\n\n\t// Synchronize virtual light with the original light\n\n\tfunction updateVirtualLight( light, cascade ) {\n\n\t\tvar virtualLight = light.shadowCascadeArray[ cascade ];\n\n\t\tvirtualLight.position.copy( light.position );\n\t\tvirtualLight.target.position.copy( light.target.position );\n\t\tvirtualLight.lookAt( virtualLight.target );\n\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\n\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\n\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\n\n\t\tvar pointsFrustum = virtualLight.pointsFrustum;\n\n\t\tpointsFrustum[ 0 ].z = nearZ;\n\t\tpointsFrustum[ 1 ].z = nearZ;\n\t\tpointsFrustum[ 2 ].z = nearZ;\n\t\tpointsFrustum[ 3 ].z = nearZ;\n\n\t\tpointsFrustum[ 4 ].z = farZ;\n\t\tpointsFrustum[ 5 ].z = farZ;\n\t\tpointsFrustum[ 6 ].z = farZ;\n\t\tpointsFrustum[ 7 ].z = farZ;\n\n\t}\n\n\t// Fit shadow camera's ortho frustum to camera frustum\n\n\tfunction updateShadowCamera( camera, light ) {\n\n\t\tvar shadowCamera = light.shadowCamera,\n\t\t\tpointsFrustum = light.pointsFrustum,\n\t\t\tpointsWorld = light.pointsWorld;\n\n\t\t_min.set( Infinity, Infinity, Infinity );\n\t\t_max.set( -Infinity, -Infinity, -Infinity );\n\n\t\tfor ( var i = 0; i < 8; i ++ ) {\n\n\t\t\tvar p = pointsWorld[ i ];\n\n\t\t\tp.copy( pointsFrustum[ i ] );\n\t\t\tTHREE.ShadowMapPlugin.__projector.unprojectVector( p, camera );\n\n\t\t\tp.applyMatrix4( shadowCamera.matrixWorldInverse );\n\n\t\t\tif ( p.x < _min.x ) _min.x = p.x;\n\t\t\tif ( p.x > _max.x ) _max.x = p.x;\n\n\t\t\tif ( p.y < _min.y ) _min.y = p.y;\n\t\t\tif ( p.y > _max.y ) _max.y = p.y;\n\n\t\t\tif ( p.z < _min.z ) _min.z = p.z;\n\t\t\tif ( p.z > _max.z ) _max.z = p.z;\n\n\t\t}\n\n\t\tshadowCamera.left = _min.x;\n\t\tshadowCamera.right = _max.x;\n\t\tshadowCamera.top = _max.y;\n\t\tshadowCamera.bottom = _min.y;\n\n\t\t// can't really fit near/far\n\t\t//shadowCamera.near = _min.z;\n\t\t//shadowCamera.far = _max.z;\n\n\t\tshadowCamera.updateProjectionMatrix();\n\n\t}\n\n\t// For the moment just ignore objects that have multiple materials with different animation methods\n\t// Only the first material will be taken into account for deciding which depth material to use for shadow maps\n\n\tfunction getObjectMaterial( object ) {\n\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\n\t\t\t? object.material.materials[ 0 ]\n\t\t\t: object.material;\n\n\t};\n\n};\n\nTHREE.ShadowMapPlugin.__projector = new THREE.Projector();\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpritePlugin = function () {\n\n\tvar _gl, _renderer, _texture;\n\n\tvar vertices, faces, vertexBuffer, elementBuffer;\n\tvar program, attributes, uniforms;\n\n\tthis.init = function ( renderer ) {\n\n\t\t_gl = renderer.context;\n\t\t_renderer = renderer;\n\n\t\tvertices = new Float32Array( [\n\t\t\t- 0.5, - 0.5, 0, 0, \n\t\t\t  0.5, - 0.5, 1, 0,\n\t\t\t  0.5,   0.5, 1, 1,\n\t\t\t- 0.5,   0.5, 0, 1\n\t\t] );\n\n\t\tfaces = new Uint16Array( [\n\t\t\t0, 1, 2,\n\t\t\t0, 2, 3\n\t\t] );\n\n\t\tvertexBuffer  = _gl.createBuffer();\n\t\telementBuffer = _gl.createBuffer();\n\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );\n\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertices, _gl.STATIC_DRAW );\n\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faces, _gl.STATIC_DRAW );\n\n\t\tprogram = createProgram();\n\n\t\tattributes = {\n\t\t\tposition:\t\t\t_gl.getAttribLocation ( program, 'position' ),\n\t\t\tuv:\t\t\t\t\t_gl.getAttribLocation ( program, 'uv' )\n\t\t};\n\n\t\tuniforms = {\n\t\t\tuvOffset:\t\t\t_gl.getUniformLocation( program, 'uvOffset' ),\n\t\t\tuvScale:\t\t\t_gl.getUniformLocation( program, 'uvScale' ),\n\n\t\t\trotation:\t\t\t_gl.getUniformLocation( program, 'rotation' ),\n\t\t\tscale:\t\t\t\t_gl.getUniformLocation( program, 'scale' ),\n\n\t\t\tcolor:\t\t\t\t_gl.getUniformLocation( program, 'color' ),\n\t\t\tmap:\t\t\t\t_gl.getUniformLocation( program, 'map' ),\n\t\t\topacity:\t\t\t_gl.getUniformLocation( program, 'opacity' ),\n\n\t\t\tmodelViewMatrix: \t_gl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\tprojectionMatrix:\t_gl.getUniformLocation( program, 'projectionMatrix' ),\n\n\t\t\tfogType:\t\t\t_gl.getUniformLocation( program, 'fogType' ),\n\t\t\tfogDensity:\t\t\t_gl.getUniformLocation( program, 'fogDensity' ),\n\t\t\tfogNear:\t\t\t_gl.getUniformLocation( program, 'fogNear' ),\n\t\t\tfogFar:\t\t\t\t_gl.getUniformLocation( program, 'fogFar' ),\n\t\t\tfogColor:\t\t\t_gl.getUniformLocation( program, 'fogColor' ),\n\n\t\t\talphaTest:\t\t\t_gl.getUniformLocation( program, 'alphaTest' )\n\t\t};\n\n\t\tvar canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = 8;\n\t\tcanvas.height = 8;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tcontext.fillStyle = '#ffffff';\n\t\tcontext.fillRect( 0, 0, canvas.width, canvas.height );\n\n\t\t_texture = new THREE.Texture( canvas );\n\t\t_texture.needsUpdate = true;\n\n\t};\n\n\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\n\n\t\tvar sprites = scene.__webglSprites,\n\t\t\tnSprites = sprites.length;\n\n\t\tif ( ! nSprites ) return;\n\n\t\t// setup gl\n\n\t\t_gl.useProgram( program );\n\n\t\t_gl.enableVertexAttribArray( attributes.position );\n\t\t_gl.enableVertexAttribArray( attributes.uv );\n\n\t\t_gl.disable( _gl.CULL_FACE );\n\t\t_gl.enable( _gl.BLEND );\n\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );\n\t\t_gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );\n\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\t_gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\t_gl.activeTexture( _gl.TEXTURE0 );\n\t\t_gl.uniform1i( uniforms.map, 0 );\n\n\t\tvar oldFogType = 0;\n\t\tvar sceneFogType = 0;\n\t\tvar fog = scene.fog;\n\n\t\tif ( fog ) {\n\n\t\t\t_gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\n\t\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\t\t_gl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\t_gl.uniform1f( uniforms.fogFar, fog.far );\n\n\t\t\t\t_gl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\toldFogType = 1;\n\t\t\t\tsceneFogType = 1;\n\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\t\t_gl.uniform1f( uniforms.fogDensity, fog.density );\n\n\t\t\t\t_gl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\toldFogType = 2;\n\t\t\t\tsceneFogType = 2;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.uniform1i( uniforms.fogType, 0 );\n\t\t\toldFogType = 0;\n\t\t\tsceneFogType = 0;\n\n\t\t}\n\n\n\t\t// update positions and sort\n\n\t\tvar i, sprite, material, fogType, scale = [];\n\n\t\tfor( i = 0; i < nSprites; i ++ ) {\n\n\t\t\tsprite = sprites[ i ];\n\t\t\tmaterial = sprite.material;\n\n\t\t\tif ( sprite.visible === false ) continue;\n\n\t\t\tsprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\tsprite.z = - sprite._modelViewMatrix.elements[ 14 ];\n\n\t\t}\n\n\t\tsprites.sort( painterSortStable );\n\n\t\t// render all sprites\n\n\t\tfor( i = 0; i < nSprites; i ++ ) {\n\n\t\t\tsprite = sprites[ i ];\n\n\t\t\tif ( sprite.visible === false ) continue;\n\n\t\t\tmaterial = sprite.material;\n\n\t\t\t_gl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );\n\n\t\t\tscale[ 0 ] = sprite.scale.x;\n\t\t\tscale[ 1 ] = sprite.scale.y;\n\n\t\t\tif ( scene.fog && material.fog ) {\n\n\t\t\t\tfogType = sceneFogType;\n\n\t\t\t} else {\n\n\t\t\t\tfogType = 0;\n\n\t\t\t}\n\n\t\t\tif ( oldFogType !== fogType ) {\n\n\t\t\t\t_gl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\toldFogType = fogType;\n\n\t\t\t}\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\t_gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\t_gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\t_gl.uniform2f( uniforms.uvScale, 1, 1 );\n\n\t\t\t}\n\n\t\t\t_gl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\t_gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\n\t\t\t_gl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\t_gl.uniform2fv( uniforms.scale, scale );\n\n\t\t\t_renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\t_renderer.setDepthTest( material.depthTest );\n\t\t\t_renderer.setDepthWrite( material.depthWrite );\n\n\t\t\tif ( material.map && material.map.image && material.map.image.width ) {\n\n\t\t\t\t_renderer.setTexture( material.map, 0 );\n\n\t\t\t} else {\n\n\t\t\t\t_renderer.setTexture( _texture, 0 );\n\n\t\t\t}\n\n\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\n\t\t}\n\n\t\t// restore gl\n\n\t\t_gl.enable( _gl.CULL_FACE );\n\n\t};\n\n\tfunction createProgram () {\n\n\t\tvar program = _gl.createProgram();\n\n\t\tvar vertexShader = _gl.createShader( _gl.VERTEX_SHADER );\n\t\tvar fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );\n\n\t\t_gl.shaderSource( vertexShader, [\n\n\t\t\t'precision ' + _renderer.getPrecision() + ' float;',\n\n\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform float rotation;',\n\t\t\t'uniform vec2 scale;',\n\t\t\t'uniform vec2 uvOffset;',\n\t\t\t'uniform vec2 uvScale;',\n\n\t\t\t'attribute vec2 position;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\n\t\t\t\t'vec2 alignedPosition = position * scale;',\n\n\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\n\t\t\t\t'vec4 finalPosition;',\n\n\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\n\t\t\t\t'gl_Position = finalPosition;',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ) );\n\n\t\t_gl.shaderSource( fragmentShader, [\n\n\t\t\t'precision ' + _renderer.getPrecision() + ' float;',\n\n\t\t\t'uniform vec3 color;',\n\t\t\t'uniform sampler2D map;',\n\t\t\t'uniform float opacity;',\n\n\t\t\t'uniform int fogType;',\n\t\t\t'uniform vec3 fogColor;',\n\t\t\t'uniform float fogDensity;',\n\t\t\t'uniform float fogNear;',\n\t\t\t'uniform float fogFar;',\n\t\t\t'uniform float alphaTest;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\n\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\n\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\n\t\t\t\t'if ( fogType > 0 ) {',\n\n\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t'float fogFactor = 0.0;',\n\n\t\t\t\t\t'if ( fogType == 1 ) {',\n\n\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\n\t\t\t\t\t'} else {',\n\n\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\n\t\t\t\t\t'}',\n\n\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\n\t\t\t\t'}',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ) );\n\n\t\t_gl.compileShader( vertexShader );\n\t\t_gl.compileShader( fragmentShader );\n\n\t\t_gl.attachShader( program, vertexShader );\n\t\t_gl.attachShader( program, fragmentShader );\n\n\t\t_gl.linkProgram( program );\n\n\t\treturn program;\n\n\t};\n\n\tfunction painterSortStable ( a, b ) {\n\n\t\tif ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn b.id - a.id;\n\n\t\t}\n\n\t};\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DepthPassPlugin = function () {\n\n\tthis.enabled = false;\n\tthis.renderTarget = null;\n\n\tvar _gl,\n\t_renderer,\n\t_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\n\n\t_frustum = new THREE.Frustum(),\n\t_projScreenMatrix = new THREE.Matrix4();\n\n\tthis.init = function ( renderer ) {\n\n\t\t_gl = renderer.context;\n\t\t_renderer = renderer;\n\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\n\n\t\t_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\n\t\t_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );\n\t\t_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );\n\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );\n\n\t\t_depthMaterial._shadowPass = true;\n\t\t_depthMaterialMorph._shadowPass = true;\n\t\t_depthMaterialSkin._shadowPass = true;\n\t\t_depthMaterialMorphSkin._shadowPass = true;\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( ! this.enabled ) return;\n\n\t\tthis.update( scene, camera );\n\n\t};\n\n\tthis.update = function ( scene, camera ) {\n\n\t\tvar i, il, j, jl, n,\n\n\t\tprogram, buffer, material,\n\t\twebglObject, object, light,\n\t\trenderList,\n\n\t\tfog = null;\n\n\t\t// set GL state for depth map\n\n\t\t_gl.clearColor( 1, 1, 1, 1 );\n\t\t_gl.disable( _gl.BLEND );\n\n\t\t_renderer.setDepthTest( true );\n\n\t\t// update scene\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t// render depth map\n\n\t\t_renderer.setRenderTarget( this.renderTarget );\n\t\t_renderer.clear();\n\n\t\t// set object matrices & frustum culling\n\n\t\trenderList = scene.__webglObjects;\n\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\twebglObject = renderList[ j ];\n\t\t\tobject = webglObject.object;\n\n\t\t\twebglObject.render = false;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\t\twebglObject.render = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// render regular objects\n\n\t\tvar objectMaterial, useMorphing, useSkinning;\n\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\twebglObject = renderList[ j ];\n\n\t\t\tif ( webglObject.render ) {\n\n\t\t\t\tobject = webglObject.object;\n\t\t\t\tbuffer = webglObject.buffer;\n\n\t\t\t\t// todo: create proper depth material for particles\n\n\t\t\t\tif ( object instanceof THREE.ParticleSystem && !object.customDepthMaterial ) continue;\n\n\t\t\t\tobjectMaterial = getObjectMaterial( object );\n\n\t\t\t\tif ( objectMaterial ) _renderer.setMaterialFaces( object.material );\n\n\t\t\t\tuseMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\n\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\n\n\t\t\t\tif ( object.customDepthMaterial ) {\n\n\t\t\t\t\tmaterial = object.customDepthMaterial;\n\n\t\t\t\t} else if ( useSkinning ) {\n\n\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\n\n\t\t\t\t} else if ( useMorphing ) {\n\n\t\t\t\t\tmaterial = _depthMaterialMorph;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial = _depthMaterial;\n\n\t\t\t\t}\n\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t_renderer.renderBufferDirect( camera, scene.__lights, fog, material, buffer, object );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_renderer.renderBuffer( camera, scene.__lights, fog, material, buffer, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// set matrices and render immediate objects\n\n\t\trenderList = scene.__webglObjectsImmediate;\n\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\twebglObject = renderList[ j ];\n\t\t\tobject = webglObject.object;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\t_renderer.renderImmediateObject( camera, scene.__lights, fog, _depthMaterial, object );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore GL state\n\n\t\tvar clearColor = _renderer.getClearColor(),\n\t\tclearAlpha = _renderer.getClearAlpha();\n\n\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\n\t\t_gl.enable( _gl.BLEND );\n\n\t};\n\n\t// For the moment just ignore objects that have multiple materials with different animation methods\n\t// Only the first material will be taken into account for deciding which depth material to use\n\n\tfunction getObjectMaterial( object ) {\n\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\n\t\t\t? object.material.materials[ 0 ]\n\t\t\t: object.material;\n\n\t};\n\n};\n\n\n/**\n * @author mikael emtinger / http://gomo.se/\n */\n\nTHREE.ShaderFlares = {\n\n\t'lensFlareVertexTexture': {\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\"uniform vec2 scale;\",\n\t\t\t\"uniform float rotation;\",\n\n\t\t\t\"uniform sampler2D occlusionMap;\",\n\n\t\t\t\"attribute vec2 position;\",\n\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\"if( renderType == 2 ) {\",\n\n\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\n\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\"uniform sampler2D map;\",\n\t\t\t\"uniform float opacity;\",\n\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t// pink square\n\n\t\t\t\t\"if( renderType == 0 ) {\",\n\n\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n\t\t\t\t// restore\n\n\t\t\t\t\"} else if( renderType == 1 ) {\",\n\n\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t// flare\n\n\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\n\t},\n\n\n\t'lensFlare': {\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\"uniform vec2 scale;\",\n\t\t\t\"uniform float rotation;\",\n\n\t\t\t\"attribute vec2 position;\",\n\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\"if( renderType == 2 ) {\",\n\n\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"precision mediump float;\",\n\n\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\"uniform sampler2D map;\",\n\t\t\t\"uniform sampler2D occlusionMap;\",\n\t\t\t\"uniform float opacity;\",\n\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t// pink square\n\n\t\t\t\t\"if( renderType == 0 ) {\",\n\n\t\t\t\t\t\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\n\n\t\t\t\t// restore\n\n\t\t\t\t\"} else if( renderType == 1 ) {\",\n\n\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t// flare\n\n\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\n\t\t\t\t\t\"visibility = ( 1.0 - visibility / 4.0 );\",\n\n\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\"texture.a *= opacity * visibility;\",\n\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t}\n\n};\n\n",
      "content": "/**\n * @author mrdoob / http://mrdoob.com/\n * @author Larry Battle / http://bateru.com/news\n * @author bhouston / http://exocortex.com\n */\n\nvar THREE = { REVISION: '65' };\n\nself.console = self.console || {\n\n\tinfo: function () {},\n\tlog: function () {},\n\tdebug: function () {},\n\twarn: function () {},\n\terror: function () {}\n\n};\n\nString.prototype.trim = String.prototype.trim || function () {\n\n\treturn this.replace( /^\\s+|\\s+$/g, '' );\n\n};\n\n// based on https://github.com/documentcloud/underscore/blob/bf657be243a075b5e72acc8a83e6f12a564d8f55/underscore.js#L767\nTHREE.extend = function ( obj, source ) {\n\n\t// ECMAScript5 compatibility based on: http://www.nczonline.net/blog/2012/12/11/are-your-mixins-ecmascript-5-compatible/\n\tif ( Object.keys ) {\n\n\t\tvar keys = Object.keys( source );\n\n\t\tfor (var i = 0, il = keys.length; i < il; i++) {\n\n\t\t\tvar prop = keys[i];\n\t\t\tObject.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );\n\n\t\t}\n\n\t} else {\n\n\t\tvar safeHasOwnProperty = {}.hasOwnProperty;\n\n\t\tfor ( var prop in source ) {\n\n\t\t\tif ( safeHasOwnProperty.call( source, prop ) ) {\n\n\t\t\t\tobj[prop] = source[prop];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn obj;\n\n};\n\n// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\n\n// requestAnimationFrame polyfill by Erik Mller\n// fixes from Paul Irish and Tino Zijdel\n// using 'self' instead of 'window' for compatibility with both NodeJS and IE10.\n( function () {\n\n\tvar lastTime = 0;\n\tvar vendors = [ 'ms', 'moz', 'webkit', 'o' ];\n\n\tfor ( var x = 0; x < vendors.length && !self.requestAnimationFrame; ++ x ) {\n\n\t\tself.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];\n\t\tself.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];\n\n\t}\n\n\tif ( self.requestAnimationFrame === undefined && self['setTimeout'] !== undefined ) {\n\n\t\tself.requestAnimationFrame = function ( callback ) {\n\n\t\t\tvar currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );\n\t\t\tvar id = self.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );\n\t\t\tlastTime = currTime + timeToCall;\n\t\t\treturn id;\n\n\t\t};\n\n\t}\n\n\tif( self.cancelAnimationFrame === undefined && self['clearTimeout'] !== undefined ) {\n\n\t\tself.cancelAnimationFrame = function ( id ) { self.clearTimeout( id ) };\n\n\t}\n\n}() );\n\n// GL STATE CONSTANTS\n\nTHREE.CullFaceNone = 0;\nTHREE.CullFaceBack = 1;\nTHREE.CullFaceFront = 2;\nTHREE.CullFaceFrontBack = 3;\n\nTHREE.FrontFaceDirectionCW = 0;\nTHREE.FrontFaceDirectionCCW = 1;\n\n// SHADOWING TYPES\n\nTHREE.BasicShadowMap = 0;\nTHREE.PCFShadowMap = 1;\nTHREE.PCFSoftShadowMap = 2;\n\n// MATERIAL CONSTANTS\n\n// side\n\nTHREE.FrontSide = 0;\nTHREE.BackSide = 1;\nTHREE.DoubleSide = 2;\n\n// shading\n\nTHREE.NoShading = 0;\nTHREE.FlatShading = 1;\nTHREE.SmoothShading = 2;\n\n// colors\n\nTHREE.NoColors = 0;\nTHREE.FaceColors = 1;\nTHREE.VertexColors = 2;\n\n// blending modes\n\nTHREE.NoBlending = 0;\nTHREE.NormalBlending = 1;\nTHREE.AdditiveBlending = 2;\nTHREE.SubtractiveBlending = 3;\nTHREE.MultiplyBlending = 4;\nTHREE.CustomBlending = 5;\n\n// custom blending equations\n// (numbers start from 100 not to clash with other\n//  mappings to OpenGL constants defined in Texture.js)\n\nTHREE.AddEquation = 100;\nTHREE.SubtractEquation = 101;\nTHREE.ReverseSubtractEquation = 102;\n\n// custom blending destination factors\n\nTHREE.ZeroFactor = 200;\nTHREE.OneFactor = 201;\nTHREE.SrcColorFactor = 202;\nTHREE.OneMinusSrcColorFactor = 203;\nTHREE.SrcAlphaFactor = 204;\nTHREE.OneMinusSrcAlphaFactor = 205;\nTHREE.DstAlphaFactor = 206;\nTHREE.OneMinusDstAlphaFactor = 207;\n\n// custom blending source factors\n\n//THREE.ZeroFactor = 200;\n//THREE.OneFactor = 201;\n//THREE.SrcAlphaFactor = 204;\n//THREE.OneMinusSrcAlphaFactor = 205;\n//THREE.DstAlphaFactor = 206;\n//THREE.OneMinusDstAlphaFactor = 207;\nTHREE.DstColorFactor = 208;\nTHREE.OneMinusDstColorFactor = 209;\nTHREE.SrcAlphaSaturateFactor = 210;\n\n\n// TEXTURE CONSTANTS\n\nTHREE.MultiplyOperation = 0;\nTHREE.MixOperation = 1;\nTHREE.AddOperation = 2;\n\n// Mapping modes\n\nTHREE.UVMapping = function () {};\n\nTHREE.CubeReflectionMapping = function () {};\nTHREE.CubeRefractionMapping = function () {};\n\nTHREE.SphericalReflectionMapping = function () {};\nTHREE.SphericalRefractionMapping = function () {};\n\n// Wrapping modes\n\nTHREE.RepeatWrapping = 1000;\nTHREE.ClampToEdgeWrapping = 1001;\nTHREE.MirroredRepeatWrapping = 1002;\n\n// Filters\n\nTHREE.NearestFilter = 1003;\nTHREE.NearestMipMapNearestFilter = 1004;\nTHREE.NearestMipMapLinearFilter = 1005;\nTHREE.LinearFilter = 1006;\nTHREE.LinearMipMapNearestFilter = 1007;\nTHREE.LinearMipMapLinearFilter = 1008;\n\n// Data types\n\nTHREE.UnsignedByteType = 1009;\nTHREE.ByteType = 1010;\nTHREE.ShortType = 1011;\nTHREE.UnsignedShortType = 1012;\nTHREE.IntType = 1013;\nTHREE.UnsignedIntType = 1014;\nTHREE.FloatType = 1015;\n\n// Pixel types\n\n//THREE.UnsignedByteType = 1009;\nTHREE.UnsignedShort4444Type = 1016;\nTHREE.UnsignedShort5551Type = 1017;\nTHREE.UnsignedShort565Type = 1018;\n\n// Pixel formats\n\nTHREE.AlphaFormat = 1019;\nTHREE.RGBFormat = 1020;\nTHREE.RGBAFormat = 1021;\nTHREE.LuminanceFormat = 1022;\nTHREE.LuminanceAlphaFormat = 1023;\n\n// Compressed texture formats\n\nTHREE.RGB_S3TC_DXT1_Format = 2001;\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\n\n/*\n// Potential future PVRTC compressed texture formats\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\n*/\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Color = function ( value ) {\n\n\tif ( value !== undefined ) this.set( value );\n\n\treturn this;\n\n};\n\nTHREE.Color.prototype = {\n\n\tconstructor: THREE.Color,\n\n\tr: 1, g: 1, b: 1,\n\n\tset: function ( value ) {\n\n\t\tif ( value instanceof THREE.Color ) {\n\n\t\t\tthis.copy( value );\n\n\t\t} else if ( typeof value === 'number' ) {\n\n\t\t\tthis.setHex( value );\n\n\t\t} else if ( typeof value === 'string' ) {\n\n\t\t\tthis.setStyle( value );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetHex: function ( hex ) {\n\n\t\thex = Math.floor( hex );\n\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\n\t\tthis.b = ( hex & 255 ) / 255;\n\n\t\treturn this;\n\n\t},\n\n\tsetRGB: function ( r, g, b ) {\n\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\n\t\treturn this;\n\n\t},\n\n\tsetHSL: function ( h, s, l ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tif ( s === 0 ) {\n\n\t\t\tthis.r = this.g = this.b = l;\n\n\t\t} else {\n\n\t\t\tvar hue2rgb = function ( p, q, t ) {\n\n\t\t\t\tif ( t < 0 ) t += 1;\n\t\t\t\tif ( t > 1 ) t -= 1;\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\n\t\t\t\tif ( t < 1 / 2 ) return q;\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\n\t\t\t\treturn p;\n\n\t\t\t};\n\n\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\n\t\t\tvar q = ( 2 * l ) - p;\n\n\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\n\t\t\tthis.g = hue2rgb( q, p, h );\n\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetStyle: function ( style ) {\n\n\t\t// rgb(255,0,0)\n\n\t\tif ( /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.test( style ) ) {\n\n\t\t\tvar color = /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.exec( style );\n\n\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\n\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\n\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// rgb(100%,0%,0%)\n\n\t\tif ( /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.test( style ) ) {\n\n\t\t\tvar color = /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.exec( style );\n\n\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\n\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\n\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// #ff0000\n\n\t\tif ( /^\\#([0-9a-f]{6})$/i.test( style ) ) {\n\n\t\t\tvar color = /^\\#([0-9a-f]{6})$/i.exec( style );\n\n\t\t\tthis.setHex( parseInt( color[ 1 ], 16 ) );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// #f00\n\n\t\tif ( /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {\n\n\t\t\tvar color = /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );\n\n\t\t\tthis.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\t// red\n\n\t\tif ( /^(\\w+)$/i.test( style ) ) {\n\n\t\t\tthis.setHex( THREE.ColorKeywords[ style ] );\n\n\t\t\treturn this;\n\n\t\t}\n\n\n\t},\n\n\tcopy: function ( color ) {\n\n\t\tthis.r = color.r;\n\t\tthis.g = color.g;\n\t\tthis.b = color.b;\n\n\t\treturn this;\n\n\t},\n\n\tcopyGammaToLinear: function ( color ) {\n\n\t\tthis.r = color.r * color.r;\n\t\tthis.g = color.g * color.g;\n\t\tthis.b = color.b * color.b;\n\n\t\treturn this;\n\n\t},\n\n\tcopyLinearToGamma: function ( color ) {\n\n\t\tthis.r = Math.sqrt( color.r );\n\t\tthis.g = Math.sqrt( color.g );\n\t\tthis.b = Math.sqrt( color.b );\n\n\t\treturn this;\n\n\t},\n\n\tconvertGammaToLinear: function () {\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tthis.r = r * r;\n\t\tthis.g = g * g;\n\t\tthis.b = b * b;\n\n\t\treturn this;\n\n\t},\n\n\tconvertLinearToGamma: function () {\n\n\t\tthis.r = Math.sqrt( this.r );\n\t\tthis.g = Math.sqrt( this.g );\n\t\tthis.b = Math.sqrt( this.b );\n\n\t\treturn this;\n\n\t},\n\n\tgetHex: function () {\n\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\n\n\t},\n\n\tgetHexString: function () {\n\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\n\n\t},\n\n\tgetHSL: function ( optionalTarget ) {\n\n\t\t// h,s,l ranges are in 0.0 - 1.0\n\n\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\n\n\t\tvar r = this.r, g = this.g, b = this.b;\n\n\t\tvar max = Math.max( r, g, b );\n\t\tvar min = Math.min( r, g, b );\n\n\t\tvar hue, saturation;\n\t\tvar lightness = ( min + max ) / 2.0;\n\n\t\tif ( min === max ) {\n\n\t\t\thue = 0;\n\t\t\tsaturation = 0;\n\n\t\t} else {\n\n\t\t\tvar delta = max - min;\n\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\n\n\t\t\tswitch ( max ) {\n\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\n\n\t\t\t}\n\n\t\t\thue /= 6;\n\n\t\t}\n\n\t\thsl.h = hue;\n\t\thsl.s = saturation;\n\t\thsl.l = lightness;\n\n\t\treturn hsl;\n\n\t},\n\n\tgetStyle: function () {\n\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\n\n\t},\n\n\toffsetHSL: function ( h, s, l ) {\n\n\t\tvar hsl = this.getHSL();\n\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\n\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( color ) {\n\n\t\tthis.r += color.r;\n\t\tthis.g += color.g;\n\t\tthis.b += color.b;\n\n\t\treturn this;\n\n\t},\n\n\taddColors: function ( color1, color2 ) {\n\n\t\tthis.r = color1.r + color2.r;\n\t\tthis.g = color1.g + color2.g;\n\t\tthis.b = color1.b + color2.b;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.r += s;\n\t\tthis.g += s;\n\t\tthis.b += s;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( color ) {\n\n\t\tthis.r *= color.r;\n\t\tthis.g *= color.g;\n\t\tthis.b *= color.b;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.r *= s;\n\t\tthis.g *= s;\n\t\tthis.b *= s;\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( color, alpha ) {\n\n\t\tthis.r += ( color.r - this.r ) * alpha;\n\t\tthis.g += ( color.g - this.g ) * alpha;\n\t\tthis.b += ( color.b - this.b ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( c ) {\n\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.r = array[ 0 ];\n\t\tthis.g = array[ 1 ];\n\t\tthis.b = array[ 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\treturn [ this.r, this.g, this.b ];\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Color().setRGB( this.r, this.g, this.b );\n\n\t}\n\n};\n\nTHREE.ColorKeywords = { \"aliceblue\": 0xF0F8FF, \"antiquewhite\": 0xFAEBD7, \"aqua\": 0x00FFFF, \"aquamarine\": 0x7FFFD4, \"azure\": 0xF0FFFF,\n\"beige\": 0xF5F5DC, \"bisque\": 0xFFE4C4, \"black\": 0x000000, \"blanchedalmond\": 0xFFEBCD, \"blue\": 0x0000FF, \"blueviolet\": 0x8A2BE2,\n\"brown\": 0xA52A2A, \"burlywood\": 0xDEB887, \"cadetblue\": 0x5F9EA0, \"chartreuse\": 0x7FFF00, \"chocolate\": 0xD2691E, \"coral\": 0xFF7F50,\n\"cornflowerblue\": 0x6495ED, \"cornsilk\": 0xFFF8DC, \"crimson\": 0xDC143C, \"cyan\": 0x00FFFF, \"darkblue\": 0x00008B, \"darkcyan\": 0x008B8B,\n\"darkgoldenrod\": 0xB8860B, \"darkgray\": 0xA9A9A9, \"darkgreen\": 0x006400, \"darkgrey\": 0xA9A9A9, \"darkkhaki\": 0xBDB76B, \"darkmagenta\": 0x8B008B,\n\"darkolivegreen\": 0x556B2F, \"darkorange\": 0xFF8C00, \"darkorchid\": 0x9932CC, \"darkred\": 0x8B0000, \"darksalmon\": 0xE9967A, \"darkseagreen\": 0x8FBC8F,\n\"darkslateblue\": 0x483D8B, \"darkslategray\": 0x2F4F4F, \"darkslategrey\": 0x2F4F4F, \"darkturquoise\": 0x00CED1, \"darkviolet\": 0x9400D3,\n\"deeppink\": 0xFF1493, \"deepskyblue\": 0x00BFFF, \"dimgray\": 0x696969, \"dimgrey\": 0x696969, \"dodgerblue\": 0x1E90FF, \"firebrick\": 0xB22222,\n\"floralwhite\": 0xFFFAF0, \"forestgreen\": 0x228B22, \"fuchsia\": 0xFF00FF, \"gainsboro\": 0xDCDCDC, \"ghostwhite\": 0xF8F8FF, \"gold\": 0xFFD700,\n\"goldenrod\": 0xDAA520, \"gray\": 0x808080, \"green\": 0x008000, \"greenyellow\": 0xADFF2F, \"grey\": 0x808080, \"honeydew\": 0xF0FFF0, \"hotpink\": 0xFF69B4,\n\"indianred\": 0xCD5C5C, \"indigo\": 0x4B0082, \"ivory\": 0xFFFFF0, \"khaki\": 0xF0E68C, \"lavender\": 0xE6E6FA, \"lavenderblush\": 0xFFF0F5, \"lawngreen\": 0x7CFC00,\n\"lemonchiffon\": 0xFFFACD, \"lightblue\": 0xADD8E6, \"lightcoral\": 0xF08080, \"lightcyan\": 0xE0FFFF, \"lightgoldenrodyellow\": 0xFAFAD2, \"lightgray\": 0xD3D3D3,\n\"lightgreen\": 0x90EE90, \"lightgrey\": 0xD3D3D3, \"lightpink\": 0xFFB6C1, \"lightsalmon\": 0xFFA07A, \"lightseagreen\": 0x20B2AA, \"lightskyblue\": 0x87CEFA,\n\"lightslategray\": 0x778899, \"lightslategrey\": 0x778899, \"lightsteelblue\": 0xB0C4DE, \"lightyellow\": 0xFFFFE0, \"lime\": 0x00FF00, \"limegreen\": 0x32CD32,\n\"linen\": 0xFAF0E6, \"magenta\": 0xFF00FF, \"maroon\": 0x800000, \"mediumaquamarine\": 0x66CDAA, \"mediumblue\": 0x0000CD, \"mediumorchid\": 0xBA55D3,\n\"mediumpurple\": 0x9370DB, \"mediumseagreen\": 0x3CB371, \"mediumslateblue\": 0x7B68EE, \"mediumspringgreen\": 0x00FA9A, \"mediumturquoise\": 0x48D1CC,\n\"mediumvioletred\": 0xC71585, \"midnightblue\": 0x191970, \"mintcream\": 0xF5FFFA, \"mistyrose\": 0xFFE4E1, \"moccasin\": 0xFFE4B5, \"navajowhite\": 0xFFDEAD,\n\"navy\": 0x000080, \"oldlace\": 0xFDF5E6, \"olive\": 0x808000, \"olivedrab\": 0x6B8E23, \"orange\": 0xFFA500, \"orangered\": 0xFF4500, \"orchid\": 0xDA70D6,\n\"palegoldenrod\": 0xEEE8AA, \"palegreen\": 0x98FB98, \"paleturquoise\": 0xAFEEEE, \"palevioletred\": 0xDB7093, \"papayawhip\": 0xFFEFD5, \"peachpuff\": 0xFFDAB9,\n\"peru\": 0xCD853F, \"pink\": 0xFFC0CB, \"plum\": 0xDDA0DD, \"powderblue\": 0xB0E0E6, \"purple\": 0x800080, \"red\": 0xFF0000, \"rosybrown\": 0xBC8F8F,\n\"royalblue\": 0x4169E1, \"saddlebrown\": 0x8B4513, \"salmon\": 0xFA8072, \"sandybrown\": 0xF4A460, \"seagreen\": 0x2E8B57, \"seashell\": 0xFFF5EE,\n\"sienna\": 0xA0522D, \"silver\": 0xC0C0C0, \"skyblue\": 0x87CEEB, \"slateblue\": 0x6A5ACD, \"slategray\": 0x708090, \"slategrey\": 0x708090, \"snow\": 0xFFFAFA,\n\"springgreen\": 0x00FF7F, \"steelblue\": 0x4682B4, \"tan\": 0xD2B48C, \"teal\": 0x008080, \"thistle\": 0xD8BFD8, \"tomato\": 0xFF6347, \"turquoise\": 0x40E0D0,\n\"violet\": 0xEE82EE, \"wheat\": 0xF5DEB3, \"white\": 0xFFFFFF, \"whitesmoke\": 0xF5F5F5, \"yellow\": 0xFFFF00, \"yellowgreen\": 0x9ACD32 };\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Quaternion = function ( x, y, z, w ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Quaternion.prototype = {\n\n\tconstructor: THREE.Quaternion,\n\n\t_x: 0,_y: 0, _z: 0, _w: 0,\n\n\t_euler: undefined,\n\n\t_updateEuler: function ( callback ) {\n\n\t\tif ( this._euler !== undefined ) {\n\n\t\t\tthis._euler.setFromQuaternion( this, undefined, false );\n\n\t\t}\n\n\t},\n\n\tget x () {\n\n\t\treturn this._x;\n\n\t},\n\n\tset x ( value ) {\n\n\t\tthis._x = value;\n\t\tthis._updateEuler();\n\n\t},\n\n\tget y () {\n\n\t\treturn this._y;\n\n\t},\n\n\tset y ( value ) {\n\n\t\tthis._y = value;\n\t\tthis._updateEuler();\n\n\t},\n\n\tget z () {\n\n\t\treturn this._z;\n\n\t},\n\n\tset z ( value ) {\n\n\t\tthis._z = value;\n\t\tthis._updateEuler();\n\n\t},\n\n\tget w () {\n\n\t\treturn this._w;\n\n\t},\n\n\tset w ( value ) {\n\n\t\tthis._w = value;\n\t\tthis._updateEuler();\n\n\t},\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._w = w;\n\n\t\tthis._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( quaternion ) {\n\n\t\tthis._x = quaternion._x;\n\t\tthis._y = quaternion._y;\n\t\tthis._z = quaternion._z;\n\t\tthis._w = quaternion._w;\n\n\t\tthis._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromEuler: function ( euler, update ) {\n\n\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\tthrow new Error( 'ERROR: Quaternion\\'s .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );\n\t\t}\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n\t\t//\tcontent/SpinCalc.m\n\n\t\tvar c1 = Math.cos( euler._x / 2 );\n\t\tvar c2 = Math.cos( euler._y / 2 );\n\t\tvar c3 = Math.cos( euler._z / 2 );\n\t\tvar s1 = Math.sin( euler._x / 2 );\n\t\tvar s2 = Math.sin( euler._y / 2 );\n\t\tvar s3 = Math.sin( euler._z / 2 );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\n\n\t\t}\n\n\t\tif ( update !== false ) this._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromAxisAngle: function ( axis, angle ) {\n\n\t\t// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\t\t// axis have to be normalized\n\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\t\tthis._x = axis.x * s;\n\t\tthis._y = axis.y * s;\n\t\tthis._z = axis.z * s;\n\t\tthis._w = Math.cos( halfAngle );\n\n\t\tthis._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar te = m.elements,\n\n\t\t\tm11 = te[0], m12 = te[4], m13 = te[8],\n\t\t\tm21 = te[1], m22 = te[5], m23 = te[9],\n\t\t\tm31 = te[2], m32 = te[6], m33 = te[10],\n\n\t\t\ttrace = m11 + m22 + m33,\n\t\t\ts;\n\n\t\tif ( trace > 0 ) {\n\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\t\tthis._w = 0.25 / s;\n\t\t\tthis._x = ( m32 - m23 ) * s;\n\t\t\tthis._y = ( m13 - m31 ) * s;\n\t\t\tthis._z = ( m21 - m12 ) * s;\n\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\t\tthis._w = (m32 - m23 ) / s;\n\t\t\tthis._x = 0.25 * s;\n\t\t\tthis._y = (m12 + m21 ) / s;\n\t\t\tthis._z = (m13 + m31 ) / s;\n\n\t\t} else if ( m22 > m33 ) {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\t\tthis._w = (m13 - m31 ) / s;\n\t\t\tthis._x = (m12 + m21 ) / s;\n\t\t\tthis._y = 0.25 * s;\n\t\t\tthis._z = (m23 + m32 ) / s;\n\n\t\t} else {\n\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\t\tthis._w = ( m21 - m12 ) / s;\n\t\t\tthis._x = ( m13 + m31 ) / s;\n\t\t\tthis._y = ( m23 + m32 ) / s;\n\t\t\tthis._z = 0.25 * s;\n\n\t\t}\n\n\t\tthis._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\tinverse: function () {\n\n\t\tthis.conjugate().normalize();\n\n\t\treturn this;\n\n\t},\n\n\tconjugate: function () {\n\n\t\tthis._x *= -1;\n\t\tthis._y *= -1;\n\t\tthis._z *= -1;\n\n\t\tthis._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\tvar l = this.length();\n\n\t\tif ( l === 0 ) {\n\n\t\t\tthis._x = 0;\n\t\t\tthis._y = 0;\n\t\t\tthis._z = 0;\n\t\t\tthis._w = 1;\n\n\t\t} else {\n\n\t\t\tl = 1 / l;\n\n\t\t\tthis._x = this._x * l;\n\t\t\tthis._y = this._y * l;\n\t\t\tthis._z = this._z * l;\n\t\t\tthis._w = this._w * l;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( q, p ) {\n\n\t\tif ( p !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Quaternion\\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\n\t\t\treturn this.multiplyQuaternions( q, p );\n\n\t\t}\n\n\t\treturn this.multiplyQuaternions( this, q );\n\n\t},\n\n\tmultiplyQuaternions: function ( a, b ) {\n\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\t\tthis._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVector3: function ( vector ) {\n\n\t\tconsole.warn( 'DEPRECATED: Quaternion\\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\n\t\treturn vector.applyQuaternion( this );\n\n\t},\n\n\tslerp: function ( qb, t ) {\n\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\n\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\n\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n\n\t\tif ( cosHalfTheta < 0 ) {\n\n\t\t\tthis._w = -qb._w;\n\t\t\tthis._x = -qb._x;\n\t\t\tthis._y = -qb._y;\n\t\t\tthis._z = -qb._z;\n\n\t\t\tcosHalfTheta = -cosHalfTheta;\n\n\t\t} else {\n\n\t\t\tthis.copy( qb );\n\n\t\t}\n\n\t\tif ( cosHalfTheta >= 1.0 ) {\n\n\t\t\tthis._w = w;\n\t\t\tthis._x = x;\n\t\t\tthis._y = y;\n\t\t\tthis._z = z;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar halfTheta = Math.acos( cosHalfTheta );\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\n\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\n\n\t\t\tthis._w = 0.5 * ( w + this._w );\n\t\t\tthis._x = 0.5 * ( x + this._x );\n\t\t\tthis._y = 0.5 * ( y + this._y );\n\t\t\tthis._z = 0.5 * ( z + this._z );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\n\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\n\n\t\tthis._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( quaternion ) {\n\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tthis._w = array[ 3 ];\n\n\t\tthis._updateEuler();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\treturn [ this._x, this._y, this._z, this._w ];\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Quaternion( this._x, this._y, this._z, this._w );\n\n\t}\n\n};\n\nTHREE.Quaternion.slerp = function ( qa, qb, qm, t ) {\n\n\treturn qm.copy( qa ).slerp( qb, t );\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author philogb / http://blog.thejit.org/\n * @author egraether / http://egraether.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.Vector2 = function ( x, y ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\n};\n\nTHREE.Vector2.prototype = {\n\n\tconstructor: THREE.Vector2,\n\n\tset: function ( x, y ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector2\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector2\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tthis.x *= s;\n\t\tthis.y *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\tif ( scalar !== 0 ) {\n\n\t\t\tvar invScalar = 1 / scalar;\n\n\t\t\tthis.x *= invScalar;\n\t\t\tthis.y *= invScalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tif ( this.x > v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y > v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tif ( this.x < v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y < v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tif ( this.x < min.x ) {\n\n\t\t\tthis.x = min.x;\n\n\t\t} else if ( this.x > max.x ) {\n\n\t\t\tthis.x = max.x;\n\n\t\t}\n\n\t\tif ( this.y < min.y ) {\n\n\t\t\tthis.y = min.y;\n\n\t\t} else if ( this.y > max.y ) {\n\n\t\t\tthis.y = max.y;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function() {\n\n\t\treturn this.multiplyScalar( - 1 );\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\n\t\treturn dx * dx + dy * dy;\n\n\t},\n\n\tsetLength: function ( l ) {\n\n\t\tvar oldLength = this.length();\n\n\t\tif ( oldLength !== 0 && l !== oldLength ) {\n\n\t\t\tthis.multiplyScalar( l / oldLength );\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.x = array[ 0 ];\n\t\tthis.y = array[ 1 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\treturn [ this.x, this.y ];\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Vector2( this.x, this.y );\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author *kile / http://kile.stravaganza.org/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector3 = function ( x, y, z ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\n};\n\nTHREE.Vector3.prototype = {\n\n\tconstructor: THREE.Vector3,\n\n\tset: function ( x, y, z ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiply: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t\t\treturn this.multiplyVectors( v, w );\n\n\t\t}\n\n\t\tthis.x *= v.x;\n\t\tthis.y *= v.y;\n\t\tthis.z *= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVectors: function ( a, b ) {\n\n\t\tthis.x = a.x * b.x;\n\t\tthis.y = a.y * b.y;\n\t\tthis.z = a.z * b.z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix3: function ( m ) {\n\n\t\tvar x = this.x;\n\t\tvar y = this.y;\n\t\tvar z = this.z;\n\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[0] * x + e[3] * y + e[6] * z;\n\t\tthis.y = e[1] * x + e[4] * y + e[7] * z;\n\t\tthis.z = e[2] * x + e[5] * y + e[8] * z;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[0] * x + e[4] * y + e[8]  * z + e[12];\n\t\tthis.y = e[1] * x + e[5] * y + e[9]  * z + e[13];\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14];\n\n\t\treturn this;\n\n\t},\n\n\tapplyProjection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 projection matrix\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tvar e = m.elements;\n\t\tvar d = 1 / ( e[3] * x + e[7] * y + e[11] * z + e[15] ); // perspective divide\n\n\t\tthis.x = ( e[0] * x + e[4] * y + e[8]  * z + e[12] ) * d;\n\t\tthis.y = ( e[1] * x + e[5] * y + e[9]  * z + e[13] ) * d;\n\t\tthis.z = ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;\n\n\t\treturn this;\n\n\t},\n\n\tapplyQuaternion: function ( q ) {\n\n\t\tvar x = this.x;\n\t\tvar y = this.y;\n\t\tvar z = this.z;\n\n\t\tvar qx = q.x;\n\t\tvar qy = q.y;\n\t\tvar qz = q.z;\n\t\tvar qw = q.w;\n\n\t\t// calculate quat * vector\n\n\t\tvar ix =  qw * x + qy * z - qz * y;\n\t\tvar iy =  qw * y + qz * x - qx * z;\n\t\tvar iz =  qw * z + qx * y - qy * x;\n\t\tvar iw = -qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\n\t\tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n\t\tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n\t\tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n\t\treturn this;\n\n\t},\n\n\ttransformDirection: function ( m ) {\n\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[0] * x + e[4] * y + e[8]  * z;\n\t\tthis.y = e[1] * x + e[5] * y + e[9]  * z;\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z;\n\n\t\tthis.normalize();\n\n\t\treturn this;\n\n\t},\n\n\tdivide: function ( v ) {\n\n\t\tthis.x /= v.x;\n\t\tthis.y /= v.y;\n\t\tthis.z /= v.z;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\tif ( scalar !== 0 ) {\n\n\t\t\tvar invScalar = 1 / scalar;\n\n\t\t\tthis.x *= invScalar;\n\t\t\tthis.y *= invScalar;\n\t\t\tthis.z *= invScalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tif ( this.x > v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y > v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\tif ( this.z > v.z ) {\n\n\t\t\tthis.z = v.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tif ( this.x < v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y < v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\tif ( this.z < v.z ) {\n\n\t\t\tthis.z = v.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tif ( this.x < min.x ) {\n\n\t\t\tthis.x = min.x;\n\n\t\t} else if ( this.x > max.x ) {\n\n\t\t\tthis.x = max.x;\n\n\t\t}\n\n\t\tif ( this.y < min.y ) {\n\n\t\t\tthis.y = min.y;\n\n\t\t} else if ( this.y > max.y ) {\n\n\t\t\tthis.y = max.y;\n\n\t\t}\n\n\t\tif ( this.z < min.z ) {\n\n\t\t\tthis.z = min.z;\n\n\t\t} else if ( this.z > max.z ) {\n\n\t\t\tthis.z = max.z;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\treturn this.multiplyScalar( - 1 );\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( l ) {\n\n\t\tvar oldLength = this.length();\n\n\t\tif ( oldLength !== 0 && l !== oldLength  ) {\n\n\t\t\tthis.multiplyScalar( l / oldLength );\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tcross: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector3\\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t\treturn this.crossVectors( v, w );\n\n\t\t}\n\n\t\tvar x = this.x, y = this.y, z = this.z;\n\n\t\tthis.x = y * v.z - z * v.y;\n\t\tthis.y = z * v.x - x * v.z;\n\t\tthis.z = x * v.y - y * v.x;\n\n\t\treturn this;\n\n\t},\n\n\tcrossVectors: function ( a, b ) {\n\n\t\tvar ax = a.x, ay = a.y, az = a.z;\n\t\tvar bx = b.x, by = b.y, bz = b.z;\n\n\t\tthis.x = ay * bz - az * by;\n\t\tthis.y = az * bx - ax * bz;\n\t\tthis.z = ax * by - ay * bx;\n\n\t\treturn this;\n\n\t},\n\n\tangleTo: function ( v ) {\n\n\t\tvar theta = this.dot( v ) / ( this.length() * v.length() );\n\n\t\t// clamp, to handle numerical problems\n\n\t\treturn Math.acos( THREE.Math.clamp( theta, -1, 1 ) );\n\n\t},\n\n\tdistanceTo: function ( v ) {\n\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\n\n\t},\n\n\tdistanceToSquared: function ( v ) {\n\n\t\tvar dx = this.x - v.x;\n\t\tvar dy = this.y - v.y;\n\t\tvar dz = this.z - v.z;\n\n\t\treturn dx * dx + dy * dy + dz * dz;\n\n\t},\n\n\tsetEulerFromRotationMatrix: function ( m, order ) {\n\n\t\tconsole.error( \"REMOVED: Vector3\\'s setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.\");\n\n\t},\n\n\tsetEulerFromQuaternion: function ( q, order ) {\n\n\t\tconsole.error( \"REMOVED: Vector3\\'s setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.\");\n\n\t},\n\n\tgetPositionFromMatrix: function ( m ) {\n\n\t\tconsole.warn( \"DEPRECATED: Vector3\\'s .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code.\" );\n\n\t\treturn this.setFromMatrixPosition( m );\n\n\t},\n\n\tgetScaleFromMatrix: function ( m ) {\n\n\t\tconsole.warn( \"DEPRECATED: Vector3\\'s .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code.\" );\n\n\t\treturn this.setFromMatrixScale( m );\n\t},\n\n\tgetColumnFromMatrix: function ( index, matrix ) {\n\n\t\tconsole.warn( \"DEPRECATED: Vector3\\'s .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code.\" );\n\n\t\treturn this.setFromMatrixColumn( index, matrix );\n\n\t},\n\n\tsetFromMatrixPosition: function ( m ) {\n\n\t\tthis.x = m.elements[ 12 ];\n\t\tthis.y = m.elements[ 13 ];\n\t\tthis.z = m.elements[ 14 ];\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrixScale: function ( m ) {\n\n\t\tvar sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();\n\t\tvar sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();\n\t\tvar sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();\n\n\t\tthis.x = sx;\n\t\tthis.y = sy;\n\t\tthis.z = sz;\n\n\t\treturn this;\n\t},\n\n\tsetFromMatrixColumn: function ( index, matrix ) {\n\n\t\tvar offset = index * 4;\n\n\t\tvar me = matrix.elements;\n\n\t\tthis.x = me[ offset ];\n\t\tthis.y = me[ offset + 1 ];\n\t\tthis.z = me[ offset + 2 ];\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.x = array[ 0 ];\n\t\tthis.y = array[ 1 ];\n\t\tthis.z = array[ 2 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\treturn [ this.x, this.y, this.z ];\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Vector3( this.x, this.y, this.z );\n\n\t}\n\n};\n\nTHREE.extend( THREE.Vector3.prototype, {\n\n\tapplyEuler: function () {\n\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function ( euler ) {\n\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\t\tconsole.error( 'ERROR: Vector3\\'s .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );\n\n\t\t\t}\n\n\t\t\tthis.applyQuaternion( quaternion.setFromEuler( euler ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tapplyAxisAngle: function () {\n\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\treturn function ( axis, angle ) {\n\n\t\t\tthis.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tprojectOnVector: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( vector ) {\n\n\t\t\tv1.copy( vector ).normalize();\n\t\t\tvar d = this.dot( v1 );\n\t\t\treturn this.copy( v1 ).multiplyScalar( d );\n\n\t\t};\n\n\t}(),\n\n\tprojectOnPlane: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( planeNormal ) {\n\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\n\n\t\t\treturn this.sub( v1 );\n\n\t\t}\n\n\t}(),\n\n\treflect: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( vector ) {\n\n\t\t    v1.copy( this ).projectOnVector( vector ).multiplyScalar( 2 );\n\n\t\t    return this.subVectors( v1, this );\n\n\t\t}\n\n\t}()\n\n} );\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Vector4 = function ( x, y, z, w ) {\n\n\tthis.x = x || 0;\n\tthis.y = y || 0;\n\tthis.z = z || 0;\n\tthis.w = ( w !== undefined ) ? w : 1;\n\n};\n\nTHREE.Vector4.prototype = {\n\n\tconstructor: THREE.Vector4,\n\n\tset: function ( x, y, z, w ) {\n\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetX: function ( x ) {\n\n\t\tthis.x = x;\n\n\t\treturn this;\n\n\t},\n\n\tsetY: function ( y ) {\n\n\t\tthis.y = y;\n\n\t\treturn this;\n\n\t},\n\n\tsetZ: function ( z ) {\n\n\t\tthis.z = z;\n\n\t\treturn this;\n\n\t},\n\n\tsetW: function ( w ) {\n\n\t\tthis.w = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponent: function ( index, value ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: this.x = value; break;\n\t\t\tcase 1: this.y = value; break;\n\t\t\tcase 2: this.z = value; break;\n\t\t\tcase 3: this.w = value; break;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tgetComponent: function ( index ) {\n\n\t\tswitch ( index ) {\n\n\t\t\tcase 0: return this.x;\n\t\t\tcase 1: return this.y;\n\t\t\tcase 2: return this.z;\n\t\t\tcase 3: return this.w;\n\t\t\tdefault: throw new Error( \"index is out of range: \" + index );\n\n\t\t}\n\n\t},\n\n\tcopy: function ( v ) {\n\n\t\tthis.x = v.x;\n\t\tthis.y = v.y;\n\t\tthis.z = v.z;\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\n\n\t\treturn this;\n\n\t},\n\n\tadd: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector4\\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\n\t\t\treturn this.addVectors( v, w );\n\n\t\t}\n\n\t\tthis.x += v.x;\n\t\tthis.y += v.y;\n\t\tthis.z += v.z;\n\t\tthis.w += v.w;\n\n\t\treturn this;\n\n\t},\n\n\taddScalar: function ( s ) {\n\n\t\tthis.x += s;\n\t\tthis.y += s;\n\t\tthis.z += s;\n\t\tthis.w += s;\n\n\t\treturn this;\n\n\t},\n\n\taddVectors: function ( a, b ) {\n\n\t\tthis.x = a.x + b.x;\n\t\tthis.y = a.y + b.y;\n\t\tthis.z = a.z + b.z;\n\t\tthis.w = a.w + b.w;\n\n\t\treturn this;\n\n\t},\n\n\tsub: function ( v, w ) {\n\n\t\tif ( w !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Vector4\\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t\treturn this.subVectors( v, w );\n\n\t\t}\n\n\t\tthis.x -= v.x;\n\t\tthis.y -= v.y;\n\t\tthis.z -= v.z;\n\t\tthis.w -= v.w;\n\n\t\treturn this;\n\n\t},\n\n\tsubVectors: function ( a, b ) {\n\n\t\tthis.x = a.x - b.x;\n\t\tthis.y = a.y - b.y;\n\t\tthis.z = a.z - b.z;\n\t\tthis.w = a.w - b.w;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( scalar ) {\n\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\tthis.w *= scalar;\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function ( m ) {\n\n\t\tvar x = this.x;\n\t\tvar y = this.y;\n\t\tvar z = this.z;\n\t\tvar w = this.w;\n\n\t\tvar e = m.elements;\n\n\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n\t\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n\n\t\treturn this;\n\n\t},\n\n\tdivideScalar: function ( scalar ) {\n\n\t\tif ( scalar !== 0 ) {\n\n\t\t\tvar invScalar = 1 / scalar;\n\n\t\t\tthis.x *= invScalar;\n\t\t\tthis.y *= invScalar;\n\t\t\tthis.z *= invScalar;\n\t\t\tthis.w *= invScalar;\n\n\t\t} else {\n\n\t\t\tthis.x = 0;\n\t\t\tthis.y = 0;\n\t\t\tthis.z = 0;\n\t\t\tthis.w = 1;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetAxisAngleFromQuaternion: function ( q ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t\t// q is assumed to be normalized\n\n\t\tthis.w = 2 * Math.acos( q.w );\n\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\n\n\t\tif ( s < 0.0001 ) {\n\n\t\t\t this.x = 1;\n\t\t\t this.y = 0;\n\t\t\t this.z = 0;\n\n\t\t} else {\n\n\t\t\t this.x = q.x / s;\n\t\t\t this.y = q.y / s;\n\t\t\t this.z = q.z / s;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\n\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tvar angle, x, y, z,\t\t// variables for result\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\n\n\t\t\tte = m.elements,\n\n\t\t\tm11 = te[0], m12 = te[4], m13 = te[8],\n\t\t\tm21 = te[1], m22 = te[5], m23 = te[9],\n\t\t\tm31 = te[2], m32 = te[6], m33 = te[10];\n\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon )\n\t\t  && ( Math.abs( m13 - m31 ) < epsilon )\n\t\t  && ( Math.abs( m23 - m32 ) < epsilon ) ) {\n\n\t\t\t// singularity found\n\t\t\t// first check for identity matrix which must have +1 for all terms\n\t\t\t// in leading diagonal and zero in other terms\n\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 )\n\t\t\t  && ( Math.abs( m13 + m31 ) < epsilon2 )\n\t\t\t  && ( Math.abs( m23 + m32 ) < epsilon2 )\n\t\t\t  && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\n\n\t\t\t\t// this singularity is identity matrix so angle = 0\n\n\t\t\t\tthis.set( 1, 0, 0, 0 );\n\n\t\t\t\treturn this; // zero angle, arbitrary axis\n\n\t\t\t}\n\n\t\t\t// otherwise this singularity is angle = 180\n\n\t\t\tangle = Math.PI;\n\n\t\t\tvar xx = ( m11 + 1 ) / 2;\n\t\t\tvar yy = ( m22 + 1 ) / 2;\n\t\t\tvar zz = ( m33 + 1 ) / 2;\n\t\t\tvar xy = ( m12 + m21 ) / 4;\n\t\t\tvar xz = ( m13 + m31 ) / 4;\n\t\t\tvar yz = ( m23 + m32 ) / 4;\n\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term\n\n\t\t\t\tif ( xx < epsilon ) {\n\n\t\t\t\t\tx = 0;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tx = Math.sqrt( xx );\n\t\t\t\t\ty = xy / x;\n\t\t\t\t\tz = xz / x;\n\n\t\t\t\t}\n\n\t\t\t} else if ( yy > zz ) { // m22 is the largest diagonal term\n\n\t\t\t\tif ( yy < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0;\n\t\t\t\t\tz = 0.707106781;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ty = Math.sqrt( yy );\n\t\t\t\t\tx = xy / y;\n\t\t\t\t\tz = yz / y;\n\n\t\t\t\t}\n\n\t\t\t} else { // m33 is the largest diagonal term so base result on this\n\n\t\t\t\tif ( zz < epsilon ) {\n\n\t\t\t\t\tx = 0.707106781;\n\t\t\t\t\ty = 0.707106781;\n\t\t\t\t\tz = 0;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tz = Math.sqrt( zz );\n\t\t\t\t\tx = xz / z;\n\t\t\t\t\ty = yz / z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.set( x, y, z, angle );\n\n\t\t\treturn this; // return 180 deg rotation\n\n\t\t}\n\n\t\t// as we have reached here there are no singularities so we can handle normally\n\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\n\t\t\t\t\t\t + ( m13 - m31 ) * ( m13 - m31 )\n\t\t\t\t\t\t + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\n\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\n\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t\t// caught by singularity test above, but I've left it in just in case\n\n\t\tthis.x = ( m32 - m23 ) / s;\n\t\tthis.y = ( m13 - m31 ) / s;\n\t\tthis.z = ( m21 - m12 ) / s;\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\n\n\t\treturn this;\n\n\t},\n\n\tmin: function ( v ) {\n\n\t\tif ( this.x > v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y > v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\tif ( this.z > v.z ) {\n\n\t\t\tthis.z = v.z;\n\n\t\t}\n\n\t\tif ( this.w > v.w ) {\n\n\t\t\tthis.w = v.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tmax: function ( v ) {\n\n\t\tif ( this.x < v.x ) {\n\n\t\t\tthis.x = v.x;\n\n\t\t}\n\n\t\tif ( this.y < v.y ) {\n\n\t\t\tthis.y = v.y;\n\n\t\t}\n\n\t\tif ( this.z < v.z ) {\n\n\t\t\tthis.z = v.z;\n\n\t\t}\n\n\t\tif ( this.w < v.w ) {\n\n\t\t\tthis.w = v.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tclamp: function ( min, max ) {\n\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\n\n\t\tif ( this.x < min.x ) {\n\n\t\t\tthis.x = min.x;\n\n\t\t} else if ( this.x > max.x ) {\n\n\t\t\tthis.x = max.x;\n\n\t\t}\n\n\t\tif ( this.y < min.y ) {\n\n\t\t\tthis.y = min.y;\n\n\t\t} else if ( this.y > max.y ) {\n\n\t\t\tthis.y = max.y;\n\n\t\t}\n\n\t\tif ( this.z < min.z ) {\n\n\t\t\tthis.z = min.z;\n\n\t\t} else if ( this.z > max.z ) {\n\n\t\t\tthis.z = max.z;\n\n\t\t}\n\n\t\tif ( this.w < min.w ) {\n\n\t\t\tthis.w = min.w;\n\n\t\t} else if ( this.w > max.w ) {\n\n\t\t\tthis.w = max.w;\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function() {\n\n\t\treturn this.multiplyScalar( -1 );\n\n\t},\n\n\tdot: function ( v ) {\n\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n\n\t},\n\n\tlengthSq: function () {\n\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\n\t},\n\n\tlength: function () {\n\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\n\n\t},\n\n\tlengthManhattan: function () {\n\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\n\n\t},\n\n\tnormalize: function () {\n\n\t\treturn this.divideScalar( this.length() );\n\n\t},\n\n\tsetLength: function ( l ) {\n\n\t\tvar oldLength = this.length();\n\n\t\tif ( oldLength !== 0 && l !== oldLength ) {\n\n\t\t\tthis.multiplyScalar( l / oldLength );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tlerp: function ( v, alpha ) {\n\n\t\tthis.x += ( v.x - this.x ) * alpha;\n\t\tthis.y += ( v.y - this.y ) * alpha;\n\t\tthis.z += ( v.z - this.z ) * alpha;\n\t\tthis.w += ( v.w - this.w ) * alpha;\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( v ) {\n\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.x = array[ 0 ];\n\t\tthis.y = array[ 1 ];\n\t\tthis.z = array[ 2 ];\n\t\tthis.w = array[ 3 ];\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\treturn [ this.x, this.y, this.z, this.w ];\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Vector4( this.x, this.y, this.z, this.w );\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Euler = function ( x, y, z, order ) {\n\n\tthis._x = x || 0;\n\tthis._y = y || 0;\n\tthis._z = z || 0;\n\tthis._order = order || THREE.Euler.DefaultOrder;\n\n};\n\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\n\nTHREE.Euler.DefaultOrder = 'XYZ';\n\nTHREE.Euler.prototype = {\n\n\tconstructor: THREE.Euler,\n\n\t_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,\n\n\t_quaternion: undefined,\n\n\t_updateQuaternion: function () {\n\n\t\tif ( this._quaternion !== undefined ) {\n\n\t\t\tthis._quaternion.setFromEuler( this, false );\n\n\t\t}\n\n\t},\n\n\tget x () {\n\n\t\treturn this._x;\n\n\t},\n\n\tset x ( value ) {\n\n\t\tthis._x = value;\n\t\tthis._updateQuaternion();\n\n\t},\n\n\tget y () {\n\n\t\treturn this._y;\n\n\t},\n\n\tset y ( value ) {\n\n\t\tthis._y = value;\n\t\tthis._updateQuaternion();\n\n\t},\n\n\tget z () {\n\n\t\treturn this._z;\n\n\t},\n\n\tset z ( value ) {\n\n\t\tthis._z = value;\n\t\tthis._updateQuaternion();\n\n\t},\n\n\tget order () {\n\n\t\treturn this._order;\n\n\t},\n\n\tset order ( value ) {\n\n\t\tthis._order = value;\n\t\tthis._updateQuaternion();\n\n\t},\n\n\tset: function ( x, y, z, order ) {\n\n\t\tthis._x = x;\n\t\tthis._y = y;\n\t\tthis._z = z;\n\t\tthis._order = order || this._order;\n\n\t\tthis._updateQuaternion();\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( euler ) {\n\n\t\tthis._x = euler._x;\n\t\tthis._y = euler._y;\n\t\tthis._z = euler._z;\n\t\tthis._order = euler._order;\n\n\t\tthis._updateQuaternion();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromRotationMatrix: function ( m, order ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\t// clamp, to handle numerical problems\n\n\t\tfunction clamp( x ) {\n\n\t\t\treturn Math.min( Math.max( x, -1 ), 1 );\n\n\t\t}\n\n\t\tvar te = m.elements;\n\t\tvar m11 = te[0], m12 = te[4], m13 = te[8];\n\t\tvar m21 = te[1], m22 = te[5], m23 = te[9];\n\t\tvar m31 = te[2], m32 = te[6], m33 = te[10];\n\n\t\torder = order || this._order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._y = Math.asin( clamp( m13 ) );\n\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'YXZ' ) {\n\n\t\t\tthis._x = Math.asin( - clamp( m23 ) );\n\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\t\t\t\tthis._z = 0;\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = Math.asin( clamp( m32 ) );\n\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\n\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._y = 0;\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._y = Math.asin( - clamp( m31 ) );\n\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._z = Math.asin( clamp( m21 ) );\n\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = 0;\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\n\n\t\t\t}\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._z = Math.asin( - clamp( m12 ) );\n\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\n\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\n\n\t\t\t} else {\n\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\n\t\t\t\tthis._y = 0;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'WARNING: Euler.setFromRotationMatrix() given unsupported order: ' + order )\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tthis._updateQuaternion();\n\n\t\treturn this;\n\n\t},\n\n\tsetFromQuaternion: function ( q, order, update ) {\n\n\t\t// q is assumed to be normalized\n\n\t\t// clamp, to handle numerical problems\n\n\t\tfunction clamp( x ) {\n\n\t\t\treturn Math.min( Math.max( x, -1 ), 1 );\n\n\t\t}\n\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m\n\n\t\tvar sqx = q.x * q.x;\n\t\tvar sqy = q.y * q.y;\n\t\tvar sqz = q.z * q.z;\n\t\tvar sqw = q.w * q.w;\n\n\t\torder = order || this._order;\n\n\t\tif ( order === 'XYZ' ) {\n\n\t\t\tthis._x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );\n\t\t\tthis._y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ) ) );\n\t\t\tthis._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );\n\n\t\t} else if ( order ===  'YXZ' ) {\n\n\t\t\tthis._x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ) ) );\n\t\t\tthis._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );\n\t\t\tthis._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );\n\n\t\t} else if ( order === 'ZXY' ) {\n\n\t\t\tthis._x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ) ) );\n\t\t\tthis._y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );\n\t\t\tthis._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );\n\n\t\t} else if ( order === 'ZYX' ) {\n\n\t\t\tthis._x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );\n\t\t\tthis._y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ) ) );\n\t\t\tthis._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );\n\n\t\t} else if ( order === 'YZX' ) {\n\n\t\t\tthis._x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );\n\t\t\tthis._y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );\n\t\t\tthis._z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ) ) );\n\n\t\t} else if ( order === 'XZY' ) {\n\n\t\t\tthis._x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );\n\t\t\tthis._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );\n\t\t\tthis._z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ) ) );\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'WARNING: Euler.setFromQuaternion() given unsupported order: ' + order )\n\n\t\t}\n\n\t\tthis._order = order;\n\n\t\tif ( update !== false ) this._updateQuaternion();\n\n\t\treturn this;\n\n\t},\n\n\treorder: function () {\n\n\t\t// WARNING: this discards revolution information -bhouston\n\n\t\tvar q = new THREE.Quaternion();\n\n\t\treturn function ( newOrder ) {\n\n\t\t\tq.setFromEuler( this );\n\t\t\tthis.setFromQuaternion( q, newOrder );\n\n\t\t};\n\n\n\t}(),\n\n\tfromArray: function ( array ) {\n\n\t\tthis._x = array[ 0 ];\n\t\tthis._y = array[ 1 ];\n\t\tthis._z = array[ 2 ];\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\n\n\t\tthis._updateQuaternion();\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\treturn [ this._x, this._y, this._z, this._order ];\n\n\t},\n\n\tequals: function ( euler ) {\n\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Euler( this._x, this._y, this._z, this._order );\n\n\t}\n\n};\n\n/**\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Line3 = function ( start, end ) {\n\n\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\n\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\n\n};\n\nTHREE.Line3.prototype = {\n\n\tconstructor: THREE.Line3,\n\n\tset: function ( start, end ) {\n\n\t\tthis.start.copy( start );\n\t\tthis.end.copy( end );\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( line ) {\n\n\t\tthis.start.copy( line.start );\n\t\tthis.end.copy( line.end );\n\n\t\treturn this;\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\n\n\t},\n\n\tdelta: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.end, this.start );\n\n\t},\n\n\tdistanceSq: function () {\n\n\t\treturn this.start.distanceToSquared( this.end );\n\n\t},\n\n\tdistance: function () {\n\n\t\treturn this.start.distanceTo( this.end );\n\n\t},\n\n\tat: function ( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tclosestPointToPointParameter: function() {\n\n\t\tvar startP = new THREE.Vector3();\n\t\tvar startEnd = new THREE.Vector3();\n\n\t\treturn function ( point, clampToLine ) {\n\n\t\t\tstartP.subVectors( point, this.start );\n\t\t\tstartEnd.subVectors( this.end, this.start );\n\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\n\n\t\t\tvar t = startEnd_startP / startEnd2;\n\n\t\t\tif ( clampToLine ) {\n\n\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\n\n\t\t\t}\n\n\t\t\treturn t;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\n\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.start.applyMatrix4( matrix );\n\t\tthis.end.applyMatrix4( matrix );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( line ) {\n\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Line3().copy( this );\n\n\t}\n\n};\n\n/**\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Box2 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );\n\n};\n\nTHREE.Box2.prototype = {\n\n\tconstructor: THREE.Box2,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tif ( points.length > 0 ) {\n\n\t\t\tvar point = points[ 0 ];\n\n\t\t\tthis.min.copy( point );\n\t\t\tthis.max.copy( point );\n\n\t\t\tfor ( var i = 1, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tpoint = points[ i ];\n\n\t\t\t\tif ( point.x < this.min.x ) {\n\n\t\t\t\t\tthis.min.x = point.x;\n\n\t\t\t\t} else if ( point.x > this.max.x ) {\n\n\t\t\t\t\tthis.max.x = point.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( point.y < this.min.y ) {\n\n\t\t\t\t\tthis.min.y = point.y;\n\n\t\t\t\t} else if ( point.y > this.max.y ) {\n\n\t\t\t\t\tthis.max.y = point.y;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.makeEmpty();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function () {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function ( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = Infinity;\n\t\tthis.max.x = this.max.y = -Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( -scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\n\t\treturn result.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\n\t\t);\n\n\t},\n\n\tisIntersectionBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector2();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector2();\n\n\t\treturn function ( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Box2().copy( this );\n\n\t}\n\n};\n\n/**\n * @author bhouston / http://exocortex.com\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Box3 = function ( min, max ) {\n\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );\n\n};\n\nTHREE.Box3.prototype = {\n\n\tconstructor: THREE.Box3,\n\n\tset: function ( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t},\n\n\taddPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x ) {\n\n\t\t\tthis.min.x = point.x;\n\n\t\t} else if ( point.x > this.max.x ) {\n\n\t\t\tthis.max.x = point.x;\n\n\t\t}\n\n\t\tif ( point.y < this.min.y ) {\n\n\t\t\tthis.min.y = point.y;\n\n\t\t} else if ( point.y > this.max.y ) {\n\n\t\t\tthis.max.y = point.y;\n\n\t\t}\n\n\t\tif ( point.z < this.min.z ) {\n\n\t\t\tthis.min.z = point.z;\n\n\t\t} else if ( point.z > this.max.z ) {\n\n\t\t\tthis.max.z = point.z;\n\n\t\t}\n\n\t},\n\n\tsetFromPoints: function ( points ) {\n\n\t\tif ( points.length > 0 ) {\n\n\t\t\tvar point = points[ 0 ];\n\n\t\t\tthis.min.copy( point );\n\t\t\tthis.max.copy( point );\n\n\t\t\tfor ( var i = 1, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tthis.addPoint( points[ i ] )\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.makeEmpty();\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCenterAndSize: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( center, size ) {\n\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\n\n\t\t\tthis.min.copy( center ).sub( halfSize );\n\t\t\tthis.max.copy( center ).add( halfSize );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tsetFromObject: function() {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and childrens', world transforms\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function( object ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\tif ( node.geometry !== undefined && node.geometry.vertices !== undefined ) {\n\n\t\t\t\t\tvar vertices = node.geometry.vertices;\n\n\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i++ ) {\n\n\t\t\t\t\t\tv1.copy( vertices[ i ] );\n\n\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\tscope.expandByPoint( v1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tcopy: function ( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tmakeEmpty: function () {\n\n\t\tthis.min.x = this.min.y = this.min.z = Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = -Infinity;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t},\n\n\tcenter: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t},\n\n\tsize: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.subVectors( this.max, this.min );\n\n\t},\n\n\texpandByPoint: function ( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t},\n\n\texpandByVector: function ( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t},\n\n\texpandByScalar: function ( scalar ) {\n\n\t\tthis.min.addScalar( -scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\n\t\t     point.y < this.min.y || point.y > this.max.y ||\n\t\t     point.z < this.min.z || point.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tcontainsBox: function ( box ) {\n\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tgetParameter: function ( point, optionalTarget ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t},\n\n\tisIntersectionBox: function ( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t     box.max.z < this.min.z || box.min.z > this.max.z ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( point ).clamp( this.min, this.max );\n\n\t},\n\n\tdistanceToPoint: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( point ) {\n\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\n\t\t\treturn clampedPoint.sub( point ).length();\n\n\t\t};\n\n\t}(),\n\n\tgetBoundingSphere: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\n\n\t\t\tresult.center = this.center();\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\n\n\t\t\treturn result;\n\n\t\t};\n\n\t}(),\n\n\tintersect: function ( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tunion: function ( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t},\n\n\tapplyMatrix4: function() {\n\n\t\tvar points = [\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3(),\n\t\t\tnew THREE.Vector3()\n\t\t];\n\n\t\treturn function ( matrix ) {\n\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t\tpoints[0].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t\tpoints[1].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t\tpoints[2].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t\tpoints[3].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t\tpoints[4].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t\tpoints[5].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t\tpoints[6].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t\tpoints[7].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111\n\n\t\t\tthis.makeEmpty();\n\t\t\tthis.setFromPoints( points );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Box3().copy( this );\n\n\t}\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Matrix3 = function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\tthis.elements = new Float32Array(9);\n\n\tthis.set(\n\n\t\t( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0,\n\t\tn21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0,\n\t\tn31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1\n\n\t);\n};\n\nTHREE.Matrix3.prototype = {\n\n\tconstructor: THREE.Matrix3,\n\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[0] = n11; te[3] = n12; te[6] = n13;\n\t\tte[1] = n21; te[4] = n22; te[7] = n23;\n\t\tte[2] = n31; te[5] = n32; te[8] = n33;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0,\n\t\t\t0, 1, 0,\n\t\t\t0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tvar me = m.elements;\n\n\t\tthis.set(\n\n\t\t\tme[0], me[3], me[6],\n\t\t\tme[1], me[4], me[7],\n\t\t\tme[2], me[5], me[8]\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVector3: function ( vector ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix3\\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\n\t\treturn vector.applyMatrix3( this );\n\n\t},\n\n\tmultiplyVector3Array: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( a ) {\n\n\t\t\tfor ( var i = 0, il = a.length; i < il; i += 3 ) {\n\n\t\t\t\tv1.x = a[ i ];\n\t\t\t\tv1.y = a[ i + 1 ];\n\t\t\t\tv1.z = a[ i + 2 ];\n\n\t\t\t\tv1.applyMatrix3(this);\n\n\t\t\t\ta[ i ]     = v1.x;\n\t\t\t\ta[ i + 1 ] = v1.y;\n\t\t\t\ta[ i + 2 ] = v1.z;\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t};\n\n\t}(),\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[0] *= s; te[3] *= s; te[6] *= s;\n\t\tte[1] *= s; te[4] *= s; te[7] *= s;\n\t\tte[2] *= s; te[5] *= s; te[8] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar a = te[0], b = te[1], c = te[2],\n\t\t\td = te[3], e = te[4], f = te[5],\n\t\t\tg = te[6], h = te[7], i = te[8];\n\n\t\treturn a*e*i - a*f*h - b*d*i + b*f*g + c*d*h - c*e*g;\n\n\t},\n\n\tgetInverse: function ( matrix, throwOnInvertible ) {\n\n\t\t// input: THREE.Matrix4\n\t\t// ( based on http://code.google.com/p/webgl-mjs/ )\n\n\t\tvar me = matrix.elements;\n\t\tvar te = this.elements;\n\n\t\tte[ 0 ] =   me[10] * me[5] - me[6] * me[9];\n\t\tte[ 1 ] = - me[10] * me[1] + me[2] * me[9];\n\t\tte[ 2 ] =   me[6] * me[1] - me[2] * me[5];\n\t\tte[ 3 ] = - me[10] * me[4] + me[6] * me[8];\n\t\tte[ 4 ] =   me[10] * me[0] - me[2] * me[8];\n\t\tte[ 5 ] = - me[6] * me[0] + me[2] * me[4];\n\t\tte[ 6 ] =   me[9] * me[4] - me[5] * me[8];\n\t\tte[ 7 ] = - me[9] * me[0] + me[1] * me[8];\n\t\tte[ 8 ] =   me[5] * me[0] - me[1] * me[4];\n\n\t\tvar det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];\n\n\t\t// no inverse\n\n\t\tif ( det === 0 ) {\n\n\t\t\tvar msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnInvertible || false ) {\n\n\t\t\t\tthrow new Error( msg );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\tthis.identity();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tthis.multiplyScalar( 1.0 / det );\n\n\t\treturn this;\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar tmp, m = this.elements;\n\n\t\ttmp = m[1]; m[1] = m[3]; m[3] = tmp;\n\t\ttmp = m[2]; m[2] = m[6]; m[6] = tmp;\n\t\ttmp = m[5]; m[5] = m[7]; m[7] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tgetNormalMatrix: function ( m ) {\n\n\t\t// input: THREE.Matrix4\n\n\t\tthis.getInverse( m ).transpose();\n\n\t\treturn this;\n\n\t},\n\n\ttransposeIntoArray: function ( r ) {\n\n\t\tvar m = this.elements;\n\n\t\tr[ 0 ] = m[ 0 ];\n\t\tr[ 1 ] = m[ 3 ];\n\t\tr[ 2 ] = m[ 6 ];\n\t\tr[ 3 ] = m[ 1 ];\n\t\tr[ 4 ] = m[ 4 ];\n\t\tr[ 5 ] = m[ 7 ];\n\t\tr[ 6 ] = m[ 2 ];\n\t\tr[ 7 ] = m[ 5 ];\n\t\tr[ 8 ] = m[ 8 ];\n\n\t\treturn this;\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.elements.set( array );\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\tvar te = this.elements;\n\n\t\treturn [\n\t\t\tte[ 0 ], te[ 1 ], te[ 2 ],\n\t\t\tte[ 3 ], te[ 4 ], te[ 5 ],\n\t\t\tte[ 6 ], te[ 7 ], te[ 8 ]\n\t\t];\n\n\t},\n\n\tclone: function () {\n\n\t\tvar te = this.elements;\n\n\t\treturn new THREE.Matrix3(\n\n\t\t\tte[0], te[3], te[6],\n\t\t\tte[1], te[4], te[7],\n\t\t\tte[2], te[5], te[8]\n\n\t\t);\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author jordi_ros / http://plattsoft.com\n * @author D1plo1d / http://github.com/D1plo1d\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author timknip / http://www.floorplanner.com/\n * @author bhouston / http://exocortex.com\n * @author WestLangley / http://github.com/WestLangley\n */\n\n\nTHREE.Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\tthis.elements = new Float32Array( 16 );\n\n\t// TODO: if n11 is undefined, then just set to identity, otherwise copy all other values into matrix\n\t//   we should not support semi specification of Matrix4, it is just weird.\n\n\tvar te = this.elements;\n\n\tte[0] = ( n11 !== undefined ) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;\n\tte[1] = n21 || 0; te[5] = ( n22 !== undefined ) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;\n\tte[2] = n31 || 0; te[6] = n32 || 0; te[10] = ( n33 !== undefined ) ? n33 : 1; te[14] = n34 || 0;\n\tte[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = ( n44 !== undefined ) ? n44 : 1;\n\n};\n\nTHREE.Matrix4.prototype = {\n\n\tconstructor: THREE.Matrix4,\n\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;\n\t\tte[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;\n\t\tte[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;\n\t\tte[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;\n\n\t\treturn this;\n\n\t},\n\n\tidentity: function () {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( m ) {\n\n\t\tthis.elements.set( m.elements );\n\n\t\treturn this;\n\n\t},\n\n\textractPosition: function ( m ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .extractPosition() has been renamed to .copyPosition().' );\n\t\treturn this.copyPosition( m );\n\n\t},\n\n\tcopyPosition: function ( m ) {\n\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tte[12] = me[12];\n\t\tte[13] = me[13];\n\t\tte[14] = me[14];\n\n\t\treturn this;\n\n\t},\n\n\textractRotation: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( m ) {\n\n\t\t\tvar te = this.elements;\n\t\t\tvar me = m.elements;\n\n\t\t\tvar scaleX = 1 / v1.set( me[0], me[1], me[2] ).length();\n\t\t\tvar scaleY = 1 / v1.set( me[4], me[5], me[6] ).length();\n\t\t\tvar scaleZ = 1 / v1.set( me[8], me[9], me[10] ).length();\n\n\t\t\tte[0] = me[0] * scaleX;\n\t\t\tte[1] = me[1] * scaleX;\n\t\t\tte[2] = me[2] * scaleX;\n\n\t\t\tte[4] = me[4] * scaleY;\n\t\t\tte[5] = me[5] * scaleY;\n\t\t\tte[6] = me[6] * scaleY;\n\n\t\t\tte[8] = me[8] * scaleZ;\n\t\t\tte[9] = me[9] * scaleZ;\n\t\t\tte[10] = me[10] * scaleZ;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeRotationFromEuler: function ( euler ) {\n\n\t\tif ( euler instanceof THREE.Euler === false ) {\n\n\t\t\tconsole.error( 'ERROR: Matrix\\'s .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );\n\n\t\t}\n\n\t\tvar te = this.elements;\n\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\n\n\t\tif ( euler.order === 'XYZ' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[0] = c * e;\n\t\t\tte[4] = - c * f;\n\t\t\tte[8] = d;\n\n\t\t\tte[1] = af + be * d;\n\t\t\tte[5] = ae - bf * d;\n\t\t\tte[9] = - b * c;\n\n\t\t\tte[2] = bf - ae * d;\n\t\t\tte[6] = be + af * d;\n\t\t\tte[10] = a * c;\n\n\t\t} else if ( euler.order === 'YXZ' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[0] = ce + df * b;\n\t\t\tte[4] = de * b - cf;\n\t\t\tte[8] = a * d;\n\n\t\t\tte[1] = a * f;\n\t\t\tte[5] = a * e;\n\t\t\tte[9] = - b;\n\n\t\t\tte[2] = cf * b - de;\n\t\t\tte[6] = df + ce * b;\n\t\t\tte[10] = a * c;\n\n\t\t} else if ( euler.order === 'ZXY' ) {\n\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\n\n\t\t\tte[0] = ce - df * b;\n\t\t\tte[4] = - a * f;\n\t\t\tte[8] = de + cf * b;\n\n\t\t\tte[1] = cf + de * b;\n\t\t\tte[5] = a * e;\n\t\t\tte[9] = df - ce * b;\n\n\t\t\tte[2] = - a * d;\n\t\t\tte[6] = b;\n\t\t\tte[10] = a * c;\n\n\t\t} else if ( euler.order === 'ZYX' ) {\n\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\n\n\t\t\tte[0] = c * e;\n\t\t\tte[4] = be * d - af;\n\t\t\tte[8] = ae * d + bf;\n\n\t\t\tte[1] = c * f;\n\t\t\tte[5] = bf * d + ae;\n\t\t\tte[9] = af * d - be;\n\n\t\t\tte[2] = - d;\n\t\t\tte[6] = b * c;\n\t\t\tte[10] = a * c;\n\n\t\t} else if ( euler.order === 'YZX' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[0] = c * e;\n\t\t\tte[4] = bd - ac * f;\n\t\t\tte[8] = bc * f + ad;\n\n\t\t\tte[1] = f;\n\t\t\tte[5] = a * e;\n\t\t\tte[9] = - b * e;\n\n\t\t\tte[2] = - d * e;\n\t\t\tte[6] = ad * f + bc;\n\t\t\tte[10] = ac - bd * f;\n\n\t\t} else if ( euler.order === 'XZY' ) {\n\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n\n\t\t\tte[0] = c * e;\n\t\t\tte[4] = - f;\n\t\t\tte[8] = d * e;\n\n\t\t\tte[1] = ac * f + bd;\n\t\t\tte[5] = a * e;\n\t\t\tte[9] = ad * f - bc;\n\n\t\t\tte[2] = bc * f - ad;\n\t\t\tte[6] = b * e;\n\t\t\tte[10] = bd * f + ac;\n\n\t\t}\n\n\t\t// last column\n\t\tte[3] = 0;\n\t\tte[7] = 0;\n\t\tte[11] = 0;\n\n\t\t// bottom row\n\t\tte[12] = 0;\n\t\tte[13] = 0;\n\t\tte[14] = 0;\n\t\tte[15] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.' );\n\n\t\treturn this.makeRotationFromQuaternion( q );\n\n\t},\n\n\tmakeRotationFromQuaternion: function ( q ) {\n\n\t\tvar te = this.elements;\n\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\n\n\t\tte[0] = 1 - ( yy + zz );\n\t\tte[4] = xy - wz;\n\t\tte[8] = xz + wy;\n\n\t\tte[1] = xy + wz;\n\t\tte[5] = 1 - ( xx + zz );\n\t\tte[9] = yz - wx;\n\n\t\tte[2] = xz - wy;\n\t\tte[6] = yz + wx;\n\t\tte[10] = 1 - ( xx + yy );\n\n\t\t// last column\n\t\tte[3] = 0;\n\t\tte[7] = 0;\n\t\tte[11] = 0;\n\n\t\t// bottom row\n\t\tte[12] = 0;\n\t\tte[13] = 0;\n\t\tte[14] = 0;\n\t\tte[15] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tlookAt: function() {\n\n\t\tvar x = new THREE.Vector3();\n\t\tvar y = new THREE.Vector3();\n\t\tvar z = new THREE.Vector3();\n\n\t\treturn function ( eye, target, up ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tz.subVectors( eye, target ).normalize();\n\n\t\t\tif ( z.length() === 0 ) {\n\n\t\t\t\tz.z = 1;\n\n\t\t\t}\n\n\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\tif ( x.length() === 0 ) {\n\n\t\t\t\tz.x += 0.0001;\n\t\t\t\tx.crossVectors( up, z ).normalize();\n\n\t\t\t}\n\n\t\t\ty.crossVectors( z, x );\n\n\n\t\t\tte[0] = x.x; te[4] = y.x; te[8] = z.x;\n\t\t\tte[1] = x.y; te[5] = y.y; te[9] = z.y;\n\t\t\tte[2] = x.z; te[6] = y.z; te[10] = z.z;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmultiply: function ( m, n ) {\n\n\t\tif ( n !== undefined ) {\n\n\t\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t\t\treturn this.multiplyMatrices( m, n );\n\n\t\t}\n\n\t\treturn this.multiplyMatrices( this, m );\n\n\t},\n\n\tmultiplyMatrices: function ( a, b ) {\n\n\t\tvar ae = a.elements;\n\t\tvar be = b.elements;\n\t\tvar te = this.elements;\n\n\t\tvar a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n\t\tvar a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n\t\tvar a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n\t\tvar a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n\n\t\tvar b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n\t\tvar b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n\t\tvar b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\n\t\tvar b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n\n\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\t\tte[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\t\tte[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\t\tte[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\t\tte[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\t\tte[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\t\tte[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\t\tte[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\t\tte[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\t\tte[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\t\tte[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\t\tte[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\t\tte[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\t\tte[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyToArray: function ( a, b, r ) {\n\n\t\tvar te = this.elements;\n\n\t\tthis.multiplyMatrices( a, b );\n\n\t\tr[ 0 ] = te[0]; r[ 1 ] = te[1]; r[ 2 ] = te[2]; r[ 3 ] = te[3];\n\t\tr[ 4 ] = te[4]; r[ 5 ] = te[5]; r[ 6 ] = te[6]; r[ 7 ] = te[7];\n\t\tr[ 8 ]  = te[8]; r[ 9 ]  = te[9]; r[ 10 ] = te[10]; r[ 11 ] = te[11];\n\t\tr[ 12 ] = te[12]; r[ 13 ] = te[13]; r[ 14 ] = te[14]; r[ 15 ] = te[15];\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyScalar: function ( s ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;\n\t\tte[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;\n\t\tte[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;\n\t\tte[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;\n\n\t\treturn this;\n\n\t},\n\n\tmultiplyVector3: function ( vector ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\n\t\treturn vector.applyProjection( this );\n\n\t},\n\n\tmultiplyVector4: function ( vector ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\n\t},\n\n\tmultiplyVector3Array: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( a ) {\n\n\t\t\tfor ( var i = 0, il = a.length; i < il; i += 3 ) {\n\n\t\t\t\tv1.x = a[ i ];\n\t\t\t\tv1.y = a[ i + 1 ];\n\t\t\t\tv1.z = a[ i + 2 ];\n\n\t\t\t\tv1.applyProjection( this );\n\n\t\t\t\ta[ i ]     = v1.x;\n\t\t\t\ta[ i + 1 ] = v1.y;\n\t\t\t\ta[ i + 2 ] = v1.z;\n\n\t\t\t}\n\n\t\t\treturn a;\n\n\t\t};\n\n\t}(),\n\n\trotateAxis: function ( v ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\n\n\t\tv.transformDirection( this );\n\n\t},\n\n\tcrossVector: function ( vector ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\n\t\treturn vector.applyMatrix4( this );\n\n\t},\n\n\tdeterminant: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n\t\tvar n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n\t\tvar n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n\t\tvar n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 * (\n\t\t\t\t+n14 * n23 * n32\n\t\t\t\t-n13 * n24 * n32\n\t\t\t\t-n14 * n22 * n33\n\t\t\t\t+n12 * n24 * n33\n\t\t\t\t+n13 * n22 * n34\n\t\t\t\t-n12 * n23 * n34\n\t\t\t) +\n\t\t\tn42 * (\n\t\t\t\t+n11 * n23 * n34\n\t\t\t\t-n11 * n24 * n33\n\t\t\t\t+n14 * n21 * n33\n\t\t\t\t-n13 * n21 * n34\n\t\t\t\t+n13 * n24 * n31\n\t\t\t\t-n14 * n23 * n31\n\t\t\t) +\n\t\t\tn43 * (\n\t\t\t\t+n11 * n24 * n32\n\t\t\t\t-n11 * n22 * n34\n\t\t\t\t-n14 * n21 * n32\n\t\t\t\t+n12 * n21 * n34\n\t\t\t\t+n14 * n22 * n31\n\t\t\t\t-n12 * n24 * n31\n\t\t\t) +\n\t\t\tn44 * (\n\t\t\t\t-n13 * n22 * n31\n\t\t\t\t-n11 * n23 * n32\n\t\t\t\t+n11 * n22 * n33\n\t\t\t\t+n13 * n21 * n32\n\t\t\t\t-n12 * n21 * n33\n\t\t\t\t+n12 * n23 * n31\n\t\t\t)\n\n\t\t);\n\n\t},\n\n\ttranspose: function () {\n\n\t\tvar te = this.elements;\n\t\tvar tmp;\n\n\t\ttmp = te[1]; te[1] = te[4]; te[4] = tmp;\n\t\ttmp = te[2]; te[2] = te[8]; te[8] = tmp;\n\t\ttmp = te[6]; te[6] = te[9]; te[9] = tmp;\n\n\t\ttmp = te[3]; te[3] = te[12]; te[12] = tmp;\n\t\ttmp = te[7]; te[7] = te[13]; te[13] = tmp;\n\t\ttmp = te[11]; te[11] = te[14]; te[14] = tmp;\n\n\t\treturn this;\n\n\t},\n\n\tflattenToArray: function ( flat ) {\n\n\t\tvar te = this.elements;\n\t\tflat[ 0 ] = te[0]; flat[ 1 ] = te[1]; flat[ 2 ] = te[2]; flat[ 3 ] = te[3];\n\t\tflat[ 4 ] = te[4]; flat[ 5 ] = te[5]; flat[ 6 ] = te[6]; flat[ 7 ] = te[7];\n\t\tflat[ 8 ] = te[8]; flat[ 9 ] = te[9]; flat[ 10 ] = te[10]; flat[ 11 ] = te[11];\n\t\tflat[ 12 ] = te[12]; flat[ 13 ] = te[13]; flat[ 14 ] = te[14]; flat[ 15 ] = te[15];\n\n\t\treturn flat;\n\n\t},\n\n\tflattenToArrayOffset: function( flat, offset ) {\n\n\t\tvar te = this.elements;\n\t\tflat[ offset ] = te[0];\n\t\tflat[ offset + 1 ] = te[1];\n\t\tflat[ offset + 2 ] = te[2];\n\t\tflat[ offset + 3 ] = te[3];\n\n\t\tflat[ offset + 4 ] = te[4];\n\t\tflat[ offset + 5 ] = te[5];\n\t\tflat[ offset + 6 ] = te[6];\n\t\tflat[ offset + 7 ] = te[7];\n\n\t\tflat[ offset + 8 ]  = te[8];\n\t\tflat[ offset + 9 ]  = te[9];\n\t\tflat[ offset + 10 ] = te[10];\n\t\tflat[ offset + 11 ] = te[11];\n\n\t\tflat[ offset + 12 ] = te[12];\n\t\tflat[ offset + 13 ] = te[13];\n\t\tflat[ offset + 14 ] = te[14];\n\t\tflat[ offset + 15 ] = te[15];\n\n\t\treturn flat;\n\n\t},\n\n\tgetPosition: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function () {\n\n\t\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\n\n\t\t\tvar te = this.elements;\n\t\t\treturn v1.set( te[12], te[13], te[14] );\n\n\t\t};\n\n\t}(),\n\n\tsetPosition: function ( v ) {\n\n\t\tvar te = this.elements;\n\n\t\tte[12] = v.x;\n\t\tte[13] = v.y;\n\t\tte[14] = v.z;\n\n\t\treturn this;\n\n\t},\n\n\tgetInverse: function ( m, throwOnInvertible ) {\n\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\tvar te = this.elements;\n\t\tvar me = m.elements;\n\n\t\tvar n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];\n\t\tvar n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];\n\t\tvar n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];\n\t\tvar n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];\n\n\t\tte[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;\n\t\tte[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;\n\t\tte[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;\n\t\tte[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;\n\t\tte[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;\n\t\tte[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;\n\t\tte[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;\n\t\tte[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;\n\t\tte[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;\n\t\tte[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;\n\t\tte[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;\n\t\tte[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;\n\t\tte[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;\n\t\tte[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;\n\t\tte[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;\n\t\tte[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;\n\n\t\tvar det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];\n\n\t\tif ( det == 0 ) {\n\n\t\t\tvar msg = \"Matrix4.getInverse(): can't invert matrix, determinant is 0\";\n\n\t\t\tif ( throwOnInvertible || false ) {\n\n\t\t\t\tthrow new Error( msg ); \n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( msg );\n\n\t\t\t}\n\n\t\t\tthis.identity();\n\n\t\t\treturn this;\n\t\t}\n\n\t\tthis.multiplyScalar( 1 / det );\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( v ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .translate() has been removed.');\n\n\t},\n\n\trotateX: function ( angle ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .rotateX() has been removed.');\n\n\t},\n\n\trotateY: function ( angle ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .rotateY() has been removed.');\n\n\t},\n\n\trotateZ: function ( angle ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .rotateZ() has been removed.');\n\n\t},\n\n\trotateByAxis: function ( axis, angle ) {\n\n\t\tconsole.warn( 'DEPRECATED: Matrix4\\'s .rotateByAxis() has been removed.');\n\n\t},\n\n\tscale: function ( v ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = v.x, y = v.y, z = v.z;\n\n\t\tte[0] *= x; te[4] *= y; te[8] *= z;\n\t\tte[1] *= x; te[5] *= y; te[9] *= z;\n\t\tte[2] *= x; te[6] *= y; te[10] *= z;\n\t\tte[3] *= x; te[7] *= y; te[11] *= z;\n\n\t\treturn this;\n\n\t},\n\n\tgetMaxScaleOnAxis: function () {\n\n\t\tvar te = this.elements;\n\n\t\tvar scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n\t\tvar scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n\t\tvar scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n\n\t\treturn Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );\n\n\t},\n\n\tmakeTranslation: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\t1, 0, 0, x,\n\t\t\t0, 1, 0, y,\n\t\t\t0, 0, 1, z,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationX: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t1, 0,  0, 0,\n\t\t\t0, c, -s, 0,\n\t\t\t0, s,  c, 0,\n\t\t\t0, 0,  0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationY: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\t c, 0, s, 0,\n\t\t\t 0, 1, 0, 0,\n\t\t\t-s, 0, c, 0,\n\t\t\t 0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationZ: function ( theta ) {\n\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\n\n\t\tthis.set(\n\n\t\t\tc, -s, 0, 0,\n\t\t\ts,  c, 0, 0,\n\t\t\t0,  0, 1, 0,\n\t\t\t0,  0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tmakeRotationAxis: function ( axis, angle ) {\n\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t\tvar c = Math.cos( angle );\n\t\tvar s = Math.sin( angle );\n\t\tvar t = 1 - c;\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\n\t\tvar tx = t * x, ty = t * y;\n\n\t\tthis.set(\n\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\t return this;\n\n\t},\n\n\tmakeScale: function ( x, y, z ) {\n\n\t\tthis.set(\n\n\t\t\tx, 0, 0, 0,\n\t\t\t0, y, 0, 0,\n\t\t\t0, 0, z, 0,\n\t\t\t0, 0, 0, 1\n\n\t\t);\n\n\t\treturn this;\n\n\t},\n\n\tcompose: function ( position, quaternion, scale ) {\n\n\t\tthis.makeRotationFromQuaternion( quaternion );\n\t\tthis.scale( scale );\n\t\tthis.setPosition( position );\n\n\t\treturn this;\n\n\t},\n\n\tdecompose: function () {\n\n\t\tvar vector = new THREE.Vector3();\n\t\tvar matrix = new THREE.Matrix4();\n\n\t\treturn function ( position, quaternion, scale ) {\n\n\t\t\tvar te = this.elements;\n\n\t\t\tvar sx = vector.set( te[0], te[1], te[2] ).length();\n\t\t\tvar sy = vector.set( te[4], te[5], te[6] ).length();\n\t\t\tvar sz = vector.set( te[8], te[9], te[10] ).length();\n\n\t\t\t// if determine is negative, we need to invert one scale\n\t\t\tvar det = this.determinant();\n\t\t\tif( det < 0 ) {\n\t\t\t\tsx = -sx;\n\t\t\t}\n\n\t\t\tposition.x = te[12];\n\t\t\tposition.y = te[13];\n\t\t\tposition.z = te[14];\n\n\t\t\t// scale the rotation part\n\n\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\n\n\t\t\tvar invSX = 1 / sx;\n\t\t\tvar invSY = 1 / sy;\n\t\t\tvar invSZ = 1 / sz;\n\n\t\t\tmatrix.elements[0] *= invSX;\n\t\t\tmatrix.elements[1] *= invSX;\n\t\t\tmatrix.elements[2] *= invSX;\n\n\t\t\tmatrix.elements[4] *= invSY;\n\t\t\tmatrix.elements[5] *= invSY;\n\t\t\tmatrix.elements[6] *= invSY;\n\n\t\t\tmatrix.elements[8] *= invSZ;\n\t\t\tmatrix.elements[9] *= invSZ;\n\t\t\tmatrix.elements[10] *= invSZ;\n\n\t\t\tquaternion.setFromRotationMatrix( matrix );\n\n\t\t\tscale.x = sx;\n\t\t\tscale.y = sy;\n\t\t\tscale.z = sz;\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar x = 2 * near / ( right - left );\n\t\tvar y = 2 * near / ( top - bottom );\n\n\t\tvar a = ( right + left ) / ( right - left );\n\t\tvar b = ( top + bottom ) / ( top - bottom );\n\t\tvar c = - ( far + near ) / ( far - near );\n\t\tvar d = - 2 * far * near / ( far - near );\n\n\t\tte[0] = x;\tte[4] = 0;\tte[8] = a;\tte[12] = 0;\n\t\tte[1] = 0;\tte[5] = y;\tte[9] = b;\tte[13] = 0;\n\t\tte[2] = 0;\tte[6] = 0;\tte[10] = c;\tte[14] = d;\n\t\tte[3] = 0;\tte[7] = 0;\tte[11] = - 1;\tte[15] = 0;\n\n\t\treturn this;\n\n\t},\n\n\tmakePerspective: function ( fov, aspect, near, far ) {\n\n\t\tvar ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\n\t\tvar ymin = - ymax;\n\t\tvar xmin = ymin * aspect;\n\t\tvar xmax = ymax * aspect;\n\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\n\n\t},\n\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\n\n\t\tvar te = this.elements;\n\t\tvar w = right - left;\n\t\tvar h = top - bottom;\n\t\tvar p = far - near;\n\n\t\tvar x = ( right + left ) / w;\n\t\tvar y = ( top + bottom ) / h;\n\t\tvar z = ( far + near ) / p;\n\n\t\tte[0] = 2 / w;\tte[4] = 0;\tte[8] = 0;\tte[12] = -x;\n\t\tte[1] = 0;\tte[5] = 2 / h;\tte[9] = 0;\tte[13] = -y;\n\t\tte[2] = 0;\tte[6] = 0;\tte[10] = -2/p;\tte[14] = -z;\n\t\tte[3] = 0;\tte[7] = 0;\tte[11] = 0;\tte[15] = 1;\n\n\t\treturn this;\n\n\t},\n\n\tfromArray: function ( array ) {\n\n\t\tthis.elements.set( array );\n\n\t\treturn this;\n\n\t},\n\n\ttoArray: function () {\n\n\t\tvar te = this.elements;\n\n\t\treturn [\n\t\t\tte[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],\n\t\t\tte[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],\n\t\t\tte[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],\n\t\t\tte[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]\n\t\t];\n\n\t},\n\n\tclone: function () {\n\n\t\tvar te = this.elements;\n\n\t\treturn new THREE.Matrix4(\n\n\t\t\tte[0], te[4], te[8], te[12],\n\t\t\tte[1], te[5], te[9], te[13],\n\t\t\tte[2], te[6], te[10], te[14],\n\t\t\tte[3], te[7], te[11], te[15]\n\n\t\t);\n\n\t}\n\n};\n\n/**\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Ray = function ( origin, direction ) {\n\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\n\n};\n\nTHREE.Ray.prototype = {\n\n\tconstructor: THREE.Ray,\n\n\tset: function ( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t},\n\n\tat: function ( t, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t},\n\n\trecast: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( t ) {\n\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\tclosestPointToPoint: function ( point, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\tresult.subVectors( point, this.origin );\n\t\tvar directionDistance = result.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn result.copy( this.origin );\n\n\t\t}\n\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t},\n\n\tdistanceToPoint: function () {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( point ) {\n\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t\t// point behind the ray\n\n\t\t\tif ( directionDistance < 0 ) {\n\n\t\t\t\treturn this.origin.distanceTo( point );\n\n\t\t\t}\n\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\t\treturn v1.distanceTo( point );\n\n\t\t};\n\n\t}(),\n\n\tdistanceSqToSegment: function( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\tvar segCenter = v0.clone().add( v1 ).multiplyScalar( 0.5 );\n\t\tvar segDir = v1.clone().sub( v0 ).normalize();\n\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\tvar diff = this.origin.clone().sub( segCenter );\n\t\tvar a01 = - this.direction.dot( segDir );\n\t\tvar b0 = diff.dot( this.direction );\n\t\tvar b1 = - diff.dot( segDir );\n\t\tvar c = diff.lengthSq();\n\t\tvar det = Math.abs( 1 - a01 * a01 );\n\t\tvar s0, s1, sqrDist, extDet;\n\n\t\tif ( det >= 0 ) {\n\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0;\n\t\t\ts1 = a01 * b0 - b1;\n\t\t\textDet = segExtent * det;\n\n\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tvar invDet = 1 / det;\n\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( s1 <= - extDet) {\n\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0;\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t}\n\n\t\tif ( optionalPointOnRay ) {\n\n\t\t\toptionalPointOnRay.copy( this.direction.clone().multiplyScalar( s0 ).add( this.origin ) );\n\n\t\t}\n\n\t\tif ( optionalPointOnSegment ) {\n\n\t\t\toptionalPointOnSegment.copy( segDir.clone().multiplyScalar( s1 ).add( segCenter ) );\n\n\t\t}\n\n\t\treturn sqrDist;\n\n\t},\n\n\tisIntersectionSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\n\n\t},\n\n\tisIntersectionPlane: function ( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t},\n\n\tdistanceToPlane: function ( plane ) {\n\n\t\tvar denominator = plane.normal.dot( this.direction );\n\t\tif ( denominator == 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif( plane.distanceToPoint( this.origin ) == 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t :  null;\n\n\t},\n\n\tintersectPlane: function ( plane, optionalTarget ) {\n\n\t\tvar t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this.at( t, optionalTarget );\n\n\t},\n\n\tisIntersectionBox: function () {\n\t\t\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function ( box ) {\n\n\t\t\treturn this.intersectBox( box, v ) !== null;\n\n\t\t}\n\n\t}(),\n\n\tintersectBox: function ( box , optionalTarget ) {\n\n\t\t// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/\n\n\t\tvar tmin,tmax,tymin,tymax,tzmin,tzmax;\n\n\t\tvar invdirx = 1/this.direction.x,\n\t\t\tinvdiry = 1/this.direction.y,\n\t\t\tinvdirz = 1/this.direction.z;\n\n\t\tvar origin = this.origin;\n\n\t\tif (invdirx >= 0) {\n\t\t\t\t\n\t\t\ttmin = (box.min.x - origin.x) * invdirx;\n\t\t\ttmax = (box.max.x - origin.x) * invdirx;\n\n\t\t} else { \n\n\t\t\ttmin = (box.max.x - origin.x) * invdirx;\n\t\t\ttmax = (box.min.x - origin.x) * invdirx;\n\t\t}\t\t\t\n\n\t\tif (invdiry >= 0) {\n\t\t\n\t\t\ttymin = (box.min.y - origin.y) * invdiry;\n\t\t\ttymax = (box.max.y - origin.y) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = (box.max.y - origin.y) * invdiry;\n\t\t\ttymax = (box.min.y - origin.y) * invdiry;\n\t\t}\n\n\t\tif ((tmin > tymax) || (tymin > tmax)) return null;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\t\t\n\t\tif (tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\tif (tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\tif (invdirz >= 0) {\n\t\t\n\t\t\ttzmin = (box.min.z - origin.z) * invdirz;\n\t\t\ttzmax = (box.max.z - origin.z) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = (box.max.z - origin.z) * invdirz;\n\t\t\ttzmax = (box.min.z - origin.z) * invdirz;\n\t\t}\n\n\t\tif ((tmin > tzmax) || (tzmin > tmax)) return null;\n\n\t\tif (tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif (tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\n\n\t},\n\n\tintersectTriangle: function() {\n\n\t\t// Compute the offset origin, edges, and normal.\n\t\tvar diff = new THREE.Vector3();\n\t\tvar edge1 = new THREE.Vector3();\n\t\tvar edge2 = new THREE.Vector3();\n\t\tvar normal = new THREE.Vector3();\n\n\t\treturn function ( a, b, c, backfaceCulling, optionalTarget ) {\n\n\t\t\t// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\n\n\t\t\tedge1.subVectors( b, a );\n\t\t\tedge2.subVectors( c, a );\n\t\t\tnormal.crossVectors( edge1, edge2 );\n\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\t\tvar DdN = this.direction.dot( normal );\n\t\t\tvar sign;\n\n\t\t\tif ( DdN > 0 ) {\n\n\t\t\t\tif ( backfaceCulling ) return null;\n\t\t\t\tsign = 1;\n\n\t\t\t} else if ( DdN < 0 ) {\n\n\t\t\t\tsign = - 1;\n\t\t\t\tDdN = - DdN;\n\n\t\t\t} else {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tdiff.subVectors( this.origin, a );\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\n\n\t\t\t// b1 < 0, no intersection\n\t\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\n\n\t\t\t// b2 < 0, no intersection\n\t\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// b1+b2 > 1, no intersection\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Line intersects triangle, check if ray does.\n\t\t\tvar QdN = - sign * diff.dot( normal );\n\n\t\t\t// t < 0, no intersection\n\t\t\tif ( QdN < 0 ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\t// Ray intersects triangle.\n\t\t\treturn this.at( QdN / DdN, optionalTarget );\n\t\n\t\t}\n\t\n\t}(),\n\n\tapplyMatrix4: function ( matrix4 ) {\n\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.sub( this.origin );\n\t\tthis.direction.normalize();\n\n\t\treturn this;\n\t},\n\n\tequals: function ( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Ray().copy( this );\n\n\t}\n\n};\n\n/**\n * @author bhouston / http://exocortex.com\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Sphere = function ( center, radius ) {\n\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\n\n};\n\nTHREE.Sphere.prototype = {\n\n\tconstructor: THREE.Sphere,\n\n\tset: function ( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\t},\n\n\n\tsetFromPoints: function () {\n\n\t\tvar box = new THREE.Box3();\n\n\t\treturn function ( points, optionalCenter )  {\n\n\t\t\tvar center = this.center;\n\n\t\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\t\tcenter.copy( optionalCenter );\n\n\t\t\t} else {\n\n\t\t\t\tbox.setFromPoints( points ).center( center );\n\n\t\t\t}\n\n\t\t\tvar maxRadiusSq = 0;\n\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\treturn this;\t\t\t\n \t\t\n \t\t};\n\n\t}(),\n\n\tcopy: function ( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t},\n\n\tempty: function () {\n\n\t\treturn ( this.radius <= 0 );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t},\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t},\n\n\tclampPoint: function ( point, optionalTarget ) {\n\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\tresult.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\tresult.sub( this.center ).normalize();\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\tgetBoundingBox: function ( optionalTarget ) {\n\n\t\tvar box = optionalTarget || new THREE.Box3();\n\n\t\tbox.set( this.center, this.center );\n\t\tbox.expandByScalar( this.radius );\n\n\t\treturn box;\n\n\t},\n\n\tapplyMatrix4: function ( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t},\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Sphere().copy( this );\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\n\n\tthis.planes = [\n\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\n\n\t];\n\n};\n\nTHREE.Frustum.prototype = {\n\n\tconstructor: THREE.Frustum,\n\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\n\n\t\tvar planes = this.planes;\n\n\t\tplanes[0].copy( p0 );\n\t\tplanes[1].copy( p1 );\n\t\tplanes[2].copy( p2 );\n\t\tplanes[3].copy( p3 );\n\t\tplanes[4].copy( p4 );\n\t\tplanes[5].copy( p5 );\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( frustum ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor( var i = 0; i < 6; i ++ ) {\n\n\t\t\tplanes[i].copy( frustum.planes[i] );\n\n\t\t}\n\n\t\treturn this;\n\n\t},\n\n\tsetFromMatrix: function ( m ) {\n\n\t\tvar planes = this.planes;\n\t\tvar me = m.elements;\n\t\tvar me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\n\t\tvar me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];\n\t\tvar me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];\n\t\tvar me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];\n\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\n\n\t\treturn this;\n\n\t},\n\n\tintersectsObject: function () {\n\n\t\tvar sphere = new THREE.Sphere();\n\n\t\treturn function ( object ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( object.matrixWorld );\n\n\t\t\treturn this.intersectsSphere( sphere );\n\n\t\t};\n\n\t}(),\n\n\tintersectsSphere: function ( sphere ) {\n\n\t\tvar planes = this.planes;\n\t\tvar center = sphere.center;\n\t\tvar negRadius = -sphere.radius;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\n\n\t\t\tif ( distance < negRadius ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tintersectsBox : function() {\n\n\t\tvar p1 = new THREE.Vector3(),\n\t\t\tp2 = new THREE.Vector3();\n\n\t\treturn function( box ) {\n\n\t\t\tvar planes = this.planes;\n\t\t\t\n\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\n\t\t\t\n\t\t\t\tvar plane = planes[i];\n\t\t\t\t\n\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\n\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\n\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\n\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n\n\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\n\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\n\t\t\t\t\n\t\t\t\t// if both outside plane, no intersection\n\n\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\n\t\t\t\t\t\n\t\t\t\t\treturn false;\n\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t};\n\n\t}(),\n\n\n\tcontainsPoint: function ( point ) {\n\n\t\tvar planes = this.planes;\n\n\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Frustum().copy( this );\n\n\t}\n\n};\n\n/**\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Plane = function ( normal, constant ) {\n\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\n\n};\n\nTHREE.Plane.prototype = {\n\n\tconstructor: THREE.Plane,\n\n\tset: function ( normal, constant ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = constant;\n\n\t\treturn this;\n\n\t},\n\n\tsetComponents: function ( x, y, z, w ) {\n\n\t\tthis.normal.set( x, y, z );\n\t\tthis.constant = w;\n\n\t\treturn this;\n\n\t},\n\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\n\n\t\tthis.normal.copy( normal );\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\n\n\t\treturn this;\n\n\t},\n\n\tsetFromCoplanarPoints: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\n\t\treturn function ( a, b, c ) {\n\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\n\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\n\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\n\tcopy: function ( plane ) {\n\n\t\tthis.normal.copy( plane.normal );\n\t\tthis.constant = plane.constant;\n\n\t\treturn this;\n\n\t},\n\n\tnormalize: function () {\n\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\n\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\n\t\tthis.constant *= inverseNormalLength;\n\n\t\treturn this;\n\n\t},\n\n\tnegate: function () {\n\n\t\tthis.constant *= -1;\n\t\tthis.normal.negate();\n\n\t\treturn this;\n\n\t},\n\n\tdistanceToPoint: function ( point ) {\n\n\t\treturn this.normal.dot( point ) + this.constant;\n\n\t},\n\n\tdistanceToSphere: function ( sphere ) {\n\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\n\n\t},\n\n\tprojectPoint: function ( point, optionalTarget ) {\n\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\n\n\t},\n\n\torthoPoint: function ( point, optionalTarget ) {\n\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\n\n\t},\n\n\tisIntersectionLine: function ( line ) {\n\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\n\n\t\tvar startSign = this.distanceToPoint( line.start );\n\t\tvar endSign = this.distanceToPoint( line.end );\n\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\n\n\t},\n\n\tintersectLine: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( line, optionalTarget ) {\n\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t\tvar direction = line.delta( v1 );\n\n\t\t\tvar denominator = this.normal.dot( direction );\n\n\t\t\tif ( denominator == 0 ) {\n\n\t\t\t\t// line is coplanar, return origin\n\t\t\t\tif( this.distanceToPoint( line.start ) == 0 ) {\n\n\t\t\t\t\treturn result.copy( line.start );\n\n\t\t\t\t}\n\n\t\t\t\t// Unsure if this is the correct method to handle this case.\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\n\n\t\t\tif( t < 0 || t > 1 ) {\n\n\t\t\t\treturn undefined;\n\n\t\t\t}\n\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\n\n\t\t};\n\n\t}(),\n\n\n\tcoplanarPoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\n\n\t},\n\n\tapplyMatrix4: function() {\n\n\t\tvar v1 = new THREE.Vector3();\n\t\tvar v2 = new THREE.Vector3();\n\t\tvar m1 = new THREE.Matrix3();\n\n\t\treturn function ( matrix, optionalNormalMatrix ) {\n\n\t\t\t// compute new normal based on theory here:\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\n\t\t\tvar newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );\n\t\t\t\n\t\t\tvar newCoplanarPoint = this.coplanarPoint( v2 );\n\t\t\tnewCoplanarPoint.applyMatrix4( matrix );\n\n\t\t\tthis.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );\n\n\t\t\treturn this;\n\n\t\t};\n\n\t}(),\n\n\ttranslate: function ( offset ) {\n\n\t\tthis.constant = this.constant - offset.dot( this.normal );\n\n\t\treturn this;\n\n\t},\n\n\tequals: function ( plane ) {\n\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant == this.constant );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Plane().copy( this );\n\n\t}\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Math = {\n\n\tPI2: Math.PI * 2,\n\n\tgenerateUUID: function () {\n\n\t\t// http://www.broofa.com/Tools/Math.uuid.htm\n\t\t\n\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n\t\tvar uuid = new Array(36);\n\t\tvar rnd = 0, r;\n\n\t\treturn function () {\n\n\t\t\tfor ( var i = 0; i < 36; i ++ ) {\n\n\t\t\t\tif ( i == 8 || i == 13 || i == 18 || i == 23 ) {\n\t\t\t\n\t\t\t\t\tuuid[ i ] = '-';\n\t\t\t\n\t\t\t\t} else if ( i == 14 ) {\n\t\t\t\n\t\t\t\t\tuuid[ i ] = '4';\n\t\t\t\n\t\t\t\t} else {\n\t\t\t\n\t\t\t\t\tif (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;\n\t\t\t\t\tr = rnd & 0xf;\n\t\t\t\t\trnd = rnd >> 4;\n\t\t\t\t\tuuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn uuid.join('');\n\n\t\t};\n\n\t}(),\n\n\t// Clamp value to range <a, b>\n\n\tclamp: function ( x, a, b ) {\n\n\t\treturn ( x < a ) ? a : ( ( x > b ) ? b : x );\n\n\t},\n\n\t// Clamp value to range <a, inf)\n\n\tclampBottom: function ( x, a ) {\n\n\t\treturn x < a ? a : x;\n\n\t},\n\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\n\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\n\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n\n\t},\n\n\t// http://en.wikipedia.org/wiki/Smoothstep\n\n\tsmoothstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min )/( max - min );\n\n\t\treturn x*x*(3 - 2*x);\n\n\t},\n\n\tsmootherstep: function ( x, min, max ) {\n\n\t\tif ( x <= min ) return 0;\n\t\tif ( x >= max ) return 1;\n\n\t\tx = ( x - min )/( max - min );\n\n\t\treturn x*x*x*(x*(x*6 - 15) + 10);\n\n\t},\n\n\t// Random float from <0, 1> with 16 bits of randomness\n\t// (standard Math.random() creates repetitive patterns when applied over larger space)\n\n\trandom16: function () {\n\n\t\treturn ( 65280 * Math.random() + 255 * Math.random() ) / 65535;\n\n\t},\n\n\t// Random integer from <low, high> interval\n\n\trandInt: function ( low, high ) {\n\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\n\n\t},\n\n\t// Random float from <low, high> interval\n\n\trandFloat: function ( low, high ) {\n\n\t\treturn low + Math.random() * ( high - low );\n\n\t},\n\n\t// Random float from <-range/2, range/2> interval\n\n\trandFloatSpread: function ( range ) {\n\n\t\treturn range * ( 0.5 - Math.random() );\n\n\t},\n\n\tsign: function ( x ) {\n\n\t\treturn ( x < 0 ) ? -1 : ( ( x > 0 ) ? 1 : 0 );\n\n\t},\n\n\tdegToRad: function() {\n\n\t\tvar degreeToRadiansFactor = Math.PI / 180;\n\n\t\treturn function ( degrees ) {\n\n\t\t\treturn degrees * degreeToRadiansFactor;\n\n\t\t};\n\n\t}(),\n\n\tradToDeg: function() {\n\n\t\tvar radianToDegreesFactor = 180 / Math.PI;\n\n\t\treturn function ( radians ) {\n\n\t\t\treturn radians * radianToDegreesFactor;\n\n\t\t};\n\n\t}()\n\n};\n\n/**\n * Spline from Tween.js, slightly optimized (and trashed)\n * http://sole.github.com/tween.js/examples/05_spline.html\n *\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Spline = function ( points ) {\n\n\tthis.points = points;\n\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\n\tpoint, intPoint, weight, w2, w3,\n\tpa, pb, pc, pd;\n\n\tthis.initFromArray = function( a ) {\n\n\t\tthis.points = [];\n\n\t\tfor ( var i = 0; i < a.length; i++ ) {\n\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\n\n\t\t}\n\n\t};\n\n\tthis.getPoint = function ( k ) {\n\n\t\tpoint = ( this.points.length - 1 ) * k;\n\t\tintPoint = Math.floor( point );\n\t\tweight = point - intPoint;\n\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\t\tc[ 1 ] = intPoint;\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\n\n\t\tpa = this.points[ c[ 0 ] ];\n\t\tpb = this.points[ c[ 1 ] ];\n\t\tpc = this.points[ c[ 2 ] ];\n\t\tpd = this.points[ c[ 3 ] ];\n\n\t\tw2 = weight * weight;\n\t\tw3 = weight * w2;\n\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\n\n\t\treturn v3;\n\n\t};\n\n\tthis.getControlPointsArray = function () {\n\n\t\tvar i, p, l = this.points.length,\n\t\t\tcoords = [];\n\n\t\tfor ( i = 0; i < l; i ++ ) {\n\n\t\t\tp = this.points[ i ];\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\n\n\t\t}\n\n\t\treturn coords;\n\n\t};\n\n\t// approximate length by summing linear segments\n\n\tthis.getLength = function ( nSubDivisions ) {\n\n\t\tvar i, index, nSamples, position,\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\n\t\t\toldPosition = new THREE.Vector3(),\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tchunkLengths = [],\n\t\t\ttotalLength = 0;\n\n\t\t// first point has 0 length\n\n\t\tchunkLengths[ 0 ] = 0;\n\n\t\tif ( !nSubDivisions ) nSubDivisions = 100;\n\n\t\tnSamples = this.points.length * nSubDivisions;\n\n\t\toldPosition.copy( this.points[ 0 ] );\n\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\n\n\t\t\tindex = i / nSamples;\n\n\t\t\tposition = this.getPoint( index );\n\t\t\ttmpVec.copy( position );\n\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\n\n\t\t\toldPosition.copy( position );\n\n\t\t\tpoint = ( this.points.length - 1 ) * index;\n\t\t\tintPoint = Math.floor( point );\n\n\t\t\tif ( intPoint != oldIntPoint ) {\n\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\n\t\t\t\toldIntPoint = intPoint;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// last point ends with total length\n\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\n\n\t\treturn { chunks: chunkLengths, total: totalLength };\n\n\t};\n\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\n\n\t\tvar i, j,\n\t\t\tindex, indexCurrent, indexNext,\n\t\t\tlinearDistance, realDistance,\n\t\t\tsampling, position,\n\t\t\tnewpoints = [],\n\t\t\ttmpVec = new THREE.Vector3(),\n\t\t\tsl = this.getLength();\n\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\n\n\t\tfor ( i = 1; i < this.points.length; i++ ) {\n\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\n\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\n\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\n\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\n\t\t\tindexNext = i / ( this.points.length - 1 );\n\n\t\t\tfor ( j = 1; j < sampling - 1; j++ ) {\n\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\n\n\t\t\t\tposition = this.getPoint( index );\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\n\n\t\t\t}\n\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\n\n\t\t}\n\n\t\tthis.points = newpoints;\n\n\t};\n\n\t// Catmull-Rom\n\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t};\n\n};\n\n/**\n * @author bhouston / http://exocortex.com\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Triangle = function ( a, b, c ) {\n\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\n\n};\n\nTHREE.Triangle.normal = function() {\n\n\tvar v0 = new THREE.Vector3();\n\n\treturn function ( a, b, c, optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\tresult.subVectors( c, b );\n\t\tv0.subVectors( a, b );\n\t\tresult.cross( v0 );\n\n\t\tvar resultLengthSq = result.lengthSq();\n\t\tif( resultLengthSq > 0 ) {\n\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\n\n\t\t}\n\n\t\treturn result.set( 0, 0, 0 );\n\n\t};\n\n}();\n\n// static/instance method to calculate barycoordinates\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\nTHREE.Triangle.barycoordFromPoint = function() {\n\n\tvar v0 = new THREE.Vector3();\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\n\treturn function ( point, a, b, c, optionalTarget ) {\n\n\t\tv0.subVectors( c, a );\n\t\tv1.subVectors( b, a );\n\t\tv2.subVectors( point, a );\n\n\t\tvar dot00 = v0.dot( v0 );\n\t\tvar dot01 = v0.dot( v1 );\n\t\tvar dot02 = v0.dot( v2 );\n\t\tvar dot11 = v1.dot( v1 );\n\t\tvar dot12 = v1.dot( v2 );\n\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\n\t\t// colinear or singular triangle\n\t\tif( denom == 0 ) {\n\t\t\t// arbitrary location outside of triangle?\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\n\t\t\treturn result.set( -2, -1, -1 );\n\t\t}\n\n\t\tvar invDenom = 1 / denom;\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\n\n\t\t// barycoordinates must always sum to 1\n\t\treturn result.set( 1 - u - v, v, u );\n\n\t};\n\n}();\n\nTHREE.Triangle.containsPoint = function() {\n\n\tvar v1 = new THREE.Vector3();\n\n\treturn function ( point, a, b, c ) {\n\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\n\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\n\n\t};\n\n}();\n\nTHREE.Triangle.prototype = {\n\n\tconstructor: THREE.Triangle,\n\n\tset: function ( a, b, c ) {\n\n\t\tthis.a.copy( a );\n\t\tthis.b.copy( b );\n\t\tthis.c.copy( c );\n\n\t\treturn this;\n\n\t},\n\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\n\n\t\tthis.a.copy( points[i0] );\n\t\tthis.b.copy( points[i1] );\n\t\tthis.c.copy( points[i2] );\n\n\t\treturn this;\n\n\t},\n\n\tcopy: function ( triangle ) {\n\n\t\tthis.a.copy( triangle.a );\n\t\tthis.b.copy( triangle.b );\n\t\tthis.c.copy( triangle.c );\n\n\t\treturn this;\n\n\t},\n\n\tarea: function() {\n\n\t\tvar v0 = new THREE.Vector3();\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function () {\n\n\t\t\tv0.subVectors( this.c, this.b );\n\t\t\tv1.subVectors( this.a, this.b );\n\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\n\n\t\t};\n\n\t}(),\n\n\tmidpoint: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Vector3();\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\n\n\t},\n\n\tnormal: function ( optionalTarget ) {\n\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tplane: function ( optionalTarget ) {\n\n\t\tvar result = optionalTarget || new THREE.Plane();\n\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\n\n\t},\n\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\n\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\n\n\t},\n\n\tcontainsPoint: function ( point ) {\n\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\n\n\t},\n\n\tequals: function ( triangle ) {\n\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\n\n\t},\n\n\tclone: function () {\n\n\t\treturn new THREE.Triangle().copy( this );\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Vertex = function ( v ) {\n\n\tconsole.warn( 'THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.')\n\treturn v;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.UV = function ( u, v ) {\n\n\tconsole.warn( 'THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.')\n\treturn new THREE.Vector2( u, v );\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Clock = function ( autoStart ) {\n\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\n\n\tthis.startTime = 0;\n\tthis.oldTime = 0;\n\tthis.elapsedTime = 0;\n\n\tthis.running = false;\n\n};\n\nTHREE.Clock.prototype = {\n\n\tconstructor: THREE.Clock,\n\n\tstart: function () {\n\n\t\tthis.startTime = self.performance !== undefined && self.performance.now !== undefined\n\t\t\t\t\t? self.performance.now()\n\t\t\t\t\t: Date.now();\n\n\t\tthis.oldTime = this.startTime;\n\t\tthis.running = true;\n\t},\n\n\tstop: function () {\n\n\t\tthis.getElapsedTime();\n\t\tthis.running = false;\n\n\t},\n\n\tgetElapsedTime: function () {\n\n\t\tthis.getDelta();\n\t\treturn this.elapsedTime;\n\n\t},\n\n\tgetDelta: function () {\n\n\t\tvar diff = 0;\n\n\t\tif ( this.autoStart && ! this.running ) {\n\n\t\t\tthis.start();\n\n\t\t}\n\n\t\tif ( this.running ) {\n\n\t\t\tvar newTime = self.performance !== undefined && self.performance.now !== undefined\n\t\t\t\t\t? self.performance.now()\n\t\t\t\t\t: Date.now();\n\n\t\t\tdiff = 0.001 * ( newTime - this.oldTime );\n\t\t\tthis.oldTime = newTime;\n\n\t\t\tthis.elapsedTime += diff;\n\n\t\t}\n\n\t\treturn diff;\n\n\t}\n\n};\n\n/**\n * https://github.com/mrdoob/eventdispatcher.js/\n */\n\nTHREE.EventDispatcher = function () {}\n\nTHREE.EventDispatcher.prototype = {\n\n\tconstructor: THREE.EventDispatcher,\n\n\tapply: function ( object ) {\n\n\t\tobject.addEventListener = THREE.EventDispatcher.prototype.addEventListener;\n\t\tobject.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;\n\t\tobject.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;\n\t\tobject.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\n\n\t},\n\n\taddEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) this._listeners = {};\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] === undefined ) {\n\n\t\t\tlisteners[ type ] = [];\n\n\t\t}\n\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\n\n\t\t\tlisteners[ type ].push( listener );\n\n\t\t}\n\n\t},\n\n\thasEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return false;\n\n\t\tvar listeners = this._listeners;\n\n\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t},\n\n\tremoveEventListener: function ( type, listener ) {\n\n\t\tif ( this._listeners === undefined ) return;\n\n\t\tvar listeners = this._listeners;\n\t\tvar listenerArray = listeners[ type ];\n\n\t\tif ( listenerArray !== undefined ) {\n\n\t\t\tvar index = listenerArray.indexOf( listener );\n\n\t\t\tif ( index !== - 1 ) {\n\n\t\t\t\tlistenerArray.splice( index, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tdispatchEvent: function () {\n\n\t\tvar array = [];\n\n\t\treturn function ( event ) {\n\n\t\t\tif ( this._listeners === undefined ) return;\n\n\t\t\tvar listeners = this._listeners;\n\t\t\tvar listenerArray = listeners[ event.type ];\n\n\t\t\tif ( listenerArray !== undefined ) {\n\n\t\t\t\tevent.target = this;\n\n\t\t\t\tvar length = listenerArray.length;\n\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tarray[ i ] = listenerArray[ i ];\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < length; i ++ ) {\n\n\t\t\t\t\tarray[ i ].call( this, event );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}()\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author bhouston / http://exocortex.com/\n * @author stephomi / http://stephaneginier.com/\n */\n\n( function ( THREE ) {\n\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\n\n\t\tthis.ray = new THREE.Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near || 0;\n\t\tthis.far = far || Infinity;\n\n\t};\n\n\tvar sphere = new THREE.Sphere();\n\tvar localRay = new THREE.Ray();\n\tvar facePlane = new THREE.Plane();\n\tvar intersectPoint = new THREE.Vector3();\n\tvar matrixPosition = new THREE.Vector3();\n\n\tvar inverseMatrix = new THREE.Matrix4();\n\n\tvar descSort = function ( a, b ) {\n\n\t\treturn a.distance - b.distance;\n\n\t};\n\n\tvar vA = new THREE.Vector3();\n\tvar vB = new THREE.Vector3();\n\tvar vC = new THREE.Vector3();\n\n\tvar intersectObject = function ( object, raycaster, intersects ) {\n\n\t\tif ( object instanceof THREE.Sprite ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( object.matrixWorld );\n\t\t\tvar distance = raycaster.ray.distanceToPoint( matrixPosition );\n\n\t\t\tif ( distance > object.scale.x ) {\n\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\tintersects.push( {\n\n\t\t\t\tdistance: distance,\n\t\t\t\tpoint: object.position,\n\t\t\t\tface: null,\n\t\t\t\tobject: object\n\n\t\t\t} );\n\n\t\t} else if ( object instanceof THREE.LOD ) {\n\n\t\t\tmatrixPosition.setFromMatrixPosition( object.matrixWorld );\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\n\n\t\t\tintersectObject( object.getObjectForDistance( distance ), raycaster, intersects );\n\n\t\t} else if ( object instanceof THREE.Mesh ) {\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( object.matrixWorld );\n\n\t\t\tif ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\n\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\n\t\t\t// Check boundingBox before continuing\n\t\t\t\n\t\t\tinverseMatrix.getInverse( object.matrixWorld );  \n\t\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\tif ( geometry.boundingBox !== null ) {\n\n\t\t\t\tif ( localRay.isIntersectionBox( geometry.boundingBox ) === false )  {\n\n\t\t\t\t\treturn intersects;\n\n\t\t\t\t}\n\n\t\t\t} \n\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tvar material = object.material;\n\n\t\t\t\tif ( material === undefined ) return intersects;\n\t\t\t\tif ( geometry.dynamic === false ) return intersects;\n\n\t\t\t\tvar a, b, c;\n\t\t\t\tvar precision = raycaster.precision;\n\n\t\t\t\tif ( geometry.attributes.index !== undefined ) {\n\n\t\t\t\t\tvar offsets = geometry.offsets;\n\t\t\t\t\tvar indices = geometry.attributes.index.array;\n\t\t\t\t\tvar positions = geometry.attributes.position.array;\n\t\t\t\t\tvar offLength = geometry.offsets.length;\n\n\t\t\t\t\tvar fl = geometry.attributes.index.array.length / 3;\n\n\t\t\t\t\tfor ( var oi = 0; oi < offLength; ++oi ) {\n\n\t\t\t\t\t\tvar start = offsets[ oi ].start;\n\t\t\t\t\t\tvar count = offsets[ oi ].count;\n\t\t\t\t\t\tvar index = offsets[ oi ].index;\n\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\t\ta = index + indices[ i ];\n\t\t\t\t\t\t\tb = index + indices[ i + 1 ]; \n\t\t\t\t\t\t\tc = index + indices[ i + 2 ];\n\n\t\t\t\t\t\t\tvA.set(\n\t\t\t\t\t\t\t\tpositions[ a * 3 ],\n\t\t\t\t\t\t\t\tpositions[ a * 3 + 1 ],\n\t\t\t\t\t\t\t\tpositions[ a * 3 + 2 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tvB.set(\n\t\t\t\t\t\t\t\tpositions[ b * 3 ],\n\t\t\t\t\t\t\t\tpositions[ b * 3 + 1 ],\n\t\t\t\t\t\t\t\tpositions[ b * 3 + 2 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tvC.set(\n\t\t\t\t\t\t\t\tpositions[ c * 3 ],\n\t\t\t\t\t\t\t\tpositions[ c * 3 + 1 ],\n\t\t\t\t\t\t\t\tpositions[ c * 3 + 2 ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ( material.side === THREE.BackSide ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( vC, vB, vA, true ); \n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( intersectionPoint === null ) continue;\n\n\t\t\t\t\t\t\tintersectionPoint.applyMatrix4( object.matrixWorld );\n\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\n\n\t\t\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\t\tpoint: intersectionPoint,\n\t\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar offsets = geometry.offsets;\n\t\t\t\t\tvar positions = geometry.attributes.position.array;\n\t\t\t\t\tvar offLength = geometry.offsets.length;\n\n\t\t\t\t\tvar fl = geometry.attributes.position.array.length;\n\n\t\t\t\t\tfor ( var i = 0; i < fl; i += 3 ) {\n\n\t\t\t\t\t\ta = i;\n\t\t\t\t\t\tb = i + 1;\n\t\t\t\t\t\tc = i + 2;\n\n\t\t\t\t\t\tvA.set(\n\t\t\t\t\t\t\tpositions[ a * 3 ],\n\t\t\t\t\t\t\tpositions[ a * 3 + 1 ],\n\t\t\t\t\t\t\tpositions[ a * 3 + 2 ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tvB.set(\n\t\t\t\t\t\t\tpositions[ b * 3 ],\n\t\t\t\t\t\t\tpositions[ b * 3 + 1 ],\n\t\t\t\t\t\t\tpositions[ b * 3 + 2 ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tvC.set(\n\t\t\t\t\t\t\tpositions[ c * 3 ],\n\t\t\t\t\t\t\tpositions[ c * 3 + 1 ],\n\t\t\t\t\t\t\tpositions[ c * 3 + 2 ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( material.side === THREE.BackSide ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( vC, vB, vA, true ); \n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( intersectionPoint === null ) continue;\n\n\t\t\t\t\t\tintersectionPoint.applyMatrix4( object.matrixWorld );\n\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\n\n\t\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t\tpoint: intersectionPoint,\n\t\t\t\t\t\t\tface: null,\n\t\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tvar isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\n\t\t\t\tvar objectMaterials = isFaceMaterial === true ? object.material.materials : null;\n\n\t\t\t\tvar a, b, c, d;\n\t\t\t\tvar precision = raycaster.precision;\n\n\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\tfor ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tvar face = geometry.faces[ f ];\n\n\t\t\t\t\tvar material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : object.material;\n\n\t\t\t\t\tif ( material === undefined ) continue;\n\n\t\t\t\t\ta = vertices[ face.a ];\n\t\t\t\t\tb = vertices[ face.b ];\n\t\t\t\t\tc = vertices[ face.c ];\n\n\t\t\t\t\tif ( material.morphTargets === true ) {\n\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\n\n\t\t\t\t\t\tvA.set( 0, 0, 0 );\n\t\t\t\t\t\tvB.set( 0, 0, 0 );\n\t\t\t\t\t\tvC.set( 0, 0, 0 );\n\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\tvA.x += ( targets[ face.a ].x - a.x ) * influence;\n\t\t\t\t\t\t\tvA.y += ( targets[ face.a ].y - a.y ) * influence;\n\t\t\t\t\t\t\tvA.z += ( targets[ face.a ].z - a.z ) * influence;\n\n\t\t\t\t\t\t\tvB.x += ( targets[ face.b ].x - b.x ) * influence;\n\t\t\t\t\t\t\tvB.y += ( targets[ face.b ].y - b.y ) * influence;\n\t\t\t\t\t\t\tvB.z += ( targets[ face.b ].z - b.z ) * influence;\n\n\t\t\t\t\t\t\tvC.x += ( targets[ face.c ].x - c.x ) * influence;\n\t\t\t\t\t\t\tvC.y += ( targets[ face.c ].y - c.y ) * influence;\n\t\t\t\t\t\t\tvC.z += ( targets[ face.c ].z - c.z ) * influence;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvA.add( a );\n\t\t\t\t\t\tvB.add( b );\n\t\t\t\t\t\tvC.add( c );\n\n\t\t\t\t\t\ta = vA;\n\t\t\t\t\t\tb = vB;\n\t\t\t\t\t\tc = vC;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material.side === THREE.BackSide ) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( c, b, a, true );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tvar intersectionPoint = localRay.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( intersectionPoint === null ) continue;\n\n\t\t\t\t\tintersectionPoint.applyMatrix4( object.matrixWorld );\n\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPoint );\n\n\t\t\t\t\tif ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\tpoint: intersectionPoint,\n\t\t\t\t\t\tface: face,\n\t\t\t\t\t\tfaceIndex: f,\n\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tvar precision = raycaster.linePrecision;\n\t\t\tvar precisionSq = precision * precision;\n\n\t\t\tvar geometry = object.geometry;\n\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t\t// Checking boundingSphere distance to ray\n\n\t\t\tsphere.copy( geometry.boundingSphere );\n\t\t\tsphere.applyMatrix4( object.matrixWorld );\n\t\t\t\n\t\t\tif ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\n\n\t\t\t\treturn intersects;\n\n\t\t\t}\n\t\t\t\n\t\t\tinverseMatrix.getInverse( object.matrixWorld );\n\t\t\tlocalRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\n\n\t\t\t/* if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t} else */ if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\tvar vertices = geometry.vertices;\n\t\t\t\tvar nbVertices = vertices.length;\n\t\t\t\tvar interSegment = new THREE.Vector3();\n\t\t\t\tvar interRay = new THREE.Vector3();\n\t\t\t\tvar step = object.type === THREE.LineStrip ? 1 : 2;\n\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i = i + step ) {\n\n\t\t\t\t\tvar distSq = localRay.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\n\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\n\n\t\t\t\t\tvar distance = localRay.origin.distanceTo( interRay );\n\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\n\n\t\t\t\t\tintersects.push( {\n\n\t\t\t\t\t\tdistance: distance,\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( object.matrixWorld ),\n\t\t\t\t\t\tface: null,\n\t\t\t\t\t\tfaceIndex: null,\n\t\t\t\t\t\tobject: object\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tvar intersectDescendants = function ( object, raycaster, intersects ) {\n\n\t\tvar descendants = object.getDescendants();\n\n\t\tfor ( var i = 0, l = descendants.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( descendants[ i ], raycaster, intersects );\n\n\t\t}\n\t};\n\n\t//\n\n\tTHREE.Raycaster.prototype.precision = 0.0001;\n\tTHREE.Raycaster.prototype.linePrecision = 1;\n\n\tTHREE.Raycaster.prototype.set = function ( origin, direction ) {\n\n\t\tthis.ray.set( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t};\n\n\tTHREE.Raycaster.prototype.intersectObject = function ( object, recursive ) {\n\n\t\tvar intersects = [];\n\n\t\tif ( recursive === true ) {\n\n\t\t\tintersectDescendants( object, this, intersects );\n\n\t\t}\n\n\t\tintersectObject( object, this, intersects );\n\n\t\tintersects.sort( descSort );\n\n\t\treturn intersects;\n\n\t};\n\n\tTHREE.Raycaster.prototype.intersectObjects = function ( objects, recursive ) {\n\n\t\tvar intersects = [];\n\n\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( objects[ i ], this, intersects );\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tintersectDescendants( objects[ i ], this, intersects );\n\n\t\t\t}\n\n\t\t}\n\n\t\tintersects.sort( descSort );\n\n\t\treturn intersects;\n\n\t};\n\n}( THREE ) );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.Object3D = function () {\n\n\tthis.id = THREE.Object3DIdCount ++;\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\n\tthis.parent = undefined;\n\tthis.children = [];\n\n\tthis.up = new THREE.Vector3( 0, 1, 0 );\n\n\tthis.position = new THREE.Vector3();\n\tthis._rotation = new THREE.Euler();\n\tthis._quaternion = new THREE.Quaternion();\n\tthis.scale = new THREE.Vector3( 1, 1, 1 );\n\n\t// keep rotation and quaternion in sync\n\n\tthis._rotation._quaternion = this.quaternion;\n\tthis._quaternion._euler = this.rotation;\n\n\tthis.renderDepth = null;\n\n\tthis.rotationAutoUpdate = true;\n\n\tthis.matrix = new THREE.Matrix4();\n\tthis.matrixWorld = new THREE.Matrix4();\n\n\tthis.matrixAutoUpdate = true;\n\tthis.matrixWorldNeedsUpdate = true;\n\n\tthis.visible = true;\n\n\tthis.castShadow = false;\n\tthis.receiveShadow = false;\n\n\tthis.frustumCulled = true;\n\n\tthis.userData = {};\n\n};\n\n\nTHREE.Object3D.prototype = {\n\n\tconstructor: THREE.Object3D,\n\t\n\tget rotation () { \n\t\treturn this._rotation; \n\t},\n\n\tset rotation ( value ) {\n\t\t\n\t\tthis._rotation = value;\n\t\tthis._rotation._quaternion = this._quaternion;\n\t\tthis._quaternion._euler = this._rotation;\n\t\tthis._rotation._updateQuaternion();\n\t\t\n\t},\n\n\tget quaternion () { \n\t\treturn this._quaternion; \n\t},\n\t\n\tset quaternion ( value ) {\n\t\t\n\t\tthis._quaternion = value;\n\t\tthis._quaternion._euler = this._rotation;\n\t\tthis._rotation._quaternion = this._quaternion;\n\t\tthis._quaternion._updateEuler();\n\t\t\n\t},\n\n\tget eulerOrder () {\n\n\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .eulerOrder has been moved to Object3D\\'s .rotation.order.' );\n\n\t\treturn this.rotation.order;\n\n\t},\n\n\tset eulerOrder ( value ) {\n\n\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .eulerOrder has been moved to Object3D\\'s .rotation.order.' );\n\n\t\tthis.rotation.order = value;\n\n\t},\n\n\tget useQuaternion () {\n\n\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .useQuaternion has been removed. The library now uses quaternions by default.' );\n\n\t},\n\n\tset useQuaternion ( value ) {\n\n\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .useQuaternion has been removed. The library now uses quaternions by default.' );\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\n\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\n\n\t},\n\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\n\n\t\t// assumes axis is normalized\n\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\n\n\t},\n\n\tsetRotationFromEuler: function ( euler ) {\n\n\t\tthis.quaternion.setFromEuler( euler, true );\n\n\t},\n\n\tsetRotationFromMatrix: function ( m ) {\n\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tthis.quaternion.setFromRotationMatrix( m );\n\n\t},\n\n\tsetRotationFromQuaternion: function ( q ) {\n\n\t\t// assumes q is normalized\n\n\t\tthis.quaternion.copy( q );\n\n\t},\n\n\trotateOnAxis: function() {\n\n\t\t// rotate object on axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar q1 = new THREE.Quaternion();\n\n\t\treturn function ( axis, angle ) {\n\n\t\t\tq1.setFromAxisAngle( axis, angle );\n\n\t\t\tthis.quaternion.multiply( q1 );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t}(),\n\n\trotateX: function () {\n\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\n\t\treturn function ( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateY: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\n\t\treturn function ( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\trotateZ: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\n\t\treturn function ( angle ) {\n\n\t\t\treturn this.rotateOnAxis( v1, angle );\n\n\t\t};\n\n\t}(),\n\n\ttranslateOnAxis: function () {\n\n\t\t// translate object by distance along axis in object space\n\t\t// axis is assumed to be normalized\n\n\t\tvar v1 = new THREE.Vector3();\n\n\t\treturn function ( axis, distance ) {\n\n\t\t\tv1.copy( axis );\n\n\t\t\tv1.applyQuaternion( this.quaternion );\n\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\n\n\t\t\treturn this;\n\n\t\t}\n\n\t}(),\n\n\ttranslate: function ( distance, axis ) {\n\n\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.' );\n\t\treturn this.translateOnAxis( axis, distance );\n\n\t},\n\n\ttranslateX: function () {\n\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\n\n\t\treturn function ( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateY: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\n\n\t\treturn function ( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\ttranslateZ: function () {\n\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\n\n\t\treturn function ( distance ) {\n\n\t\t\treturn this.translateOnAxis( v1, distance );\n\n\t\t};\n\n\t}(),\n\n\tlocalToWorld: function ( vector ) {\n\n\t\treturn vector.applyMatrix4( this.matrixWorld );\n\n\t},\n\n\tworldToLocal: function () {\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function ( vector ) {\n\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\n\n\t\t};\n\n\t}(),\n\n\tlookAt: function () {\n\n\t\t// This routine does not support objects with rotated and/or translated parent(s)\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function ( vector ) {\n\n\t\t\tm1.lookAt( vector, this.position, this.up );\n\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t\t};\n\n\t}(),\n\n\tadd: function ( object ) {\n\n\t\tif ( object === this ) {\n\n\t\t\tconsole.warn( 'THREE.Object3D.add: An object can\\'t be added as a child of itself.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( object instanceof THREE.Object3D ) {\n\n\t\t\tif ( object.parent !== undefined ) {\n\n\t\t\t\tobject.parent.remove( object );\n\n\t\t\t}\n\n\t\t\tobject.parent = this;\n\t\t\tobject.dispatchEvent( { type: 'added' } );\n\n\t\t\tthis.children.push( object );\n\n\t\t\t// add to scene\n\n\t\t\tvar scene = this;\n\n\t\t\twhile ( scene.parent !== undefined ) {\n\n\t\t\t\tscene = scene.parent;\n\n\t\t\t}\n\n\t\t\tif ( scene !== undefined && scene instanceof THREE.Scene )  {\n\n\t\t\t\tscene.__addObject( object );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tremove: function ( object ) {\n\n\t\tvar index = this.children.indexOf( object );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\tobject.parent = undefined;\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\n\n\t\t\tthis.children.splice( index, 1 );\n\n\t\t\t// remove from scene\n\n\t\t\tvar scene = this;\n\n\t\t\twhile ( scene.parent !== undefined ) {\n\n\t\t\t\tscene = scene.parent;\n\n\t\t\t}\n\n\t\t\tif ( scene !== undefined && scene instanceof THREE.Scene ) {\n\n\t\t\t\tscene.__removeObject( object );\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\ttraverse: function ( callback ) {\n\n\t\tcallback( this );\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].traverse( callback );\n\n\t\t}\n\n\t},\n\n\tgetObjectById: function ( id, recursive ) {\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\n\t\t\tif ( child.id === id ) {\n\n\t\t\t\treturn child;\n\n\t\t\t}\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tchild = child.getObjectById( id, recursive );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\treturn child;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t},\n\n\tgetObjectByName: function ( name, recursive ) {\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\n\t\t\tif ( child.name === name ) {\n\n\t\t\t\treturn child;\n\n\t\t\t}\n\n\t\t\tif ( recursive === true ) {\n\n\t\t\t\tchild = child.getObjectByName( name, recursive );\n\n\t\t\t\tif ( child !== undefined ) {\n\n\t\t\t\t\treturn child;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t},\n\n\tgetChildByName: function ( name, recursive ) {\n\n\t\tconsole.warn( 'DEPRECATED: Object3D\\'s .getChildByName() has been renamed to .getObjectByName().' );\n\t\treturn this.getObjectByName( name, recursive );\n\n\t},\n\n\tgetDescendants: function ( array ) {\n\n\t\tif ( array === undefined ) array = [];\n\n\t\tArray.prototype.push.apply( array, this.children );\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].getDescendants( array );\n\n\t\t}\n\n\t\treturn array;\n\n\t},\n\n\tupdateMatrix: function () {\n\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\t\tthis.matrixWorldNeedsUpdate = true;\n\n\t},\n\n\tupdateMatrixWorld: function ( force ) {\n\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\n\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\n\n\t\t\tif ( this.parent === undefined ) {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\n\n\t\t}\n\n\t},\n\n\tclone: function ( object, recursive ) {\n\n\t\tif ( object === undefined ) object = new THREE.Object3D();\n\t\tif ( recursive === undefined ) recursive = true;\n\n\t\tobject.name = this.name;\n\n\t\tobject.up.copy( this.up );\n\n\t\tobject.position.copy( this.position );\n\t\tobject.quaternion.copy( this.quaternion );\n\t\tobject.scale.copy( this.scale );\n\n\t\tobject.renderDepth = this.renderDepth;\n\n\t\tobject.rotationAutoUpdate = this.rotationAutoUpdate;\n\n\t\tobject.matrix.copy( this.matrix );\n\t\tobject.matrixWorld.copy( this.matrixWorld );\n\n\t\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\n\t\tobject.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\n\n\t\tobject.visible = this.visible;\n\n\t\tobject.castShadow = this.castShadow;\n\t\tobject.receiveShadow = this.receiveShadow;\n\n\t\tobject.frustumCulled = this.frustumCulled;\n\n\t\tobject.userData = JSON.parse( JSON.stringify( this.userData ) );\n\n\t\tif ( recursive === true ) {\n\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\n\n\t\t\t\tvar child = this.children[ i ];\n\t\t\t\tobject.add( child.clone() );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn object;\n\n\t}\n\n};\n\nTHREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );\n\nTHREE.Object3DIdCount = 0;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author julianwa / https://github.com/julianwa\n */\n\nTHREE.Projector = function () {\n\n\tvar _object, _objectCount, _objectPool = [], _objectPoolLength = 0,\n\t_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,\n\t_face, _face3Count, _face3Pool = [], _face3PoolLength = 0,\n\t_line, _lineCount, _linePool = [], _linePoolLength = 0,\n\t_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,\n\n\t_renderData = { objects: [], sprites: [], lights: [], elements: [] },\n\n\t_vA = new THREE.Vector3(),\n\t_vB = new THREE.Vector3(),\n\t_vC = new THREE.Vector3(),\n\n\t_vector3 = new THREE.Vector3(),\n\t_vector4 = new THREE.Vector4(),\n\n\t_clipBox = new THREE.Box3( new THREE.Vector3( -1, -1, -1 ), new THREE.Vector3( 1, 1, 1 ) ),\n\t_boundingBox = new THREE.Box3(),\n\t_points3 = new Array( 3 ),\n\t_points4 = new Array( 4 ),\n\n\t_viewMatrix = new THREE.Matrix4(),\n\t_viewProjectionMatrix = new THREE.Matrix4(),\n\n\t_modelMatrix,\n\t_modelViewProjectionMatrix = new THREE.Matrix4(),\n\n\t_normalMatrix = new THREE.Matrix3(),\n\t_normalViewMatrix = new THREE.Matrix3(),\n\n\t_centroid = new THREE.Vector3(),\n\n\t_frustum = new THREE.Frustum(),\n\n\t_clippedVertex1PositionScreen = new THREE.Vector4(),\n\t_clippedVertex2PositionScreen = new THREE.Vector4();\n\n\tthis.projectVector = function ( vector, camera ) {\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\n\t\treturn vector.applyProjection( _viewProjectionMatrix );\n\n\t};\n\n\tthis.unprojectVector = function () {\n\n\t\tvar projectionMatrixInverse = new THREE.Matrix4();\n\n\t\treturn function ( vector, camera ) {\n\n\t\t\tprojectionMatrixInverse.getInverse( camera.projectionMatrix );\n\t\t\t_viewProjectionMatrix.multiplyMatrices( camera.matrixWorld, projectionMatrixInverse );\n\n\t\t\treturn vector.applyProjection( _viewProjectionMatrix );\n\n\t\t};\n\n\t}();\n\n\tthis.pickingRay = function ( vector, camera ) {\n\n\t\t// set two vectors with opposing z values\n\t\tvector.z = -1.0;\n\t\tvar end = new THREE.Vector3( vector.x, vector.y, 1.0 );\n\n\t\tthis.unprojectVector( vector, camera );\n\t\tthis.unprojectVector( end, camera );\n\n\t\t// find direction from vector to end\n\t\tend.sub( vector ).normalize();\n\n\t\treturn new THREE.Raycaster( vector, end );\n\n\t};\n\n\tvar getObject = function ( object ) {\n\n\t\t_object = getNextObjectInPool();\n\t\t_object.id = object.id;\n\t\t_object.object = object;\n\n\t\tif ( object.renderDepth !== null ) {\n\n\t\t\t_object.z = object.renderDepth;\n\n\t\t} else {\n\n\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t_vector3.applyProjection( _viewProjectionMatrix );\n\t\t\t_object.z = _vector3.z;\n\n\t\t}\n\n\t\treturn _object;\n\n\t};\n\n\tvar projectVertex = function ( vertex ) {\n\n\t\tvar position = vertex.position;\n\t\tvar positionWorld = vertex.positionWorld;\n\t\tvar positionScreen = vertex.positionScreen;\n\n\t\tpositionWorld.copy( position ).applyMatrix4( _modelMatrix );\n\t\tpositionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );\n\n\t\tvar invW = 1 / positionScreen.w;\n\n\t\tpositionScreen.x *= invW;\n\t\tpositionScreen.y *= invW;\n\t\tpositionScreen.z *= invW;\n\n\t\tvertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 &&\n\t\t\t\t positionScreen.y >= -1 && positionScreen.y <= 1 &&\n\t\t\t\t positionScreen.z >= -1 && positionScreen.z <= 1;\n\n\t};\n\n\tvar projectObject = function ( object ) {\n\n\t\tif ( object.visible === false ) return;\n\n\t\tif ( object instanceof THREE.Light ) {\n\n\t\t\t_renderData.lights.push( object );\n\n\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line ) {\n\n\t\t\tif ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {\n\n\t\t\t\t_renderData.objects.push( getObject( object ) );\n\n\t\t\t}\n\n\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t_renderData.sprites.push( getObject( object ) );\n\n\t\t}\n\n\t\tfor ( var i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\tprojectObject( object.children[ i ] );\n\n\t\t}\n\n\t};\n\n\tvar projectGraph = function ( root, sortObjects ) {\n\n\t\t_objectCount = 0;\n\n\t\t_renderData.objects.length = 0;\n\t\t_renderData.sprites.length = 0;\n\t\t_renderData.lights.length = 0;\n\n\t\tprojectObject( root );\n\n\t\tif ( sortObjects === true ) {\n\n\t\t\t_renderData.objects.sort( painterSort );\n\n\t\t}\n\n\t};\n\n\tthis.projectScene = function ( scene, camera, sortObjects, sortElements ) {\n\n\t\tvar visible = false,\n\t\tobject, geometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs,\n\t\tv1, v2, v3, v4, isFaceMaterial, objectMaterials;\n\n\t\t_face3Count = 0;\n\t\t_lineCount = 0;\n\t\t_spriteCount = 0;\n\n\t\t_renderData.elements.length = 0;\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\n\t\t_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );\n\t\t_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );\n\n\t\t_normalViewMatrix.getNormalMatrix( _viewMatrix );\n\n\t\t_frustum.setFromMatrix( _viewProjectionMatrix );\n\n\t\tprojectGraph( scene, sortObjects );\n\n\t\tfor ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {\n\n\t\t\tobject = _renderData.objects[ o ].object;\n\n\t\t\t_modelMatrix = object.matrixWorld;\n\n\t\t\t_vertexCount = 0;\n\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t\tgeometry = object.geometry;\n\n\t\t\t\tvertices = geometry.vertices;\n\t\t\t\tfaces = geometry.faces;\n\t\t\t\tfaceVertexUvs = geometry.faceVertexUvs;\n\n\t\t\t\t_normalMatrix.getNormalMatrix( _modelMatrix );\n\n\t\t\t\tisFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;\n\t\t\t\tobjectMaterials = isFaceMaterial === true ? object.material : null;\n\n\t\t\t\tfor ( var v = 0, vl = vertices.length; v < vl; v ++ ) {\n\n\t\t\t\t\t_vertex = getNextVertexInPool();\n\t\t\t\t\t_vertex.position.copy( vertices[ v ] );\n\n\t\t\t\t\tprojectVertex( _vertex );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = faces[ f ];\n\n\t\t\t\t\tvar material = isFaceMaterial === true\n\t\t\t\t\t\t? objectMaterials.materials[ face.materialIndex ]\n\t\t\t\t\t\t: object.material;\n\n\t\t\t\t\tif ( material === undefined ) continue;\n\n\t\t\t\t\tvar side = material.side;\n\n\t\t\t\t\tv1 = _vertexPool[ face.a ];\n\t\t\t\t\tv2 = _vertexPool[ face.b ];\n\t\t\t\t\tv3 = _vertexPool[ face.c ];\n\n\t\t\t\t\tif ( material.morphTargets === true ) {\n\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\n\t\t\t\t\t\tvar morphInfluences = object.morphTargetInfluences;\n\n\t\t\t\t\t\tvar v1p = v1.position;\n\t\t\t\t\t\tvar v2p = v2.position;\n\t\t\t\t\t\tvar v3p = v3.position;\n\n\t\t\t\t\t\t_vA.set( 0, 0, 0 );\n\t\t\t\t\t\t_vB.set( 0, 0, 0 );\n\t\t\t\t\t\t_vC.set( 0, 0, 0 );\n\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\n\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\n\n\t\t\t\t\t\t\t_vA.x += ( targets[ face.a ].x - v1p.x ) * influence;\n\t\t\t\t\t\t\t_vA.y += ( targets[ face.a ].y - v1p.y ) * influence;\n\t\t\t\t\t\t\t_vA.z += ( targets[ face.a ].z - v1p.z ) * influence;\n\n\t\t\t\t\t\t\t_vB.x += ( targets[ face.b ].x - v2p.x ) * influence;\n\t\t\t\t\t\t\t_vB.y += ( targets[ face.b ].y - v2p.y ) * influence;\n\t\t\t\t\t\t\t_vB.z += ( targets[ face.b ].z - v2p.z ) * influence;\n\n\t\t\t\t\t\t\t_vC.x += ( targets[ face.c ].x - v3p.x ) * influence;\n\t\t\t\t\t\t\t_vC.y += ( targets[ face.c ].y - v3p.y ) * influence;\n\t\t\t\t\t\t\t_vC.z += ( targets[ face.c ].z - v3p.z ) * influence;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tv1.position.add( _vA );\n\t\t\t\t\t\tv2.position.add( _vB );\n\t\t\t\t\t\tv3.position.add( _vC );\n\n\t\t\t\t\t\tprojectVertex( v1 );\n\t\t\t\t\t\tprojectVertex( v2 );\n\t\t\t\t\t\tprojectVertex( v3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_points3[ 0 ] = v1.positionScreen;\n\t\t\t\t\t_points3[ 1 ] = v2.positionScreen;\n\t\t\t\t\t_points3[ 2 ] = v3.positionScreen;\n\n\t\t\t\t\tif ( v1.visible === true || v2.visible === true || v3.visible === true ||\n\t\t\t\t\t\t_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) ) ) {\n\n\t\t\t\t\t\tvisible = ( ( v3.positionScreen.x - v1.positionScreen.x ) *\n\t\t\t\t\t\t\t    ( v2.positionScreen.y - v1.positionScreen.y ) -\n\t\t\t\t\t\t\t    ( v3.positionScreen.y - v1.positionScreen.y ) *\n\t\t\t\t\t\t\t    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;\n\n\t\t\t\t\t\tif ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {\n\n\t\t\t\t\t\t\t_face = getNextFace3InPool();\n\n\t\t\t\t\t\t\t_face.id = object.id;\n\t\t\t\t\t\t\t_face.v1.copy( v1 );\n\t\t\t\t\t\t\t_face.v2.copy( v2 );\n\t\t\t\t\t\t\t_face.v3.copy( v3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_face.normalModel.copy( face.normal );\n\n\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\n\t\t\t\t\t\t_face.normalModel.negate();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_face.normalModel.applyMatrix3( _normalMatrix ).normalize();\n\n\t\t\t\t\t_face.normalModelView.copy( _face.normalModel ).applyMatrix3( _normalViewMatrix );\n\n\t\t\t\t\t_face.centroidModel.copy( face.centroid ).applyMatrix4( _modelMatrix );\n\n\t\t\t\t\tfaceVertexNormals = face.vertexNormals;\n\n\t\t\t\t\tfor ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {\n\n\t\t\t\t\t\tvar normalModel = _face.vertexNormalsModel[ n ];\n\t\t\t\t\t\tnormalModel.copy( faceVertexNormals[ n ] );\n\n\t\t\t\t\t\tif ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {\n\n\t\t\t\t\t\t\tnormalModel.negate();\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnormalModel.applyMatrix3( _normalMatrix ).normalize();\n\n\t\t\t\t\t\tvar normalModelView = _face.vertexNormalsModelView[ n ];\n\t\t\t\t\t\tnormalModelView.copy( normalModel ).applyMatrix3( _normalViewMatrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_face.vertexNormalsLength = faceVertexNormals.length;\n\n\t\t\t\t\tfor ( var c = 0, cl = Math.min( faceVertexUvs.length, 3 ); c < cl; c ++ ) {\n\n\t\t\t\t\t\tuvs = faceVertexUvs[ c ][ f ];\n\n\t\t\t\t\t\tif ( uvs === undefined ) continue;\n\n\t\t\t\t\t\tfor ( var u = 0, ul = uvs.length; u < ul; u ++ ) {\n\n\t\t\t\t\t\t\t_face.uvs[ c ][ u ] = uvs[ u ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_face.color = face.color;\n\t\t\t\t\t_face.material = material;\n\n\t\t\t\t\t_centroid.copy( _face.centroidModel ).applyProjection( _viewProjectionMatrix );\n\n\t\t\t\t\t_face.z = _centroid.z;\n\n\t\t\t\t\t_renderData.elements.push( _face );\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\t\t_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );\n\n\t\t\t\tvertices = object.geometry.vertices;\n\n\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\tv1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );\n\n\t\t\t\t// Handle LineStrip and LinePieces\n\t\t\t\tvar step = object.type === THREE.LinePieces ? 2 : 1;\n\n\t\t\t\tfor ( v = 1, vl = vertices.length; v < vl; v ++ ) {\n\n\t\t\t\t\tv1 = getNextVertexInPool();\n\t\t\t\t\tv1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );\n\n\t\t\t\t\tif ( ( v + 1 ) % step > 0 ) continue;\n\n\t\t\t\t\tv2 = _vertexPool[ _vertexCount - 2 ];\n\n\t\t\t\t\t_clippedVertex1PositionScreen.copy( v1.positionScreen );\n\t\t\t\t\t_clippedVertex2PositionScreen.copy( v2.positionScreen );\n\n\t\t\t\t\tif ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {\n\n\t\t\t\t\t\t// Perform the perspective divide\n\t\t\t\t\t\t_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );\n\t\t\t\t\t\t_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );\n\n\t\t\t\t\t\t_line = getNextLineInPool();\n\n\t\t\t\t\t\t_line.id = object.id;\n\t\t\t\t\t\t_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );\n\t\t\t\t\t\t_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );\n\n\t\t\t\t\t\t_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );\n\n\t\t\t\t\t\t_line.material = object.material;\n\n\t\t\t\t\t\tif ( object.material.vertexColors === THREE.VertexColors ) {\n\n\t\t\t\t\t\t\t_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );\n\t\t\t\t\t\t\t_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t_renderData.elements.push( _line );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( o = 0, ol = _renderData.sprites.length; o < ol; o++ ) {\n\n\t\t\tobject = _renderData.sprites[ o ].object;\n\n\t\t\t_modelMatrix = object.matrixWorld;\n\n\t\t\t_vector4.set( _modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1 );\n\t\t\t_vector4.applyMatrix4( _viewProjectionMatrix );\n\n\t\t\tvar invW = 1 / _vector4.w;\n\n\t\t\t_vector4.z *= invW;\n\n\t\t\tif ( _vector4.z >= -1 && _vector4.z <= 1 ) {\n\n\t\t\t\t_sprite = getNextSpriteInPool();\n\t\t\t\t_sprite.id = object.id;\n\t\t\t\t_sprite.x = _vector4.x * invW;\n\t\t\t\t_sprite.y = _vector4.y * invW;\n\t\t\t\t_sprite.z = _vector4.z;\n\t\t\t\t_sprite.object = object;\n\n\t\t\t\t_sprite.rotation = object.rotation;\n\n\t\t\t\t_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[0] ) / ( _vector4.w + camera.projectionMatrix.elements[12] ) );\n\t\t\t\t_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[5] ) / ( _vector4.w + camera.projectionMatrix.elements[13] ) );\n\n\t\t\t\t_sprite.material = object.material;\n\n\t\t\t\t_renderData.elements.push( _sprite );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( sortElements === true ) _renderData.elements.sort( painterSort );\n\n\t\treturn _renderData;\n\n\t};\n\n\t// Pools\n\n\tfunction getNextObjectInPool() {\n\n\t\tif ( _objectCount === _objectPoolLength ) {\n\n\t\t\tvar object = new THREE.RenderableObject();\n\t\t\t_objectPool.push( object );\n\t\t\t_objectPoolLength ++;\n\t\t\t_objectCount ++;\n\t\t\treturn object;\n\n\t\t}\n\n\t\treturn _objectPool[ _objectCount ++ ];\n\n\t}\n\n\tfunction getNextVertexInPool() {\n\n\t\tif ( _vertexCount === _vertexPoolLength ) {\n\n\t\t\tvar vertex = new THREE.RenderableVertex();\n\t\t\t_vertexPool.push( vertex );\n\t\t\t_vertexPoolLength ++;\n\t\t\t_vertexCount ++;\n\t\t\treturn vertex;\n\n\t\t}\n\n\t\treturn _vertexPool[ _vertexCount ++ ];\n\n\t}\n\n\tfunction getNextFace3InPool() {\n\n\t\tif ( _face3Count === _face3PoolLength ) {\n\n\t\t\tvar face = new THREE.RenderableFace3();\n\t\t\t_face3Pool.push( face );\n\t\t\t_face3PoolLength ++;\n\t\t\t_face3Count ++;\n\t\t\treturn face;\n\n\t\t}\n\n\t\treturn _face3Pool[ _face3Count ++ ];\n\n\n\t}\n\n\tfunction getNextLineInPool() {\n\n\t\tif ( _lineCount === _linePoolLength ) {\n\n\t\t\tvar line = new THREE.RenderableLine();\n\t\t\t_linePool.push( line );\n\t\t\t_linePoolLength ++;\n\t\t\t_lineCount ++\n\t\t\treturn line;\n\n\t\t}\n\n\t\treturn _linePool[ _lineCount ++ ];\n\n\t}\n\n\tfunction getNextSpriteInPool() {\n\n\t\tif ( _spriteCount === _spritePoolLength ) {\n\n\t\t\tvar sprite = new THREE.RenderableSprite();\n\t\t\t_spritePool.push( sprite );\n\t\t\t_spritePoolLength ++;\n\t\t\t_spriteCount ++\n\t\t\treturn sprite;\n\n\t\t}\n\n\t\treturn _spritePool[ _spriteCount ++ ];\n\n\t}\n\n\t//\n\n\tfunction painterSort( a, b ) {\n\n\t\tif ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else if ( a.id !== b.id ) {\n\n\t\t\treturn a.id - b.id;\n\n\t\t} else {\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t}\n\n\tfunction clipLine( s1, s2 ) {\n\n\t\tvar alpha1 = 0, alpha2 = 1,\n\n\t\t// Calculate the boundary coordinate of each vertex for the near and far clip planes,\n\t\t// Z = -1 and Z = +1, respectively.\n\t\tbc1near =  s1.z + s1.w,\n\t\tbc2near =  s2.z + s2.w,\n\t\tbc1far =  - s1.z + s1.w,\n\t\tbc2far =  - s2.z + s2.w;\n\n\t\tif ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {\n\n\t\t\t// Both vertices lie entirely within all clip planes.\n\t\t\treturn true;\n\n\t\t} else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {\n\n\t\t\t// Both vertices lie entirely outside one of the clip planes.\n\t\t\treturn false;\n\n\t\t} else {\n\n\t\t\t// The line segment spans at least one clip plane.\n\n\t\t\tif ( bc1near < 0 ) {\n\n\t\t\t\t// v1 lies outside the near plane, v2 inside\n\t\t\t\talpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );\n\n\t\t\t} else if ( bc2near < 0 ) {\n\n\t\t\t\t// v2 lies outside the near plane, v1 inside\n\t\t\t\talpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );\n\n\t\t\t}\n\n\t\t\tif ( bc1far < 0 ) {\n\n\t\t\t\t// v1 lies outside the far plane, v2 inside\n\t\t\t\talpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );\n\n\t\t\t} else if ( bc2far < 0 ) {\n\n\t\t\t\t// v2 lies outside the far plane, v2 inside\n\t\t\t\talpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );\n\n\t\t\t}\n\n\t\t\tif ( alpha2 < alpha1 ) {\n\n\t\t\t\t// The line segment spans two boundaries, but is outside both of them.\n\t\t\t\t// (This can't happen when we're only clipping against just near/far but good\n\t\t\t\t//  to leave the check here for future usage if other clip planes are added.)\n\t\t\t\treturn false;\n\n\t\t\t} else {\n\n\t\t\t\t// Update the s1 and s2 vertices to match the clipped line segment.\n\t\t\t\ts1.lerp( s2, alpha1 );\n\t\t\t\ts2.lerp( s1, 1 - alpha2 );\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\n\n\tthis.a = a;\n\tthis.b = b;\n\tthis.c = c;\n\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\n\tthis.vertexNormals = normal instanceof Array ? normal : [ ];\n\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\n\tthis.vertexColors = color instanceof Array ? color : [];\n\n\tthis.vertexTangents = [];\n\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\n\n\tthis.centroid = new THREE.Vector3();\n\n};\n\nTHREE.Face3.prototype = {\n\n\tconstructor: THREE.Face3,\n\n\tclone: function () {\n\n\t\tvar face = new THREE.Face3( this.a, this.b, this.c );\n\n\t\tface.normal.copy( this.normal );\n\t\tface.color.copy( this.color );\n\t\tface.centroid.copy( this.centroid );\n\n\t\tface.materialIndex = this.materialIndex;\n\n\t\tvar i, il;\n\t\tfor ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\n\t\tfor ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();\n\t\tfor ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\n\n\t\treturn face;\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\n\n\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.')\n\n\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author bhouston / http://exocortex.com\n */\n\nTHREE.Geometry = function () {\n\n\tthis.id = THREE.GeometryIdCount ++;\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\n\tthis.vertices = [];\n\tthis.colors = [];  // one-to-one vertex colors, used in ParticleSystem and Line\n\n\tthis.faces = [];\n\n\tthis.faceVertexUvs = [[]];\n\n\tthis.morphTargets = [];\n\tthis.morphColors = [];\n\tthis.morphNormals = [];\n\n\tthis.skinWeights = [];\n\tthis.skinIndices = [];\n\n\tthis.lineDistances = [];\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.hasTangents = false;\n\n\tthis.dynamic = true; // the intermediate typed arrays will be deleted when set to false\n\n\t// update flags\n\n\tthis.verticesNeedUpdate = false;\n\tthis.elementsNeedUpdate = false;\n\tthis.uvsNeedUpdate = false;\n\tthis.normalsNeedUpdate = false;\n\tthis.tangentsNeedUpdate = false;\n\tthis.colorsNeedUpdate = false;\n\tthis.lineDistancesNeedUpdate = false;\n\n\tthis.buffersNeedUpdate = false;\n\n};\n\nTHREE.Geometry.prototype = {\n\n\tconstructor: THREE.Geometry,\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = this.vertices[ i ];\n\t\t\tvertex.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = this.faces[ i ];\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tface.centroid.applyMatrix4( matrix );\n\n\t\t}\n\n\t\tif ( this.boundingBox instanceof THREE.Box3 ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere instanceof THREE.Sphere ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t},\n\n\tcomputeCentroids: function () {\n\n\t\tvar f, fl, face;\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\t\t\tface.centroid.set( 0, 0, 0 );\n\n\t\t\tface.centroid.add( this.vertices[ face.a ] );\n\t\t\tface.centroid.add( this.vertices[ face.b ] );\n\t\t\tface.centroid.add( this.vertices[ face.c ] );\n\t\t\tface.centroid.divideScalar( 3 );\n\n\t\t}\n\n\t},\n\n\tcomputeFaceNormals: function () {\n\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\n\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tvar face = this.faces[ f ];\n\n\t\t\tvar vA = this.vertices[ face.a ];\n\t\t\tvar vB = this.vertices[ face.b ];\n\t\t\tvar vC = this.vertices[ face.c ];\n\n\t\t\tcb.subVectors( vC, vB );\n\t\t\tab.subVectors( vA, vB );\n\t\t\tcb.cross( ab );\n\n\t\t\tcb.normalize();\n\n\t\t\tface.normal.copy( cb );\n\n\t\t}\n\n\t},\n\n\tcomputeVertexNormals: function ( areaWeighted ) {\n\n\t\tvar v, vl, f, fl, face, vertices;\n\n\t\tvertices = new Array( this.vertices.length );\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tif ( areaWeighted ) {\n\n\t\t\t// vertex normals weighted by triangle areas\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\n\n\t\t\tvar vA, vB, vC, vD;\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3(),\n\t\t\t\tdb = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvA = this.vertices[ face.a ];\n\t\t\t\tvB = this.vertices[ face.b ];\n\t\t\t\tvC = this.vertices[ face.c ];\n\n\t\t\t\tcb.subVectors( vC, vB );\n\t\t\t\tab.subVectors( vA, vB );\n\t\t\t\tcb.cross( ab );\n\n\t\t\t\tvertices[ face.a ].add( cb );\n\t\t\t\tvertices[ face.b ].add( cb );\n\t\t\t\tvertices[ face.c ].add( cb );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tvertices[ face.a ].add( face.normal );\n\t\t\t\tvertices[ face.b ].add( face.normal );\n\t\t\t\tvertices[ face.c ].add( face.normal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\tvertices[ v ].normalize();\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tface.vertexNormals[ 0 ] = vertices[ face.a ].clone();\n\t\t\tface.vertexNormals[ 1 ] = vertices[ face.b ].clone();\n\t\t\tface.vertexNormals[ 2 ] = vertices[ face.c ].clone();\n\n\t\t}\n\n\t},\n\n\tcomputeMorphNormals: function () {\n\n\t\tvar i, il, f, fl, face;\n\n\t\t// save original normals\n\t\t// - create temp variables on first access\n\t\t//   otherwise just copy (for faster repeated calls)\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tif ( ! face.__originalFaceNormal ) {\n\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\n\n\t\t\t} else {\n\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\n\n\t\t\t}\n\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\n\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\n\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use temp geometry to compute face and vertex normals for each morph\n\n\t\tvar tmpGeo = new THREE.Geometry();\n\t\ttmpGeo.faces = this.faces;\n\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\n\n\t\t\t// create on first access\n\n\t\t\tif ( ! this.morphNormals[ i ] ) {\n\n\t\t\t\tthis.morphNormals[ i ] = {};\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\n\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\n\n\t\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\n\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\n\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar morphNormals = this.morphNormals[ i ];\n\n\t\t\t// set vertices to morph target\n\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\n\n\t\t\t// compute morph normals\n\n\t\t\ttmpGeo.computeFaceNormals();\n\t\t\ttmpGeo.computeVertexNormals();\n\n\t\t\t// store morph normals\n\n\t\t\tvar faceNormal, vertexNormals;\n\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\t\tface = this.faces[ f ];\n\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\n\n\t\t\t\tfaceNormal.copy( face.normal );\n\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore original normals\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tface.normal = face.__originalFaceNormal;\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\n\n\t\t}\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// tangents go to vertices\n\n\t\tvar f, fl, v, vl, i, il, vertexIndex,\n\t\t\tface, uv, vA, vB, vC, uvA, uvB, uvC,\n\t\t\tx1, x2, y1, y2, z1, z2,\n\t\t\ts1, s2, t1, t2, r, t, test,\n\t\t\ttan1 = [], tan2 = [],\n\t\t\tsdir = new THREE.Vector3(), tdir = new THREE.Vector3(),\n\t\t\ttmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),\n\t\t\tn = new THREE.Vector3(), w;\n\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\n\n\t\t\ttan1[ v ] = new THREE.Vector3();\n\t\t\ttan2[ v ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tfunction handleTriangle( context, a, b, c, ua, ub, uc ) {\n\n\t\t\tvA = context.vertices[ a ];\n\t\t\tvB = context.vertices[ b ];\n\t\t\tvC = context.vertices[ c ];\n\n\t\t\tuvA = uv[ ua ];\n\t\t\tuvB = uv[ ub ];\n\t\t\tuvC = uv[ uc ];\n\n\t\t\tx1 = vB.x - vA.x;\n\t\t\tx2 = vC.x - vA.x;\n\t\t\ty1 = vB.y - vA.y;\n\t\t\ty2 = vC.y - vA.y;\n\t\t\tz1 = vB.z - vA.z;\n\t\t\tz2 = vC.z - vA.z;\n\n\t\t\ts1 = uvB.x - uvA.x;\n\t\t\ts2 = uvC.x - uvA.x;\n\t\t\tt1 = uvB.y - uvA.y;\n\t\t\tt2 = uvC.y - uvA.y;\n\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\n\t\t\tsdir.set( ( t2 * x1 - t1 * x2 ) * r,\n\t\t\t\t\t  ( t2 * y1 - t1 * y2 ) * r,\n\t\t\t\t\t  ( t2 * z1 - t1 * z2 ) * r );\n\t\t\ttdir.set( ( s1 * x2 - s2 * x1 ) * r,\n\t\t\t\t\t  ( s1 * y2 - s2 * y1 ) * r,\n\t\t\t\t\t  ( s1 * z2 - s2 * z1 ) * r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\t\t\tuv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents\n\n\t\t\thandleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );\n\n\t\t}\n\n\t\tvar faceIndex = [ 'a', 'b', 'c', 'd' ];\n\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = this.faces[ f ];\n\n\t\t\tfor ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i++ ) {\n\n\t\t\t\tn.copy( face.vertexNormals[ i ] );\n\n\t\t\t\tvertexIndex = face[ faceIndex[ i ] ];\n\n\t\t\t\tt = tan1[ vertexIndex ];\n\n\t\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\t\ttmp.copy( t );\n\t\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t\t// Calculate handedness\n\n\t\t\t\ttmp2.crossVectors( face.vertexNormals[ i ], t );\n\t\t\t\ttest = tmp2.dot( tan2[ vertexIndex ] );\n\t\t\t\tw = (test < 0.0) ? -1.0 : 1.0;\n\n\t\t\t\tface.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.hasTangents = true;\n\n\t},\n\n\tcomputeLineDistances: function ( ) {\n\n\t\tvar d = 0;\n\t\tvar vertices = this.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tif ( i > 0 ) {\n\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\n\n\t\t\t}\n\n\t\t\tthis.lineDistances[ i ] = d;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tthis.boundingBox.setFromPoints( this.vertices );\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t}\n\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\n\n\t},\n\n\t/*\n\t * Checks for duplicate vertices with hashmap.\n\t * Duplicated vertices are removed\n\t * and faces' vertices are updated.\n\t */\n\n\tmergeVertices: function () {\n\n\t\tvar verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)\n\t\tvar unique = [], changes = [];\n\n\t\tvar v, key;\n\t\tvar precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001\n\t\tvar precision = Math.pow( 10, precisionPoints );\n\t\tvar i,il, face;\n\t\tvar indices, k, j, jl, u;\n\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\n\n\t\t\tv = this.vertices[ i ];\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\n\n\t\t\tif ( verticesMap[ key ] === undefined ) {\n\n\t\t\t\tverticesMap[ key ] = i;\n\t\t\t\tunique.push( this.vertices[ i ] );\n\t\t\t\tchanges[ i ] = unique.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\n\n\t\t\t}\n\n\t\t};\n\n\n\t\t// if faces are completely degenerate after merging vertices, we\n\t\t// have to remove them from the geometry.\n\t\tvar faceIndicesToRemove = [];\n\n\t\tfor( i = 0, il = this.faces.length; i < il; i ++ ) {\n\n\t\t\tface = this.faces[ i ];\n\n\t\t\tface.a = changes[ face.a ];\n\t\t\tface.b = changes[ face.b ];\n\t\t\tface.c = changes[ face.c ];\n\n\t\t\tindices = [ face.a, face.b, face.c ];\n\n\t\t\tvar dupIndex = -1;\n\n\t\t\t// if any duplicate vertices are found in a Face3\n\t\t\t// we have to remove the face as nothing can be saved\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\n\t\t\t\tif ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {\n\n\t\t\t\t\tdupIndex = n;\n\t\t\t\t\tfaceIndicesToRemove.push( i );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\n\t\t\tvar idx = faceIndicesToRemove[ i ];\n\n\t\t\tthis.faces.splice( idx, 1 );\n\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Use unique set of vertices\n\n\t\tvar diff = this.vertices.length - unique.length;\n\t\tthis.vertices = unique;\n\t\treturn diff;\n\n\t},\n\n\tclone: function () {\n\n\t\tvar geometry = new THREE.Geometry();\n\n\t\tvar vertices = this.vertices;\n\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\n\n\t\t\tgeometry.vertices.push( vertices[ i ].clone() );\n\n\t\t}\n\n\t\tvar faces = this.faces;\n\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\n\n\t\t\tgeometry.faces.push( faces[ i ].clone() );\n\n\t\t}\n\n\t\tvar uvs = this.faceVertexUvs[ 0 ];\n\n\t\tfor ( var i = 0, il = uvs.length; i < il; i ++ ) {\n\n\t\t\tvar uv = uvs[ i ], uvCopy = [];\n\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );\n\n\t\t\t}\n\n\t\t\tgeometry.faceVertexUvs[ 0 ].push( uvCopy );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nTHREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );\n\nTHREE.GeometryIdCount = 0;\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.BufferGeometry = function () {\n\n\tthis.id = THREE.GeometryIdCount ++;\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\n\t// attributes\n\n\tthis.attributes = {};\n\n\t// attributes typed arrays are kept only if dynamic flag is set\n\n\tthis.dynamic = true;\n\n\t// offsets for chunks when using indexed elements\n\n\tthis.offsets = [];\n\n\t// boundings\n\n\tthis.boundingBox = null;\n\tthis.boundingSphere = null;\n\n\tthis.hasTangents = false;\n\n\t// for compatibility\n\n\tthis.morphTargets = [];\n\n};\n\nTHREE.BufferGeometry.prototype = {\n\n\tconstructor: THREE.BufferGeometry,\n\n\taddAttribute: function( name, type, numItems, itemSize ) {\n\n\t\tthis.attributes[ name ] = {\n\n\t\t\titemSize: itemSize,\n\t\t\tarray: new type( numItems * itemSize )\n\n\t\t};\n\n\t},\n\n\tapplyMatrix: function ( matrix ) {\n\n\t\tvar positionArray;\n\t\tvar normalArray;\n\n\t\tif ( this.attributes[ \"position\" ] ) positionArray = this.attributes[ \"position\" ].array;\n\t\tif ( this.attributes[ \"normal\" ] ) normalArray = this.attributes[ \"normal\" ].array;\n\n\t\tif ( positionArray !== undefined ) {\n\n\t\t\tmatrix.multiplyVector3Array( positionArray );\n\t\t\tthis.verticesNeedUpdate = true;\n\n\t\t}\n\n\t\tif ( normalArray !== undefined ) {\n\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormalMatrix.multiplyVector3Array( normalArray );\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingBox: function () {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new THREE.Box3();\n\n\t\t}\n\n\t\tvar positions = this.attributes[ \"position\" ].array;\n\n\t\tif ( positions ) {\n\n\t\t\tvar bb = this.boundingBox;\n\t\t\tvar x, y, z;\n\n\t\t\tif( positions.length >= 3 ) {\n\t\t\t\tbb.min.x = bb.max.x = positions[ 0 ];\n\t\t\t\tbb.min.y = bb.max.y = positions[ 1 ];\n\t\t\t\tbb.min.z = bb.max.z = positions[ 2 ];\n\t\t\t}\n\n\t\t\tfor ( var i = 3, il = positions.length; i < il; i += 3 ) {\n\n\t\t\t\tx = positions[ i ];\n\t\t\t\ty = positions[ i + 1 ];\n\t\t\t\tz = positions[ i + 2 ];\n\n\t\t\t\t// bounding box\n\n\t\t\t\tif ( x < bb.min.x ) {\n\n\t\t\t\t\tbb.min.x = x;\n\n\t\t\t\t} else if ( x > bb.max.x ) {\n\n\t\t\t\t\tbb.max.x = x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( y < bb.min.y ) {\n\n\t\t\t\t\tbb.min.y = y;\n\n\t\t\t\t} else if ( y > bb.max.y ) {\n\n\t\t\t\t\tbb.max.y = y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( z < bb.min.z ) {\n\n\t\t\t\t\tbb.min.z = z;\n\n\t\t\t\t} else if ( z > bb.max.z ) {\n\n\t\t\t\t\tbb.max.z = z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( positions === undefined || positions.length === 0 ) {\n\n\t\t\tthis.boundingBox.min.set( 0, 0, 0 );\n\t\t\tthis.boundingBox.max.set( 0, 0, 0 );\n\n\t\t}\n\n\t},\n\n\tcomputeBoundingSphere: function () {\n\n\t\tvar box = new THREE.Box3();\n\t\tvar vector = new THREE.Vector3();\n\n\t\treturn function () {\n\n\t\t\tif ( this.boundingSphere === null ) {\n\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\n\n\t\t\t}\n\n\t\t\tvar positions = this.attributes[ \"position\" ].array;\n\n\t\t\tif ( positions ) {\n\n\t\t\t\tbox.makeEmpty();\n\n\t\t\t\tvar center = this.boundingSphere.center;\n\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\n\n\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\t\t\t\t\tbox.addPoint( vector );\n\n\t\t\t\t}\n\n\t\t\t\tbox.center( center );\n\n\t\t\t\tvar maxRadiusSq = 0;\n\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\n\n\t\t\t\t\tvector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\n\n\t\t\t\t}\n\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\t}\n\n\t\t}\n\n\t}(),\n\n\tcomputeVertexNormals: function () {\n\n\t\tif ( this.attributes[ \"position\" ] ) {\n\n\t\t\tvar i, il;\n\t\t\tvar j, jl;\n\n\t\t\tvar nVertexElements = this.attributes[ \"position\" ].array.length;\n\n\t\t\tif ( this.attributes[ \"normal\" ] === undefined ) {\n\n\t\t\t\tthis.attributes[ \"normal\" ] = {\n\n\t\t\t\t\titemSize: 3,\n\t\t\t\t\tarray: new Float32Array( nVertexElements )\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( i = 0, il = this.attributes[ \"normal\" ].array.length; i < il; i ++ ) {\n\n\t\t\t\t\tthis.attributes[ \"normal\" ].array[ i ] = 0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar positions = this.attributes[ \"position\" ].array;\n\t\t\tvar normals = this.attributes[ \"normal\" ].array;\n\n\t\t\tvar vA, vB, vC, x, y, z,\n\n\t\t\tpA = new THREE.Vector3(),\n\t\t\tpB = new THREE.Vector3(),\n\t\t\tpC = new THREE.Vector3(),\n\n\t\t\tcb = new THREE.Vector3(),\n\t\t\tab = new THREE.Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( this.attributes[ \"index\" ] ) {\n\n\t\t\t\tvar indices = this.attributes[ \"index\" ].array;\n\n\t\t\t\tvar offsets = this.offsets;\n\n\t\t\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\n\n\t\t\t\t\tvar start = offsets[ j ].start;\n\t\t\t\t\tvar count = offsets[ j ].count;\n\t\t\t\t\tvar index = offsets[ j ].index;\n\n\t\t\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\t\t\tvA = index + indices[ i ];\n\t\t\t\t\t\tvB = index + indices[ i + 1 ];\n\t\t\t\t\t\tvC = index + indices[ i + 2 ];\n\n\t\t\t\t\t\tx = positions[ vA * 3 ];\n\t\t\t\t\t\ty = positions[ vA * 3 + 1 ];\n\t\t\t\t\t\tz = positions[ vA * 3 + 2 ];\n\t\t\t\t\t\tpA.set( x, y, z );\n\n\t\t\t\t\t\tx = positions[ vB * 3 ];\n\t\t\t\t\t\ty = positions[ vB * 3 + 1 ];\n\t\t\t\t\t\tz = positions[ vB * 3 + 2 ];\n\t\t\t\t\t\tpB.set( x, y, z );\n\n\t\t\t\t\t\tx = positions[ vC * 3 ];\n\t\t\t\t\t\ty = positions[ vC * 3 + 1 ];\n\t\t\t\t\t\tz = positions[ vC * 3 + 2 ];\n\t\t\t\t\t\tpC.set( x, y, z );\n\n\t\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\t\tnormals[ vA * 3 ]     += cb.x;\n\t\t\t\t\t\tnormals[ vA * 3 + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vA * 3 + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vB * 3 ]     += cb.x;\n\t\t\t\t\t\tnormals[ vB * 3 + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vB * 3 + 2 ] += cb.z;\n\n\t\t\t\t\t\tnormals[ vC * 3 ]     += cb.x;\n\t\t\t\t\t\tnormals[ vC * 3 + 1 ] += cb.y;\n\t\t\t\t\t\tnormals[ vC * 3 + 2 ] += cb.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t} else {\n\n\t\t\t\tfor ( i = 0, il = positions.length; i < il; i += 9 ) {\n\n\t\t\t\t\tx = positions[ i ];\n\t\t\t\t\ty = positions[ i + 1 ];\n\t\t\t\t\tz = positions[ i + 2 ];\n\t\t\t\t\tpA.set( x, y, z );\n\n\t\t\t\t\tx = positions[ i + 3 ];\n\t\t\t\t\ty = positions[ i + 4 ];\n\t\t\t\t\tz = positions[ i + 5 ];\n\t\t\t\t\tpB.set( x, y, z );\n\n\t\t\t\t\tx = positions[ i + 6 ];\n\t\t\t\t\ty = positions[ i + 7 ];\n\t\t\t\t\tz = positions[ i + 8 ];\n\t\t\t\t\tpC.set( x, y, z );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormals[ i ] \t = cb.x;\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\n\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tthis.normalsNeedUpdate = true;\n\n\t\t}\n\n\t},\n\n\tnormalizeNormals: function () {\n\n\t\tvar normals = this.attributes[ \"normal\" ].array;\n\n\t\tvar x, y, z, n;\n\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\n\n\t\t\tx = normals[ i ];\n\t\t\ty = normals[ i + 1 ];\n\t\t\tz = normals[ i + 2 ];\n\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\n\n\t\t\tnormals[ i ] \t *= n;\n\t\t\tnormals[ i + 1 ] *= n;\n\t\t\tnormals[ i + 2 ] *= n;\n\n\t\t}\n\n\t},\n\n\tcomputeTangents: function () {\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( this.attributes[ \"index\" ] === undefined ||\n\t\t\t this.attributes[ \"position\" ] === undefined ||\n\t\t\t this.attributes[ \"normal\" ] === undefined ||\n\t\t\t this.attributes[ \"uv\" ] === undefined ) {\n\n\t\t\tconsole.warn( \"Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()\" );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar indices = this.attributes[ \"index\" ].array;\n\t\tvar positions = this.attributes[ \"position\" ].array;\n\t\tvar normals = this.attributes[ \"normal\" ].array;\n\t\tvar uvs = this.attributes[ \"uv\" ].array;\n\n\t\tvar nVertices = positions.length / 3;\n\n\t\tif ( this.attributes[ \"tangent\" ] === undefined ) {\n\n\t\t\tvar nTangentElements = 4 * nVertices;\n\n\t\t\tthis.attributes[ \"tangent\" ] = {\n\n\t\t\t\titemSize: 4,\n\t\t\t\tarray: new Float32Array( nTangentElements )\n\n\t\t\t};\n\n\t\t}\n\n\t\tvar tangents = this.attributes[ \"tangent\" ].array;\n\n\t\tvar tan1 = [], tan2 = [];\n\n\t\tfor ( var k = 0; k < nVertices; k ++ ) {\n\n\t\t\ttan1[ k ] = new THREE.Vector3();\n\t\t\ttan2[ k ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tvar xA, yA, zA,\n\t\t\txB, yB, zB,\n\t\t\txC, yC, zC,\n\n\t\t\tuA, vA,\n\t\t\tuB, vB,\n\t\t\tuC, vC,\n\n\t\t\tx1, x2, y1, y2, z1, z2,\n\t\t\ts1, s2, t1, t2, r;\n\n\t\tvar sdir = new THREE.Vector3(), tdir = new THREE.Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\txA = positions[ a * 3 ];\n\t\t\tyA = positions[ a * 3 + 1 ];\n\t\t\tzA = positions[ a * 3 + 2 ];\n\n\t\t\txB = positions[ b * 3 ];\n\t\t\tyB = positions[ b * 3 + 1 ];\n\t\t\tzB = positions[ b * 3 + 2 ];\n\n\t\t\txC = positions[ c * 3 ];\n\t\t\tyC = positions[ c * 3 + 1 ];\n\t\t\tzC = positions[ c * 3 + 2 ];\n\n\t\t\tuA = uvs[ a * 2 ];\n\t\t\tvA = uvs[ a * 2 + 1 ];\n\n\t\t\tuB = uvs[ b * 2 ];\n\t\t\tvB = uvs[ b * 2 + 1 ];\n\n\t\t\tuC = uvs[ c * 2 ];\n\t\t\tvC = uvs[ c * 2 + 1 ];\n\n\t\t\tx1 = xB - xA;\n\t\t\tx2 = xC - xA;\n\n\t\t\ty1 = yB - yA;\n\t\t\ty2 = yC - yA;\n\n\t\t\tz1 = zB - zA;\n\t\t\tz2 = zC - zA;\n\n\t\t\ts1 = uB - uA;\n\t\t\ts2 = uC - uA;\n\n\t\t\tt1 = vB - vA;\n\t\t\tt2 = vC - vA;\n\n\t\t\tr = 1.0 / ( s1 * t2 - s2 * t1 );\n\n\t\t\tsdir.set(\n\t\t\t\t( t2 * x1 - t1 * x2 ) * r,\n\t\t\t\t( t2 * y1 - t1 * y2 ) * r,\n\t\t\t\t( t2 * z1 - t1 * z2 ) * r\n\t\t\t);\n\n\t\t\ttdir.set(\n\t\t\t\t( s1 * x2 - s2 * x1 ) * r,\n\t\t\t\t( s1 * y2 - s2 * y1 ) * r,\n\t\t\t\t( s1 * z2 - s2 * z1 ) * r\n\t\t\t);\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tvar i, il;\n\t\tvar j, jl;\n\t\tvar iA, iB, iC;\n\n\t\tvar offsets = this.offsets;\n\n\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\n\n\t\t\tvar start = offsets[ j ].start;\n\t\t\tvar count = offsets[ j ].count;\n\t\t\tvar index = offsets[ j ].index;\n\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\tiA = index + indices[ i ];\n\t\t\t\tiB = index + indices[ i + 1 ];\n\t\t\t\tiC = index + indices[ i + 2 ];\n\n\t\t\t\thandleTriangle( iA, iB, iC );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();\n\t\tvar n = new THREE.Vector3(), n2 = new THREE.Vector3();\n\t\tvar w, t, test;\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.x = normals[ v * 3 ];\n\t\t\tn.y = normals[ v * 3 + 1 ];\n\t\t\tn.z = normals[ v * 3 + 2 ];\n\n\t\t\tn2.copy( n );\n\n\t\t\tt = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\ttest = tmp2.dot( tan2[ v ] );\n\t\t\tw = ( test < 0.0 ) ? -1.0 : 1.0;\n\n\t\t\ttangents[ v * 4 ]     = tmp.x;\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\n\t\t\ttangents[ v * 4 + 3 ] = w;\n\n\t\t}\n\n\t\tfor ( j = 0, jl = offsets.length; j < jl; ++ j ) {\n\n\t\t\tvar start = offsets[ j ].start;\n\t\t\tvar count = offsets[ j ].count;\n\t\t\tvar index = offsets[ j ].index;\n\n\t\t\tfor ( i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\tiA = index + indices[ i ];\n\t\t\t\tiB = index + indices[ i + 1 ];\n\t\t\t\tiC = index + indices[ i + 2 ];\n\n\t\t\t\thandleVertex( iA );\n\t\t\t\thandleVertex( iB );\n\t\t\t\thandleVertex( iC );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.hasTangents = true;\n\t\tthis.tangentsNeedUpdate = true;\n\n\t},\n\n\tclone: function () {\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\tvar types = [ Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];\n\n\t\tfor ( var attr in this.attributes ) {\n\n\t\t\tvar sourceAttr = this.attributes[ attr ];\n\t\t\tvar sourceArray = sourceAttr.array;\n\n\t\t\tvar attribute = {\n\n\t\t\t\titemSize: sourceAttr.itemSize,\n\t\t\t\tnumItems: sourceAttr.numItems,\n\t\t\t\tarray: null\n\n\t\t\t};\n\n\t\t\tfor ( var i = 0, il = types.length; i < il; i ++ ) {\n\n\t\t\t\tvar type = types[ i ];\n\n\t\t\t\tif ( sourceArray instanceof type ) {\n\n\t\t\t\t\tattribute.array = new type( sourceArray );\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.attributes[ attr ] = attribute;\n\n\t\t}\n\n\t\tfor ( var i = 0, il = this.offsets.length; i < il; i ++ ) {\n\n\t\t\tvar offset = this.offsets[ i ];\n\n\t\t\tgeometry.offsets.push( {\n\n\t\t\t\tstart: offset.start,\n\t\t\t\tindex: offset.index,\n\t\t\t\tcount: offset.count\n\n\t\t\t} );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nTHREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.Camera = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.matrixWorldInverse = new THREE.Matrix4();\n\tthis.projectionMatrix = new THREE.Matrix4();\n\n};\n\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Camera.prototype.lookAt = function () {\n\n\t// This routine does not support cameras with rotated and/or translated parent(s)\n\n\tvar m1 = new THREE.Matrix4();\n\n\treturn function ( vector ) {\n\n\t\tm1.lookAt( this.position, vector, this.up );\n\n\t\tthis.quaternion.setFromRotationMatrix( m1 );\n\n\t};\n\n}();\n\nTHREE.Camera.prototype.clone = function (camera) {\n\n\tif ( camera === undefined ) camera = new THREE.Camera();\n\n\tTHREE.Object3D.prototype.clone.call( this, camera );\n\n\tcamera.matrixWorldInverse.copy( this.matrixWorldInverse );\n\tcamera.projectionMatrix.copy( this.projectionMatrix );\n\n\treturn camera;\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.left = left;\n\tthis.right = right;\n\tthis.top = top;\n\tthis.bottom = bottom;\n\n\tthis.near = ( near !== undefined ) ? near : 0.1;\n\tthis.far = ( far !== undefined ) ? far : 2000;\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\n\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\n\n\tthis.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );\n\n};\n\nTHREE.OrthographicCamera.prototype.clone = function () {\n\n\tvar camera = new THREE.OrthographicCamera();\n\n\tTHREE.Camera.prototype.clone.call( this, camera );\n\n\tcamera.left = this.left;\n\tcamera.right = this.right;\n\tcamera.top = this.top;\n\tcamera.bottom = this.bottom;\n\t\n\tcamera.near = this.near;\n\tcamera.far = this.far;\n\n\treturn camera;\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author greggman / http://games.greggman.com/\n * @author zz85 / http://www.lab4games.net/zz85/blog\n */\n\nTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.fov = fov !== undefined ? fov : 50;\n\tthis.aspect = aspect !== undefined ? aspect : 1;\n\tthis.near = near !== undefined ? near : 0.1;\n\tthis.far = far !== undefined ? far : 2000;\n\n\tthis.updateProjectionMatrix();\n\n};\n\nTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\n\n\n/**\n * Uses Focal Length (in mm) to estimate and set FOV\n * 35mm (fullframe) camera is used if frame size is not specified;\n * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\n */\n\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\n\n\tif ( frameHeight === undefined ) frameHeight = 24;\n\n\tthis.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\n\tthis.updateProjectionMatrix();\n\n}\n\n\n/**\n * Sets an offset in a larger frustum. This is useful for multi-window or\n * multi-monitor/multi-machine setups.\n *\n * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n * the monitors are in grid like this\n *\n *   +---+---+---+\n *   | A | B | C |\n *   +---+---+---+\n *   | D | E | F |\n *   +---+---+---+\n *\n * then for each monitor you would call it like this\n *\n *   var w = 1920;\n *   var h = 1080;\n *   var fullWidth = w * 3;\n *   var fullHeight = h * 2;\n *\n *   --A--\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n *   --B--\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n *   --C--\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n *   --D--\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n *   --E--\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n *   --F--\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n *\n *   Note there is no reason monitors have to be the same size or in a grid.\n */\n\nTHREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\n\n\tthis.fullWidth = fullWidth;\n\tthis.fullHeight = fullHeight;\n\tthis.x = x;\n\tthis.y = y;\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.updateProjectionMatrix();\n\n};\n\n\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\n\n\tif ( this.fullWidth ) {\n\n\t\tvar aspect = this.fullWidth / this.fullHeight;\n\t\tvar top = Math.tan( THREE.Math.degToRad( this.fov * 0.5 ) ) * this.near;\n\t\tvar bottom = -top;\n\t\tvar left = aspect * bottom;\n\t\tvar right = aspect * top;\n\t\tvar width = Math.abs( right - left );\n\t\tvar height = Math.abs( top - bottom );\n\n\t\tthis.projectionMatrix.makeFrustum(\n\t\t\tleft + this.x * width / this.fullWidth,\n\t\t\tleft + ( this.x + this.width ) * width / this.fullWidth,\n\t\t\ttop - ( this.y + this.height ) * height / this.fullHeight,\n\t\t\ttop - this.y * height / this.fullHeight,\n\t\t\tthis.near,\n\t\t\tthis.far\n\t\t);\n\n\t} else {\n\n\t\tthis.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far );\n\n\t}\n\n};\n\nTHREE.PerspectiveCamera.prototype.clone = function () {\n\n\tvar camera = new THREE.PerspectiveCamera();\n\n\tTHREE.Camera.prototype.clone.call( this, camera );\n\n\tcamera.fov = this.fov;\n\tcamera.aspect = this.aspect;\n\tcamera.near = this.near;\n\tcamera.far = this.far;\n\n\treturn camera;\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n \nTHREE.Light = function ( hex ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.color = new THREE.Color( hex );\n\n};\n\nTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Light.prototype.clone = function ( light ) {\n\n\tif ( light === undefined ) light = new THREE.Light();\n\n\tTHREE.Object3D.prototype.clone.call( this, light );\n\n\tlight.color.copy( this.color );\n\n\treturn light;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AmbientLight = function ( hex ) {\n\n\tTHREE.Light.call( this, hex );\n\n};\n\nTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\n\nTHREE.AmbientLight.prototype.clone = function () {\n\n\tvar light = new THREE.AmbientLight();\n\n\tTHREE.Light.prototype.clone.call( this, light );\n\n\treturn light;\n\n};\n\n/**\n * @author MPanknin / http://www.redplant.de/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.AreaLight = function ( hex, intensity ) {\n\n\tTHREE.Light.call( this, hex );\n\n\tthis.normal = new THREE.Vector3( 0, -1, 0 );\n\tthis.right = new THREE.Vector3( 1, 0, 0 );\n\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\n\tthis.width = 1.0;\n\tthis.height = 1.0;\n\n\tthis.constantAttenuation = 1.5;\n\tthis.linearAttenuation = 0.5;\n\tthis.quadraticAttenuation = 0.1;\n\n};\n\nTHREE.AreaLight.prototype = Object.create( THREE.Light.prototype );\n\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DirectionalLight = function ( hex, intensity ) {\n\n\tTHREE.Light.call( this, hex );\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.target = new THREE.Object3D();\n\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\n\tthis.castShadow = false;\n\tthis.onlyShadow = false;\n\n\t//\n\n\tthis.shadowCameraNear = 50;\n\tthis.shadowCameraFar = 5000;\n\n\tthis.shadowCameraLeft = -500;\n\tthis.shadowCameraRight = 500;\n\tthis.shadowCameraTop = 500;\n\tthis.shadowCameraBottom = -500;\n\n\tthis.shadowCameraVisible = false;\n\n\tthis.shadowBias = 0;\n\tthis.shadowDarkness = 0.5;\n\n\tthis.shadowMapWidth = 512;\n\tthis.shadowMapHeight = 512;\n\n\t//\n\n\tthis.shadowCascade = false;\n\n\tthis.shadowCascadeOffset = new THREE.Vector3( 0, 0, -1000 );\n\tthis.shadowCascadeCount = 2;\n\n\tthis.shadowCascadeBias = [ 0, 0, 0 ];\n\tthis.shadowCascadeWidth = [ 512, 512, 512 ];\n\tthis.shadowCascadeHeight = [ 512, 512, 512 ];\n\n\tthis.shadowCascadeNearZ = [ -1.000, 0.990, 0.998 ];\n\tthis.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];\n\n\tthis.shadowCascadeArray = [];\n\n\t//\n\n\tthis.shadowMap = null;\n\tthis.shadowMapSize = null;\n\tthis.shadowCamera = null;\n\tthis.shadowMatrix = null;\n\n};\n\nTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\n\nTHREE.DirectionalLight.prototype.clone = function () {\n\n\tvar light = new THREE.DirectionalLight();\n\n\tTHREE.Light.prototype.clone.call( this, light );\n\n\tlight.target = this.target.clone();\n\n\tlight.intensity = this.intensity;\n\n\tlight.castShadow = this.castShadow;\n\tlight.onlyShadow = this.onlyShadow;\n\n\treturn light;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.HemisphereLight = function ( skyColorHex, groundColorHex, intensity ) {\n\n\tTHREE.Light.call( this, skyColorHex );\n\n\tthis.position.set( 0, 100, 0 );\n\n\tthis.groundColor = new THREE.Color( groundColorHex );\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\n};\n\nTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\n\nTHREE.HemisphereLight.prototype.clone = function () {\n\n\tvar light = new THREE.HemisphereLight();\n\n\tTHREE.Light.prototype.clone.call( this, light );\n\n\tlight.groundColor.copy( this.groundColor );\n\tlight.intensity = this.intensity;\n\n\treturn light;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PointLight = function ( hex, intensity, distance ) {\n\n\tTHREE.Light.call( this, hex );\n\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\n};\n\nTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\n\nTHREE.PointLight.prototype.clone = function () {\n\n\tvar light = new THREE.PointLight();\n\n\tTHREE.Light.prototype.clone.call( this, light );\n\n\tlight.intensity = this.intensity;\n\tlight.distance = this.distance;\n\n\treturn light;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpotLight = function ( hex, intensity, distance, angle, exponent ) {\n\n\tTHREE.Light.call( this, hex );\n\n\tthis.position.set( 0, 1, 0 );\n\tthis.target = new THREE.Object3D();\n\n\tthis.intensity = ( intensity !== undefined ) ? intensity : 1;\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\n\tthis.exponent = ( exponent !== undefined ) ? exponent : 10;\n\n\tthis.castShadow = false;\n\tthis.onlyShadow = false;\n\n\t//\n\n\tthis.shadowCameraNear = 50;\n\tthis.shadowCameraFar = 5000;\n\tthis.shadowCameraFov = 50;\n\n\tthis.shadowCameraVisible = false;\n\n\tthis.shadowBias = 0;\n\tthis.shadowDarkness = 0.5;\n\n\tthis.shadowMapWidth = 512;\n\tthis.shadowMapHeight = 512;\n\n\t//\n\n\tthis.shadowMap = null;\n\tthis.shadowMapSize = null;\n\tthis.shadowCamera = null;\n\tthis.shadowMatrix = null;\n\n};\n\nTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\n\nTHREE.SpotLight.prototype.clone = function () {\n\n\tvar light = new THREE.SpotLight();\n\n\tTHREE.Light.prototype.clone.call( this, light );\n\n\tlight.target = this.target.clone();\n\n\tlight.intensity = this.intensity;\n\tlight.distance = this.distance;\n\tlight.angle = this.angle;\n\tlight.exponent = this.exponent;\n\n\tlight.castShadow = this.castShadow;\n\tlight.onlyShadow = this.onlyShadow;\n\n\treturn light;\n\n};\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Loader = function ( showStatus ) {\r\n\r\n\tthis.showStatus = showStatus;\r\n\tthis.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;\r\n\r\n\tthis.onLoadStart = function () {};\r\n\tthis.onLoadProgress = function () {};\r\n\tthis.onLoadComplete = function () {};\r\n\r\n};\r\n\r\nTHREE.Loader.prototype = {\r\n\r\n\tconstructor: THREE.Loader,\r\n\r\n\tcrossOrigin: undefined,\r\n\r\n\taddStatusElement: function () {\r\n\r\n\t\tvar e = document.createElement( \"div\" );\r\n\r\n\t\te.style.position = \"absolute\";\r\n\t\te.style.right = \"0px\";\r\n\t\te.style.top = \"0px\";\r\n\t\te.style.fontSize = \"0.8em\";\r\n\t\te.style.textAlign = \"left\";\r\n\t\te.style.background = \"rgba(0,0,0,0.25)\";\r\n\t\te.style.color = \"#fff\";\r\n\t\te.style.width = \"120px\";\r\n\t\te.style.padding = \"0.5em 0.5em 0.5em 0.5em\";\r\n\t\te.style.zIndex = 1000;\r\n\r\n\t\te.innerHTML = \"Loading ...\";\r\n\r\n\t\treturn e;\r\n\r\n\t},\r\n\r\n\tupdateProgress: function ( progress ) {\r\n\r\n\t\tvar message = \"Loaded \";\r\n\r\n\t\tif ( progress.total ) {\r\n\r\n\t\t\tmessage += ( 100 * progress.loaded / progress.total ).toFixed(0) + \"%\";\r\n\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmessage += ( progress.loaded / 1000 ).toFixed(2) + \" KB\";\r\n\r\n\t\t}\r\n\r\n\t\tthis.statusDomElement.innerHTML = message;\r\n\r\n\t},\r\n\r\n\textractUrlBase: function ( url ) {\r\n\r\n\t\tvar parts = url.split( '/' );\r\n\t\tparts.pop();\r\n\t\treturn ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';\r\n\r\n\t},\r\n\r\n\tinitMaterials: function ( materials, texturePath ) {\r\n\r\n\t\tvar array = [];\r\n\r\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\r\n\r\n\t\t\tarray[ i ] = THREE.Loader.prototype.createMaterial( materials[ i ], texturePath );\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tneedsTangents: function ( materials ) {\r\n\r\n\t\tfor( var i = 0, il = materials.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar m = materials[ i ];\r\n\r\n\t\t\tif ( m instanceof THREE.ShaderMaterial ) return true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tcreateMaterial: function ( m, texturePath ) {\r\n\r\n\t\tvar _this = this;\r\n\r\n\t\tfunction is_pow2( n ) {\r\n\r\n\t\t\tvar l = Math.log( n ) / Math.LN2;\r\n\t\t\treturn Math.floor( l ) == l;\r\n\r\n\t\t}\r\n\r\n\t\tfunction nearest_pow2( n ) {\r\n\r\n\t\t\tvar l = Math.log( n ) / Math.LN2;\r\n\t\t\treturn Math.pow( 2, Math.round(  l ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction load_image( where, url ) {\r\n\r\n\t\t\tvar image = new Image();\r\n\r\n\t\t\timage.onload = function () {\r\n\r\n\t\t\t\tif ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {\r\n\r\n\t\t\t\t\tvar width = nearest_pow2( this.width );\r\n\t\t\t\t\tvar height = nearest_pow2( this.height );\r\n\r\n\t\t\t\t\twhere.image.width = width;\r\n\t\t\t\t\twhere.image.height = height;\r\n\t\t\t\t\twhere.image.getContext( '2d' ).drawImage( this, 0, 0, width, height );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\twhere.image = this;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\twhere.needsUpdate = true;\r\n\r\n\t\t\t};\r\n\r\n\t\t\tif ( _this.crossOrigin !== undefined ) image.crossOrigin = _this.crossOrigin;\r\n\t\t\timage.src = url;\r\n\r\n\t\t}\r\n\r\n\t\tfunction create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {\r\n\r\n\t\t\tvar isCompressed = /\\.dds$/i.test( sourceFile );\r\n\t\t\tvar fullPath = texturePath + \"/\" + sourceFile;\r\n\r\n\t\t\tif ( isCompressed ) {\r\n\r\n\t\t\t\tvar texture = THREE.ImageUtils.loadCompressedTexture( fullPath );\r\n\r\n\t\t\t\twhere[ name ] = texture;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar texture = document.createElement( 'canvas' );\r\n\r\n\t\t\t\twhere[ name ] = new THREE.Texture( texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t\twhere[ name ].sourceFile = sourceFile;\r\n\r\n\t\t\tif( repeat ) {\r\n\r\n\t\t\t\twhere[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );\r\n\r\n\t\t\t\tif ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = THREE.RepeatWrapping;\r\n\t\t\t\tif ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = THREE.RepeatWrapping;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( offset ) {\r\n\r\n\t\t\t\twhere[ name ].offset.set( offset[ 0 ], offset[ 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( wrap ) {\r\n\r\n\t\t\t\tvar wrapMap = {\r\n\t\t\t\t\t\"repeat\": THREE.RepeatWrapping,\r\n\t\t\t\t\t\"mirror\": THREE.MirroredRepeatWrapping\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];\r\n\t\t\t\tif ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( anisotropy ) {\r\n\r\n\t\t\t\twhere[ name ].anisotropy = anisotropy;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! isCompressed ) {\r\n\r\n\t\t\t\tload_image( where[ name ], fullPath );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction rgb2hex( rgb ) {\r\n\r\n\t\t\treturn ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;\r\n\r\n\t\t}\r\n\r\n\t\t// defaults\r\n\r\n\t\tvar mtype = \"MeshLambertMaterial\";\r\n\t\tvar mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };\r\n\r\n\t\t// parameters from model file\r\n\r\n\t\tif ( m.shading ) {\r\n\r\n\t\t\tvar shading = m.shading.toLowerCase();\r\n\r\n\t\t\tif ( shading === \"phong\" ) mtype = \"MeshPhongMaterial\";\r\n\t\t\telse if ( shading === \"basic\" ) mtype = \"MeshBasicMaterial\";\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {\r\n\r\n\t\t\tmpars.blending = THREE[ m.blending ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.transparent !== undefined || m.opacity < 1.0 ) {\r\n\r\n\t\t\tmpars.transparent = m.transparent;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.depthTest !== undefined ) {\r\n\r\n\t\t\tmpars.depthTest = m.depthTest;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.depthWrite !== undefined ) {\r\n\r\n\t\t\tmpars.depthWrite = m.depthWrite;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.visible !== undefined ) {\r\n\r\n\t\t\tmpars.visible = m.visible;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.flipSided !== undefined ) {\r\n\r\n\t\t\tmpars.side = THREE.BackSide;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.doubleSided !== undefined ) {\r\n\r\n\t\t\tmpars.side = THREE.DoubleSide;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.wireframe !== undefined ) {\r\n\r\n\t\t\tmpars.wireframe = m.wireframe;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.vertexColors !== undefined ) {\r\n\r\n\t\t\tif ( m.vertexColors === \"face\" ) {\r\n\r\n\t\t\t\tmpars.vertexColors = THREE.FaceColors;\r\n\r\n\t\t\t} else if ( m.vertexColors ) {\r\n\r\n\t\t\t\tmpars.vertexColors = THREE.VertexColors;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// colors\r\n\r\n\t\tif ( m.colorDiffuse ) {\r\n\r\n\t\t\tmpars.color = rgb2hex( m.colorDiffuse );\r\n\r\n\t\t} else if ( m.DbgColor ) {\r\n\r\n\t\t\tmpars.color = m.DbgColor;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.colorSpecular ) {\r\n\r\n\t\t\tmpars.specular = rgb2hex( m.colorSpecular );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.colorAmbient ) {\r\n\r\n\t\t\tmpars.ambient = rgb2hex( m.colorAmbient );\r\n\r\n\t\t}\r\n\r\n\t\t// modifiers\r\n\r\n\t\tif ( m.transparency ) {\r\n\r\n\t\t\tmpars.opacity = m.transparency;\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.specularCoef ) {\r\n\r\n\t\t\tmpars.shininess = m.specularCoef;\r\n\r\n\t\t}\r\n\r\n\t\t// textures\r\n\r\n\t\tif ( m.mapDiffuse && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"map\", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapLight && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"lightMap\", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapBump && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"bumpMap\", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapNormal && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"normalMap\", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.mapSpecular && texturePath ) {\r\n\r\n\t\t\tcreate_texture( mpars, \"specularMap\", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( m.mapBumpScale ) {\r\n\r\n\t\t\tmpars.bumpScale = m.mapBumpScale;\r\n\r\n\t\t}\r\n\r\n\t\t// special case for normal mapped material\r\n\r\n\t\tif ( m.mapNormal ) {\r\n\r\n\t\t\tvar shader = THREE.ShaderLib[ \"normalmap\" ];\r\n\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\r\n\r\n\t\t\tuniforms[ \"tNormal\" ].value = mpars.normalMap;\r\n\r\n\t\t\tif ( m.mapNormalFactor ) {\r\n\r\n\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( m.mapNormalFactor, m.mapNormalFactor );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( mpars.map ) {\r\n\r\n\t\t\t\tuniforms[ \"tDiffuse\" ].value = mpars.map;\r\n\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( mpars.specularMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tSpecular\" ].value = mpars.specularMap;\r\n\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( mpars.lightMap ) {\r\n\r\n\t\t\t\tuniforms[ \"tAO\" ].value = mpars.lightMap;\r\n\t\t\t\tuniforms[ \"enableAO\" ].value = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// for the moment don't handle displacement texture\r\n\r\n\t\t\tuniforms[ \"diffuse\" ].value.setHex( mpars.color );\r\n\t\t\tuniforms[ \"specular\" ].value.setHex( mpars.specular );\r\n\t\t\tuniforms[ \"ambient\" ].value.setHex( mpars.ambient );\r\n\r\n\t\t\tuniforms[ \"shininess\" ].value = mpars.shininess;\r\n\r\n\t\t\tif ( mpars.opacity !== undefined ) {\r\n\r\n\t\t\t\tuniforms[ \"opacity\" ].value = mpars.opacity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\r\n\t\t\tvar material = new THREE.ShaderMaterial( parameters );\r\n\r\n\t\t\tif ( mpars.transparent ) {\r\n\r\n\t\t\t\tmaterial.transparent = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar material = new THREE[ mtype ]( mpars );\r\n\r\n\t\t}\r\n\r\n\t\tif ( m.DbgName !== undefined ) material.name = m.DbgName;\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.XHRLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nTHREE.XHRLoader.prototype = {\n\n\tconstructor: THREE.XHRLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\t\tvar request = new XMLHttpRequest();\n\n\t\tif ( onLoad !== undefined ) {\n\n\t\t\trequest.addEventListener( 'load', function ( event ) {\n\n\t\t\t\tonLoad( event.target.responseText );\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\tif ( onProgress !== undefined ) {\n\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tonProgress( event );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\tif ( onError !== undefined ) {\n\n\t\t\trequest.addEventListener( 'error', function ( event ) {\n\n\t\t\t\tonError( event );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\tif ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;\n\n\t\trequest.open( 'GET', url, true );\n\t\trequest.send( null );\n\n\t\tscope.manager.itemStart( url );\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ImageLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nTHREE.ImageLoader.prototype = {\n\n\tconstructor: THREE.ImageLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\t\tvar image = document.createElement( 'img' );\n\n\t\tif ( onLoad !== undefined ) {\n\n\t\t\timage.addEventListener( 'load', function ( event ) {\n\n\t\t\t\tscope.manager.itemEnd( url );\n\t\t\t\tonLoad( this );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\tif ( onProgress !== undefined ) {\n\n\t\t\timage.addEventListener( 'progress', function ( event ) {\n\n\t\t\t\tonProgress( event );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\tif ( onError !== undefined ) {\n\n\t\t\timage.addEventListener( 'error', function ( event ) {\n\n\t\t\t\tonError( event );\n\n\t\t\t}, false );\n\n\t\t}\n\n\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n\t\timage.src = url;\n\n\t\tscope.manager.itemStart( url );\n\n\t\treturn image;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t}\n\n}\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.JSONLoader = function ( showStatus ) {\r\n\r\n\tTHREE.Loader.call( this, showStatus );\r\n\r\n\tthis.withCredentials = false;\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );\r\n\r\nTHREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {\r\n\r\n\tvar scope = this;\r\n\r\n\t// todo: unify load API to for easier SceneLoader use\r\n\r\n\ttexturePath = texturePath && ( typeof texturePath === \"string\" ) ? texturePath : this.extractUrlBase( url );\r\n\r\n\tthis.onLoadStart();\r\n\tthis.loadAjaxJSON( this, url, callback, texturePath );\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {\r\n\r\n\tvar xhr = new XMLHttpRequest();\r\n\r\n\tvar length = 0;\r\n\r\n\txhr.onreadystatechange = function () {\r\n\r\n\t\tif ( xhr.readyState === xhr.DONE ) {\r\n\r\n\t\t\tif ( xhr.status === 200 || xhr.status === 0 ) {\r\n\r\n\t\t\t\tif ( xhr.responseText ) {\r\n\r\n\t\t\t\t\tvar json = JSON.parse( xhr.responseText );\r\n\t\t\t\t\tvar result = context.parse( json, texturePath );\r\n\t\t\t\t\tcallback( result.geometry, result.materials );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( \"THREE.JSONLoader: [\" + url + \"] seems to be unreachable or file there is empty\" );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// in context of more complex asset initialization\r\n\t\t\t\t// do not block on single failed file\r\n\t\t\t\t// maybe should go even one more level up\r\n\r\n\t\t\t\tcontext.onLoadComplete();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( \"THREE.JSONLoader: Couldn't load [\" + url + \"] [\" + xhr.status + \"]\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( xhr.readyState === xhr.LOADING ) {\r\n\r\n\t\t\tif ( callbackProgress ) {\r\n\r\n\t\t\t\tif ( length === 0 ) {\r\n\r\n\t\t\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tcallbackProgress( { total: length, loaded: xhr.responseText.length } );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {\r\n\r\n\t\t\tif ( callbackProgress !== undefined ) {\r\n\r\n\t\t\t\tlength = xhr.getResponseHeader( \"Content-Length\" );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\txhr.open( \"GET\", url, true );\r\n\txhr.withCredentials = this.withCredentials;\r\n\txhr.send( null );\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype.parse = function ( json, texturePath ) {\r\n\r\n\tvar scope = this,\r\n\tgeometry = new THREE.Geometry(),\r\n\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\r\n\tparseModel( scale );\r\n\r\n\tparseSkin();\r\n\tparseMorphing( scale );\r\n\r\n\tgeometry.computeCentroids();\r\n\tgeometry.computeFaceNormals();\r\n\tgeometry.computeBoundingSphere();\r\n\r\n\tfunction parseModel( scale ) {\r\n\r\n\t\tfunction isBitSet( value, position ) {\r\n\r\n\t\t\treturn value & ( 1 << position );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, j, fi,\r\n\r\n\t\toffset, zLength,\r\n\r\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\r\n\r\n\t\ttype,\r\n\t\tisQuad,\r\n\t\thasMaterial,\r\n\t\thasFaceVertexUv,\r\n\t\thasFaceNormal, hasFaceVertexNormal,\r\n\t\thasFaceColor, hasFaceVertexColor,\r\n\r\n\t\tvertex, face, faceA, faceB, color, hex, normal,\r\n\r\n\t\tuvLayer, uv, u, v,\r\n\r\n\t\tfaces = json.faces,\r\n\t\tvertices = json.vertices,\r\n\t\tnormals = json.normals,\r\n\t\tcolors = json.colors,\r\n\r\n\t\tnUvLayers = 0;\r\n\r\n\t\tif ( json.uvs !== undefined ) {\r\n\r\n\t\t\t// disregard empty arrays\r\n\r\n\t\t\tfor ( i = 0; i < json.uvs.length; i++ ) {\r\n\r\n\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\r\n\r\n\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\toffset = 0;\r\n\t\tzLength = vertices.length;\r\n\r\n\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\tvertex = new THREE.Vector3();\r\n\r\n\t\t\tvertex.x = vertices[ offset ++ ] * scale;\r\n\t\t\tvertex.y = vertices[ offset ++ ] * scale;\r\n\t\t\tvertex.z = vertices[ offset ++ ] * scale;\r\n\r\n\t\t\tgeometry.vertices.push( vertex );\r\n\r\n\t\t}\r\n\r\n\t\toffset = 0;\r\n\t\tzLength = faces.length;\r\n\r\n\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\ttype = faces[ offset ++ ];\r\n\r\n\r\n\t\t\tisQuad              = isBitSet( type, 0 );\r\n\t\t\thasMaterial         = isBitSet( type, 1 );\r\n\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\r\n\t\t\thasFaceNormal       = isBitSet( type, 4 );\r\n\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\r\n\t\t\thasFaceColor\t    = isBitSet( type, 6 );\r\n\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\r\n\r\n\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\r\n\t\t\tif ( isQuad ) {\r\n\r\n\t\t\t\tfaceA = new THREE.Face3();\r\n\t\t\t\tfaceA.a = faces[ offset ];\r\n\t\t\t\tfaceA.b = faces[ offset + 1 ];\r\n\t\t\t\tfaceA.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\tfaceB = new THREE.Face3();\r\n\t\t\t\tfaceB.a = faces[ offset + 1 ];\r\n\t\t\t\tfaceB.b = faces[ offset + 2 ];\r\n\t\t\t\tfaceB.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\toffset += 4;\r\n\r\n\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\tfaceA.materialIndex = materialIndex;\r\n\t\t\t\t\tfaceB.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\r\n\r\n\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = []\r\n\r\n\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\tfaceA.normal.set(\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tfaceB.normal.copy( faceA.normal );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 4; i++ ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\r\n\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\r\n\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\tfaceA.color.setHex( hex );\r\n\t\t\t\t\tfaceB.color.setHex( hex );\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 4; i++ ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\r\n\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.faces.push( faceA );\r\n\t\t\t\tgeometry.faces.push( faceB );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface = new THREE.Face3();\r\n\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\tface.c = faces[ offset ++ ];\r\n\r\n\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i++ ) {\r\n\r\n\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\r\n\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\tface.normal.set(\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i++ ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tface.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\tfor ( i = 0; i < 3; i++ ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.faces.push( face );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction parseSkin() {\r\n\r\n\t\tvar i, l, x, y, z, w, a, b, c, d;\r\n\r\n\t\tif ( json.skinWeights ) {\r\n\r\n\t\t\tfor ( i = 0, l = json.skinWeights.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\tx = json.skinWeights[ i     ];\r\n\t\t\t\ty = json.skinWeights[ i + 1 ];\r\n\t\t\t\tz = 0;\r\n\t\t\t\tw = 0;\r\n\r\n\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.skinIndices ) {\r\n\r\n\t\t\tfor ( i = 0, l = json.skinIndices.length; i < l; i += 2 ) {\r\n\r\n\t\t\t\ta = json.skinIndices[ i     ];\r\n\t\t\t\tb = json.skinIndices[ i + 1 ];\r\n\t\t\t\tc = 0;\r\n\t\t\t\td = 0;\r\n\r\n\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.bones = json.bones;\r\n\t\t// could change this to json.animations[0] or remove completely\r\n\t\tgeometry.animation = json.animation;\r\n\t\tgeometry.animations = json.animations;\r\n\t};\r\n\r\n\tfunction parseMorphing( scale ) {\r\n\r\n\t\tif ( json.morphTargets !== undefined ) {\r\n\r\n\t\t\tvar i, l, v, vl, dstVertices, srcVertices;\r\n\r\n\t\t\tfor ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tgeometry.morphTargets[ i ] = {};\r\n\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\r\n\r\n\t\t\t\tdstVertices = geometry.morphTargets[ i ].vertices;\r\n\t\t\t\tsrcVertices = json.morphTargets [ i ].vertices;\r\n\r\n\t\t\t\tfor( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\r\n\t\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\r\n\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\r\n\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\r\n\r\n\t\t\t\t\tdstVertices.push( vertex );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.morphColors !== undefined ) {\r\n\r\n\t\t\tvar i, l, c, cl, dstColors, srcColors, color;\r\n\r\n\t\t\tfor ( i = 0, l = json.morphColors.length; i < l; i++ ) {\r\n\r\n\t\t\t\tgeometry.morphColors[ i ] = {};\r\n\t\t\t\tgeometry.morphColors[ i ].name = json.morphColors[ i ].name;\r\n\t\t\t\tgeometry.morphColors[ i ].colors = [];\r\n\r\n\t\t\t\tdstColors = geometry.morphColors[ i ].colors;\r\n\t\t\t\tsrcColors = json.morphColors [ i ].colors;\r\n\r\n\t\t\t\tfor ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {\r\n\r\n\t\t\t\t\tcolor = new THREE.Color( 0xffaa00 );\r\n\t\t\t\t\tcolor.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );\r\n\t\t\t\t\tdstColors.push( color );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tif ( json.materials === undefined ) {\r\n\r\n\t\treturn { geometry: geometry };\r\n\r\n\t} else {\r\n\r\n\t\tvar materials = this.initMaterials( json.materials, texturePath );\r\n\r\n\t\tif ( this.needsTangents( materials ) ) {\r\n\r\n\t\t\tgeometry.computeTangents();\r\n\r\n\t\t}\r\n\r\n\t\treturn { geometry: geometry, materials: materials };\r\n\r\n\t}\r\n\r\n};\r\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\n\n\tvar scope = this;\n\n\tvar loaded = 0, total = 0;\n\n\tthis.onLoad = onLoad;\n\tthis.onProgress = onProgress;\n\tthis.onError = onError;\n\n\tthis.itemStart = function ( url ) {\n\n\t\ttotal ++;\n\n\t};\n\n\tthis.itemEnd = function ( url ) {\n\n\t\tloaded ++;\n\n\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\tscope.onProgress( url, loaded, total );\n\n\t\t}\n\n\t\tif ( loaded === total && scope.onLoad !== undefined ) {\n\n\t\t\tscope.onLoad();\n\n\t\t}\n\n\t};\n\n};\n\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometryLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.BufferGeometryLoader.prototype = {\r\n\r\n\tconstructor: THREE.BufferGeometryLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader();\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\t\tvar attributes = json.attributes;\r\n\t\tvar offsets = json.offsets;\r\n\t\tvar boundingSphere = json.boundingSphere;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\r\n\t\t\tgeometry.attributes[ key ] = {\r\n\t\t\t\titemSize: attribute.itemSize,\r\n\t\t\t\tarray: new self[ attribute.type ]( attribute.array )\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( offsets !== undefined ) {\r\n\r\n\t\t\tgeometry.offsets = JSON.parse( JSON.stringify( offsets ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( boundingSphere !== undefined ) {\r\n\r\n\t\t\tgeometry.boundingSphere = new THREE.Sphere(\r\n\t\t\t\tnew THREE.Vector3().fromArray( boundingSphere.center !== undefined ? boundingSphere.center : [ 0, 0, 0 ] ),\r\n\t\t\t\tboundingSphere.radius\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n};\r\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.GeometryLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.GeometryLoader.prototype = {\r\n\r\n\tconstructor: THREE.GeometryLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader();\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\t\r\n\r\n\t}\r\n\r\n};\r\n\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MaterialLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.MaterialLoader.prototype = {\r\n\r\n\tconstructor: THREE.MaterialLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader();\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar material = new THREE[ json.type ];\r\n\r\n\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\r\n\t\tif ( json.ambient !== undefined ) material.ambient.setHex( json.ambient );\r\n\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\r\n\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\r\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\r\n\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\r\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\r\n\t\tif ( json.side !== undefined ) material.side = json.side;\r\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\r\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\r\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\r\n\r\n\t\tif ( json.materials !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ObjectLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nTHREE.ObjectLoader.prototype = {\n\n\tconstructor: THREE.ObjectLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\n\n\t\t} );\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t},\n\n\tparse: function ( json ) {\n\n\t\tvar geometries = this.parseGeometries( json.geometries );\n\t\tvar materials = this.parseMaterials( json.materials );\n\t\tvar object = this.parseObject( json.object, geometries, materials );\n\n\t\treturn object;\n\n\t},\n\n\tparseGeometries: function ( json ) {\n\n\t\tvar geometries = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar geometryLoader = new THREE.JSONLoader();\n\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar geometry;\n\t\t\t\tvar data = json[ i ];\n\n\t\t\t\tswitch ( data.type ) {\n\n\t\t\t\t\tcase 'PlaneGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE.PlaneGeometry(\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CircleGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE.CircleGeometry(\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.segments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CubeGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE.CubeGeometry(\n\t\t\t\t\t\t\tdata.width,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.depth,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.depthSegments\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CylinderGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE.CylinderGeometry(\n\t\t\t\t\t\t\tdata.radiusTop,\n\t\t\t\t\t\t\tdata.radiusBottom,\n\t\t\t\t\t\t\tdata.height,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.openEnded\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'SphereGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE.SphereGeometry(\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.widthSegments,\n\t\t\t\t\t\t\tdata.heightSegments,\n\t\t\t\t\t\t\tdata.phiStart,\n\t\t\t\t\t\t\tdata.phiLength,\n\t\t\t\t\t\t\tdata.thetaStart,\n\t\t\t\t\t\t\tdata.thetaLength\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'IcosahedronGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE.IcosahedronGeometry(\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.detail\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE.TorusGeometry(\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.arc\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'TorusKnotGeometry':\n\n\t\t\t\t\t\tgeometry = new THREE.TorusKnotGeometry(\n\t\t\t\t\t\t\tdata.radius,\n\t\t\t\t\t\t\tdata.tube,\n\t\t\t\t\t\t\tdata.radialSegments,\n\t\t\t\t\t\t\tdata.tubularSegments,\n\t\t\t\t\t\t\tdata.p,\n\t\t\t\t\t\t\tdata.q,\n\t\t\t\t\t\t\tdata.heightScale\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'BufferGeometry':\n\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data.data );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Geometry':\n\n\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data ).geometry;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\n\n\t\t\t\tgeometries[ data.uuid ] = geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn geometries;\n\n\t},\n\n\tparseMaterials: function ( json ) {\n\n\t\tvar materials = {};\n\n\t\tif ( json !== undefined ) {\n\n\t\t\tvar loader = new THREE.MaterialLoader();\n\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\n\n\t\t\t\tvar data = json[ i ];\n\t\t\t\tvar material = loader.parse( data );\n\n\t\t\t\tmaterial.uuid = data.uuid;\n\n\t\t\t\tif ( data.name !== undefined ) material.name = data.name;\n\n\t\t\t\tmaterials[ data.uuid ] = material;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn materials;\n\n\t},\n\n\tparseObject: function () {\n\n\t\tvar matrix = new THREE.Matrix4();\n\n\t\treturn function ( data, geometries, materials ) {\n\n\t\t\tvar object;\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'Scene':\n\n\t\t\t\t\tobject = new THREE.Scene();\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PerspectiveCamera':\n\n\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'OrthographicCamera':\n\n\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'AmbientLight':\n\n\t\t\t\t\tobject = new THREE.AmbientLight( data.color );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'DirectionalLight':\n\n\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'PointLight':\n\n\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'SpotLight':\n\n\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'HemisphereLight':\n\n\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Mesh':\n\n\t\t\t\t\tvar geometry = geometries[ data.geometry ];\n\t\t\t\t\tvar material = materials[ data.material ];\n\n\t\t\t\t\tif ( geometry === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.ObjectLoader: Undefined geometry ' + data.geometry );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.ObjectLoader: Undefined material ' + data.material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Sprite':\n\n\t\t\t\t\tvar material = materials[ data.material ];\n\n\t\t\t\t\tif ( material === undefined ) {\n\n\t\t\t\t\t\tconsole.error( 'THREE.ObjectLoader: Undefined material ' + data.material );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject = new THREE.Sprite( material );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tobject = new THREE.Object3D();\n\n\t\t\t}\n\n\t\t\tobject.uuid = data.uuid;\n\n\t\t\tif ( data.name !== undefined ) object.name = data.name;\n\t\t\tif ( data.matrix !== undefined ) {\n\n\t\t\t\tmatrix.fromArray( data.matrix );\n\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t} else {\n\n\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\n\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\n\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\n\n\t\t\t}\n\n\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\n\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\n\n\t\t\tif ( data.children !== undefined ) {\n\n\t\t\t\tfor ( var child in data.children ) {\n\n\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn object;\n\n\t\t}\n\n\t}()\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SceneLoader = function () {\n\n\tthis.onLoadStart = function () {};\n\tthis.onLoadProgress = function() {};\n\tthis.onLoadComplete = function () {};\n\n\tthis.callbackSync = function () {};\n\tthis.callbackProgress = function () {};\n\n\tthis.geometryHandlers = {};\n\tthis.hierarchyHandlers = {};\n\n\tthis.addGeometryHandler( \"ascii\", THREE.JSONLoader );\n\n};\n\nTHREE.SceneLoader.prototype = {\n\n\tconstructor: THREE.SceneLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tscope.parse( JSON.parse( text ), onLoad, url );\n\n\t\t} );\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t},\n\n\taddGeometryHandler: function ( typeID, loaderClass ) {\n\n\t\tthis.geometryHandlers[ typeID ] = { \"loaderClass\": loaderClass };\n\n\t},\n\n\taddHierarchyHandler: function ( typeID, loaderClass ) {\n\n\t\tthis.hierarchyHandlers[ typeID ] = { \"loaderClass\": loaderClass };\n\n\t},\n\n\tparse: function ( json, callbackFinished, url ) {\n\n\t\tvar scope = this;\n\n\t\tvar urlBase = THREE.Loader.prototype.extractUrlBase( url );\n\n\t\tvar geometry, material, camera, fog,\n\t\t\ttexture, images, color,\n\t\t\tlight, hex, intensity,\n\t\t\tcounter_models, counter_textures,\n\t\t\ttotal_models, total_textures,\n\t\t\tresult;\n\n\t\tvar target_array = [];\n\n\t\tvar data = json;\n\n\t\t// async geometry loaders\n\n\t\tfor ( var typeID in this.geometryHandlers ) {\n\n\t\t\tvar loaderClass = this.geometryHandlers[ typeID ][ \"loaderClass\" ];\n\t\t\tthis.geometryHandlers[ typeID ][ \"loaderObject\" ] = new loaderClass();\n\n\t\t}\n\n\t\t// async hierachy loaders\n\n\t\tfor ( var typeID in this.hierarchyHandlers ) {\n\n\t\t\tvar loaderClass = this.hierarchyHandlers[ typeID ][ \"loaderClass\" ];\n\t\t\tthis.hierarchyHandlers[ typeID ][ \"loaderObject\" ] = new loaderClass();\n\n\t\t}\n\n\t\tcounter_models = 0;\n\t\tcounter_textures = 0;\n\n\t\tresult = {\n\n\t\t\tscene: new THREE.Scene(),\n\t\t\tgeometries: {},\n\t\t\tface_materials: {},\n\t\t\tmaterials: {},\n\t\t\ttextures: {},\n\t\t\tobjects: {},\n\t\t\tcameras: {},\n\t\t\tlights: {},\n\t\t\tfogs: {},\n\t\t\tempties: {},\n\t\t\tgroups: {}\n\n\t\t};\n\n\t\tif ( data.transform ) {\n\n\t\t\tvar position = data.transform.position,\n\t\t\t\trotation = data.transform.rotation,\n\t\t\t\tscale = data.transform.scale;\n\n\t\t\tif ( position ) {\n\n\t\t\t\tresult.scene.position.fromArray( position );\n\n\t\t\t}\n\n\t\t\tif ( rotation ) {\n\n\t\t\t\tresult.scene.rotation.fromArray( rotation );\n\n\t\t\t}\n\n\t\t\tif ( scale ) {\n\n\t\t\t\tresult.scene.scale.fromArray( scale );\n\n\t\t\t}\n\n\t\t\tif ( position || rotation || scale ) {\n\n\t\t\t\tresult.scene.updateMatrix();\n\t\t\t\tresult.scene.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction get_url( source_url, url_type ) {\n\n\t\t\tif ( url_type == \"relativeToHTML\" ) {\n\n\t\t\t\treturn source_url;\n\n\t\t\t} else {\n\n\t\t\t\treturn urlBase + \"/\" + source_url;\n\n\t\t\t}\n\n\t\t};\n\n\t\t// toplevel loader function, delegates to handle_children\n\n\t\tfunction handle_objects() {\n\n\t\t\thandle_children( result.scene, data.objects );\n\n\t\t}\n\n\t\t// handle all the children from the loaded json and attach them to given parent\n\n\t\tfunction handle_children( parent, children ) {\n\n\t\t\tvar mat, dst, pos, rot, scl, quat;\n\n\t\t\tfor ( var objID in children ) {\n\n\t\t\t\t// check by id if child has already been handled,\n\t\t\t\t// if not, create new object\n\n\t\t\t\tvar object = result.objects[ objID ];\n\t\t\t\tvar objJSON = children[ objID ];\n\n\t\t\t\tif ( object === undefined ) {\n\n\t\t\t\t\t// meshes\n\n\t\t\t\t\tif ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {\n\n\t\t\t\t\t\tif ( objJSON.loading === undefined ) {\n\n\t\t\t\t\t\t\tvar reservedTypes = {\n\t\t\t\t\t\t\t\t\"type\": 1, \"url\": 1, \"material\": 1,\n\t\t\t\t\t\t\t\t\"position\": 1, \"rotation\": 1, \"scale\" : 1,\n\t\t\t\t\t\t\t\t\"visible\": 1, \"children\": 1, \"userData\": 1,\n\t\t\t\t\t\t\t\t\"skin\": 1, \"morph\": 1, \"mirroredLoop\": 1, \"duration\": 1\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tvar loaderParameters = {};\n\n\t\t\t\t\t\t\tfor ( var parType in objJSON ) {\n\n\t\t\t\t\t\t\t\tif ( ! ( parType in reservedTypes ) ) {\n\n\t\t\t\t\t\t\t\t\tloaderParameters[ parType ] = objJSON[ parType ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmaterial = result.materials[ objJSON.material ];\n\n\t\t\t\t\t\t\tobjJSON.loading = true;\n\n\t\t\t\t\t\t\tvar loader = scope.hierarchyHandlers[ objJSON.type ][ \"loaderObject\" ];\n\n\t\t\t\t\t\t\t// ColladaLoader\n\n\t\t\t\t\t\t\tif ( loader.options ) {\n\n\t\t\t\t\t\t\t\tloader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ) );\n\n\t\t\t\t\t\t\t// UTF8Loader\n\t\t\t\t\t\t\t// OBJLoader\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tloader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ), loaderParameters );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( objJSON.geometry !== undefined ) {\n\n\t\t\t\t\t\tgeometry = result.geometries[ objJSON.geometry ];\n\n\t\t\t\t\t\t// geometry already loaded\n\n\t\t\t\t\t\tif ( geometry ) {\n\n\t\t\t\t\t\t\tvar needsTangents = false;\n\n\t\t\t\t\t\t\tmaterial = result.materials[ objJSON.material ];\n\t\t\t\t\t\t\tneedsTangents = material instanceof THREE.ShaderMaterial;\n\n\t\t\t\t\t\t\tpos = objJSON.position;\n\t\t\t\t\t\t\trot = objJSON.rotation;\n\t\t\t\t\t\t\tscl = objJSON.scale;\n\t\t\t\t\t\t\tmat = objJSON.matrix;\n\t\t\t\t\t\t\tquat = objJSON.quaternion;\n\n\t\t\t\t\t\t\t// use materials from the model file\n\t\t\t\t\t\t\t// if there is no material specified in the object\n\n\t\t\t\t\t\t\tif ( ! objJSON.material ) {\n\n\t\t\t\t\t\t\t\tmaterial = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// use materials from the model file\n\t\t\t\t\t\t\t// if there is just empty face material\n\t\t\t\t\t\t\t// (must create new material as each model has its own face material)\n\n\t\t\t\t\t\t\tif ( ( material instanceof THREE.MeshFaceMaterial ) && material.materials.length === 0 ) {\n\n\t\t\t\t\t\t\t\tmaterial = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( material instanceof THREE.MeshFaceMaterial ) {\n\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < material.materials.length; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tneedsTangents = needsTangents || ( material.materials[ i ] instanceof THREE.ShaderMaterial );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( needsTangents ) {\n\n\t\t\t\t\t\t\t\tgeometry.computeTangents();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( objJSON.skin ) {\n\n\t\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\n\n\t\t\t\t\t\t\t} else if ( objJSON.morph ) {\n\n\t\t\t\t\t\t\t\tobject = new THREE.MorphAnimMesh( geometry, material );\n\n\t\t\t\t\t\t\t\tif ( objJSON.duration !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tobject.duration = objJSON.duration;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( objJSON.time !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tobject.time = objJSON.time;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( objJSON.mirroredLoop !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tobject.mirroredLoop = objJSON.mirroredLoop;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t\t\t\t\tgeometry.computeMorphNormals();\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.name = objID;\n\n\t\t\t\t\t\t\tif ( mat ) {\n\n\t\t\t\t\t\t\t\tobject.matrixAutoUpdate = false;\n\t\t\t\t\t\t\t\tobject.matrix.set(\n\t\t\t\t\t\t\t\t\tmat[0],  mat[1],  mat[2],  mat[3],\n\t\t\t\t\t\t\t\t\tmat[4],  mat[5],  mat[6],  mat[7],\n\t\t\t\t\t\t\t\t\tmat[8],  mat[9],  mat[10], mat[11],\n\t\t\t\t\t\t\t\t\tmat[12], mat[13], mat[14], mat[15]\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tobject.position.fromArray( pos );\n\n\t\t\t\t\t\t\t\tif ( quat ) {\n\n\t\t\t\t\t\t\t\t\tobject.quaternion.fromArray( quat );\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tobject.rotation.fromArray( rot );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tobject.scale.fromArray( scl );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.visible = objJSON.visible;\n\t\t\t\t\t\t\tobject.castShadow = objJSON.castShadow;\n\t\t\t\t\t\t\tobject.receiveShadow = objJSON.receiveShadow;\n\n\t\t\t\t\t\t\tparent.add( object );\n\n\t\t\t\t\t\t\tresult.objects[ objID ] = object;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// lights\n\n\t\t\t\t\t} else if ( objJSON.type === \"AmbientLight\" || objJSON.type === \"PointLight\" ||\n\t\t\t\t\t\tobjJSON.type === \"DirectionalLight\" || objJSON.type === \"SpotLight\" ||\n\t\t\t\t\t\tobjJSON.type === \"HemisphereLight\" || objJSON.type === \"AreaLight\" ) {\n\n\t\t\t\t\t\tvar color = objJSON.color;\n\t\t\t\t\t\tvar intensity = objJSON.intensity;\n\t\t\t\t\t\tvar distance = objJSON.distance;\n\t\t\t\t\t\tvar position = objJSON.position;\n\t\t\t\t\t\tvar rotation = objJSON.rotation;\n\n\t\t\t\t\t\tswitch ( objJSON.type ) {\n\n\t\t\t\t\t\t\tcase 'AmbientLight':\n\t\t\t\t\t\t\t\tlight = new THREE.AmbientLight( color );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'PointLight':\n\t\t\t\t\t\t\t\tlight = new THREE.PointLight( color, intensity, distance );\n\t\t\t\t\t\t\t\tlight.position.fromArray( position );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'DirectionalLight':\n\t\t\t\t\t\t\t\tlight = new THREE.DirectionalLight( color, intensity );\n\t\t\t\t\t\t\t\tlight.position.fromArray( objJSON.direction );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'SpotLight':\n\t\t\t\t\t\t\t\tlight = new THREE.SpotLight( color, intensity, distance, 1 );\n\t\t\t\t\t\t\t\tlight.angle = objJSON.angle;\n\t\t\t\t\t\t\t\tlight.position.fromArray( position );\n\t\t\t\t\t\t\t\tlight.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );\n\t\t\t\t\t\t\t\tlight.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'HemisphereLight':\n\t\t\t\t\t\t\t\tlight = new THREE.DirectionalLight( color, intensity, distance );\n\t\t\t\t\t\t\t\tlight.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );\n\t\t\t\t\t\t\t\tlight.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'AreaLight':\n\t\t\t\t\t\t\t\tlight = new THREE.AreaLight(color, intensity);\n\t\t\t\t\t\t\t\tlight.position.fromArray( position );\n\t\t\t\t\t\t\t\tlight.width = objJSON.size;\n\t\t\t\t\t\t\t\tlight.height = objJSON.size_y;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparent.add( light );\n\n\t\t\t\t\t\tlight.name = objID;\n\t\t\t\t\t\tresult.lights[ objID ] = light;\n\t\t\t\t\t\tresult.objects[ objID ] = light;\n\n\t\t\t\t\t// cameras\n\n\t\t\t\t\t} else if ( objJSON.type === \"PerspectiveCamera\" || objJSON.type === \"OrthographicCamera\" ) {\n\n\t\t\t\t\t\tpos = objJSON.position;\n\t\t\t\t\t\trot = objJSON.rotation;\n\t\t\t\t\t\tquat = objJSON.quaternion;\n\n\t\t\t\t\t\tif ( objJSON.type === \"PerspectiveCamera\" ) {\n\n\t\t\t\t\t\t\tcamera = new THREE.PerspectiveCamera( objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far );\n\n\t\t\t\t\t\t} else if ( objJSON.type === \"OrthographicCamera\" ) {\n\n\t\t\t\t\t\t\tcamera = new THREE.OrthographicCamera( objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcamera.name = objID;\n\t\t\t\t\t\tcamera.position.fromArray( pos );\n\n\t\t\t\t\t\tif ( quat !== undefined ) {\n\n\t\t\t\t\t\t\tcamera.quaternion.fromArray( quat );\n\n\t\t\t\t\t\t} else if ( rot !== undefined ) {\n\n\t\t\t\t\t\t\tcamera.rotation.fromArray( rot );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tparent.add( camera );\n\n\t\t\t\t\t\tresult.cameras[ objID ] = camera;\n\t\t\t\t\t\tresult.objects[ objID ] = camera;\n\n\t\t\t\t\t// pure Object3D\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpos = objJSON.position;\n\t\t\t\t\t\trot = objJSON.rotation;\n\t\t\t\t\t\tscl = objJSON.scale;\n\t\t\t\t\t\tquat = objJSON.quaternion;\n\n\t\t\t\t\t\tobject = new THREE.Object3D();\n\t\t\t\t\t\tobject.name = objID;\n\t\t\t\t\t\tobject.position.fromArray( pos );\n\n\t\t\t\t\t\tif ( quat ) {\n\n\t\t\t\t\t\t\tobject.quaternion.fromArray( quat );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject.rotation.fromArray( rot );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tobject.scale.fromArray( scl );\n\t\t\t\t\t\tobject.visible = ( objJSON.visible !== undefined ) ? objJSON.visible : false;\n\n\t\t\t\t\t\tparent.add( object );\n\n\t\t\t\t\t\tresult.objects[ objID ] = object;\n\t\t\t\t\t\tresult.empties[ objID ] = object;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( object ) {\n\n\t\t\t\t\t\tif ( objJSON.userData !== undefined ) {\n\n\t\t\t\t\t\t\tfor ( var key in objJSON.userData ) {\n\n\t\t\t\t\t\t\t\tvar value = objJSON.userData[ key ];\n\t\t\t\t\t\t\t\tobject.userData[ key ] = value;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( objJSON.groups !== undefined ) {\n\n\t\t\t\t\t\t\tfor ( var i = 0; i < objJSON.groups.length; i ++ ) {\n\n\t\t\t\t\t\t\t\tvar groupID = objJSON.groups[ i ];\n\n\t\t\t\t\t\t\t\tif ( result.groups[ groupID ] === undefined ) {\n\n\t\t\t\t\t\t\t\t\tresult.groups[ groupID ] = [];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tresult.groups[ groupID ].push( objID );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( object !== undefined && objJSON.children !== undefined ) {\n\n\t\t\t\t\thandle_children( object, objJSON.children );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction handle_mesh( geo, mat, id ) {\n\n\t\t\tresult.geometries[ id ] = geo;\n\t\t\tresult.face_materials[ id ] = mat;\n\t\t\thandle_objects();\n\n\t\t};\n\n\t\tfunction handle_hierarchy( node, id, parent, material, obj ) {\n\n\t\t\tvar p = obj.position;\n\t\t\tvar r = obj.rotation;\n\t\t\tvar q = obj.quaternion;\n\t\t\tvar s = obj.scale;\n\n\t\t\tnode.position.fromArray( p );\n\n\t\t\tif ( q ) {\n\n\t\t\t\tnode.quaternion.fromArray( q );\n\n\t\t\t} else {\n\n\t\t\t\tnode.rotation.fromArray( r );\n\n\t\t\t}\n\n\t\t\tnode.scale.fromArray( s );\n\n\t\t\t// override children materials\n\t\t\t// if object material was specified in JSON explicitly\n\n\t\t\tif ( material ) {\n\n\t\t\t\tnode.traverse( function ( child ) {\n\n\t\t\t\t\tchild.material = material;\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\t// override children visibility\n\t\t\t// with root node visibility as specified in JSON\n\n\t\t\tvar visible = ( obj.visible !== undefined ) ? obj.visible : true;\n\n\t\t\tnode.traverse( function ( child ) {\n\n\t\t\t\tchild.visible = visible;\n\n\t\t\t} );\n\n\t\t\tparent.add( node );\n\n\t\t\tnode.name = id;\n\n\t\t\tresult.objects[ id ] = node;\n\t\t\thandle_objects();\n\n\t\t};\n\n\t\tfunction create_callback_geometry( id ) {\n\n\t\t\treturn function ( geo, mat ) {\n\n\t\t\t\tgeo.name = id;\n\n\t\t\t\thandle_mesh( geo, mat, id );\n\n\t\t\t\tcounter_models -= 1;\n\n\t\t\t\tscope.onLoadComplete();\n\n\t\t\t\tasync_callback_gate();\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction create_callback_hierachy( id, parent, material, obj ) {\n\n\t\t\treturn function ( event ) {\n\n\t\t\t\tvar result;\n\n\t\t\t\t// loaders which use EventDispatcher\n\n\t\t\t\tif ( event.content ) {\n\n\t\t\t\t\tresult = event.content;\n\n\t\t\t\t// ColladaLoader\n\n\t\t\t\t} else if ( event.dae ) {\n\n\t\t\t\t\tresult = event.scene;\n\n\n\t\t\t\t// UTF8Loader\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult = event;\n\n\t\t\t\t}\n\n\t\t\t\thandle_hierarchy( result, id, parent, material, obj );\n\n\t\t\t\tcounter_models -= 1;\n\n\t\t\t\tscope.onLoadComplete();\n\n\t\t\t\tasync_callback_gate();\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction create_callback_embed( id ) {\n\n\t\t\treturn function ( geo, mat ) {\n\n\t\t\t\tgeo.name = id;\n\n\t\t\t\tresult.geometries[ id ] = geo;\n\t\t\t\tresult.face_materials[ id ] = mat;\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction async_callback_gate() {\n\n\t\t\tvar progress = {\n\n\t\t\t\ttotalModels : total_models,\n\t\t\t\ttotalTextures : total_textures,\n\t\t\t\tloadedModels : total_models - counter_models,\n\t\t\t\tloadedTextures : total_textures - counter_textures\n\n\t\t\t};\n\n\t\t\tscope.callbackProgress( progress, result );\n\n\t\t\tscope.onLoadProgress();\n\n\t\t\tif ( counter_models === 0 && counter_textures === 0 ) {\n\n\t\t\t\tfinalize();\n\t\t\t\tcallbackFinished( result );\n\n\t\t\t}\n\n\t\t};\n\n\t\tfunction finalize() {\n\n\t\t\t// take care of targets which could be asynchronously loaded objects\n\n\t\t\tfor ( var i = 0; i < target_array.length; i ++ ) {\n\n\t\t\t\tvar ta = target_array[ i ];\n\n\t\t\t\tvar target = result.objects[ ta.targetName ];\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\tta.object.target = target;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if there was error and target of specified name doesn't exist in the scene file\n\t\t\t\t\t// create instead dummy target\n\t\t\t\t\t// (target must be added to scene explicitly as parent is already added)\n\n\t\t\t\t\tta.object.target = new THREE.Object3D();\n\t\t\t\t\tresult.scene.add( ta.object.target );\n\n\t\t\t\t}\n\n\t\t\t\tta.object.target.userData.targetInverse = ta.object;\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar callbackTexture = function ( count ) {\n\n\t\t\tcounter_textures -= count;\n\t\t\tasync_callback_gate();\n\n\t\t\tscope.onLoadComplete();\n\n\t\t};\n\n\t\t// must use this instead of just directly calling callbackTexture\n\t\t// because of closure in the calling context loop\n\n\t\tvar generateTextureCallback = function ( count ) {\n\n\t\t\treturn function () {\n\n\t\t\t\tcallbackTexture( count );\n\n\t\t\t};\n\n\t\t};\n\n\t\tfunction traverse_json_hierarchy( objJSON, callback ) {\n\n\t\t\tcallback( objJSON );\n\n\t\t\tif ( objJSON.children !== undefined ) {\n\n\t\t\t\tfor ( var objChildID in objJSON.children ) {\n\n\t\t\t\t\ttraverse_json_hierarchy( objJSON.children[ objChildID ], callback );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\t// first go synchronous elements\n\n\t\t// fogs\n\n\t\tvar fogID, fogJSON;\n\n\t\tfor ( fogID in data.fogs ) {\n\n\t\t\tfogJSON = data.fogs[ fogID ];\n\n\t\t\tif ( fogJSON.type === \"linear\" ) {\n\n\t\t\t\tfog = new THREE.Fog( 0x000000, fogJSON.near, fogJSON.far );\n\n\t\t\t} else if ( fogJSON.type === \"exp2\" ) {\n\n\t\t\t\tfog = new THREE.FogExp2( 0x000000, fogJSON.density );\n\n\t\t\t}\n\n\t\t\tcolor = fogJSON.color;\n\t\t\tfog.color.setRGB( color[0], color[1], color[2] );\n\n\t\t\tresult.fogs[ fogID ] = fog;\n\n\t\t}\n\n\t\t// now come potentially asynchronous elements\n\n\t\t// geometries\n\n\t\t// count how many geometries will be loaded asynchronously\n\n\t\tvar geoID, geoJSON;\n\n\t\tfor ( geoID in data.geometries ) {\n\n\t\t\tgeoJSON = data.geometries[ geoID ];\n\n\t\t\tif ( geoJSON.type in this.geometryHandlers ) {\n\n\t\t\t\tcounter_models += 1;\n\n\t\t\t\tscope.onLoadStart();\n\n\t\t\t}\n\n\t\t}\n\n\t\t// count how many hierarchies will be loaded asynchronously\n\n\t\tfor ( var objID in data.objects ) {\n\n\t\t\ttraverse_json_hierarchy( data.objects[ objID ], function ( objJSON ) {\n\n\t\t\t\tif ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {\n\n\t\t\t\t\tcounter_models += 1;\n\n\t\t\t\t\tscope.onLoadStart();\n\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t}\n\n\t\ttotal_models = counter_models;\n\n\t\tfor ( geoID in data.geometries ) {\n\n\t\t\tgeoJSON = data.geometries[ geoID ];\n\n\t\t\tif ( geoJSON.type === \"cube\" ) {\n\n\t\t\t\tgeometry = new THREE.CubeGeometry( geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments );\n\t\t\t\tgeometry.name = geoID;\n\t\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t\t} else if ( geoJSON.type === \"plane\" ) {\n\n\t\t\t\tgeometry = new THREE.PlaneGeometry( geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments );\n\t\t\t\tgeometry.name = geoID;\n\t\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t\t} else if ( geoJSON.type === \"sphere\" ) {\n\n\t\t\t\tgeometry = new THREE.SphereGeometry( geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments );\n\t\t\t\tgeometry.name = geoID;\n\t\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t\t} else if ( geoJSON.type === \"cylinder\" ) {\n\n\t\t\t\tgeometry = new THREE.CylinderGeometry( geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs );\n\t\t\t\tgeometry.name = geoID;\n\t\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t\t} else if ( geoJSON.type === \"torus\" ) {\n\n\t\t\t\tgeometry = new THREE.TorusGeometry( geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT );\n\t\t\t\tgeometry.name = geoID;\n\t\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t\t} else if ( geoJSON.type === \"icosahedron\" ) {\n\n\t\t\t\tgeometry = new THREE.IcosahedronGeometry( geoJSON.radius, geoJSON.subdivisions );\n\t\t\t\tgeometry.name = geoID;\n\t\t\t\tresult.geometries[ geoID ] = geometry;\n\n\t\t\t} else if ( geoJSON.type in this.geometryHandlers ) {\n\n\t\t\t\tvar loaderParameters = {};\n\n\t\t\t\tfor ( var parType in geoJSON ) {\n\n\t\t\t\t\tif ( parType !== \"type\" && parType !== \"url\" ) {\n\n\t\t\t\t\t\tloaderParameters[ parType ] = geoJSON[ parType ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar loader = this.geometryHandlers[ geoJSON.type ][ \"loaderObject\" ];\n\t\t\t\tloader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry( geoID ), loaderParameters );\n\n\t\t\t} else if ( geoJSON.type === \"embedded\" ) {\n\n\t\t\t\tvar modelJson = data.embeds[ geoJSON.id ],\n\t\t\t\t\ttexture_path = \"\";\n\n\t\t\t\t// pass metadata along to jsonLoader so it knows the format version\n\n\t\t\t\tmodelJson.metadata = data.metadata;\n\n\t\t\t\tif ( modelJson ) {\n\n\t\t\t\t\tvar jsonLoader = this.geometryHandlers[ \"ascii\" ][ \"loaderObject\" ];\n\t\t\t\t\tvar model = jsonLoader.parse( modelJson, texture_path );\n\t\t\t\t\tcreate_callback_embed( geoID )( model.geometry, model.materials );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// textures\n\n\t\t// count how many textures will be loaded asynchronously\n\n\t\tvar textureID, textureJSON;\n\n\t\tfor ( textureID in data.textures ) {\n\n\t\t\ttextureJSON = data.textures[ textureID ];\n\n\t\t\tif ( textureJSON.url instanceof Array ) {\n\n\t\t\t\tcounter_textures += textureJSON.url.length;\n\n\t\t\t\tfor( var n = 0; n < textureJSON.url.length; n ++ ) {\n\n\t\t\t\t\tscope.onLoadStart();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tcounter_textures += 1;\n\n\t\t\t\tscope.onLoadStart();\n\n\t\t\t}\n\n\t\t}\n\n\t\ttotal_textures = counter_textures;\n\n\t\tfor ( textureID in data.textures ) {\n\n\t\t\ttextureJSON = data.textures[ textureID ];\n\n\t\t\tif ( textureJSON.mapping !== undefined && THREE[ textureJSON.mapping ] !== undefined ) {\n\n\t\t\t\ttextureJSON.mapping = new THREE[ textureJSON.mapping ]();\n\n\t\t\t}\n\n\t\t\tif ( textureJSON.url instanceof Array ) {\n\n\t\t\t\tvar count = textureJSON.url.length;\n\t\t\t\tvar url_array = [];\n\n\t\t\t\tfor( var i = 0; i < count; i ++ ) {\n\n\t\t\t\t\turl_array[ i ] = get_url( textureJSON.url[ i ], data.urlBaseType );\n\n\t\t\t\t}\n\n\t\t\t\tvar isCompressed = /\\.dds$/i.test( url_array[ 0 ] );\n\n\t\t\t\tif ( isCompressed ) {\n\n\t\t\t\t\ttexture = THREE.ImageUtils.loadCompressedTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture = THREE.ImageUtils.loadTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tvar isCompressed = /\\.dds$/i.test( textureJSON.url );\n\t\t\t\tvar fullUrl = get_url( textureJSON.url, data.urlBaseType );\n\t\t\t\tvar textureCallback = generateTextureCallback( 1 );\n\n\t\t\t\tif ( isCompressed ) {\n\n\t\t\t\t\ttexture = THREE.ImageUtils.loadCompressedTexture( fullUrl, textureJSON.mapping, textureCallback );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture = THREE.ImageUtils.loadTexture( fullUrl, textureJSON.mapping, textureCallback );\n\n\t\t\t\t}\n\n\t\t\t\tif ( THREE[ textureJSON.minFilter ] !== undefined )\n\t\t\t\t\ttexture.minFilter = THREE[ textureJSON.minFilter ];\n\n\t\t\t\tif ( THREE[ textureJSON.magFilter ] !== undefined )\n\t\t\t\t\ttexture.magFilter = THREE[ textureJSON.magFilter ];\n\n\t\t\t\tif ( textureJSON.anisotropy ) texture.anisotropy = textureJSON.anisotropy;\n\n\t\t\t\tif ( textureJSON.repeat ) {\n\n\t\t\t\t\ttexture.repeat.set( textureJSON.repeat[ 0 ], textureJSON.repeat[ 1 ] );\n\n\t\t\t\t\tif ( textureJSON.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tif ( textureJSON.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( textureJSON.offset ) {\n\n\t\t\t\t\ttexture.offset.set( textureJSON.offset[ 0 ], textureJSON.offset[ 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\t// handle wrap after repeat so that default repeat can be overriden\n\n\t\t\t\tif ( textureJSON.wrap ) {\n\n\t\t\t\t\tvar wrapMap = {\n\t\t\t\t\t\t\"repeat\": THREE.RepeatWrapping,\n\t\t\t\t\t\t\"mirror\": THREE.MirroredRepeatWrapping\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( wrapMap[ textureJSON.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ textureJSON.wrap[ 0 ] ];\n\t\t\t\t\tif ( wrapMap[ textureJSON.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ textureJSON.wrap[ 1 ] ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tresult.textures[ textureID ] = texture;\n\n\t\t}\n\n\t\t// materials\n\n\t\tvar matID, matJSON;\n\t\tvar parID;\n\n\t\tfor ( matID in data.materials ) {\n\n\t\t\tmatJSON = data.materials[ matID ];\n\n\t\t\tfor ( parID in matJSON.parameters ) {\n\n\t\t\t\tif ( parID === \"envMap\" || parID === \"map\" || parID === \"lightMap\" || parID === \"bumpMap\" ) {\n\n\t\t\t\t\tmatJSON.parameters[ parID ] = result.textures[ matJSON.parameters[ parID ] ];\n\n\t\t\t\t} else if ( parID === \"shading\" ) {\n\n\t\t\t\t\tmatJSON.parameters[ parID ] = ( matJSON.parameters[ parID ] === \"flat\" ) ? THREE.FlatShading : THREE.SmoothShading;\n\n\t\t\t\t} else if ( parID === \"side\" ) {\n\n\t\t\t\t\tif ( matJSON.parameters[ parID ] == \"double\" ) {\n\n\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.DoubleSide;\n\n\t\t\t\t\t} else if ( matJSON.parameters[ parID ] == \"back\" ) {\n\n\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.BackSide;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.FrontSide;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( parID === \"blending\" ) {\n\n\t\t\t\t\tmatJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.NormalBlending;\n\n\t\t\t\t} else if ( parID === \"combine\" ) {\n\n\t\t\t\t\tmatJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.MultiplyOperation;\n\n\t\t\t\t} else if ( parID === \"vertexColors\" ) {\n\n\t\t\t\t\tif ( matJSON.parameters[ parID ] == \"face\" ) {\n\n\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.FaceColors;\n\n\t\t\t\t\t// default to vertex colors if \"vertexColors\" is anything else face colors or 0 / null / false\n\n\t\t\t\t\t} else if ( matJSON.parameters[ parID ] ) {\n\n\t\t\t\t\t\tmatJSON.parameters[ parID ] = THREE.VertexColors;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( parID === \"wrapRGB\" ) {\n\n\t\t\t\t\tvar v3 = matJSON.parameters[ parID ];\n\t\t\t\t\tmatJSON.parameters[ parID ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0 ) {\n\n\t\t\t\tmatJSON.parameters.transparent = true;\n\n\t\t\t}\n\n\t\t\tif ( matJSON.parameters.normalMap ) {\n\n\t\t\t\tvar shader = THREE.ShaderLib[ \"normalmap\" ];\n\t\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\t\t\tvar diffuse = matJSON.parameters.color;\n\t\t\t\tvar specular = matJSON.parameters.specular;\n\t\t\t\tvar ambient = matJSON.parameters.ambient;\n\t\t\t\tvar shininess = matJSON.parameters.shininess;\n\n\t\t\t\tuniforms[ \"tNormal\" ].value = result.textures[ matJSON.parameters.normalMap ];\n\n\t\t\t\tif ( matJSON.parameters.normalScale ) {\n\n\t\t\t\t\tuniforms[ \"uNormalScale\" ].value.set( matJSON.parameters.normalScale[ 0 ], matJSON.parameters.normalScale[ 1 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( matJSON.parameters.map ) {\n\n\t\t\t\t\tuniforms[ \"tDiffuse\" ].value = matJSON.parameters.map;\n\t\t\t\t\tuniforms[ \"enableDiffuse\" ].value = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( matJSON.parameters.envMap ) {\n\n\t\t\t\t\tuniforms[ \"tCube\" ].value = matJSON.parameters.envMap;\n\t\t\t\t\tuniforms[ \"enableReflection\" ].value = true;\n\t\t\t\t\tuniforms[ \"reflectivity\" ].value = matJSON.parameters.reflectivity;\n\n\t\t\t\t}\n\n\t\t\t\tif ( matJSON.parameters.lightMap ) {\n\n\t\t\t\t\tuniforms[ \"tAO\" ].value = matJSON.parameters.lightMap;\n\t\t\t\t\tuniforms[ \"enableAO\" ].value = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( matJSON.parameters.specularMap ) {\n\n\t\t\t\t\tuniforms[ \"tSpecular\" ].value = result.textures[ matJSON.parameters.specularMap ];\n\t\t\t\t\tuniforms[ \"enableSpecular\" ].value = true;\n\n\t\t\t\t}\n\n\t\t\t\tif ( matJSON.parameters.displacementMap ) {\n\n\t\t\t\t\tuniforms[ \"tDisplacement\" ].value = result.textures[ matJSON.parameters.displacementMap ];\n\t\t\t\t\tuniforms[ \"enableDisplacement\" ].value = true;\n\n\t\t\t\t\tuniforms[ \"uDisplacementBias\" ].value = matJSON.parameters.displacementBias;\n\t\t\t\t\tuniforms[ \"uDisplacementScale\" ].value = matJSON.parameters.displacementScale;\n\n\t\t\t\t}\n\n\t\t\t\tuniforms[ \"diffuse\" ].value.setHex( diffuse );\n\t\t\t\tuniforms[ \"specular\" ].value.setHex( specular );\n\t\t\t\tuniforms[ \"ambient\" ].value.setHex( ambient );\n\n\t\t\t\tuniforms[ \"shininess\" ].value = shininess;\n\n\t\t\t\tif ( matJSON.parameters.opacity ) {\n\n\t\t\t\t\tuniforms[ \"opacity\" ].value = matJSON.parameters.opacity;\n\n\t\t\t\t}\n\n\t\t\t\tvar parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };\n\n\t\t\t\tmaterial = new THREE.ShaderMaterial( parameters );\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = new THREE[ matJSON.type ]( matJSON.parameters );\n\n\t\t\t}\n\n\t\t\tmaterial.name = matID;\n\n\t\t\tresult.materials[ matID ] = material;\n\n\t\t}\n\n\t\t// second pass through all materials to initialize MeshFaceMaterials\n\t\t// that could be referring to other materials out of order\n\n\t\tfor ( matID in data.materials ) {\n\n\t\t\tmatJSON = data.materials[ matID ];\n\n\t\t\tif ( matJSON.parameters.materials ) {\n\n\t\t\t\tvar materialArray = [];\n\n\t\t\t\tfor ( var i = 0; i < matJSON.parameters.materials.length; i ++ ) {\n\n\t\t\t\t\tvar label = matJSON.parameters.materials[ i ];\n\t\t\t\t\tmaterialArray.push( result.materials[ label ] );\n\n\t\t\t\t}\n\n\t\t\t\tresult.materials[ matID ].materials = materialArray;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// objects ( synchronous init of procedural primitives )\n\n\t\thandle_objects();\n\n\t\t// defaults\n\n\t\tif ( result.cameras && data.defaults.camera ) {\n\n\t\t\tresult.currentCamera = result.cameras[ data.defaults.camera ];\n\n\t\t}\n\n\t\tif ( result.fogs && data.defaults.fog ) {\n\n\t\t\tresult.scene.fog = result.fogs[ data.defaults.fog ];\n\n\t\t}\n\n\t\t// synchronous callback\n\n\t\tscope.callbackSync( result );\n\n\t\t// just in case there are no async elements\n\n\t\tasync_callback_gate();\n\n\t}\n\n}\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.TextureLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nTHREE.TextureLoader.prototype = {\n\n\tconstructor: THREE.TextureLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.ImageLoader( scope.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.load( url, function ( image ) {\n\n\t\t\tvar texture = new THREE.Texture( image );\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t} );\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t}\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Material = function () {\n\n\tthis.id = THREE.MaterialIdCount ++;\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\n\tthis.side = THREE.FrontSide;\n\n\tthis.opacity = 1;\n\tthis.transparent = false;\n\n\tthis.blending = THREE.NormalBlending;\n\n\tthis.blendSrc = THREE.SrcAlphaFactor;\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\n\tthis.blendEquation = THREE.AddEquation;\n\n\tthis.depthTest = true;\n\tthis.depthWrite = true;\n\n\tthis.polygonOffset = false;\n\tthis.polygonOffsetFactor = 0;\n\tthis.polygonOffsetUnits = 0;\n\n\tthis.alphaTest = 0;\n\n\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\n\n\tthis.visible = true;\n\n\tthis.needsUpdate = true;\n\n};\n\nTHREE.Material.prototype = {\n\n\tconstructor: THREE.Material,\n\n\tsetValues: function ( values ) {\n\n\t\tif ( values === undefined ) return;\n\n\t\tfor ( var key in values ) {\n\n\t\t\tvar newValue = values[ key ];\n\n\t\t\tif ( newValue === undefined ) {\n\n\t\t\t\tconsole.warn( 'THREE.Material: \\'' + key + '\\' parameter is undefined.' );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( key in this ) {\n\n\t\t\t\tvar currentValue = this[ key ];\n\n\t\t\t\tif ( currentValue instanceof THREE.Color ) {\n\n\t\t\t\t\tcurrentValue.set( newValue );\n\n\t\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\n\n\t\t\t\t\tcurrentValue.copy( newValue );\n\n\t\t\t\t} else if ( key == 'overdraw') {\n\n\t\t\t\t\t// ensure overdraw is backwards-compatable with legacy boolean type\n\t\t\t\t\tthis[ key ] = Number(newValue);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis[ key ] = newValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\tclone: function ( material ) {\n\n\t\tif ( material === undefined ) material = new THREE.Material();\n\n\t\tmaterial.name = this.name;\n\n\t\tmaterial.side = this.side;\n\n\t\tmaterial.opacity = this.opacity;\n\t\tmaterial.transparent = this.transparent;\n\n\t\tmaterial.blending = this.blending;\n\n\t\tmaterial.blendSrc = this.blendSrc;\n\t\tmaterial.blendDst = this.blendDst;\n\t\tmaterial.blendEquation = this.blendEquation;\n\n\t\tmaterial.depthTest = this.depthTest;\n\t\tmaterial.depthWrite = this.depthWrite;\n\n\t\tmaterial.polygonOffset = this.polygonOffset;\n\t\tmaterial.polygonOffsetFactor = this.polygonOffsetFactor;\n\t\tmaterial.polygonOffsetUnits = this.polygonOffsetUnits;\n\n\t\tmaterial.alphaTest = this.alphaTest;\n\n\t\tmaterial.overdraw = this.overdraw;\n\n\t\tmaterial.visible = this.visible;\n\n\t\treturn material;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nTHREE.EventDispatcher.prototype.apply( THREE.Material.prototype );\n\nTHREE.MaterialIdCount = 0;\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  linewidth: <float>,\n *  linecap: \"round\",\n *  linejoin: \"round\",\n *\n *  vertexColors: <bool>\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.LineBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\tthis.linecap = 'round';\n\tthis.linejoin = 'round';\n\n\tthis.vertexColors = false;\n\n\tthis.fog = true;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.LineBasicMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.LineBasicMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\n\tmaterial.linewidth = this.linewidth;\n\tmaterial.linecap = this.linecap;\n\tmaterial.linejoin = this.linejoin;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.fog = this.fog;\n\n\treturn material;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  linewidth: <float>,\n *\n *  scale: <float>,\n *  dashSize: <float>,\n *  gapSize: <float>,\n *\n *  vertexColors: <bool>\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.LineDashedMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.linewidth = 1;\n\n\tthis.scale = 1;\n\tthis.dashSize = 3;\n\tthis.gapSize = 1;\n\n\tthis.vertexColors = false;\n\n\tthis.fog = true;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.LineDashedMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.LineDashedMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\n\tmaterial.linewidth = this.linewidth;\n\n\tmaterial.scale = this.scale;\n\tmaterial.dashSize = this.dashSize;\n\tmaterial.gapSize = this.gapSize;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.fog = this.fog;\n\n\treturn material;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.MeshBasicMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.fog = true;\n\n\tthis.shading = THREE.SmoothShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.vertexColors = THREE.NoColors;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshBasicMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshBasicMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\n\tmaterial.map = this.map;\n\n\tmaterial.lightMap = this.lightMap;\n\n\tmaterial.specularMap = this.specularMap;\n\n\tmaterial.envMap = this.envMap;\n\tmaterial.combine = this.combine;\n\tmaterial.reflectivity = this.reflectivity;\n\tmaterial.refractionRatio = this.refractionRatio;\n\n\tmaterial.fog = this.fog;\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.skinning = this.skinning;\n\tmaterial.morphTargets = this.morphTargets;\n\n\treturn material;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  ambient: <hex>,\n *  emissive: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *\tfog: <bool>\n * }\n */\n\nTHREE.MeshLambertMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.ambient = new THREE.Color( 0xffffff );\n\tthis.emissive = new THREE.Color( 0x000000 );\n\n\tthis.wrapAround = false;\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.fog = true;\n\n\tthis.shading = THREE.SmoothShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.vertexColors = THREE.NoColors;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshLambertMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshLambertMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\tmaterial.ambient.copy( this.ambient );\n\tmaterial.emissive.copy( this.emissive );\n\n\tmaterial.wrapAround = this.wrapAround;\n\tmaterial.wrapRGB.copy( this.wrapRGB );\n\n\tmaterial.map = this.map;\n\n\tmaterial.lightMap = this.lightMap;\n\n\tmaterial.specularMap = this.specularMap;\n\n\tmaterial.envMap = this.envMap;\n\tmaterial.combine = this.combine;\n\tmaterial.reflectivity = this.reflectivity;\n\tmaterial.refractionRatio = this.refractionRatio;\n\n\tmaterial.fog = this.fog;\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.skinning = this.skinning;\n\tmaterial.morphTargets = this.morphTargets;\n\tmaterial.morphNormals = this.morphNormals;\n\n\treturn material;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  ambient: <hex>,\n *  emissive: <hex>,\n *  specular: <hex>,\n *  shininess: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalScale: <Vector2>,\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *\tfog: <bool>\n * }\n */\n\nTHREE.MeshPhongMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\n\tthis.ambient = new THREE.Color( 0xffffff );\n\tthis.emissive = new THREE.Color( 0x000000 );\n\tthis.specular = new THREE.Color( 0x111111 );\n\tthis.shininess = 30;\n\n\tthis.metal = false;\n\tthis.perPixel = true;\n\n\tthis.wrapAround = false;\n\tthis.wrapRGB = new THREE.Vector3( 1, 1, 1 );\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\n\n\tthis.specularMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = THREE.MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.fog = true;\n\n\tthis.shading = THREE.SmoothShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.vertexColors = THREE.NoColors;\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshPhongMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshPhongMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\tmaterial.ambient.copy( this.ambient );\n\tmaterial.emissive.copy( this.emissive );\n\tmaterial.specular.copy( this.specular );\n\tmaterial.shininess = this.shininess;\n\n\tmaterial.metal = this.metal;\n\tmaterial.perPixel = this.perPixel;\n\n\tmaterial.wrapAround = this.wrapAround;\n\tmaterial.wrapRGB.copy( this.wrapRGB );\n\n\tmaterial.map = this.map;\n\n\tmaterial.lightMap = this.lightMap;\n\n\tmaterial.bumpMap = this.bumpMap;\n\tmaterial.bumpScale = this.bumpScale;\n\n\tmaterial.normalMap = this.normalMap;\n\tmaterial.normalScale.copy( this.normalScale );\n\n\tmaterial.specularMap = this.specularMap;\n\n\tmaterial.envMap = this.envMap;\n\tmaterial.combine = this.combine;\n\tmaterial.reflectivity = this.reflectivity;\n\tmaterial.refractionRatio = this.refractionRatio;\n\n\tmaterial.fog = this.fog;\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\tmaterial.wireframeLinecap = this.wireframeLinecap;\n\tmaterial.wireframeLinejoin = this.wireframeLinejoin;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.skinning = this.skinning;\n\tmaterial.morphTargets = this.morphTargets;\n\tmaterial.morphNormals = this.morphNormals;\n\n\treturn material;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  opacity: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshDepthMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshDepthMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshDepthMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\n\treturn material;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  opacity: <float>,\n *\n *  shading: THREE.FlatShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>\n * }\n */\n\nTHREE.MeshNormalMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this, parameters );\n\n\tthis.shading = THREE.FlatShading;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.morphTargets = false;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.MeshNormalMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshNormalMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\n\treturn material;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.MeshFaceMaterial = function ( materials ) {\n\n\tthis.materials = materials instanceof Array ? materials : [];\n\n};\n\nTHREE.MeshFaceMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.MeshFaceMaterial();\n\n\tfor ( var i = 0; i < this.materials.length; i ++ ) {\n\n\t\tmaterial.materials.push( this.materials[ i ].clone() );\n\n\t}\n\n\treturn material;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  vertexColors: <bool>,\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.ParticleSystemMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff );\n\n\tthis.map = null;\n\n\tthis.size = 1;\n\tthis.sizeAttenuation = true;\n\n\tthis.vertexColors = false;\n\n\tthis.fog = true;\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.ParticleSystemMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.ParticleSystemMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.ParticleSystemMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\n\tmaterial.map = this.map;\n\n\tmaterial.size = this.size;\n\tmaterial.sizeAttenuation = this.sizeAttenuation;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.fog = this.fog;\n\n\treturn material;\n\n};\n\n// backwards compatibility\n\nTHREE.ParticleBasicMaterial = THREE.ParticleSystemMaterial;\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  fragmentShader: <string>,\n *  vertexShader: <string>,\n *\n *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\n *\n *  defines: { \"label\" : \"value\" },\n *\n *  shading: THREE.SmoothShading,\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  lights: <bool>,\n *\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>,\n *\n *\tfog: <bool>\n * }\n */\n\nTHREE.ShaderMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.fragmentShader = \"void main() {}\";\n\tthis.vertexShader = \"void main() {}\";\n\tthis.uniforms = {};\n\tthis.defines = {};\n\tthis.attributes = null;\n\n\tthis.shading = THREE.SmoothShading;\n\n\tthis.linewidth = 1;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\n\tthis.fog = false; // set to use scene fog\n\n\tthis.lights = false; // set to use scene lights\n\n\tthis.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\n\n\tthis.skinning = false; // set to use skinning attribute streams\n\n\tthis.morphTargets = false; // set to use morph targets\n\tthis.morphNormals = false; // set to use morph normals\n\n\t// When rendered geometry doesn't include these attributes but the material does,\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\n\tthis.defaultAttributeValues = {\n\t\t\"color\" : [ 1, 1, 1],\n\t\t\"uv\" : [ 0, 0 ],\n\t\t\"uv2\" : [ 0, 0 ]\n\t};\n\n\t// By default, bind position to attribute index 0. In WebGL, attribute 0\n\t// should always be used to avoid potentially expensive emulation.\n\tthis.index0AttributeName = \"position\";\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.ShaderMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.ShaderMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.fragmentShader = this.fragmentShader;\n\tmaterial.vertexShader = this.vertexShader;\n\n\tmaterial.uniforms = THREE.UniformsUtils.clone( this.uniforms );\n\n\tmaterial.attributes = this.attributes;\n\tmaterial.defines = this.defines;\n\n\tmaterial.shading = this.shading;\n\n\tmaterial.wireframe = this.wireframe;\n\tmaterial.wireframeLinewidth = this.wireframeLinewidth;\n\n\tmaterial.fog = this.fog;\n\n\tmaterial.lights = this.lights;\n\n\tmaterial.vertexColors = this.vertexColors;\n\n\tmaterial.skinning = this.skinning;\n\n\tmaterial.morphTargets = this.morphTargets;\n\tmaterial.morphNormals = this.morphNormals;\n\n\treturn material;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *\n *  blending: THREE.NormalBlending,\n *  depthTest: <bool>,\n *  depthWrite: <bool>,\n *\n *\tuvOffset: new THREE.Vector2(),\n *\tuvScale: new THREE.Vector2(),\n *\n *  fog: <bool>\n * }\n */\n\nTHREE.SpriteMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\t// defaults\n\n\tthis.color = new THREE.Color( 0xffffff );\n\tthis.map = null;\n\n\tthis.rotation = 0;\n\n\tthis.fog = false;\n\n\t// set parameters\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.SpriteMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.SpriteMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\tmaterial.map = this.map;\n\n\tmaterial.rotation = this.rotation;\n\n\tmaterial.fog = this.fog;\n\n\treturn material;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n *\n * parameters = {\n *  color: <hex>,\n *  program: <function>,\n *  opacity: <float>,\n *  blending: THREE.NormalBlending\n * }\n */\n\nTHREE.SpriteCanvasMaterial = function ( parameters ) {\n\n\tTHREE.Material.call( this );\n\n\tthis.color = new THREE.Color( 0xffffff );\n\tthis.program = function ( context, color ) {};\n\n\tthis.setValues( parameters );\n\n};\n\nTHREE.SpriteCanvasMaterial.prototype = Object.create( THREE.Material.prototype );\n\nTHREE.SpriteCanvasMaterial.prototype.clone = function () {\n\n\tvar material = new THREE.SpriteCanvasMaterial();\n\n\tTHREE.Material.prototype.clone.call( this, material );\n\n\tmaterial.color.copy( this.color );\n\tmaterial.program = this.program;\n\n\treturn material;\n\n};\n\n// backwards compatibility\n\nTHREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial;\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tthis.id = THREE.TextureIdCount ++;\n\tthis.uuid = THREE.Math.generateUUID();\n\n\tthis.name = '';\n\n\tthis.image = image;\n\tthis.mipmaps = [];\n\n\tthis.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();\n\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\n\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\n\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\n\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\n\n\tthis.offset = new THREE.Vector2( 0, 0 );\n\tthis.repeat = new THREE.Vector2( 1, 1 );\n\n\tthis.generateMipmaps = true;\n\tthis.premultiplyAlpha = false;\n\tthis.flipY = true;\n\tthis.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\n\n\tthis._needsUpdate = false;\n\tthis.onUpdate = null;\n\n};\n\nTHREE.Texture.prototype = {\n\n\tconstructor: THREE.Texture,\n\n\tget needsUpdate () {\n\n\t\treturn this._needsUpdate;\n\n\t},\n\n\tset needsUpdate ( value ) {\n\n\t\tif ( value === true ) this.update();\n\n\t\tthis._needsUpdate = value;\n\n\t},\n\n\tclone: function ( texture ) {\n\n\t\tif ( texture === undefined ) texture = new THREE.Texture();\n\n\t\ttexture.image = this.image;\n\t\ttexture.mipmaps = this.mipmaps.slice(0);\n\n\t\ttexture.mapping = this.mapping;\n\n\t\ttexture.wrapS = this.wrapS;\n\t\ttexture.wrapT = this.wrapT;\n\n\t\ttexture.magFilter = this.magFilter;\n\t\ttexture.minFilter = this.minFilter;\n\n\t\ttexture.anisotropy = this.anisotropy;\n\n\t\ttexture.format = this.format;\n\t\ttexture.type = this.type;\n\n\t\ttexture.offset.copy( this.offset );\n\t\ttexture.repeat.copy( this.repeat );\n\n\t\ttexture.generateMipmaps = this.generateMipmaps;\n\t\ttexture.premultiplyAlpha = this.premultiplyAlpha;\n\t\ttexture.flipY = this.flipY;\n\t\ttexture.unpackAlignment = this.unpackAlignment;\n\n\t\treturn texture;\n\n\t},\n\n\tupdate: function () {\n\n\t\tthis.dispatchEvent( { type: 'update' } );\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nTHREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );\n\nTHREE.TextureIdCount = 0;\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.image = { width: width, height: height };\n\tthis.mipmaps = mipmaps;\n\n\tthis.generateMipmaps = false; // WebGL currently can't generate mipmaps for compressed textures, they must be embedded in DDS file\n\n};\n\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\n\nTHREE.CompressedTexture.prototype.clone = function () {\n\n\tvar texture = new THREE.CompressedTexture();\n\n\tTHREE.Texture.prototype.clone.call( this, texture );\n\n\treturn texture;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\n\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.image = { data: data, width: width, height: height };\n\n};\n\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\n\nTHREE.DataTexture.prototype.clone = function () {\n\n\tvar texture = new THREE.DataTexture();\n\n\tTHREE.Texture.prototype.clone.call( this, texture );\n\n\treturn texture;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ParticleSystem = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\n\tthis.material = material !== undefined ? material : new THREE.ParticleSystemMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.sortParticles = false;\n\tthis.frustumCulled = false;\n\n};\n\nTHREE.ParticleSystem.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.ParticleSystem.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.ParticleSystem( this.geometry, this.material );\n\n\tobject.sortParticles = this.sortParticles;\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Line = function ( geometry, material, type ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\n\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.type = ( type !== undefined ) ? type : THREE.LineStrip;\n\n};\n\nTHREE.LineStrip = 0;\nTHREE.LinePieces = 1;\n\nTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Line.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.type );\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author jonobr1 / http://jonobr1.com/\n */\n\nTHREE.Mesh = function ( geometry, material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\n\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\n\n\tthis.updateMorphTargets();\n\n};\n\nTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Mesh.prototype.updateMorphTargets = function () {\n\n\tif ( this.geometry.morphTargets.length > 0 ) {\n\n\t\tthis.morphTargetBase = -1;\n\t\tthis.morphTargetForcedOrder = [];\n\t\tthis.morphTargetInfluences = [];\n\t\tthis.morphTargetDictionary = {};\n\n\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\n\n\t\t\tthis.morphTargetInfluences.push( 0 );\n\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\n\n\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\n\n\t\treturn this.morphTargetDictionary[ name ];\n\n\t}\n\n\tconsole.log( \"THREE.Mesh.getMorphTargetIndexByName: morph target \" + name + \" does not exist. Returning 0.\" );\n\n\treturn 0;\n\n};\n\nTHREE.Mesh.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Bone = function( belongsToSkin ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.skin = belongsToSkin;\n\tthis.skinMatrix = new THREE.Matrix4();\n\n};\n\nTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Bone.prototype.update = function ( parentSkinMatrix, forceUpdate ) {\n\n\t// update local\n\n\tif ( this.matrixAutoUpdate ) {\n\n\t\tforceUpdate |= this.updateMatrix();\n\n\t}\n\n\t// update skin matrix\n\n\tif ( forceUpdate || this.matrixWorldNeedsUpdate ) {\n\n\t\tif( parentSkinMatrix ) {\n\n\t\t\tthis.skinMatrix.multiplyMatrices( parentSkinMatrix, this.matrix );\n\n\t\t} else {\n\n\t\t\tthis.skinMatrix.copy( this.matrix );\n\n\t\t}\n\n\t\tthis.matrixWorldNeedsUpdate = false;\n\t\tforceUpdate = true;\n\n\t}\n\n\t// update children\n\n\tvar child, i, l = this.children.length;\n\n\tfor ( i = 0; i < l; i ++ ) {\n\n\t\tthis.children[ i ].update( this.skinMatrix, forceUpdate );\n\n\t}\n\n};\n\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\t//\n\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\n\n\t// init bones\n\n\tthis.identityMatrix = new THREE.Matrix4();\n\n\tthis.bones = [];\n\tthis.boneMatrices = [];\n\n\tvar b, bone, gbone, p, q, s;\n\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\n\n\t\tfor ( b = 0; b < this.geometry.bones.length; b ++ ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\n\t\t\tp = gbone.pos;\n\t\t\tq = gbone.rotq;\n\t\t\ts = gbone.scl;\n\n\t\t\tbone = this.addBone();\n\n\t\t\tbone.name = gbone.name;\n\t\t\tbone.position.set( p[0], p[1], p[2] );\n\t\t\tbone.quaternion.set( q[0], q[1], q[2], q[3] );\n\t\t\n\t\t\tif ( s !== undefined ) {\n\n\t\t\t\tbone.scale.set( s[0], s[1], s[2] );\n\n\t\t\t} else {\n\n\t\t\t\tbone.scale.set( 1, 1, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( b = 0; b < this.bones.length; b ++ ) {\n\n\t\t\tgbone = this.geometry.bones[ b ];\n\t\t\tbone = this.bones[ b ];\n\n\t\t\tif ( gbone.parent === -1 ) {\n\n\t\t\t\tthis.add( bone );\n\n\t\t\t} else {\n\n\t\t\t\tthis.bones[ gbone.parent ].add( bone );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tvar nBones = this.bones.length;\n\n\t\tif ( this.useVertexTexture ) {\n\n\t\t\t// layout (1 matrix = 4 pixels)\n\t\t\t//\tRGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\n\t\t\t//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)\n\t\t\t//  \t 16x16 pixel texture max   64 bones (16 * 16 / 4)\n\t\t\t//  \t 32x32 pixel texture max  256 bones (32 * 32 / 4)\n\t\t\t//  \t 64x64 pixel texture max 1024 bones (64 * 64 / 4)\n\n\t\t\tvar size;\n\n\t\t\tif ( nBones > 256 )\n\t\t\t\tsize = 64;\n\t\t\telse if ( nBones > 64 )\n\t\t\t\tsize = 32;\n\t\t\telse if ( nBones > 16 )\n\t\t\t\tsize = 16;\n\t\t\telse\n\t\t\t\tsize = 8;\n\n\t\t\tthis.boneTextureWidth = size;\n\t\t\tthis.boneTextureHeight = size;\n\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\n\t\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\n\t\t\tthis.boneTexture.minFilter = THREE.NearestFilter;\n\t\t\tthis.boneTexture.magFilter = THREE.NearestFilter;\n\t\t\tthis.boneTexture.generateMipmaps = false;\n\t\t\tthis.boneTexture.flipY = false;\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = new Float32Array( 16 * nBones );\n\n\t\t}\n\n\t\tthis.pose();\n\n\t}\n\n};\n\nTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\n\nTHREE.SkinnedMesh.prototype.addBone = function( bone ) {\n\n\tif ( bone === undefined ) {\n\n\t\tbone = new THREE.Bone( this );\n\n\t}\n\n\tthis.bones.push( bone );\n\n\treturn bone;\n\n};\n\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function () {\n\n\tvar offsetMatrix = new THREE.Matrix4();\n\n\treturn function ( force ) {\n\n\t\tthis.matrixAutoUpdate && this.updateMatrix();\n\n\t\t// update matrixWorld\n\n\t\tif ( this.matrixWorldNeedsUpdate || force ) {\n\n\t\t\tif ( this.parent ) {\n\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false;\n\n\t\t\tforce = true;\n\n\t\t}\n\n\t\t// update children\n\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\n\n\t\t\tvar child = this.children[ i ];\n\n\t\t\tif ( child instanceof THREE.Bone ) {\n\n\t\t\t\tchild.update( this.identityMatrix, false );\n\n\t\t\t} else {\n\n\t\t\t\tchild.updateMatrixWorld( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// make a snapshot of the bones' rest position\n\n\t\tif ( this.boneInverses == undefined ) {\n\n\t\t\tthis.boneInverses = [];\n\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t\tvar inverse = new THREE.Matrix4();\n\n\t\t\t\tinverse.getInverse( this.bones[ b ].skinMatrix );\n\n\t\t\t\tthis.boneInverses.push( inverse );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// flatten bone matrices to array\n\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\n\n\t\t\t// compute the offset between the current and the original transform;\n\n\t\t\t// TODO: we could get rid of this multiplication step if the skinMatrix\n\t\t\t// was already representing the offset; however, this requires some\n\t\t\t// major changes to the animation system\n\n\t\t\toffsetMatrix.multiplyMatrices( this.bones[ b ].skinMatrix, this.boneInverses[ b ] );\n\t\t\toffsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\n\n\t\t}\n\n\t\tif ( this.useVertexTexture ) {\n\n\t\t\tthis.boneTexture.needsUpdate = true;\n\n\t\t}\n\n\t};\n\n}();\n\nTHREE.SkinnedMesh.prototype.pose = function () {\n\n\tthis.updateMatrixWorld( true );\n\n\tthis.normalizeSkinWeights();\n\n};\n\nTHREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\n\n\tif ( this.geometry instanceof THREE.Geometry ) {\n\n\t\tfor ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {\n\n\t\t\tvar sw = this.geometry.skinWeights[ i ];\n\n\t\t\tvar scale = 1.0 / sw.lengthManhattan();\n\n\t\t\tif ( scale !== Infinity ) {\n\n\t\t\t\tsw.multiplyScalar( scale );\n\n\t\t\t} else {\n\n\t\t\t\tsw.set( 1 ); // this will be normalized by the shader anyway\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// skinning weights assumed to be normalized for THREE.BufferGeometry\n\n\t}\n\n};\n\nTHREE.SkinnedMesh.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) {\n\n\t\tobject = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );\n\n\t}\n\n\tTHREE.Mesh.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.MorphAnimMesh = function ( geometry, material ) {\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\t// API\n\n\tthis.duration = 1000; // milliseconds\n\tthis.mirroredLoop = false;\n\tthis.time = 0;\n\n\t// internals\n\n\tthis.lastKeyframe = 0;\n\tthis.currentKeyframe = 0;\n\n\tthis.direction = 1;\n\tthis.directionBackwards = false;\n\n\tthis.setFrameRange( 0, this.geometry.morphTargets.length - 1 );\n\n};\n\nTHREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );\n\nTHREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {\n\n\tthis.startKeyframe = start;\n\tthis.endKeyframe = end;\n\n\tthis.length = this.endKeyframe - this.startKeyframe + 1;\n\n};\n\nTHREE.MorphAnimMesh.prototype.setDirectionForward = function () {\n\n\tthis.direction = 1;\n\tthis.directionBackwards = false;\n\n};\n\nTHREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\n\n\tthis.direction = -1;\n\tthis.directionBackwards = true;\n\n};\n\nTHREE.MorphAnimMesh.prototype.parseAnimations = function () {\n\n\tvar geometry = this.geometry;\n\n\tif ( ! geometry.animations ) geometry.animations = {};\n\n\tvar firstAnimation, animations = geometry.animations;\n\n\tvar pattern = /([a-z]+)(\\d+)/;\n\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\n\n\t\tvar morph = geometry.morphTargets[ i ];\n\t\tvar parts = morph.name.match( pattern );\n\n\t\tif ( parts && parts.length > 1 ) {\n\n\t\t\tvar label = parts[ 1 ];\n\t\t\tvar num = parts[ 2 ];\n\n\t\t\tif ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: -Infinity };\n\n\t\t\tvar animation = animations[ label ];\n\n\t\t\tif ( i < animation.start ) animation.start = i;\n\t\t\tif ( i > animation.end ) animation.end = i;\n\n\t\t\tif ( ! firstAnimation ) firstAnimation = label;\n\n\t\t}\n\n\t}\n\n\tgeometry.firstAnimation = firstAnimation;\n\n};\n\nTHREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {\n\n\tif ( ! this.geometry.animations ) this.geometry.animations = {};\n\n\tthis.geometry.animations[ label ] = { start: start, end: end };\n\n};\n\nTHREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {\n\n\tvar animation = this.geometry.animations[ label ];\n\n\tif ( animation ) {\n\n\t\tthis.setFrameRange( animation.start, animation.end );\n\t\tthis.duration = 1000 * ( ( animation.end - animation.start ) / fps );\n\t\tthis.time = 0;\n\n\t} else {\n\n\t\tconsole.warn( \"animation[\" + label + \"] undefined\" );\n\n\t}\n\n};\n\nTHREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {\n\n\tvar frameTime = this.duration / this.length;\n\n\tthis.time += this.direction * delta;\n\n\tif ( this.mirroredLoop ) {\n\n\t\tif ( this.time > this.duration || this.time < 0 ) {\n\n\t\t\tthis.direction *= -1;\n\n\t\t\tif ( this.time > this.duration ) {\n\n\t\t\t\tthis.time = this.duration;\n\t\t\t\tthis.directionBackwards = true;\n\n\t\t\t}\n\n\t\t\tif ( this.time < 0 ) {\n\n\t\t\t\tthis.time = 0;\n\t\t\t\tthis.directionBackwards = false;\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tthis.time = this.time % this.duration;\n\n\t\tif ( this.time < 0 ) this.time += this.duration;\n\n\t}\n\n\tvar keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );\n\n\tif ( keyframe !== this.currentKeyframe ) {\n\n\t\tthis.morphTargetInfluences[ this.lastKeyframe ] = 0;\n\t\tthis.morphTargetInfluences[ this.currentKeyframe ] = 1;\n\n\t\tthis.morphTargetInfluences[ keyframe ] = 0;\n\n\t\tthis.lastKeyframe = this.currentKeyframe;\n\t\tthis.currentKeyframe = keyframe;\n\n\t}\n\n\tvar mix = ( this.time % frameTime ) / frameTime;\n\n\tif ( this.directionBackwards ) {\n\n\t\tmix = 1 - mix;\n\n\t}\n\n\tthis.morphTargetInfluences[ this.currentKeyframe ] = mix;\n\tthis.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;\n\n};\n\nTHREE.MorphAnimMesh.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );\n\n\tobject.duration = this.duration;\n\tobject.mirroredLoop = this.mirroredLoop;\n\tobject.time = this.time;\n\n\tobject.lastKeyframe = this.lastKeyframe;\n\tobject.currentKeyframe = this.currentKeyframe;\n\n\tobject.direction = this.direction;\n\tobject.directionBackwards = this.directionBackwards;\n\n\tTHREE.Mesh.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.LOD = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.objects = [];\n\n};\n\n\nTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.LOD.prototype.addLevel = function ( object, distance ) {\n\n\tif ( distance === undefined ) distance = 0;\n\n\tdistance = Math.abs( distance );\n\n\tfor ( var l = 0; l < this.objects.length; l ++ ) {\n\n\t\tif ( distance < this.objects[ l ].distance ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tthis.objects.splice( l, 0, { distance: distance, object: object } );\n\tthis.add( object );\n\n};\n\nTHREE.LOD.prototype.getObjectForDistance = function ( distance ) {\n\n\tfor ( var i = 1, l = this.objects.length; i < l; i ++ ) {\n\n\t\tif ( distance < this.objects[ i ].distance ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\treturn this.objects[ i - 1 ].object;\n\n};\n\nTHREE.LOD.prototype.update = function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\n\treturn function ( camera ) {\n\n\t\tif ( this.objects.length > 1 ) {\n\n\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\n\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\n\n\t\t\tvar distance = v1.distanceTo( v2 );\n\n\t\t\tthis.objects[ 0 ].object.visible = true;\n\n\t\t\tfor ( var i = 1, l = this.objects.length; i < l; i ++ ) {\n\n\t\t\t\tif ( distance >= this.objects[ i ].distance ) {\n\n\t\t\t\t\tthis.objects[ i - 1 ].object.visible = false;\n\t\t\t\t\tthis.objects[ i     ].object.visible = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor( ; i < l; i ++ ) {\n\n\t\t\t\tthis.objects[ i ].object.visible = false;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n}();\n\nTHREE.LOD.prototype.clone = function () {\n\n\t// TODO\n\n};\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Sprite = function ( material ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\n\n};\n\nTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\n\n/*\n * Custom update matrix\n */\n\nTHREE.Sprite.prototype.updateMatrix = function () {\n\n\tthis.matrix.compose( this.position, this.quaternion, this.scale );\n\n\tthis.matrixWorldNeedsUpdate = true;\n\n};\n\nTHREE.Sprite.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Sprite( this.material );\n\n\tTHREE.Object3D.prototype.clone.call( this, object );\n\n\treturn object;\n\n};\n\n// Backwards compatibility\n\nTHREE.Particle = THREE.Sprite;\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Scene = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.fog = null;\n\tthis.overrideMaterial = null;\n\n\tthis.autoUpdate = true; // checked by the renderer\n\tthis.matrixAutoUpdate = false;\n\n\tthis.__lights = [];\n\n\tthis.__objectsAdded = [];\n\tthis.__objectsRemoved = [];\n\n};\n\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.Scene.prototype.__addObject = function ( object ) {\n\n\tif ( object instanceof THREE.Light ) {\n\n\t\tif ( this.__lights.indexOf( object ) === - 1 ) {\n\n\t\t\tthis.__lights.push( object );\n\n\t\t}\n\n\t\tif ( object.target && object.target.parent === undefined ) {\n\n\t\t\tthis.add( object.target );\n\n\t\t}\n\n\t} else if ( !( object instanceof THREE.Camera || object instanceof THREE.Bone ) ) {\n\n\t\tthis.__objectsAdded.push( object );\n\n\t\t// check if previously removed\n\n\t\tvar i = this.__objectsRemoved.indexOf( object );\n\n\t\tif ( i !== -1 ) {\n\n\t\t\tthis.__objectsRemoved.splice( i, 1 );\n\n\t\t}\n\n\t}\n\n\tthis.dispatchEvent( { type: 'objectAdded', object: object } );\n\tobject.dispatchEvent( { type: 'addedToScene', scene: this } );\n\n\tfor ( var c = 0; c < object.children.length; c ++ ) {\n\n\t\tthis.__addObject( object.children[ c ] );\n\n\t}\n\n};\n\nTHREE.Scene.prototype.__removeObject = function ( object ) {\n\n\tif ( object instanceof THREE.Light ) {\n\n\t\tvar i = this.__lights.indexOf( object );\n\n\t\tif ( i !== -1 ) {\n\n\t\t\tthis.__lights.splice( i, 1 );\n\n\t\t}\n\n\t\tif ( object.shadowCascadeArray ) {\n\n\t\t\tfor ( var x = 0; x < object.shadowCascadeArray.length; x ++ ) {\n\n\t\t\t\tthis.__removeObject( object.shadowCascadeArray[ x ] );\n\n\t\t\t}\n\n\t\t}\n\n\t} else if ( !( object instanceof THREE.Camera ) ) {\n\n\t\tthis.__objectsRemoved.push( object );\n\n\t\t// check if previously added\n\n\t\tvar i = this.__objectsAdded.indexOf( object );\n\n\t\tif ( i !== -1 ) {\n\n\t\t\tthis.__objectsAdded.splice( i, 1 );\n\n\t\t}\n\n\t}\n\n\tthis.dispatchEvent( { type: 'objectRemoved', object: object } );\n\tobject.dispatchEvent( { type: 'removedFromScene', scene: this } );\n\n\tfor ( var c = 0; c < object.children.length; c ++ ) {\n\n\t\tthis.__removeObject( object.children[ c ] );\n\n\t}\n\n};\n\nTHREE.Scene.prototype.clone = function ( object ) {\n\n\tif ( object === undefined ) object = new THREE.Scene();\n\n\tTHREE.Object3D.prototype.clone.call(this, object);\n\n\tif ( this.fog !== null ) object.fog = this.fog.clone();\n\tif ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();\n\n\tobject.autoUpdate = this.autoUpdate;\n\tobject.matrixAutoUpdate = this.matrixAutoUpdate;\n\n\treturn object;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Fog = function ( hex, near, far ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( hex );\n\n\tthis.near = ( near !== undefined ) ? near : 1;\n\tthis.far = ( far !== undefined ) ? far : 1000;\n\n};\n\nTHREE.Fog.prototype.clone = function () {\n\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.FogExp2 = function ( hex, density ) {\n\n\tthis.name = '';\n\n\tthis.color = new THREE.Color( hex );\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\n\n};\n\nTHREE.FogExp2.prototype.clone = function () {\n\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CanvasRenderer = function ( parameters ) {\n\n\tconsole.log( 'THREE.CanvasRenderer', THREE.REVISION );\n\n\tvar smoothstep = THREE.Math.smoothstep;\n\n\tparameters = parameters || {};\n\n\tvar _this = this,\n\t_renderData, _elements, _lights,\n\t_projector = new THREE.Projector(),\n\n\t_canvas = parameters.canvas !== undefined\n\t\t\t? parameters.canvas\n\t\t\t: document.createElement( 'canvas' ),\n\n\t_canvasWidth = _canvas.width,\n\t_canvasHeight = _canvas.height,\n\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 ),\n\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 ),\n\t\n\t_context = _canvas.getContext( '2d' ),\n\n\t_clearColor = new THREE.Color( 0x000000 ),\n\t_clearAlpha = 0,\n\n\t_contextGlobalAlpha = 1,\n\t_contextGlobalCompositeOperation = 0,\n\t_contextStrokeStyle = null,\n\t_contextFillStyle = null,\n\t_contextLineWidth = null,\n\t_contextLineCap = null,\n\t_contextLineJoin = null,\n\t_contextDashSize = null,\n\t_contextGapSize = 0,\n\n\t_camera,\n\n\t_v1, _v2, _v3, _v4,\n\t_v5 = new THREE.RenderableVertex(),\n\t_v6 = new THREE.RenderableVertex(),\n\n\t_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,\n\t_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,\n\n\t_color = new THREE.Color(),\n\t_color1 = new THREE.Color(),\n\t_color2 = new THREE.Color(),\n\t_color3 = new THREE.Color(),\n\t_color4 = new THREE.Color(),\n\n\t_diffuseColor = new THREE.Color(),\n\t_emissiveColor = new THREE.Color(),\n\n\t_lightColor = new THREE.Color(),\n\n\t_patterns = {},\n\n\t_near, _far,\n\n\t_image, _uvs,\n\t_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,\n\n\t_clipBox = new THREE.Box2(),\n\t_clearBox = new THREE.Box2(),\n\t_elemBox = new THREE.Box2(),\n\n\t_ambientLight = new THREE.Color(),\n\t_directionalLights = new THREE.Color(),\n\t_pointLights = new THREE.Color(),\n\n\t_vector3 = new THREE.Vector3(), // Needed for PointLight\n\n\t_pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData,\n\t_gradientMap, _gradientMapContext, _gradientMapQuality = 16;\n\n\t_pixelMap = document.createElement( 'canvas' );\n\t_pixelMap.width = _pixelMap.height = 2;\n\n\t_pixelMapContext = _pixelMap.getContext( '2d' );\n\t_pixelMapContext.fillStyle = 'rgba(0,0,0,1)';\n\t_pixelMapContext.fillRect( 0, 0, 2, 2 );\n\n\t_pixelMapImage = _pixelMapContext.getImageData( 0, 0, 2, 2 );\n\t_pixelMapData = _pixelMapImage.data;\n\n\t_gradientMap = document.createElement( 'canvas' );\n\t_gradientMap.width = _gradientMap.height = _gradientMapQuality;\n\n\t_gradientMapContext = _gradientMap.getContext( '2d' );\n\t_gradientMapContext.translate( - _gradientMapQuality / 2, - _gradientMapQuality / 2 );\n\t_gradientMapContext.scale( _gradientMapQuality, _gradientMapQuality );\n\n\t_gradientMapQuality --; // Fix UVs\n\n\t// dash+gap fallbacks for Firefox and everything else\n\n\tif ( _context.setLineDash === undefined ) {\n\n\t\tif ( _context.mozDash !== undefined ) {\n\n\t\t\t_context.setLineDash = function ( values ) {\n\n\t\t\t\t_context.mozDash = values[ 0 ] !== null ? values : null;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_context.setLineDash = function () {}\n\n\t\t}\n\n\t}\n\n\tthis.domElement = _canvas;\n\n\tthis.devicePixelRatio = parameters.devicePixelRatio !== undefined\n\t\t\t\t? parameters.devicePixelRatio\n\t\t\t\t: self.devicePixelRatio !== undefined\n\t\t\t\t\t? self.devicePixelRatio\n\t\t\t\t\t: 1;\n\n\tthis.autoClear = true;\n\tthis.sortObjects = true;\n\tthis.sortElements = true;\n\n\tthis.info = {\n\n\t\trender: {\n\n\t\t\tvertices: 0,\n\t\t\tfaces: 0\n\n\t\t}\n\n\t}\n\n\t// WebGLRenderer compatibility\n\n\tthis.supportsVertexTextures = function () {};\n\tthis.setFaceCulling = function () {};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t_canvasWidth = width * this.devicePixelRatio;\n\t\t_canvasHeight = height * this.devicePixelRatio;\n\n\t\t_canvasWidthHalf = Math.floor( _canvasWidth / 2 );\n\t\t_canvasHeightHalf = Math.floor( _canvasHeight / 2 );\n\n\t\t_canvas.width = _canvasWidth;\n\t\t_canvas.height = _canvasHeight;\n\n\t\tif ( this.devicePixelRatio !== 1 && updateStyle !== false ) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\n\t\t}\n\n\t\t_clipBox.set(\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\n\t\t);\n\n\t\t_clearBox.set(\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\n\t\t);\n\n\t\t_contextGlobalAlpha = 1;\n\t\t_contextGlobalCompositeOperation = 0;\n\t\t_contextStrokeStyle = null;\n\t\t_contextFillStyle = null;\n\t\t_contextLineWidth = null;\n\t\t_contextLineCap = null;\n\t\t_contextLineJoin = null;\n\n\t};\n\n\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t_clearColor.set( color );\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\t_clearBox.set(\n\t\t\tnew THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),\n\t\t\tnew THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )\n\t\t);\n\n\t};\n\n\tthis.setClearColorHex = function ( hex, alpha ) {\n\n\t\tconsole.warn( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );\n\t\tthis.setClearColor( hex, alpha );\n\n\t};\n\n\tthis.getMaxAnisotropy = function () {\n\n\t\treturn 0;\n\n\t};\n\n\tthis.clear = function () {\n\n\t\t_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );\n\n\t\tif ( _clearBox.empty() === false ) {\n\n\t\t\t_clearBox.intersect( _clipBox );\n\t\t\t_clearBox.expandByScalar( 2 );\n\n\t\t\tif ( _clearAlpha < 1 ) {\n\n\t\t\t\t_context.clearRect(\n\t\t\t\t\t_clearBox.min.x | 0,\n\t\t\t\t\t_clearBox.min.y | 0,\n\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\n\t\t\t\t\t( _clearBox.max.y - _clearBox.min.y ) | 0\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tif ( _clearAlpha > 0 ) {\n\n\t\t\t\tsetBlending( THREE.NormalBlending );\n\t\t\t\tsetOpacity( 1 );\n\n\t\t\t\tsetFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearAlpha + ')' );\n\n\t\t\t\t_context.fillRect(\n\t\t\t\t\t_clearBox.min.x | 0,\n\t\t\t\t\t_clearBox.min.y | 0,\n\t\t\t\t\t( _clearBox.max.x - _clearBox.min.x ) | 0,\n\t\t\t\t\t( _clearBox.max.y - _clearBox.min.y ) | 0\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t_clearBox.makeEmpty();\n\n\t\t}\n\n\t};\n\n\t// compatibility\n\n\tthis.clearColor = function () {};\n\tthis.clearDepth = function () {};\n\tthis.clearStencil = function () {};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( camera instanceof THREE.Camera === false ) {\n\n\t\t\tconsole.error( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( this.autoClear === true ) this.clear();\n\n\t\t_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );\n\n\t\t_this.info.render.vertices = 0;\n\t\t_this.info.render.faces = 0;\n\n\t\t_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );\n\t\t_elements = _renderData.elements;\n\t\t_lights = _renderData.lights;\n\t\t_camera = camera;\n\n\t\t/* DEBUG\n\t\tsetFillStyle( 'rgba( 0, 255, 255, 0.5 )' );\n\t\t_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );\n\t\t*/\n\n\t\tcalculateLights();\n\n\t\tfor ( var e = 0, el = _elements.length; e < el; e++ ) {\n\n\t\t\tvar element = _elements[ e ];\n\n\t\t\tvar material = element.material;\n\n\t\t\tif ( material === undefined || material.visible === false ) continue;\n\n\t\t\t_elemBox.makeEmpty();\n\n\t\t\tif ( element instanceof THREE.RenderableSprite ) {\n\n\t\t\t\t_v1 = element;\n\t\t\t\t_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;\n\n\t\t\t\trenderSprite( _v1, element, material );\n\n\t\t\t} else if ( element instanceof THREE.RenderableLine ) {\n\n\t\t\t\t_v1 = element.v1; _v2 = element.v2;\n\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\n\n\t\t\t\t_elemBox.setFromPoints( [\n\t\t\t\t\t_v1.positionScreen,\n\t\t\t\t\t_v2.positionScreen\n\t\t\t\t] );\n\n\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === true ) {\n\n\t\t\t\t\trenderLine( _v1, _v2, element, material );\n\n\t\t\t\t}\n\n\t\t\t} else if ( element instanceof THREE.RenderableFace3 ) {\n\n\t\t\t\t_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;\n\n\t\t\t\tif ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;\n\t\t\t\tif ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;\n\t\t\t\tif ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;\n\n\t\t\t\t_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;\n\t\t\t\t_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;\n\n\t\t\t\tif ( material.overdraw > 0 ) {\n\n\t\t\t\t\texpand( _v1.positionScreen, _v2.positionScreen, material.overdraw );\n\t\t\t\t\texpand( _v2.positionScreen, _v3.positionScreen, material.overdraw );\n\t\t\t\t\texpand( _v3.positionScreen, _v1.positionScreen, material.overdraw );\n\n\t\t\t\t}\n\n\t\t\t\t_elemBox.setFromPoints( [\n\t\t\t\t\t_v1.positionScreen,\n\t\t\t\t\t_v2.positionScreen,\n\t\t\t\t\t_v3.positionScreen\n\t\t\t\t] );\n\n\t\t\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === true ) {\n\n\t\t\t\t\trenderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* DEBUG\n\t\t\tsetLineWidth( 1 );\n\t\t\tsetStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );\n\t\t\t_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );\n\t\t\t*/\n\n\t\t\t_clearBox.union( _elemBox );\n\n\t\t}\n\n\t\t/* DEBUG\n\t\tsetLineWidth( 1 );\n\t\tsetStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );\n\t\t_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );\n\t\t*/\n\n\t\t_context.setTransform( 1, 0, 0, 1, 0, 0 );\n\n\t};\n\n\t//\n\n\tfunction calculateLights() {\n\n\t\t_ambientLight.setRGB( 0, 0, 0 );\n\t\t_directionalLights.setRGB( 0, 0, 0 );\n\t\t_pointLights.setRGB( 0, 0, 0 );\n\n\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\n\n\t\t\tvar light = _lights[ l ];\n\t\t\tvar lightColor = light.color;\n\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\n\t\t\t\t_ambientLight.add( lightColor );\n\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\t// for sprites\n\n\t\t\t\t_directionalLights.add( lightColor );\n\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\t// for sprites\n\n\t\t\t\t_pointLights.add( lightColor );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction calculateLight( position, normal, color ) {\n\n\t\tfor ( var l = 0, ll = _lights.length; l < ll; l ++ ) {\n\n\t\t\tvar light = _lights[ l ];\n\n\t\t\t_lightColor.copy( light.color );\n\n\t\t\tif ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\tvar lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld ).normalize();\n\n\t\t\t\tvar amount = normal.dot( lightPosition );\n\n\t\t\t\tif ( amount <= 0 ) continue;\n\n\t\t\t\tamount *= light.intensity;\n\n\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\n\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tvar lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld );\n\n\t\t\t\tvar amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );\n\n\t\t\t\tif ( amount <= 0 ) continue;\n\n\t\t\t\tamount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );\n\n\t\t\t\tif ( amount == 0 ) continue;\n\n\t\t\t\tamount *= light.intensity;\n\n\t\t\t\tcolor.add( _lightColor.multiplyScalar( amount ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction renderSprite( v1, element, material ) {\n\n\t\tsetOpacity( material.opacity );\n\t\tsetBlending( material.blending );\n\n\t\tvar scaleX = element.scale.x * _canvasWidthHalf;\n\t\tvar scaleY = element.scale.y * _canvasHeightHalf;\n\n\t\tvar dist = 0.5 * Math.sqrt( scaleX * scaleX + scaleY * scaleY ); // allow for rotated sprite\n\t\t_elemBox.min.set( v1.x - dist, v1.y - dist );\n\t\t_elemBox.max.set( v1.x + dist, v1.y + dist );\n\n\t\tif ( _clipBox.isIntersectionBox( _elemBox ) === false ) {\n\n\t\t\t_elemBox.makeEmpty();\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( material instanceof THREE.SpriteMaterial ||\n\t\t\t material instanceof THREE.ParticleSystemMaterial ) { // Backwards compatibility\n\n\t\t\tvar texture = material.map;\n\n\t\t\tif ( texture !== null ) {\n\n\t\t\t\tif ( texture.hasEventListener( 'update', onTextureUpdate ) === false ) {\n\n\t\t\t\t\tif ( texture.image !== undefined && texture.image.width > 0 ) {\n\n\t\t\t\t\t\ttextureToPattern( texture );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.addEventListener( 'update', onTextureUpdate );\n\n\t\t\t\t}\n\n\t\t\t\tvar pattern = _patterns[ texture.id ];\n\n\t\t\t\tif ( pattern !== undefined ) {\n\n\t\t\t\t\tsetFillStyle( pattern );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetFillStyle( 'rgba( 0, 0, 0, 1 )' );\n\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tvar bitmap = texture.image;\n\n\t\t\t\tvar ox = bitmap.width * texture.offset.x;\n\t\t\t\tvar oy = bitmap.height * texture.offset.y;\n\n\t\t\t\tvar sx = bitmap.width * texture.repeat.x;\n\t\t\t\tvar sy = bitmap.height * texture.repeat.y;\n\n\t\t\t\tvar cx = scaleX / sx;\n\t\t\t\tvar cy = scaleY / sy;\n\n\t\t\t\t_context.save();\n\t\t\t\t_context.translate( v1.x, v1.y );\n\t\t\t\tif ( material.rotation !== 0 ) _context.rotate( material.rotation );\n\t\t\t\t_context.translate( - scaleX / 2, - scaleY / 2 );\n\t\t\t\t_context.scale( cx, cy );\n\t\t\t\t_context.translate( - ox, - oy );\n\t\t\t\t_context.fillRect( ox, oy, sx, sy );\n\t\t\t\t_context.restore();\n\n\t\t\t} else { // no texture\n\n\t\t\t\tsetFillStyle( material.color.getStyle() );\n\n\t\t\t\t_context.save();\n\t\t\t\t_context.translate( v1.x, v1.y );\n\t\t\t\tif ( material.rotation !== 0 ) _context.rotate( material.rotation );\n\t\t\t\t_context.scale( scaleX, - scaleY );\n\t\t\t\t_context.fillRect( - 0.5, - 0.5, 1, 1 );\n\t\t\t\t_context.restore();\n\n\t\t\t}\n\n\t\t} else if ( material instanceof THREE.SpriteCanvasMaterial ) {\n\n\t\t\tsetStrokeStyle( material.color.getStyle() );\n\t\t\tsetFillStyle( material.color.getStyle() );\n\n\t\t\t_context.save();\n\t\t\t_context.translate( v1.x, v1.y );\n\t\t\tif ( material.rotation !== 0 ) _context.rotate( material.rotation );\n\t\t\t_context.scale( scaleX, scaleY );\n\n\t\t\tmaterial.program( _context );\n\n\t\t\t_context.restore();\n\n\t\t}\n\n\t\t/* DEBUG\n\t\tsetStrokeStyle( 'rgb(255,255,0)' );\n\t\t_context.beginPath();\n\t\t_context.moveTo( v1.x - 10, v1.y );\n\t\t_context.lineTo( v1.x + 10, v1.y );\n\t\t_context.moveTo( v1.x, v1.y - 10 );\n\t\t_context.lineTo( v1.x, v1.y + 10 );\n\t\t_context.stroke();\n\t\t*/\n\n\t}\n\n\tfunction renderLine( v1, v2, element, material ) {\n\n\t\tsetOpacity( material.opacity );\n\t\tsetBlending( material.blending );\n\n\t\t_context.beginPath();\n\t\t_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );\n\t\t_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );\n\n\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\tsetLineWidth( material.linewidth );\n\t\t\tsetLineCap( material.linecap );\n\t\t\tsetLineJoin( material.linejoin );\n\n\t\t\tif ( material.vertexColors !== THREE.VertexColors ) {\n\n\t\t\t\tsetStrokeStyle( material.color.getStyle() );\n\n\t\t\t} else {\n\n\t\t\t\tvar colorStyle1 = element.vertexColors[0].getStyle();\n\t\t\t\tvar colorStyle2 = element.vertexColors[1].getStyle();\n\n\t\t\t\tif ( colorStyle1 === colorStyle2 ) {\n\n\t\t\t\t\tsetStrokeStyle( colorStyle1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\tvar grad = _context.createLinearGradient(\n\t\t\t\t\t\t\tv1.positionScreen.x,\n\t\t\t\t\t\t\tv1.positionScreen.y,\n\t\t\t\t\t\t\tv2.positionScreen.x,\n\t\t\t\t\t\t\tv2.positionScreen.y\n\t\t\t\t\t\t);\n\t\t\t\t\t\tgrad.addColorStop( 0, colorStyle1 );\n\t\t\t\t\t\tgrad.addColorStop( 1, colorStyle2 );\n\n\t\t\t\t\t} catch ( exception ) {\n\n\t\t\t\t\t\tgrad = colorStyle1;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsetStrokeStyle( grad );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_context.stroke();\n\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\n\n\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\n\t\t\tsetLineWidth( material.linewidth );\n\t\t\tsetLineCap( material.linecap );\n\t\t\tsetLineJoin( material.linejoin );\n\t\t\tsetStrokeStyle( material.color.getStyle() );\n\t\t\tsetDashAndGap( material.dashSize, material.gapSize );\n\n\t\t\t_context.stroke();\n\n\t\t\t_elemBox.expandByScalar( material.linewidth * 2 );\n\n\t\t\tsetDashAndGap( null, null );\n\n\t\t}\n\n\t}\n\n\tfunction renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {\n\n\t\t_this.info.render.vertices += 3;\n\t\t_this.info.render.faces ++;\n\n\t\tsetOpacity( material.opacity );\n\t\tsetBlending( material.blending );\n\n\t\t_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;\n\t\t_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;\n\t\t_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;\n\n\t\tdrawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );\n\n\t\tif ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) && material.map === null ) {\n\n\t\t\t_diffuseColor.copy( material.color );\n\t\t\t_emissiveColor.copy( material.emissive );\n\n\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\n\t\t\t\t_diffuseColor.multiply( element.color );\n\n\t\t\t}\n\n\t\t\tif ( material.wireframe === false && material.shading === THREE.SmoothShading && element.vertexNormalsLength === 3 ) {\n\n\t\t\t\t_color1.copy( _ambientLight );\n\t\t\t\t_color2.copy( _ambientLight );\n\t\t\t\t_color3.copy( _ambientLight );\n\n\t\t\t\tcalculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );\n\t\t\t\tcalculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );\n\t\t\t\tcalculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color3 );\n\n\t\t\t\t_color1.multiply( _diffuseColor ).add( _emissiveColor );\n\t\t\t\t_color2.multiply( _diffuseColor ).add( _emissiveColor );\n\t\t\t\t_color3.multiply( _diffuseColor ).add( _emissiveColor );\n\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\n\n\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\n\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\n\n\t\t\t} else {\n\n\t\t\t\t_color.copy( _ambientLight );\n\n\t\t\t\tcalculateLight( element.centroidModel, element.normalModel, _color );\n\n\t\t\t\t_color.multiply( _diffuseColor ).add( _emissiveColor );\n\n\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t: fillPath( _color );\n\n\t\t\t}\n\n\t\t} else if ( material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\tif ( material.map.mapping instanceof THREE.UVMapping ) {\n\n\t\t\t\t\t_uvs = element.uvs[ 0 ];\n\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );\n\n\t\t\t\t}\n\n\n\t\t\t} else if ( material.envMap !== null ) {\n\n\t\t\t\tif ( material.envMap.mapping instanceof THREE.SphericalReflectionMapping ) {\n\n\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv1 ] );\n\t\t\t\t\t_uv1x = 0.5 * _vector3.x + 0.5;\n\t\t\t\t\t_uv1y = 0.5 * _vector3.y + 0.5;\n\n\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv2 ] );\n\t\t\t\t\t_uv2x = 0.5 * _vector3.x + 0.5;\n\t\t\t\t\t_uv2y = 0.5 * _vector3.y + 0.5;\n\n\t\t\t\t\t_vector3.copy( element.vertexNormalsModelView[ uv3 ] );\n\t\t\t\t\t_uv3x = 0.5 * _vector3.x + 0.5;\n\t\t\t\t\t_uv3y = 0.5 * _vector3.y + 0.5;\n\n\t\t\t\t\tpatternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );\n\n\t\t\t\t}/* else if ( material.envMap.mapping === THREE.SphericalRefractionMapping ) {\n\n\n\n\t\t\t\t}*/\n\n\n\t\t\t} else {\n\n\t\t\t\t_color.copy( material.color );\n\n\t\t\t\tif ( material.vertexColors === THREE.FaceColors ) {\n\n\t\t\t\t\t_color.multiply( element.color );\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t: fillPath( _color );\n\n\t\t\t}\n\n\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t_near = _camera.near;\n\t\t\t_far = _camera.far;\n\n\t\t\t_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );\n\t\t\t_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );\n\t\t\t_color3.r = _color3.g = _color3.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );\n\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\n\n\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\n\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\n\n\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\tvar normal;\n\n\t\t\tif ( material.shading === THREE.FlatShading ) {\n\n\t\t\t\tnormal = element.normalModelView;\n\n\t\t\t\t_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\tmaterial.wireframe === true\n\t\t\t\t\t? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )\n\t\t\t\t\t: fillPath( _color );\n\n\t\t\t} else if ( material.shading === THREE.SmoothShading ) {\n\n\t\t\t\tnormal = element.vertexNormalsModelView[ uv1 ];\n\t\t\t\t_color1.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\tnormal = element.vertexNormalsModelView[ uv2 ];\n\t\t\t\t_color2.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\tnormal = element.vertexNormalsModelView[ uv3 ];\n\t\t\t\t_color3.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );\n\n\t\t\t\t_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );\n\n\t\t\t\t_image = getGradientTexture( _color1, _color2, _color3, _color4 );\n\n\t\t\t\tclipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t//\n\n\tfunction drawTriangle( x0, y0, x1, y1, x2, y2 ) {\n\n\t\t_context.beginPath();\n\t\t_context.moveTo( x0, y0 );\n\t\t_context.lineTo( x1, y1 );\n\t\t_context.lineTo( x2, y2 );\n\t\t_context.closePath();\n\n\t}\n\n\tfunction strokePath( color, linewidth, linecap, linejoin ) {\n\n\t\tsetLineWidth( linewidth );\n\t\tsetLineCap( linecap );\n\t\tsetLineJoin( linejoin );\n\t\tsetStrokeStyle( color.getStyle() );\n\n\t\t_context.stroke();\n\n\t\t_elemBox.expandByScalar( linewidth * 2 );\n\n\t}\n\n\tfunction fillPath( color ) {\n\n\t\tsetFillStyle( color.getStyle() );\n\t\t_context.fill();\n\n\t}\n\n\tfunction onTextureUpdate ( event ) {\n\n\t\ttextureToPattern( event.target );\n\n\t}\n\n\tfunction textureToPattern( texture ) {\n\n\t\tvar repeatX = texture.wrapS === THREE.RepeatWrapping;\n\t\tvar repeatY = texture.wrapT === THREE.RepeatWrapping;\n\n\t\tvar image = texture.image;\n\n\t\tvar canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = image.width;\n\t\tcanvas.height = image.height;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tcontext.setTransform( 1, 0, 0, - 1, 0, image.height );\n\t\tcontext.drawImage( image, 0, 0 );\n\n\t\t_patterns[ texture.id ] = _context.createPattern(\n\t\t\tcanvas, repeatX === true && repeatY === true\n\t\t\t\t? 'repeat'\n\t\t\t\t: repeatX === true && repeatY === false\n\t\t\t\t\t? 'repeat-x'\n\t\t\t\t\t: repeatX === false && repeatY === true\n\t\t\t\t\t\t? 'repeat-y'\n\t\t\t\t\t\t: 'no-repeat'\n\t\t);\n\n\t}\n\n\tfunction patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {\n\n\t\tif ( texture instanceof THREE.DataTexture ) return;\n\n\t\tif ( texture.hasEventListener( 'update', onTextureUpdate ) === false ) {\n\n\t\t\tif ( texture.image !== undefined && texture.image.width > 0 ) {\n\n\t\t\t\ttextureToPattern( texture );\n\n\t\t\t}\n\n\t\t\ttexture.addEventListener( 'update', onTextureUpdate );\n\n\t\t}\n\n\t\tvar pattern = _patterns[ texture.id ];\n\n\t\tif ( pattern !== undefined ) {\n\n\t\t\tsetFillStyle( pattern );\n\n\t\t} else {\n\n\t\t\tsetFillStyle( 'rgba(0,0,0,1)' );\n\t\t\t_context.fill();\n\n\t\t\treturn;\n\n\t\t}\t\n\n\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n\n\t\tvar a, b, c, d, e, f, det, idet,\n\t\toffsetX = texture.offset.x / texture.repeat.x,\n\t\toffsetY = texture.offset.y / texture.repeat.y,\n\t\twidth = texture.image.width * texture.repeat.x,\n\t\theight = texture.image.height * texture.repeat.y;\n\n\t\tu0 = ( u0 + offsetX ) * width;\n\t\tv0 = ( v0 + offsetY ) * height;\n\n\t\tu1 = ( u1 + offsetX ) * width;\n\t\tv1 = ( v1 + offsetY ) * height;\n\n\t\tu2 = ( u2 + offsetX ) * width;\n\t\tv2 = ( v2 + offsetY ) * height;\n\n\t\tx1 -= x0; y1 -= y0;\n\t\tx2 -= x0; y2 -= y0;\n\n\t\tu1 -= u0; v1 -= v0;\n\t\tu2 -= u0; v2 -= v0;\n\n\t\tdet = u1 * v2 - u2 * v1;\n\n\t\tif ( det === 0 ) return;\n\n\t\tidet = 1 / det;\n\n\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\n\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\n\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\n\t\td = ( u1 * y2 - u2 * y1 ) * idet;\n\n\t\te = x0 - a * u0 - c * v0;\n\t\tf = y0 - b * u0 - d * v0;\n\n\t\t_context.save();\n\t\t_context.transform( a, b, c, d, e, f );\n\t\t_context.fill();\n\t\t_context.restore();\n\n\t}\n\n\tfunction clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {\n\n\t\t// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120\n\n\t\tvar a, b, c, d, e, f, det, idet,\n\t\twidth = image.width - 1,\n\t\theight = image.height - 1;\n\n\t\tu0 *= width; v0 *= height;\n\t\tu1 *= width; v1 *= height;\n\t\tu2 *= width; v2 *= height;\n\n\t\tx1 -= x0; y1 -= y0;\n\t\tx2 -= x0; y2 -= y0;\n\n\t\tu1 -= u0; v1 -= v0;\n\t\tu2 -= u0; v2 -= v0;\n\n\t\tdet = u1 * v2 - u2 * v1;\n\n\t\tidet = 1 / det;\n\n\t\ta = ( v2 * x1 - v1 * x2 ) * idet;\n\t\tb = ( v2 * y1 - v1 * y2 ) * idet;\n\t\tc = ( u1 * x2 - u2 * x1 ) * idet;\n\t\td = ( u1 * y2 - u2 * y1 ) * idet;\n\n\t\te = x0 - a * u0 - c * v0;\n\t\tf = y0 - b * u0 - d * v0;\n\n\t\t_context.save();\n\t\t_context.transform( a, b, c, d, e, f );\n\t\t_context.clip();\n\t\t_context.drawImage( image, 0, 0 );\n\t\t_context.restore();\n\n\t}\n\n\tfunction getGradientTexture( color1, color2, color3, color4 ) {\n\n\t\t// http://mrdoob.com/blog/post/710\n\n\t\t_pixelMapData[ 0 ] = ( color1.r * 255 ) | 0;\n\t\t_pixelMapData[ 1 ] = ( color1.g * 255 ) | 0;\n\t\t_pixelMapData[ 2 ] = ( color1.b * 255 ) | 0;\n\n\t\t_pixelMapData[ 4 ] = ( color2.r * 255 ) | 0;\n\t\t_pixelMapData[ 5 ] = ( color2.g * 255 ) | 0;\n\t\t_pixelMapData[ 6 ] = ( color2.b * 255 ) | 0;\n\n\t\t_pixelMapData[ 8 ] = ( color3.r * 255 ) | 0;\n\t\t_pixelMapData[ 9 ] = ( color3.g * 255 ) | 0;\n\t\t_pixelMapData[ 10 ] = ( color3.b * 255 ) | 0;\n\n\t\t_pixelMapData[ 12 ] = ( color4.r * 255 ) | 0;\n\t\t_pixelMapData[ 13 ] = ( color4.g * 255 ) | 0;\n\t\t_pixelMapData[ 14 ] = ( color4.b * 255 ) | 0;\n\n\t\t_pixelMapContext.putImageData( _pixelMapImage, 0, 0 );\n\t\t_gradientMapContext.drawImage( _pixelMap, 0, 0 );\n\n\t\treturn _gradientMap;\n\n\t}\n\n\t// Hide anti-alias gaps\n\n\tfunction expand( v1, v2, pixels ) {\n\n\t\tvar x = v2.x - v1.x, y = v2.y - v1.y,\n\t\tdet = x * x + y * y, idet;\n\n\t\tif ( det === 0 ) return;\n\n\t\tidet = pixels / Math.sqrt( det );\n\n\t\tx *= idet; y *= idet;\n\n\t\tv2.x += x; v2.y += y;\n\t\tv1.x -= x; v1.y -= y;\n\n\t}\n\n\t// Context cached methods.\n\n\tfunction setOpacity( value ) {\n\n\t\tif ( _contextGlobalAlpha !== value ) {\n\n\t\t\t_context.globalAlpha = value;\n\t\t\t_contextGlobalAlpha = value;\n\n\t\t}\n\n\t}\n\n\tfunction setBlending( value ) {\n\n\t\tif ( _contextGlobalCompositeOperation !== value ) {\n\n\t\t\tif ( value === THREE.NormalBlending ) {\n\n\t\t\t\t_context.globalCompositeOperation = 'source-over';\n\n\t\t\t} else if ( value === THREE.AdditiveBlending ) {\n\n\t\t\t\t_context.globalCompositeOperation = 'lighter';\n\n\t\t\t} else if ( value === THREE.SubtractiveBlending ) {\n\n\t\t\t\t_context.globalCompositeOperation = 'darker';\n\n\t\t\t}\n\n\t\t\t_contextGlobalCompositeOperation = value;\n\n\t\t}\n\n\t}\n\n\tfunction setLineWidth( value ) {\n\n\t\tif ( _contextLineWidth !== value ) {\n\n\t\t\t_context.lineWidth = value;\n\t\t\t_contextLineWidth = value;\n\n\t\t}\n\n\t}\n\n\tfunction setLineCap( value ) {\n\n\t\t// \"butt\", \"round\", \"square\"\n\n\t\tif ( _contextLineCap !== value ) {\n\n\t\t\t_context.lineCap = value;\n\t\t\t_contextLineCap = value;\n\n\t\t}\n\n\t}\n\n\tfunction setLineJoin( value ) {\n\n\t\t// \"round\", \"bevel\", \"miter\"\n\n\t\tif ( _contextLineJoin !== value ) {\n\n\t\t\t_context.lineJoin = value;\n\t\t\t_contextLineJoin = value;\n\n\t\t}\n\n\t}\n\n\tfunction setStrokeStyle( value ) {\n\n\t\tif ( _contextStrokeStyle !== value ) {\n\n\t\t\t_context.strokeStyle = value;\n\t\t\t_contextStrokeStyle = value;\n\n\t\t}\n\n\t}\n\n\tfunction setFillStyle( value ) {\n\n\t\tif ( _contextFillStyle !== value ) {\n\n\t\t\t_context.fillStyle = value;\n\t\t\t_contextFillStyle = value;\n\n\t\t}\n\n\t}\n\n\tfunction setDashAndGap( dashSizeValue, gapSizeValue ) {\n\n\t\tif ( _contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue ) {\n\n\t\t\t_context.setLineDash( [ dashSizeValue, gapSizeValue ] );\n\t\t\t_contextDashSize = dashSizeValue;\n\t\t\t_contextGapSize = gapSizeValue;\n\n\t\t}\n\n\t}\n\n};\n\n/**\n * Shader chunks for WebLG Shader library\n * \n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\nTHREE.ShaderChunk = {\n\n\t// FOG\n\n\tfog_pars_fragment: [\n\n\t\t\"#ifdef USE_FOG\",\n\n\t\t\t\"uniform vec3 fogColor;\",\n\n\t\t\t\"#ifdef FOG_EXP2\",\n\n\t\t\t\t\"uniform float fogDensity;\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"uniform float fogNear;\",\n\t\t\t\t\"uniform float fogFar;\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tfog_fragment: [\n\n\t\t\"#ifdef USE_FOG\",\n\n\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\n\n\t\t\t\"#ifdef FOG_EXP2\",\n\n\t\t\t\t\"const float LOG2 = 1.442695;\",\n\t\t\t\t\"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\",\n\t\t\t\t\"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"float fogFactor = smoothstep( fogNear, fogFar, depth );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// ENVIRONMENT MAP\n\n\tenvmap_pars_fragment: [\n\n\t\t\"#ifdef USE_ENVMAP\",\n\n\t\t\t\"uniform float reflectivity;\",\n\t\t\t\"uniform samplerCube envMap;\",\n\t\t\t\"uniform float flipEnvMap;\",\n\t\t\t\"uniform int combine;\",\n\n\t\t\t\"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\",\n\n\t\t\t\t\"uniform bool useRefract;\",\n\t\t\t\t\"uniform float refractionRatio;\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"varying vec3 vReflect;\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tenvmap_fragment: [\n\n\t\t\"#ifdef USE_ENVMAP\",\n\n\t\t\t\"vec3 reflectVec;\",\n\n\t\t\t\"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\",\n\n\t\t\t\t\"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\n\n\t\t\t\t\"if ( useRefract ) {\",\n\n\t\t\t\t\t\"reflectVec = refract( cameraToVertex, normal, refractionRatio );\",\n\n\t\t\t\t\"} else { \",\n\n\t\t\t\t\t\"reflectVec = reflect( cameraToVertex, normal );\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"reflectVec = vReflect;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\n\t\t\t\t\"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\"cubeColor.xyz *= cubeColor.xyz;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"if ( combine == 1 ) {\",\n\n\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\",\n\n\t\t\t\"} else if ( combine == 2 ) {\",\n\n\t\t\t\t\"gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\",\n\n\t\t\t\"} else {\",\n\n\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tenvmap_pars_vertex: [\n\n\t\t\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\",\n\n\t\t\t\"varying vec3 vReflect;\",\n\n\t\t\t\"uniform float refractionRatio;\",\n\t\t\t\"uniform bool useRefract;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tworldpos_vertex : [\n\n\t\t\"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\",\n\n\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\"vec4 worldPosition = modelMatrix * skinned;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\n\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\",\n\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tenvmap_vertex : [\n\n\t\t\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\",\n\n\t\t\t\"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\",\n\t\t\t\"worldNormal = normalize( worldNormal );\",\n\n\t\t\t\"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\",\n\n\t\t\t\"if ( useRefract ) {\",\n\n\t\t\t\t\"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\",\n\n\t\t\t\"} else {\",\n\n\t\t\t\t\"vReflect = reflect( cameraToVertex, worldNormal );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// COLOR MAP (particles)\n\n\tmap_particle_pars_fragment: [\n\n\t\t\"#ifdef USE_MAP\",\n\n\t\t\t\"uniform sampler2D map;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n\tmap_particle_fragment: [\n\n\t\t\"#ifdef USE_MAP\",\n\n\t\t\t\"gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// COLOR MAP (triangles)\n\n\tmap_pars_vertex: [\n\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"uniform vec4 offsetRepeat;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tmap_pars_fragment: [\n\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef USE_MAP\",\n\n\t\t\t\"uniform sampler2D map;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tmap_vertex: [\n\n\t\t\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\",\n\n\t\t\t\"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tmap_fragment: [\n\n\t\t\"#ifdef USE_MAP\",\n\n\t\t\t\"vec4 texelColor = texture2D( map, vUv );\",\n\n\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\"texelColor.xyz *= texelColor.xyz;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"gl_FragColor = gl_FragColor * texelColor;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// LIGHT MAP\n\n\tlightmap_pars_fragment: [\n\n\t\t\"#ifdef USE_LIGHTMAP\",\n\n\t\t\t\"varying vec2 vUv2;\",\n\t\t\t\"uniform sampler2D lightMap;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlightmap_pars_vertex: [\n\n\t\t\"#ifdef USE_LIGHTMAP\",\n\n\t\t\t\"varying vec2 vUv2;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlightmap_fragment: [\n\n\t\t\"#ifdef USE_LIGHTMAP\",\n\n\t\t\t\"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlightmap_vertex: [\n\n\t\t\"#ifdef USE_LIGHTMAP\",\n\n\t\t\t\"vUv2 = uv2;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// BUMP MAP\n\n\tbumpmap_pars_fragment: [\n\n\t\t\"#ifdef USE_BUMPMAP\",\n\n\t\t\t\"uniform sampler2D bumpMap;\",\n\t\t\t\"uniform float bumpScale;\",\n\n\t\t\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n\t\t\t//\thttp://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n\t\t\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\t\t\t\"vec2 dHdxy_fwd() {\",\n\n\t\t\t\t\"vec2 dSTdx = dFdx( vUv );\",\n\t\t\t\t\"vec2 dSTdy = dFdy( vUv );\",\n\n\t\t\t\t\"float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\",\n\t\t\t\t\"float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\",\n\t\t\t\t\"float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\",\n\n\t\t\t\t\"return vec2( dBx, dBy );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\",\n\n\t\t\t\t\"vec3 vSigmaX = dFdx( surf_pos );\",\n\t\t\t\t\"vec3 vSigmaY = dFdy( surf_pos );\",\n\t\t\t\t\"vec3 vN = surf_norm;\",\t\t// normalized\n\n\t\t\t\t\"vec3 R1 = cross( vSigmaY, vN );\",\n\t\t\t\t\"vec3 R2 = cross( vN, vSigmaX );\",\n\n\t\t\t\t\"float fDet = dot( vSigmaX, R1 );\",\n\n\t\t\t\t\"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\",\n\t\t\t\t\"return normalize( abs( fDet ) * surf_norm - vGrad );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// NORMAL MAP\n\n\tnormalmap_pars_fragment: [\n\n\t\t\"#ifdef USE_NORMALMAP\",\n\n\t\t\t\"uniform sampler2D normalMap;\",\n\t\t\t\"uniform vec2 normalScale;\",\n\n\t\t\t// Per-Pixel Tangent Space Normal Mapping\n\t\t\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\t\t\t\"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\",\n\n\t\t\t\t\"vec3 q0 = dFdx( eye_pos.xyz );\",\n\t\t\t\t\"vec3 q1 = dFdy( eye_pos.xyz );\",\n\t\t\t\t\"vec2 st0 = dFdx( vUv.st );\",\n\t\t\t\t\"vec2 st1 = dFdy( vUv.st );\",\n\n\t\t\t\t\"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );\",\n\t\t\t\t\"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\",\n\t\t\t\t\"vec3 N = normalize( surf_norm );\",\n\n\t\t\t\t\"vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\",\n\t\t\t\t\"mapN.xy = normalScale * mapN.xy;\",\n\t\t\t\t\"mat3 tsn = mat3( S, T, N );\",\n\t\t\t\t\"return normalize( tsn * mapN );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// SPECULAR MAP\n\n\tspecularmap_pars_fragment: [\n\n\t\t\"#ifdef USE_SPECULARMAP\",\n\n\t\t\t\"uniform sampler2D specularMap;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tspecularmap_fragment: [\n\n\t\t\"float specularStrength;\",\n\n\t\t\"#ifdef USE_SPECULARMAP\",\n\n\t\t\t\"vec4 texelSpecular = texture2D( specularMap, vUv );\",\n\t\t\t\"specularStrength = texelSpecular.r;\",\n\n\t\t\"#else\",\n\n\t\t\t\"specularStrength = 1.0;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// LIGHTS LAMBERT\n\n\tlights_lambert_pars_vertex: [\n\n\t\t\"uniform vec3 ambient;\",\n\t\t\"uniform vec3 diffuse;\",\n\t\t\"uniform vec3 emissive;\",\n\n\t\t\"uniform vec3 ambientLightColor;\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\"uniform vec3 wrapRGB;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlights_lambert_vertex: [\n\n\t\t\"vLightFront = vec3( 0.0 );\",\n\n\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\"vLightBack = vec3( 0.0 );\",\n\n\t\t\"#endif\",\n\n\t\t\"transformedNormal = normalize( transformedNormal );\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\n\n\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\n\n\t\t\t\"float dotProduct = dot( transformedNormal, dirVector );\",\n\t\t\t\"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n\t\t\t\t\"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\",\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\",\n\n\t\t\t\"#endif\",\n\n\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\"lVector = normalize( lVector );\",\n\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\n\n\t\t\t\t\"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n\t\t\t\t\t\"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\",\n\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\t\"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\",\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\",\n\n\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\n\n\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\n\n\t\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\"lVector = normalize( lVector );\",\n\n\t\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\n\t\t\t\t\t\"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\",\n\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\t\"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\",\n\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\t\"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\",\n\t\t\t\t\t\t\"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\",\n\n\t\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\t\t\"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\",\n\n\t\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\t\"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\n\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t\"float dotProduct = dot( transformedNormal, lVector );\",\n\n\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\t\t\t\t\"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\",\n\n\t\t\t\t\"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t\"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\",\n\n\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\"vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// LIGHTS PHONG\n\n\tlights_phong_pars_vertex: [\n\n\t\t\"#ifndef PHONG_PER_PIXEL\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n\tlights_phong_vertex: [\n\n\t\t\"#ifndef PHONG_PER_PIXEL\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\"vPointLight[ i ] = vec4( lVector, lDistance );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\t\t\t\t\"vec3 lVector = lPosition.xyz - mvPosition.xyz;\",\n\n\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\"vSpotLight[ i ] = vec4( lVector, lDistance );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n\n\t\t\t\"vWorldPosition = worldPosition.xyz;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tlights_phong_pars_fragment: [\n\n\t\t\"uniform vec3 ambientLightColor;\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\n\t\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\t\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\n\t\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\"uniform vec3 wrapRGB;\",\n\n\t\t\"#endif\",\n\n\t\t\"varying vec3 vViewPosition;\",\n\t\t\"varying vec3 vNormal;\"\n\n\t].join(\"\\n\"),\n\n\tlights_phong_fragment: [\n\n\t\t\"vec3 normal = normalize( vNormal );\",\n\t\t\"vec3 viewPosition = normalize( vViewPosition );\",\n\n\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef USE_NORMALMAP\",\n\n\t\t\t\"normal = perturbNormal2Arb( -vViewPosition, normal );\",\n\n\t\t\"#elif defined( USE_BUMPMAP )\",\n\n\t\t\t\"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"vec3 pointDiffuse  = vec3( 0.0 );\",\n\t\t\t\"vec3 pointSpecular = vec3( 0.0 );\",\n\n\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\n\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\n\n\t\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\"lVector = normalize( lVector );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"vec3 lVector = normalize( vPointLight[ i ].xyz );\",\n\t\t\t\t\t\"float lDistance = vPointLight[ i ].w;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// diffuse\n\n\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"float pointDiffuseWeightFull = max( dotProduct, 0.0 );\",\n\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n\n\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"float pointDiffuseWeight = max( dotProduct, 0.0 );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\",\n\n\t\t\t\t// specular\n\n\t\t\t\t\"vec3 pointHalfVector = normalize( lVector + viewPosition );\",\n\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\n\t\t\t\t\"float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\",\n\t\t\t\t\"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"vec3 spotDiffuse  = vec3( 0.0 );\",\n\t\t\t\"vec3 spotSpecular = vec3( 0.0 );\",\n\n\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"#ifdef PHONG_PER_PIXEL\",\n\n\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\"vec3 lVector = lPosition.xyz + vViewPosition.xyz;\",\n\n\t\t\t\t\t\"float lDistance = 1.0;\",\n\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\"lVector = normalize( lVector );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"vec3 lVector = normalize( vSpotLight[ i ].xyz );\",\n\t\t\t\t\t\"float lDistance = vSpotLight[ i ].w;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\n\n\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\n\n\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\n\n\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\n\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\"float spotDiffuseWeightFull = max( dotProduct, 0.0 );\",\n\t\t\t\t\t\t\"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n\n\t\t\t\t\t\t\"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"float spotDiffuseWeight = max( dotProduct, 0.0 );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\",\n\n\t\t\t\t\t// specular\n\n\t\t\t\t\t\"vec3 spotHalfVector = normalize( lVector + viewPosition );\",\n\t\t\t\t\t\"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\n\t\t\t\t\t\"float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\",\n\t\t\t\t\t\"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\"vec3 dirDiffuse  = vec3( 0.0 );\",\n\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\" ,\n\n\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n\t\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t// diffuse\n\n\t\t\t\t\"float dotProduct = dot( normal, dirVector );\",\n\n\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\"float dirDiffuseWeightFull = max( dotProduct, 0.0 );\",\n\t\t\t\t\t\"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\",\n\n\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"float dirDiffuseWeight = max( dotProduct, 0.0 );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\",\n\n\t\t\t\t// specular\n\n\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\n\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\n\t\t\t\t\"float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\t/*\n\t\t\t\t// fresnel term from skin shader\n\t\t\t\t\"const float F0 = 0.128;\",\n\n\t\t\t\t\"float base = 1.0 - dot( viewPosition, dirHalfVector );\",\n\t\t\t\t\"float exponential = pow( base, 5.0 );\",\n\n\t\t\t\t\"float fresnel = exponential + F0 * ( 1.0 - exponential );\",\n\t\t\t\t*/\n\n\t\t\t\t/*\n\t\t\t\t// fresnel term from fresnel shader\n\t\t\t\t\"const float mFresnelBias = 0.08;\",\n\t\t\t\t\"const float mFresnelScale = 0.3;\",\n\t\t\t\t\"const float mFresnelPower = 5.0;\",\n\n\t\t\t\t\"float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\",\n\t\t\t\t*/\n\n\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t//\"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\",\n\n\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\n\t\t\t\t\"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\n\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\n\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\" ,\n\n\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\n\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t// diffuse\n\n\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\n\t\t\t\t\"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\n\t\t\t\t\"hemiDiffuse += diffuse * hemiColor;\",\n\n\t\t\t\t// specular (sky light)\n\n\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\n\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\n\t\t\t\t\"float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\",\n\n\t\t\t\t// specular (ground light)\n\n\t\t\t\t\"vec3 lVectorGround = -lVector;\",\n\n\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\n\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\n\t\t\t\t\"float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\",\n\n\t\t\t\t\"float dotProductGround = dot( normal, lVectorGround );\",\n\n\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\n\t\t\t\t\"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\n\t\t\t\t\"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\",\n\n\t\t\"vec3 totalDiffuse = vec3( 0.0 );\",\n\t\t\"vec3 totalSpecular = vec3( 0.0 );\",\n\n\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\"totalDiffuse += dirDiffuse;\",\n\t\t\t\"totalSpecular += dirSpecular;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\"totalDiffuse += hemiDiffuse;\",\n\t\t\t\"totalSpecular += hemiSpecular;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\"totalDiffuse += pointDiffuse;\",\n\t\t\t\"totalSpecular += pointSpecular;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\"totalDiffuse += spotDiffuse;\",\n\t\t\t\"totalSpecular += spotSpecular;\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef METAL\",\n\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\",\n\n\t\t\"#else\",\n\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// VERTEX COLORS\n\n\tcolor_pars_fragment: [\n\n\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\"varying vec3 vColor;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n\tcolor_fragment: [\n\n\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\"gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tcolor_pars_vertex: [\n\n\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\"varying vec3 vColor;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\n\tcolor_vertex: [\n\n\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\"vColor = color * color;\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"vColor = color;\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// SKINNING\n\n\tskinning_pars_vertex: [\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"#ifdef BONE_TEXTURE\",\n\n\t\t\t\t\"uniform sampler2D boneTexture;\",\n\t\t\t\t\"uniform int boneTextureWidth;\",\n\t\t\t\t\"uniform int boneTextureHeight;\",\n\n\t\t\t\t\"mat4 getBoneMatrix( const in float i ) {\",\n\n\t\t\t\t\t\"float j = i * 4.0;\",\n\t\t\t\t\t\"float x = mod( j, float( boneTextureWidth ) );\",\n\t\t\t\t\t\"float y = floor( j / float( boneTextureWidth ) );\",\n\n\t\t\t\t\t\"float dx = 1.0 / float( boneTextureWidth );\",\n\t\t\t\t\t\"float dy = 1.0 / float( boneTextureHeight );\",\n\n\t\t\t\t\t\"y = dy * ( y + 0.5 );\",\n\n\t\t\t\t\t\"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\",\n\t\t\t\t\t\"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\",\n\t\t\t\t\t\"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\",\n\t\t\t\t\t\"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\",\n\n\t\t\t\t\t\"mat4 bone = mat4( v1, v2, v3, v4 );\",\n\n\t\t\t\t\t\"return bone;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"uniform mat4 boneGlobalMatrices[ MAX_BONES ];\",\n\n\t\t\t\t\"mat4 getBoneMatrix( const in float i ) {\",\n\n\t\t\t\t\t\"mat4 bone = boneGlobalMatrices[ int(i) ];\",\n\t\t\t\t\t\"return bone;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tskinbase_vertex: [\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"mat4 boneMatX = getBoneMatrix( skinIndex.x );\",\n\t\t\t\"mat4 boneMatY = getBoneMatrix( skinIndex.y );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tskinning_vertex: [\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"#ifdef USE_MORPHTARGETS\",\n\n\t\t\t\"vec4 skinVertex = vec4( morphed, 1.0 );\",\n\n\t\t\t\"#else\",\n\n\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// MORPHING\n\n\tmorphtarget_pars_vertex: [\n\n\t\t\"#ifdef USE_MORPHTARGETS\",\n\n\t\t\t\"#ifndef USE_MORPHNORMALS\",\n\n\t\t\t\"uniform float morphTargetInfluences[ 8 ];\",\n\n\t\t\t\"#else\",\n\n\t\t\t\"uniform float morphTargetInfluences[ 4 ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tmorphtarget_vertex: [\n\n\t\t\"#ifdef USE_MORPHTARGETS\",\n\n\t\t\t\"vec3 morphed = vec3( 0.0 );\",\n\t\t\t\"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\",\n\t\t\t\"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\",\n\t\t\t\"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\",\n\t\t\t\"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\",\n\n\t\t\t\"#ifndef USE_MORPHNORMALS\",\n\n\t\t\t\"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\",\n\t\t\t\"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\",\n\t\t\t\"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\",\n\t\t\t\"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"morphed += position;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tdefault_vertex : [\n\n\t\t\"vec4 mvPosition;\",\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"mvPosition = modelViewMatrix * skinned;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\",\n\n\t\t\t\"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\",\n\n\t\t\"#endif\",\n\n\t\t\"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\",\n\n\t\t\t\"mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"#endif\",\n\n\t\t\"gl_Position = projectionMatrix * mvPosition;\"\n\n\t].join(\"\\n\"),\n\n\tmorphnormal_vertex: [\n\n\t\t\"#ifdef USE_MORPHNORMALS\",\n\n\t\t\t\"vec3 morphedNormal = vec3( 0.0 );\",\n\n\t\t\t\"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\",\n\t\t\t\"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\",\n\t\t\t\"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\",\n\t\t\t\"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\",\n\n\t\t\t\"morphedNormal += normal;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tskinnormal_vertex: [\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"mat4 skinMatrix = skinWeight.x * boneMatX;\",\n\t\t\t\"skinMatrix \t+= skinWeight.y * boneMatY;\",\n\n\t\t\t\"#ifdef USE_MORPHNORMALS\",\n\n\t\t\t\"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\",\n\n\t\t\t\"#else\",\n\n\t\t\t\"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tdefaultnormal_vertex: [\n\n\t\t\"vec3 objectNormal;\",\n\n\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\"objectNormal = skinnedNormal.xyz;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\",\n\n\t\t\t\"objectNormal = morphedNormal;\",\n\n\t\t\"#endif\",\n\n\t\t\"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\",\n\n\t\t\t\"objectNormal = normal;\",\n\n\t\t\"#endif\",\n\n\t\t\"#ifdef FLIP_SIDED\",\n\n\t\t\t\"objectNormal = -objectNormal;\",\n\n\t\t\"#endif\",\n\n\t\t\"vec3 transformedNormal = normalMatrix * objectNormal;\"\n\n\t].join(\"\\n\"),\n\n\t// SHADOW MAP\n\n\t// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples\n\t//  http://spidergl.org/example.php?id=6\n\t// \thttp://fabiensanglard.net/shadowmapping\n\n\tshadowmap_pars_fragment: [\n\n\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\"uniform sampler2D shadowMap[ MAX_SHADOWS ];\",\n\t\t\t\"uniform vec2 shadowMapSize[ MAX_SHADOWS ];\",\n\n\t\t\t\"uniform float shadowDarkness[ MAX_SHADOWS ];\",\n\t\t\t\"uniform float shadowBias[ MAX_SHADOWS ];\",\n\n\t\t\t\"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\n\n\t\t\t\"float unpackDepth( const in vec4 rgba_depth ) {\",\n\n\t\t\t\t\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\n\t\t\t\t\"float depth = dot( rgba_depth, bit_shift );\",\n\t\t\t\t\"return depth;\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tshadowmap_fragment: [\n\n\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\"#ifdef SHADOWMAP_DEBUG\",\n\n\t\t\t\t\"vec3 frustumColors[3];\",\n\t\t\t\t\"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\",\n\t\t\t\t\"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\",\n\t\t\t\t\"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\n\n\t\t\t\t\"int inFrustumCount = 0;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"float fDepth;\",\n\t\t\t\"vec3 shadowColor = vec3( 1.0 );\",\n\n\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n\n\t\t\t\t\"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\",\n\n\t\t\t\t// \"if ( something && something )\" \t\t breaks ATI OpenGL shader compiler\n\t\t\t\t// \"if ( all( something, something ) )\"  using this instead\n\n\t\t\t\t\"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\",\n\t\t\t\t\"bool inFrustum = all( inFrustumVec );\",\n\n\t\t\t\t// don't shadow pixels outside of light frustum\n\t\t\t\t// use just first frustum (for cascades)\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\n\n\t\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\n\n\t\t\t\t\t\"inFrustumCount += int( inFrustum );\",\n\t\t\t\t\t\"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"bool frustumTest = all( frustumTestVec );\",\n\n\t\t\t\t\"if ( frustumTest ) {\",\n\n\t\t\t\t\t\"shadowCoord.z += shadowBias[ i ];\",\n\n\t\t\t\t\t\"#if defined( SHADOWMAP_TYPE_PCF )\",\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\t\t\t\"float shadow = 0.0;\",\n\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n\t\t\t\t\t\t// must enroll loop manually\n\n\t\t\t\t\t\t\"for ( float y = -1.25; y <= 1.25; y += 1.25 )\",\n\t\t\t\t\t\t\t\"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\",\n\n\t\t\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\",\n\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple \"texture2D\" lookup\n\t\t\t\t\t\t\t\t//\"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\",\n\n\t\t\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\n\n\t\t\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\n\t\t\t\t\t\t\t\t\t\"shadow += 1.0;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\t\"shadow /= 9.0;\",\n\n\t\t\t\t\t\t*/\n\n\t\t\t\t\t\t\"const float shadowDelta = 1.0 / 9.0;\",\n\n\t\t\t\t\t\t\"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\n\t\t\t\t\t\t\"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\n\n\t\t\t\t\t\t\"float dx0 = -1.25 * xPixelOffset;\",\n\t\t\t\t\t\t\"float dy0 = -1.25 * yPixelOffset;\",\n\t\t\t\t\t\t\"float dx1 = 1.25 * xPixelOffset;\",\n\t\t\t\t\t\t\"float dy1 = 1.25 * yPixelOffset;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\",\n\n\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\n\n\t\t\t\t\t\"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\",\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\t\t\t\"float shadow = 0.0;\",\n\n\t\t\t\t\t\t\"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\",\n\t\t\t\t\t\t\"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\",\n\n\t\t\t\t\t\t\"float dx0 = -1.0 * xPixelOffset;\",\n\t\t\t\t\t\t\"float dy0 = -1.0 * yPixelOffset;\",\n\t\t\t\t\t\t\"float dx1 = 1.0 * xPixelOffset;\",\n\t\t\t\t\t\t\"float dy1 = 1.0 * yPixelOffset;\",\n\n\t\t\t\t\t\t\"mat3 shadowKernel;\",\n\t\t\t\t\t\t\"mat3 depthKernel;\",\n\n\t\t\t\t\t\t\"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\",\n\t\t\t\t\t\t\"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\",\n\t\t\t\t\t\t\"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\",\n\t\t\t\t\t\t\"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\",\n\t\t\t\t\t\t\"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\",\n\t\t\t\t\t\t\"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\",\n\t\t\t\t\t\t\"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\",\n\t\t\t\t\t\t\"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\",\n\t\t\t\t\t\t\"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\",\n\n\t\t\t\t\t\t\"vec3 shadowZ = vec3( shadowCoord.z );\",\n\t\t\t\t\t\t\"shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\",\n\t\t\t\t\t\t\"shadowKernel[0] *= vec3(0.25);\",\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\"shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\",\n\t\t\t\t\t\t\"shadowKernel[1] *= vec3(0.25);\",\n\n\t\t\t\t\t\t\"shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\",\n\t\t\t\t\t\t\"shadowKernel[2] *= vec3(0.25);\",\n\n\t\t\t\t\t\t\"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\",\n\n\t\t\t\t\t\t\"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\",\n\t\t\t\t\t\t\"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\",\n\n\t\t\t\t\t\t\"vec4 shadowValues;\",\n\t\t\t\t\t\t\"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\",\n\t\t\t\t\t\t\"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\",\n\t\t\t\t\t\t\"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\",\n\t\t\t\t\t\t\"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\",\n\n\t\t\t\t\t\t\"shadow = dot( shadowValues, vec4( 1.0 ) );\",\n\n\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\",\n\t\t\t\t\t\t\"float fDepth = unpackDepth( rgbaDepth );\",\n\n\t\t\t\t\t\t\"if ( fDepth < shadowCoord.z )\",\n\n\t\t\t\t\t\t\t// spot with multiple shadows is darker\n\n\t\t\t\t\t\t\t\"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\",\n\n\t\t\t\t\t\t\t// spot with multiple shadows has the same color as single shadow spot\n\n\t\t\t\t\t\t\t//\"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\n\t\t\t\t\"#ifdef SHADOWMAP_DEBUG\",\n\n\t\t\t\t\t\"#ifdef SHADOWMAP_CASCADE\",\n\n\t\t\t\t\t\t\"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\",\n\n\t\t\t\"#ifdef GAMMA_OUTPUT\",\n\n\t\t\t\t\"shadowColor *= shadowColor;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tshadowmap_pars_vertex: [\n\n\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\"varying vec4 vShadowCoord[ MAX_SHADOWS ];\",\n\t\t\t\"uniform mat4 shadowMatrix[ MAX_SHADOWS ];\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\tshadowmap_vertex: [\n\n\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n\n\t\t\t\t\"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\",\n\n\t\t\t\"}\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// ALPHATEST\n\n\talphatest_fragment: [\n\n\t\t\"#ifdef ALPHATEST\",\n\n\t\t\t\"if ( gl_FragColor.a < ALPHATEST ) discard;\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\"),\n\n\t// LINEAR SPACE\n\n\tlinear_to_gamma_fragment: [\n\n\t\t\"#ifdef GAMMA_OUTPUT\",\n\n\t\t\t\"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\",\n\n\t\t\"#endif\"\n\n\t].join(\"\\n\")\n\n\n};\n/**\n * Uniform Utilities\n */\n\nTHREE.UniformsUtils = {\n\n\tmerge: function ( uniforms ) {\n\n\t\tvar u, p, tmp, merged = {};\n\n\t\tfor ( u = 0; u < uniforms.length; u ++ ) {\n\n\t\t\ttmp = this.clone( uniforms[ u ] );\n\n\t\t\tfor ( p in tmp ) {\n\n\t\t\t\tmerged[ p ] = tmp[ p ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn merged;\n\n\t},\n\n\tclone: function ( uniforms_src ) {\n\n\t\tvar u, p, parameter, parameter_src, uniforms_dst = {};\n\n\t\tfor ( u in uniforms_src ) {\n\n\t\t\tuniforms_dst[ u ] = {};\n\n\t\t\tfor ( p in uniforms_src[ u ] ) {\n\n\t\t\t\tparameter_src = uniforms_src[ u ][ p ];\n\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\n\n\t\t\t\t} else if ( parameter_src instanceof Array ) {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn uniforms_dst;\n\n\t}\n\n};\n/**\n * Uniforms library for shared webgl shaders\n */\n\nTHREE.UniformsLib = {\n\n\tcommon: {\n\n\t\t\"diffuse\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\n\n\t\t\"map\" : { type: \"t\", value: null },\n\t\t\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\n\n\t\t\"lightMap\" : { type: \"t\", value: null },\n\t\t\"specularMap\" : { type: \"t\", value: null },\n\n\t\t\"envMap\" : { type: \"t\", value: null },\n\t\t\"flipEnvMap\" : { type: \"f\", value: -1 },\n\t\t\"useRefract\" : { type: \"i\", value: 0 },\n\t\t\"reflectivity\" : { type: \"f\", value: 1.0 },\n\t\t\"refractionRatio\" : { type: \"f\", value: 0.98 },\n\t\t\"combine\" : { type: \"i\", value: 0 },\n\n\t\t\"morphTargetInfluences\" : { type: \"f\", value: 0 }\n\n\t},\n\n\tbump: {\n\n\t\t\"bumpMap\" : { type: \"t\", value: null },\n\t\t\"bumpScale\" : { type: \"f\", value: 1 }\n\n\t},\n\n\tnormalmap: {\n\n\t\t\"normalMap\" : { type: \"t\", value: null },\n\t\t\"normalScale\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\n\t},\n\n\tfog : {\n\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\n\n\t},\n\n\tlights: {\n\n\t\t\"ambientLightColor\" : { type: \"fv\", value: [] },\n\n\t\t\"directionalLightDirection\" : { type: \"fv\", value: [] },\n\t\t\"directionalLightColor\" : { type: \"fv\", value: [] },\n\n\t\t\"hemisphereLightDirection\" : { type: \"fv\", value: [] },\n\t\t\"hemisphereLightSkyColor\" : { type: \"fv\", value: [] },\n\t\t\"hemisphereLightGroundColor\" : { type: \"fv\", value: [] },\n\n\t\t\"pointLightColor\" : { type: \"fv\", value: [] },\n\t\t\"pointLightPosition\" : { type: \"fv\", value: [] },\n\t\t\"pointLightDistance\" : { type: \"fv1\", value: [] },\n\n\t\t\"spotLightColor\" : { type: \"fv\", value: [] },\n\t\t\"spotLightPosition\" : { type: \"fv\", value: [] },\n\t\t\"spotLightDirection\" : { type: \"fv\", value: [] },\n\t\t\"spotLightDistance\" : { type: \"fv1\", value: [] },\n\t\t\"spotLightAngleCos\" : { type: \"fv1\", value: [] },\n\t\t\"spotLightExponent\" : { type: \"fv1\", value: [] }\n\n\t},\n\n\tparticle: {\n\n\t\t\"psColor\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\n\t\t\"opacity\" : { type: \"f\", value: 1.0 },\n\t\t\"size\" : { type: \"f\", value: 1.0 },\n\t\t\"scale\" : { type: \"f\", value: 1.0 },\n\t\t\"map\" : { type: \"t\", value: null },\n\n\t\t\"fogDensity\" : { type: \"f\", value: 0.00025 },\n\t\t\"fogNear\" : { type: \"f\", value: 1 },\n\t\t\"fogFar\" : { type: \"f\", value: 2000 },\n\t\t\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\n\n\t},\n\n\tshadowmap: {\n\n\t\t\"shadowMap\": { type: \"tv\", value: [] },\n\t\t\"shadowMapSize\": { type: \"v2v\", value: [] },\n\n\t\t\"shadowBias\" : { type: \"fv1\", value: [] },\n\t\t\"shadowDarkness\": { type: \"fv1\", value: [] },\n\n\t\t\"shadowMatrix\" : { type: \"m4v\", value: [] }\n\n\t}\n\n};\n/**\n * Webgl Shader Library for three.js\n *\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n */\n\n\nTHREE.ShaderLib = {\n\n\t'basic': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"common\" ],\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\n\t\t\t\t\"#ifdef USE_ENVMAP\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( diffuse, opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'lambert': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"common\" ],\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\n\n\t\t\t{\n\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\t\"#define LAMBERT\",\n\n\t\t\t\"varying vec3 vLightFront;\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"varying vec3 vLightBack;\",\n\n\t\t\t\"#endif\",\n\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lights_lambert_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lights_lambert_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"varying vec3 vLightFront;\",\n\n\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\"varying vec3 vLightBack;\",\n\n\t\t\t\"#endif\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\n\n\t\t\t\t\"#ifdef DOUBLE_SIDED\",\n\n\t\t\t\t\t//\"float isFront = float( gl_FrontFacing );\",\n\t\t\t\t\t//\"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;\",\n\n\t\t\t\t\t\"if ( gl_FrontFacing )\",\n\t\t\t\t\t\t\"gl_FragColor.xyz *= vLightFront;\",\n\t\t\t\t\t\"else\",\n\t\t\t\t\t\t\"gl_FragColor.xyz *= vLightBack;\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"gl_FragColor.xyz *= vLightFront;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'phong': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"common\" ],\n\t\t\tTHREE.UniformsLib[ \"bump\" ],\n\t\t\tTHREE.UniformsLib[ \"normalmap\" ],\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\n\n\t\t\t{\n\t\t\t\t\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\n\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\n\t\t\t\t\"shininess\": { type: \"f\", value: 30 },\n\t\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\t\"#define PHONG\",\n\n\t\t\t\"varying vec3 vViewPosition;\",\n\t\t\t\"varying vec3 vNormal;\",\n\n\t\t\tTHREE.ShaderChunk[ \"map_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"defaultnormal_vertex\" ],\n\n\t\t\t\t\"vNormal = normalize( transformedNormal );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform vec3 ambient;\",\n\t\t\t\"uniform vec3 emissive;\",\n\t\t\t\"uniform vec3 specular;\",\n\t\t\t\"uniform float shininess;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"map_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"envmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"specularmap_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"lights_phong_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"lightmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"envmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'particle_basic': {\n\n\t\tuniforms:  THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"particle\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ]\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform float size;\",\n\t\t\t\"uniform float scale;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\t\"#ifdef USE_SIZEATTENUATION\",\n\t\t\t\t\t\"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\",\n\t\t\t\t\"#else\",\n\t\t\t\t\t\"gl_PointSize = size;\",\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"worldpos_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 psColor;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"map_particle_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( psColor, opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"map_particle_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"alphatest_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'dashed': {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"common\" ],\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\n\t\t\t{\n\t\t\t\t\"scale\":     { type: \"f\", value: 1 },\n\t\t\t\t\"dashSize\":  { type: \"f\", value: 1 },\n\t\t\t\t\"totalSize\": { type: \"f\", value: 2 }\n\t\t\t}\n\n\t\t] ),\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform float scale;\",\n\t\t\t\"attribute float lineDistance;\",\n\n\t\t\t\"varying float vLineDistance;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"color_vertex\" ],\n\n\t\t\t\t\"vLineDistance = scale * lineDistance;\",\n\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform float dashSize;\",\n\t\t\t\"uniform float totalSize;\",\n\n\t\t\t\"varying float vLineDistance;\",\n\n\t\t\tTHREE.ShaderChunk[ \"color_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"if ( mod( vLineDistance, totalSize ) > dashSize ) {\",\n\n\t\t\t\t\t\"discard;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_FragColor = vec4( diffuse, opacity );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"color_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'depth': {\n\n\t\tuniforms: {\n\n\t\t\t\"mNear\": { type: \"f\", value: 1.0 },\n\t\t\t\"mFar\" : { type: \"f\", value: 2000.0 },\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float mNear;\",\n\t\t\t\"uniform float mFar;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"float depth = gl_FragCoord.z / gl_FragCoord.w;\",\n\t\t\t\t\"float color = 1.0 - smoothstep( mNear, mFar, depth );\",\n\t\t\t\t\"gl_FragColor = vec4( vec3( color ), opacity );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t'normal': {\n\n\t\tuniforms: {\n\n\t\t\t\"opacity\" : { type: \"f\", value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec3 vNormal;\",\n\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform float opacity;\",\n\t\t\t\"varying vec3 vNormal;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tNormal map shader\n\t//\t\t- Blinn-Phong\n\t//\t\t- normal + diffuse + specular + AO + displacement + reflection + shadow maps\n\t//\t\t- point and directional lights (use with \"lights: true\" material option)\n\t ------------------------------------------------------------------------- */\n\n\t'normalmap' : {\n\n\t\tuniforms: THREE.UniformsUtils.merge( [\n\n\t\t\tTHREE.UniformsLib[ \"fog\" ],\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\n\t\t\tTHREE.UniformsLib[ \"shadowmap\" ],\n\n\t\t\t{\n\n\t\t\t\"enableAO\"\t\t  : { type: \"i\", value: 0 },\n\t\t\t\"enableDiffuse\"\t  : { type: \"i\", value: 0 },\n\t\t\t\"enableSpecular\"  : { type: \"i\", value: 0 },\n\t\t\t\"enableReflection\": { type: \"i\", value: 0 },\n\t\t\t\"enableDisplacement\": { type: \"i\", value: 0 },\n\n\t\t\t\"tDisplacement\": { type: \"t\", value: null }, // must go first as this is vertex texture\n\t\t\t\"tDiffuse\"\t   : { type: \"t\", value: null },\n\t\t\t\"tCube\"\t\t   : { type: \"t\", value: null },\n\t\t\t\"tNormal\"\t   : { type: \"t\", value: null },\n\t\t\t\"tSpecular\"\t   : { type: \"t\", value: null },\n\t\t\t\"tAO\"\t\t   : { type: \"t\", value: null },\n\n\t\t\t\"uNormalScale\": { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\n\n\t\t\t\"uDisplacementBias\": { type: \"f\", value: 0.0 },\n\t\t\t\"uDisplacementScale\": { type: \"f\", value: 1.0 },\n\n\t\t\t\"diffuse\": { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\t\t\t\"specular\": { type: \"c\", value: new THREE.Color( 0x111111 ) },\n\t\t\t\"ambient\": { type: \"c\", value: new THREE.Color( 0xffffff ) },\n\t\t\t\"shininess\": { type: \"f\", value: 30 },\n\t\t\t\"opacity\": { type: \"f\", value: 1 },\n\n\t\t\t\"useRefract\": { type: \"i\", value: 0 },\n\t\t\t\"refractionRatio\": { type: \"f\", value: 0.98 },\n\t\t\t\"reflectivity\": { type: \"f\", value: 0.5 },\n\n\t\t\t\"uOffset\" : { type: \"v2\", value: new THREE.Vector2( 0, 0 ) },\n\t\t\t\"uRepeat\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\n\n\t\t\t\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\n\t\t\t}\n\n\t\t] ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform vec3 ambient;\",\n\t\t\t\"uniform vec3 diffuse;\",\n\t\t\t\"uniform vec3 specular;\",\n\t\t\t\"uniform float shininess;\",\n\t\t\t\"uniform float opacity;\",\n\n\t\t\t\"uniform bool enableDiffuse;\",\n\t\t\t\"uniform bool enableSpecular;\",\n\t\t\t\"uniform bool enableAO;\",\n\t\t\t\"uniform bool enableReflection;\",\n\n\t\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\t\"uniform sampler2D tNormal;\",\n\t\t\t\"uniform sampler2D tSpecular;\",\n\t\t\t\"uniform sampler2D tAO;\",\n\n\t\t\t\"uniform samplerCube tCube;\",\n\n\t\t\t\"uniform vec2 uNormalScale;\",\n\n\t\t\t\"uniform bool useRefract;\",\n\t\t\t\"uniform float refractionRatio;\",\n\t\t\t\"uniform float reflectivity;\",\n\n\t\t\t\"varying vec3 vTangent;\",\n\t\t\t\"varying vec3 vBinormal;\",\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"uniform vec3 ambientLightColor;\",\n\n\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\t\"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\t\"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\t\"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\",\n\t\t\t\t\"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\t\"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\",\n\t\t\t\t\"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\"uniform vec3 wrapRGB;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\n\t\t\tTHREE.ShaderChunk[ \"fog_pars_fragment\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = vec4( vec3( 1.0 ), opacity );\",\n\n\t\t\t\t\"vec3 specularTex = vec3( 1.0 );\",\n\n\t\t\t\t\"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\",\n\t\t\t\t\"normalTex.xy *= uNormalScale;\",\n\t\t\t\t\"normalTex = normalize( normalTex );\",\n\n\t\t\t\t\"if( enableDiffuse ) {\",\n\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\t\t\"vec4 texelColor = texture2D( tDiffuse, vUv );\",\n\t\t\t\t\t\t\"texelColor.xyz *= texelColor.xyz;\",\n\n\t\t\t\t\t\t\"gl_FragColor = gl_FragColor * texelColor;\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"if( enableAO ) {\",\n\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\t\t\"vec4 aoColor = texture2D( tAO, vUv );\",\n\t\t\t\t\t\t\"aoColor.xyz *= aoColor.xyz;\",\n\n\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"if( enableSpecular )\",\n\t\t\t\t\t\"specularTex = texture2D( tSpecular, vUv ).xyz;\",\n\n\t\t\t\t\"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\",\n\t\t\t\t\"vec3 finalNormal = tsb * normalTex;\",\n\n\t\t\t\t\"#ifdef FLIP_SIDED\",\n\n\t\t\t\t\t\"finalNormal = -finalNormal;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"vec3 normal = normalize( finalNormal );\",\n\t\t\t\t\"vec3 viewPosition = normalize( vViewPosition );\",\n\n\t\t\t\t// point lights\n\n\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\t\t\"vec3 pointDiffuse = vec3( 0.0 );\",\n\t\t\t\t\t\"vec3 pointSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\t\"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\t\"vec3 pointVector = lPosition.xyz + vViewPosition.xyz;\",\n\n\t\t\t\t\t\t\"float pointDistance = 1.0;\",\n\t\t\t\t\t\t\"if ( pointLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\t\"pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\t\"pointVector = normalize( pointVector );\",\n\n\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\t\"float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\",\n\t\t\t\t\t\t\t\"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\",\n\n\t\t\t\t\t\t\t\"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\"pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\",\n\n\t\t\t\t\t\t// specular\n\n\t\t\t\t\t\t\"vec3 pointHalfVector = normalize( pointVector + viewPosition );\",\n\t\t\t\t\t\t\"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\",\n\t\t\t\t\t\t\"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\",\n\t\t\t\t\t\t\"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// spot lights\n\n\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\t\t\"vec3 spotDiffuse = vec3( 0.0 );\",\n\t\t\t\t\t\"vec3 spotSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\t\"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\",\n\t\t\t\t\t\t\"vec3 spotVector = lPosition.xyz + vViewPosition.xyz;\",\n\n\t\t\t\t\t\t\"float spotDistance = 1.0;\",\n\t\t\t\t\t\t\"if ( spotLightDistance[ i ] > 0.0 )\",\n\t\t\t\t\t\t\t\"spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\",\n\n\t\t\t\t\t\t\"spotVector = normalize( spotVector );\",\n\n\t\t\t\t\t\t\"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\",\n\n\t\t\t\t\t\t\"if ( spotEffect > spotLightAngleCos[ i ] ) {\",\n\n\t\t\t\t\t\t\t\"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\",\n\n\t\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\",\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\",\n\n\t\t\t\t\t\t\t\t\"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\",\n\n\t\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\t\"float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\",\n\n\t\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\t\"spotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\",\n\n\t\t\t\t\t\t\t// specular\n\n\t\t\t\t\t\t\t\"vec3 spotHalfVector = normalize( spotVector + viewPosition );\",\n\t\t\t\t\t\t\t\"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\",\n\t\t\t\t\t\t\t\"float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\",\n\t\t\t\t\t\t\t\"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\",\n\n\t\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// directional lights\n\n\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\t\t\"vec3 dirDiffuse = vec3( 0.0 );\",\n\t\t\t\t\t\"vec3 dirSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\t\"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\",\n\n\t\t\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\",\n\t\t\t\t\t\t\"vec3 dirVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\"#ifdef WRAP_AROUND\",\n\n\t\t\t\t\t\t\t\"float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\",\n\t\t\t\t\t\t\t\"float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\",\n\n\t\t\t\t\t\t\t\"vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\",\n\n\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\t\"dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\",\n\n\t\t\t\t\t\t// specular\n\n\t\t\t\t\t\t\"vec3 dirHalfVector = normalize( dirVector + viewPosition );\",\n\t\t\t\t\t\t\"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\",\n\t\t\t\t\t\t\"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\",\n\n\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\",\n\t\t\t\t\t\t\"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// hemisphere lights\n\n\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\t\t\"vec3 hemiDiffuse  = vec3( 0.0 );\",\n\t\t\t\t\t\"vec3 hemiSpecular = vec3( 0.0 );\" ,\n\n\t\t\t\t\t\"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\",\n\t\t\t\t\t\t\"vec3 lVector = normalize( lDirection.xyz );\",\n\n\t\t\t\t\t\t// diffuse\n\n\t\t\t\t\t\t\"float dotProduct = dot( normal, lVector );\",\n\t\t\t\t\t\t\"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\",\n\n\t\t\t\t\t\t\"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\",\n\n\t\t\t\t\t\t\"hemiDiffuse += diffuse * hemiColor;\",\n\n\t\t\t\t\t\t// specular (sky light)\n\n\n\t\t\t\t\t\t\"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\",\n\t\t\t\t\t\t\"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\",\n\t\t\t\t\t\t\"float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\",\n\n\t\t\t\t\t\t// specular (ground light)\n\n\t\t\t\t\t\t\"vec3 lVectorGround = -lVector;\",\n\n\t\t\t\t\t\t\"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\",\n\t\t\t\t\t\t\"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\",\n\t\t\t\t\t\t\"float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\",\n\n\t\t\t\t\t\t\"float dotProductGround = dot( normal, lVectorGround );\",\n\n\t\t\t\t\t\t// 2.0 => 2.0001 is hack to work around ANGLE bug\n\n\t\t\t\t\t\t\"float specularNormalization = ( shininess + 2.0001 ) / 8.0;\",\n\n\t\t\t\t\t\t\"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\",\n\t\t\t\t\t\t\"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\",\n\t\t\t\t\t\t\"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t// all lights contribution summation\n\n\t\t\t\t\"vec3 totalDiffuse = vec3( 0.0 );\",\n\t\t\t\t\"vec3 totalSpecular = vec3( 0.0 );\",\n\n\t\t\t\t\"#if MAX_DIR_LIGHTS > 0\",\n\n\t\t\t\t\t\"totalDiffuse += dirDiffuse;\",\n\t\t\t\t\t\"totalSpecular += dirSpecular;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#if MAX_HEMI_LIGHTS > 0\",\n\n\t\t\t\t\t\"totalDiffuse += hemiDiffuse;\",\n\t\t\t\t\t\"totalSpecular += hemiSpecular;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#if MAX_POINT_LIGHTS > 0\",\n\n\t\t\t\t\t\"totalDiffuse += pointDiffuse;\",\n\t\t\t\t\t\"totalSpecular += pointSpecular;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#if MAX_SPOT_LIGHTS > 0\",\n\n\t\t\t\t\t\"totalDiffuse += spotDiffuse;\",\n\t\t\t\t\t\"totalSpecular += spotSpecular;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#ifdef METAL\",\n\n\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"if ( enableReflection ) {\",\n\n\t\t\t\t\t\"vec3 vReflect;\",\n\t\t\t\t\t\"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\",\n\n\t\t\t\t\t\"if ( useRefract ) {\",\n\n\t\t\t\t\t\t\"vReflect = refract( cameraToVertex, normal, refractionRatio );\",\n\n\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\"vReflect = reflect( cameraToVertex, normal );\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\t\"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\n\n\t\t\t\t\t\"#ifdef GAMMA_INPUT\",\n\n\t\t\t\t\t\t\"cubeColor.xyz *= cubeColor.xyz;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"shadowmap_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"fog_fragment\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tvertexShader: [\n\n\t\t\t\"attribute vec4 tangent;\",\n\n\t\t\t\"uniform vec2 uOffset;\",\n\t\t\t\"uniform vec2 uRepeat;\",\n\n\t\t\t\"uniform bool enableDisplacement;\",\n\n\t\t\t\"#ifdef VERTEX_TEXTURES\",\n\n\t\t\t\t\"uniform sampler2D tDisplacement;\",\n\t\t\t\t\"uniform float uDisplacementScale;\",\n\t\t\t\t\"uniform float uDisplacementBias;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"varying vec3 vTangent;\",\n\t\t\t\"varying vec3 vBinormal;\",\n\t\t\t\"varying vec3 vNormal;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\t\t\t\"varying vec3 vViewPosition;\",\n\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinnormal_vertex\" ],\n\n\t\t\t\t// normal, tangent and binormal vectors\n\n\t\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\t\"vNormal = normalize( normalMatrix * skinnedNormal.xyz );\",\n\n\t\t\t\t\t\"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\",\n\t\t\t\t\t\"vTangent = normalize( normalMatrix * skinnedTangent.xyz );\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"vNormal = normalize( normalMatrix * normal );\",\n\t\t\t\t\t\"vTangent = normalize( normalMatrix * tangent.xyz );\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t\"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\",\n\n\t\t\t\t\"vUv = uv * uRepeat + uOffset;\",\n\n\t\t\t\t// displacement mapping\n\n\t\t\t\t\"vec3 displacedPosition;\",\n\n\t\t\t\t\"#ifdef VERTEX_TEXTURES\",\n\n\t\t\t\t\t\"if ( enableDisplacement ) {\",\n\n\t\t\t\t\t\t\"vec3 dv = texture2D( tDisplacement, uv ).xyz;\",\n\t\t\t\t\t\t\"float df = uDisplacementScale * dv.x + uDisplacementBias;\",\n\t\t\t\t\t\t\"displacedPosition = position + normalize( normal ) * df;\",\n\n\t\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\n\n\t\t\t\t\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n\t\t\t\t\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n\n\t\t\t\t\t\t\t\"displacedPosition  = skinned.xyz;\",\n\n\t\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\t\"displacedPosition = position;\",\n\n\t\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\t\t\"vec4 skinVertex = vec4( position, 1.0 );\",\n\n\t\t\t\t\t\t\"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;\",\n\t\t\t\t\t\t\"skinned \t  += boneMatY * skinVertex * skinWeight.y;\",\n\n\t\t\t\t\t\t\"displacedPosition  = skinned.xyz;\",\n\n\t\t\t\t\t\"#else\",\n\n\t\t\t\t\t\t\"displacedPosition = position;\",\n\n\t\t\t\t\t\"#endif\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\t//\n\n\t\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\",\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\t\t//\n\n\t\t\t\t\"vWorldPosition = worldPosition.xyz;\",\n\t\t\t\t\"vViewPosition = -mvPosition.xyz;\",\n\n\t\t\t\t// shadows\n\n\t\t\t\t\"#ifdef USE_SHADOWMAP\",\n\n\t\t\t\t\t\"for( int i = 0; i < MAX_SHADOWS; i ++ ) {\",\n\n\t\t\t\t\t\t\"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\",\n\n\t\t\t\t\t\"}\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t/* -------------------------------------------------------------------------\n\t//\tCube map shader\n\t ------------------------------------------------------------------------- */\n\n\t'cube': {\n\n\t\tuniforms: { \"tCube\": { type: \"t\", value: null },\n\t\t\t\t\t\"tFlip\": { type: \"f\", value: -1 } },\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\t\t\t\t\"vWorldPosition = worldPosition.xyz;\",\n\n\t\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform samplerCube tCube;\",\n\t\t\t\"uniform float tFlip;\",\n\n\t\t\t\"varying vec3 vWorldPosition;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t},\n\n\t// Depth encoding into RGBA texture\n\t// \tbased on SpiderGL shadow map example\n\t// \t\thttp://spidergl.org/example.php?id=6\n\t// \toriginally from\n\t//\t\thttp://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\n\t// \tsee also here:\n\t//\t\thttp://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n\n\t'depthRGBA': {\n\n\t\tuniforms: {},\n\n\t\tvertexShader: [\n\n\t\t\tTHREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\n\t\t\tTHREE.ShaderChunk[ \"skinning_pars_vertex\" ],\n\n\t\t\t\"void main() {\",\n\n\t\t\t\tTHREE.ShaderChunk[ \"skinbase_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"morphtarget_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"skinning_vertex\" ],\n\t\t\t\tTHREE.ShaderChunk[ \"default_vertex\" ],\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"vec4 pack_depth( const in float depth ) {\",\n\n\t\t\t\t\"const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\n\t\t\t\t\"const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\n\t\t\t\t\"vec4 res = fract( depth * bit_shift );\",\n\t\t\t\t\"res -= res.xxyz * bit_mask;\",\n\t\t\t\t\"return res;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\",\n\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\n\t\t\t\t//\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\n\t\t\t\t//\"gl_FragData[ 0 ] = pack_depth( z );\",\n\t\t\t\t//\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t}\n\n};\n\n/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author szimek / https://github.com/szimek/\n */\n\nTHREE.WebGLRenderer = function ( parameters ) {\n\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\n\n\tparameters = parameters || {};\n\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\n\n\t_precision = parameters.precision !== undefined ? parameters.precision : 'highp',\n\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\n\n\t_clearColor = new THREE.Color( 0x000000 ),\n\t_clearAlpha = 0;\n\n\t// public properties\n\n\tthis.domElement = _canvas;\n\tthis.context = null;\n\tthis.devicePixelRatio = parameters.devicePixelRatio !== undefined\n\t\t\t\t? parameters.devicePixelRatio\n\t\t\t\t: self.devicePixelRatio !== undefined\n\t\t\t\t\t? self.devicePixelRatio\n\t\t\t\t\t: 1;\n\n\t// clearing\n\n\tthis.autoClear = true;\n\tthis.autoClearColor = true;\n\tthis.autoClearDepth = true;\n\tthis.autoClearStencil = true;\n\n\t// scene graph\n\n\tthis.sortObjects = true;\n\tthis.autoUpdateObjects = true;\n\n\t// physically based shading\n\n\tthis.gammaInput = false;\n\tthis.gammaOutput = false;\n\n\t// shadow map\n\n\tthis.shadowMapEnabled = false;\n\tthis.shadowMapAutoUpdate = true;\n\tthis.shadowMapType = THREE.PCFShadowMap;\n\tthis.shadowMapCullFace = THREE.CullFaceFront;\n\tthis.shadowMapDebug = false;\n\tthis.shadowMapCascade = false;\n\n\t// morphs\n\n\tthis.maxMorphTargets = 8;\n\tthis.maxMorphNormals = 4;\n\n\t// flags\n\n\tthis.autoScaleCubemaps = true;\n\n\t// custom render plugins\n\n\tthis.renderPluginsPre = [];\n\tthis.renderPluginsPost = [];\n\n\t// info\n\n\tthis.info = {\n\n\t\tmemory: {\n\n\t\t\tprograms: 0,\n\t\t\tgeometries: 0,\n\t\t\ttextures: 0\n\n\t\t},\n\n\t\trender: {\n\n\t\t\tcalls: 0,\n\t\t\tvertices: 0,\n\t\t\tfaces: 0,\n\t\t\tpoints: 0\n\n\t\t}\n\n\t};\n\n\t// internal properties\n\n\tvar _this = this,\n\n\t_programs = [],\n\t_programs_counter = 0,\n\n\t// internal state cache\n\n\t_currentProgram = null,\n\t_currentFramebuffer = null,\n\t_currentMaterialId = -1,\n\t_currentGeometryGroupHash = null,\n\t_currentCamera = null,\n\t_geometryGroupCounter = 0,\n\n\t_usedTextureUnits = 0,\n\n\t// GL state cache\n\n\t_oldDoubleSided = -1,\n\t_oldFlipSided = -1,\n\n\t_oldBlending = -1,\n\n\t_oldBlendEquation = -1,\n\t_oldBlendSrc = -1,\n\t_oldBlendDst = -1,\n\n\t_oldDepthTest = -1,\n\t_oldDepthWrite = -1,\n\n\t_oldPolygonOffset = null,\n\t_oldPolygonOffsetFactor = null,\n\t_oldPolygonOffsetUnits = null,\n\n\t_oldLineWidth = null,\n\n\t_viewportX = 0,\n\t_viewportY = 0,\n\t_viewportWidth = _canvas.width,\n\t_viewportHeight = _canvas.height,\n\t_currentWidth = 0,\n\t_currentHeight = 0,\n\n\t_enabledAttributes = {},\n\n\t// frustum\n\n\t_frustum = new THREE.Frustum(),\n\n\t // camera matrices cache\n\n\t_projScreenMatrix = new THREE.Matrix4(),\n\t_projScreenMatrixPS = new THREE.Matrix4(),\n\n\t_vector3 = new THREE.Vector3(),\n\n\t// light arrays cache\n\n\t_direction = new THREE.Vector3(),\n\n\t_lightsNeedUpdate = true,\n\n\t_lights = {\n\n\t\tambient: [ 0, 0, 0 ],\n\t\tdirectional: { length: 0, colors: new Array(), positions: new Array() },\n\t\tpoint: { length: 0, colors: new Array(), positions: new Array(), distances: new Array() },\n\t\tspot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), directions: new Array(), anglesCos: new Array(), exponents: new Array() },\n\t\themi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() }\n\n\t};\n\n\t// initialize\n\n\tvar _gl;\n\n\tvar _glExtensionTextureFloat;\n\tvar _glExtensionTextureFloatLinear;\n\tvar _glExtensionStandardDerivatives;\n\tvar _glExtensionTextureFilterAnisotropic;\n\tvar _glExtensionCompressedTextureS3TC;\n\n\tinitGL();\n\n\tsetDefaultGLState();\n\n\tthis.context = _gl;\n\n\t// GPU capabilities\n\n\tvar _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );\n\tvar _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\n\tvar _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );\n\tvar _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n\tvar _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;\n\n\tvar _supportsVertexTextures = ( _maxVertexTextures > 0 );\n\tvar _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;\n\n\tvar _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];\n\n\t//\n\n\tvar _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );\n\tvar _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );\n\tvar _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );\n\n\tvar _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );\n\tvar _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );\n\tvar _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );\n\n\tvar _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_INT );\n\tvar _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_INT );\n\tvar _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_INT );\n\n\tvar _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_INT );\n\tvar _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_INT );\n\tvar _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_INT );\n\n\t// clamp precision to maximum available\n\n\tvar highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;\n\tvar mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;\n\n\tif ( _precision === \"highp\" && ! highpAvailable ) {\n\n\t\tif ( mediumpAvailable ) {\n\n\t\t\t_precision = \"mediump\";\n\t\t\tconsole.warn( \"WebGLRenderer: highp not supported, using mediump\" );\n\n\t\t} else {\n\n\t\t\t_precision = \"lowp\";\n\t\t\tconsole.warn( \"WebGLRenderer: highp and mediump not supported, using lowp\" );\n\n\t\t}\n\n\t}\n\n\tif ( _precision === \"mediump\" && ! mediumpAvailable ) {\n\n\t\t_precision = \"lowp\";\n\t\tconsole.warn( \"WebGLRenderer: mediump not supported, using lowp\" );\n\n\t}\n\n\t// API\n\n\tthis.getContext = function () {\n\n\t\treturn _gl;\n\n\t};\n\n\tthis.supportsVertexTextures = function () {\n\n\t\treturn _supportsVertexTextures;\n\n\t};\n\n\tthis.supportsFloatTextures = function () {\n\n\t\treturn _glExtensionTextureFloat;\n\n\t};\n\n\tthis.supportsStandardDerivatives = function () {\n\n\t\treturn _glExtensionStandardDerivatives;\n\n\t};\n\n\tthis.supportsCompressedTextureS3TC = function () {\n\n\t\treturn _glExtensionCompressedTextureS3TC;\n\n\t};\n\n\tthis.getMaxAnisotropy  = function () {\n\n\t\treturn _maxAnisotropy;\n\n\t};\n\n\tthis.getPrecision = function () {\n\n\t\treturn _precision;\n\n\t};\n\n\tthis.setSize = function ( width, height, updateStyle ) {\n\n\t\t_canvas.width = width * this.devicePixelRatio;\n\t\t_canvas.height = height * this.devicePixelRatio;\n\n\t\tif ( this.devicePixelRatio !== 1 && updateStyle !== false ) {\n\n\t\t\t_canvas.style.width = width + 'px';\n\t\t\t_canvas.style.height = height + 'px';\n\n\t\t}\n\n\t\tthis.setViewport( 0, 0, _canvas.width, _canvas.height );\n\n\t};\n\n\tthis.setViewport = function ( x, y, width, height ) {\n\n\t\t_viewportX = x !== undefined ? x : 0;\n\t\t_viewportY = y !== undefined ? y : 0;\n\n\t\t_viewportWidth = width !== undefined ? width : _canvas.width;\n\t\t_viewportHeight = height !== undefined ? height : _canvas.height;\n\n\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\n\n\t};\n\n\tthis.setScissor = function ( x, y, width, height ) {\n\n\t\t_gl.scissor( x, y, width, height );\n\n\t};\n\n\tthis.enableScissorTest = function ( enable ) {\n\n\t\tenable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );\n\n\t};\n\n\t// Clearing\n\n\tthis.setClearColor = function ( color, alpha ) {\n\n\t\t_clearColor.set( color );\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\n\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\tthis.setClearColorHex = function ( hex, alpha ) {\n\n\t\tconsole.warn( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );\n\t\tthis.setClearColor( hex, alpha );\n\n\t};\n\n\tthis.getClearColor = function () {\n\n\t\treturn _clearColor;\n\n\t};\n\n\tthis.getClearAlpha = function () {\n\n\t\treturn _clearAlpha;\n\n\t};\n\n\tthis.clear = function ( color, depth, stencil ) {\n\n\t\tvar bits = 0;\n\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\n\n\t\t_gl.clear( bits );\n\n\t};\n\n\tthis.clearColor = function () {\n\n\t\t_gl.clear( _gl.COLOR_BUFFER_BIT );\n\n\t};\n\n\tthis.clearDepth = function () {\n\n\t\t_gl.clear( _gl.DEPTH_BUFFER_BIT );\n\n\t};\n\n\tthis.clearStencil = function () {\n\n\t\t_gl.clear( _gl.STENCIL_BUFFER_BIT );\n\n\t};\n\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\n\n\t\tthis.setRenderTarget( renderTarget );\n\t\tthis.clear( color, depth, stencil );\n\n\t};\n\n\t// Plugins\n\n\tthis.addPostPlugin = function ( plugin ) {\n\n\t\tplugin.init( this );\n\t\tthis.renderPluginsPost.push( plugin );\n\n\t};\n\n\tthis.addPrePlugin = function ( plugin ) {\n\n\t\tplugin.init( this );\n\t\tthis.renderPluginsPre.push( plugin );\n\n\t};\n\n\t// Rendering\n\n\tthis.updateShadowMap = function ( scene, camera ) {\n\n\t\t_currentProgram = null;\n\t\t_oldBlending = -1;\n\t\t_oldDepthTest = -1;\n\t\t_oldDepthWrite = -1;\n\t\t_currentGeometryGroupHash = -1;\n\t\t_currentMaterialId = -1;\n\t\t_lightsNeedUpdate = true;\n\t\t_oldDoubleSided = -1;\n\t\t_oldFlipSided = -1;\n\n\t\tthis.shadowMapPlugin.update( scene, camera );\n\n\t};\n\n\t// Internal functions\n\n\t// Buffer allocation\n\n\tfunction createParticleBuffers ( geometry ) {\n\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\n\n\t\t_this.info.memory.geometries ++;\n\n\t};\n\n\tfunction createLineBuffers ( geometry ) {\n\n\t\tgeometry.__webglVertexBuffer = _gl.createBuffer();\n\t\tgeometry.__webglColorBuffer = _gl.createBuffer();\n\t\tgeometry.__webglLineDistanceBuffer = _gl.createBuffer();\n\n\t\t_this.info.memory.geometries ++;\n\n\t};\n\n\tfunction createMeshBuffers ( geometryGroup ) {\n\n\t\tgeometryGroup.__webglVertexBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglNormalBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglTangentBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglColorBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglUVBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglUV2Buffer = _gl.createBuffer();\n\n\t\tgeometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();\n\n\t\tgeometryGroup.__webglFaceBuffer = _gl.createBuffer();\n\t\tgeometryGroup.__webglLineBuffer = _gl.createBuffer();\n\n\t\tvar m, ml;\n\n\t\tif ( geometryGroup.numMorphTargets ) {\n\n\t\t\tgeometryGroup.__webglMorphTargetsBuffers = [];\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\n\t\t\t\tgeometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( geometryGroup.numMorphNormals ) {\n\n\t\t\tgeometryGroup.__webglMorphNormalsBuffers = [];\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\n\t\t\t\tgeometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_this.info.memory.geometries ++;\n\n\t};\n\n\t// Events\n\n\tvar onGeometryDispose = function ( event ) {\n\n\t\tvar geometry = event.target;\n\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\n\n\t\tdeallocateGeometry( geometry );\n\n\t};\n\n\tvar onTextureDispose = function ( event ) {\n\n\t\tvar texture = event.target;\n\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\n\n\t\tdeallocateTexture( texture );\n\n\t\t_this.info.memory.textures --;\n\n\n\t};\n\n\tvar onRenderTargetDispose = function ( event ) {\n\n\t\tvar renderTarget = event.target;\n\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\n\n\t\tdeallocateRenderTarget( renderTarget );\n\n\t\t_this.info.memory.textures --;\n\n\t};\n\n\tvar onMaterialDispose = function ( event ) {\n\n\t\tvar material = event.target;\n\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\n\n\t\tdeallocateMaterial( material );\n\n\t};\n\n\t// Buffer deallocation\n\n\tvar deleteBuffers = function ( geometry ) {\n\n\t\tif ( geometry.__webglVertexBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglVertexBuffer );\n\t\tif ( geometry.__webglNormalBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglNormalBuffer );\n\t\tif ( geometry.__webglTangentBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglTangentBuffer );\n\t\tif ( geometry.__webglColorBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglColorBuffer );\n\t\tif ( geometry.__webglUVBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglUVBuffer );\n\t\tif ( geometry.__webglUV2Buffer !== undefined ) _gl.deleteBuffer( geometry.__webglUV2Buffer );\n\n\t\tif ( geometry.__webglSkinIndicesBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );\n\t\tif ( geometry.__webglSkinWeightsBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );\n\n\t\tif ( geometry.__webglFaceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglFaceBuffer );\n\t\tif ( geometry.__webglLineBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineBuffer );\n\n\t\tif ( geometry.__webglLineDistanceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );\n\t\t// custom attributes\n\n\t\tif ( geometry.__webglCustomAttributesList !== undefined ) {\n\n\t\t\tfor ( var id in geometry.__webglCustomAttributesList ) {\n\n\t\t\t\t_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );\n\n\t\t\t}\n\n\t\t}\n\n\t\t_this.info.memory.geometries --;\n\n\t};\n\n\tvar deallocateGeometry = function ( geometry ) {\n\n\t\tgeometry.__webglInit = undefined;\n\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tvar attributes = geometry.attributes;\n\n\t\t\tfor ( var key in attributes ) {\n\n\t\t\t\tif ( attributes[ key ].buffer !== undefined ) {\n\n\t\t\t\t\t_gl.deleteBuffer( attributes[ key ].buffer );\n\t\t\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_this.info.memory.geometries --;\n\n\t\t} else {\n\n\t\t\tif ( geometry.geometryGroups !== undefined ) {\n\n\t\t\t\tfor ( var g in geometry.geometryGroups ) {\n\n\t\t\t\t\tvar geometryGroup = geometry.geometryGroups[ g ];\n\n\t\t\t\t\tif ( geometryGroup.numMorphTargets !== undefined ) {\n\n\t\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( geometryGroup.numMorphNormals !== undefined ) {\n\n\t\t\t\t\t\tfor ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\t_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdeleteBuffers( geometryGroup );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdeleteBuffers( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tvar deallocateTexture = function ( texture ) {\n\n\t\tif ( texture.image && texture.image.__webglTextureCube ) {\n\n\t\t\t// cube texture\n\n\t\t\t_gl.deleteTexture( texture.image.__webglTextureCube );\n\n\t\t} else {\n\n\t\t\t// 2D texture\n\n\t\t\tif ( ! texture.__webglInit ) return;\n\n\t\t\ttexture.__webglInit = false;\n\t\t\t_gl.deleteTexture( texture.__webglTexture );\n\n\t\t}\n\n\t};\n\n\tvar deallocateRenderTarget = function ( renderTarget ) {\n\n\t\tif ( !renderTarget || ! renderTarget.__webglTexture ) return;\n\n\t\t_gl.deleteTexture( renderTarget.__webglTexture );\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );\n\t\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );\n\t\t\t_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );\n\n\t\t}\n\n\t};\n\n\tvar deallocateMaterial = function ( material ) {\n\n\t\tvar program = material.program;\n\n\t\tif ( program === undefined ) return;\n\n\t\tmaterial.program = undefined;\n\n\t\t// only deallocate GL program if this was the last use of shared program\n\t\t// assumed there is only single copy of any program in the _programs list\n\t\t// (that's how it's constructed)\n\n\t\tvar i, il, programInfo;\n\t\tvar deleteProgram = false;\n\n\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\n\n\t\t\tprogramInfo = _programs[ i ];\n\n\t\t\tif ( programInfo.program === program ) {\n\n\t\t\t\tprogramInfo.usedTimes --;\n\n\t\t\t\tif ( programInfo.usedTimes === 0 ) {\n\n\t\t\t\t\tdeleteProgram = true;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( deleteProgram === true ) {\n\n\t\t\t// avoid using array.splice, this is costlier than creating new array from scratch\n\n\t\t\tvar newPrograms = [];\n\n\t\t\tfor ( i = 0, il = _programs.length; i < il; i ++ ) {\n\n\t\t\t\tprogramInfo = _programs[ i ];\n\n\t\t\t\tif ( programInfo.program !== program ) {\n\n\t\t\t\t\tnewPrograms.push( programInfo );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_programs = newPrograms;\n\n\t\t\t_gl.deleteProgram( program );\n\n\t\t\t_this.info.memory.programs --;\n\n\t\t}\n\n\t};\n\n\t// Buffer initialization\n\n\tfunction initCustomAttributes ( geometry, object ) {\n\n\t\tvar nvertices = geometry.vertices.length;\n\n\t\tvar material = object.material;\n\n\t\tif ( material.attributes ) {\n\n\t\t\tif ( geometry.__webglCustomAttributesList === undefined ) {\n\n\t\t\t\tgeometry.__webglCustomAttributesList = [];\n\n\t\t\t}\n\n\t\t\tfor ( var a in material.attributes ) {\n\n\t\t\t\tvar attribute = material.attributes[ a ];\n\n\t\t\t\tif ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {\n\n\t\t\t\t\tattribute.__webglInitialized = true;\n\n\t\t\t\t\tvar size = 1;\t\t// \"f\" and \"i\"\n\n\t\t\t\t\tif ( attribute.type === \"v2\" ) size = 2;\n\t\t\t\t\telse if ( attribute.type === \"v3\" ) size = 3;\n\t\t\t\t\telse if ( attribute.type === \"v4\" ) size = 4;\n\t\t\t\t\telse if ( attribute.type === \"c\"  ) size = 3;\n\n\t\t\t\t\tattribute.size = size;\n\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\n\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\n\t\t\t\t\tattribute.buffer.belongsToAttribute = a;\n\n\t\t\t\t\tattribute.needsUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.__webglCustomAttributesList.push( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction initParticleBuffers ( geometry, object ) {\n\n\t\tvar nvertices = geometry.vertices.length;\n\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\n\n\t\tgeometry.__sortArray = [];\n\n\t\tgeometry.__webglParticleCount = nvertices;\n\n\t\tinitCustomAttributes ( geometry, object );\n\n\t};\n\n\tfunction initLineBuffers ( geometry, object ) {\n\n\t\tvar nvertices = geometry.vertices.length;\n\n\t\tgeometry.__vertexArray = new Float32Array( nvertices * 3 );\n\t\tgeometry.__colorArray = new Float32Array( nvertices * 3 );\n\t\tgeometry.__lineDistanceArray = new Float32Array( nvertices * 1 );\n\n\t\tgeometry.__webglLineCount = nvertices;\n\n\t\tinitCustomAttributes ( geometry, object );\n\n\t};\n\n\tfunction initMeshBuffers ( geometryGroup, object ) {\n\n\t\tvar geometry = object.geometry,\n\t\t\tfaces3 = geometryGroup.faces3,\n\n\t\t\tnvertices = faces3.length * 3,\n\t\t\tntris     = faces3.length * 1,\n\t\t\tnlines    = faces3.length * 3,\n\n\t\t\tmaterial = getBufferMaterial( object, geometryGroup ),\n\n\t\t\tuvType = bufferGuessUVType( material ),\n\t\t\tnormalType = bufferGuessNormalType( material ),\n\t\t\tvertexColorType = bufferGuessVertexColorType( material );\n\n\t\t// console.log( \"uvType\", uvType, \"normalType\", normalType, \"vertexColorType\", vertexColorType, object, geometryGroup, material );\n\n\t\tgeometryGroup.__vertexArray = new Float32Array( nvertices * 3 );\n\n\t\tif ( normalType ) {\n\n\t\t\tgeometryGroup.__normalArray = new Float32Array( nvertices * 3 );\n\n\t\t}\n\n\t\tif ( geometry.hasTangents ) {\n\n\t\t\tgeometryGroup.__tangentArray = new Float32Array( nvertices * 4 );\n\n\t\t}\n\n\t\tif ( vertexColorType ) {\n\n\t\t\tgeometryGroup.__colorArray = new Float32Array( nvertices * 3 );\n\n\t\t}\n\n\t\tif ( uvType ) {\n\n\t\t\tif ( geometry.faceVertexUvs.length > 0 ) {\n\n\t\t\t\tgeometryGroup.__uvArray = new Float32Array( nvertices * 2 );\n\n\t\t\t}\n\n\t\t\tif ( geometry.faceVertexUvs.length > 1 ) {\n\n\t\t\t\tgeometryGroup.__uv2Array = new Float32Array( nvertices * 2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {\n\n\t\t\tgeometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );\n\t\t\tgeometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );\n\n\t\t}\n\n\t\tgeometryGroup.__faceArray = new Uint16Array( ntris * 3 );\n\t\tgeometryGroup.__lineArray = new Uint16Array( nlines * 2 );\n\n\t\tvar m, ml;\n\n\t\tif ( geometryGroup.numMorphTargets ) {\n\n\t\t\tgeometryGroup.__morphTargetsArrays = [];\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\n\n\t\t\t\tgeometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( geometryGroup.numMorphNormals ) {\n\n\t\t\tgeometryGroup.__morphNormalsArrays = [];\n\n\t\t\tfor ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\n\n\t\t\t\tgeometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometryGroup.__webglFaceCount = ntris * 3;\n\t\tgeometryGroup.__webglLineCount = nlines * 2;\n\n\n\t\t// custom attributes\n\n\t\tif ( material.attributes ) {\n\n\t\t\tif ( geometryGroup.__webglCustomAttributesList === undefined ) {\n\n\t\t\t\tgeometryGroup.__webglCustomAttributesList = [];\n\n\t\t\t}\n\n\t\t\tfor ( var a in material.attributes ) {\n\n\t\t\t\t// Do a shallow copy of the attribute object so different geometryGroup chunks use different\n\t\t\t\t// attribute buffers which are correctly indexed in the setMeshBuffers function\n\n\t\t\t\tvar originalAttribute = material.attributes[ a ];\n\n\t\t\t\tvar attribute = {};\n\n\t\t\t\tfor ( var property in originalAttribute ) {\n\n\t\t\t\t\tattribute[ property ] = originalAttribute[ property ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {\n\n\t\t\t\t\tattribute.__webglInitialized = true;\n\n\t\t\t\t\tvar size = 1;\t\t// \"f\" and \"i\"\n\n\t\t\t\t\tif( attribute.type === \"v2\" ) size = 2;\n\t\t\t\t\telse if( attribute.type === \"v3\" ) size = 3;\n\t\t\t\t\telse if( attribute.type === \"v4\" ) size = 4;\n\t\t\t\t\telse if( attribute.type === \"c\"  ) size = 3;\n\n\t\t\t\t\tattribute.size = size;\n\n\t\t\t\t\tattribute.array = new Float32Array( nvertices * size );\n\n\t\t\t\t\tattribute.buffer = _gl.createBuffer();\n\t\t\t\t\tattribute.buffer.belongsToAttribute = a;\n\n\t\t\t\t\toriginalAttribute.needsUpdate = true;\n\t\t\t\t\tattribute.__original = originalAttribute;\n\n\t\t\t\t}\n\n\t\t\t\tgeometryGroup.__webglCustomAttributesList.push( attribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometryGroup.__inittedArrays = true;\n\n\t};\n\n\tfunction getBufferMaterial( object, geometryGroup ) {\n\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\n\t\t\t? object.material.materials[ geometryGroup.materialIndex ]\n\t\t\t: object.material;\n\n\t};\n\n\tfunction materialNeedsSmoothNormals ( material ) {\n\n\t\treturn material && material.shading !== undefined && material.shading === THREE.SmoothShading;\n\n\t};\n\n\tfunction bufferGuessNormalType ( material ) {\n\n\t\t// only MeshBasicMaterial and MeshDepthMaterial don't need normals\n\n\t\tif ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\tif ( materialNeedsSmoothNormals( material ) ) {\n\n\t\t\treturn THREE.SmoothShading;\n\n\t\t} else {\n\n\t\t\treturn THREE.FlatShading;\n\n\t\t}\n\n\t};\n\n\tfunction bufferGuessVertexColorType( material ) {\n\n\t\tif ( material.vertexColors ) {\n\n\t\t\treturn material.vertexColors;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n\tfunction bufferGuessUVType( material ) {\n\n\t\t// material must use some texture to require uvs\n\n\t\tif ( material.map ||\n\t\t     material.lightMap ||\n\t\t     material.bumpMap ||\n\t\t     material.normalMap ||\n\t\t     material.specularMap ||\n\t\t     material instanceof THREE.ShaderMaterial ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n\t//\n\n\tfunction initDirectBuffers( geometry ) {\n\n\t\tvar a, attribute, type;\n\n\t\tfor ( a in geometry.attributes ) {\n\n\t\t\tif ( a === \"index\" ) {\n\n\t\t\t\ttype = _gl.ELEMENT_ARRAY_BUFFER;\n\n\t\t\t} else {\n\n\t\t\t\ttype = _gl.ARRAY_BUFFER;\n\n\t\t\t}\n\n\t\t\tattribute = geometry.attributes[ a ];\n\n\t\t\tif ( attribute.numItems === undefined ) {\n\n\t\t\t\tattribute.numItems = attribute.array.length;\n\n\t\t\t}\n\n\t\t\tattribute.buffer = _gl.createBuffer();\n\n\t\t\t_gl.bindBuffer( type, attribute.buffer );\n\t\t\t_gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );\n\n\t\t}\n\n\t};\n\n\t// Buffer setting\n\n\tfunction setParticleBuffers ( geometry, hint, object ) {\n\n\t\tvar v, c, vertex, offset, index, color,\n\n\t\tvertices = geometry.vertices,\n\t\tvl = vertices.length,\n\n\t\tcolors = geometry.colors,\n\t\tcl = colors.length,\n\n\t\tvertexArray = geometry.__vertexArray,\n\t\tcolorArray = geometry.__colorArray,\n\n\t\tsortArray = geometry.__sortArray,\n\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\t\tdirtyElements = geometry.elementsNeedUpdate,\n\t\tdirtyColors = geometry.colorsNeedUpdate,\n\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\n\t\ti, il,\n\t\ta, ca, cal, value,\n\t\tcustomAttribute;\n\n\t\tif ( object.sortParticles ) {\n\n\t\t\t_projScreenMatrixPS.copy( _projScreenMatrix );\n\t\t\t_projScreenMatrixPS.multiply( object.matrixWorld );\n\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\tvertex = vertices[ v ];\n\n\t\t\t\t_vector3.copy( vertex );\n\t\t\t\t_vector3.applyProjection( _projScreenMatrixPS );\n\n\t\t\t\tsortArray[ v ] = [ _vector3.z, v ];\n\n\t\t\t}\n\n\t\t\tsortArray.sort( numericalSort );\n\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\tvertex = vertices[ sortArray[v][1] ];\n\n\t\t\t\toffset = v * 3;\n\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\n\t\t\t\toffset = c * 3;\n\n\t\t\t\tcolor = colors[ sortArray[c][1] ];\n\n\t\t\t\tcolorArray[ offset ]     = color.r;\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\n\t\t\t}\n\n\t\t\tif ( customAttributes ) {\n\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\t\tif ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) ) continue;\n\n\t\t\t\t\toffset = 0;\n\n\t\t\t\t\tcal = customAttribute.value.length;\n\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ index ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\n\t\t\t\t\t\t\toffset += 2;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]     = value.r;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tindex = sortArray[ ca ][ 1 ];\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ index ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\n\t\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( dirtyVertices ) {\n\n\t\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\t\tvertex = vertices[ v ];\n\n\t\t\t\t\toffset = v * 3;\n\n\t\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\t\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\t\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( dirtyColors ) {\n\n\t\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\n\t\t\t\t\tcolor = colors[ c ];\n\n\t\t\t\t\toffset = c * 3;\n\n\t\t\t\t\tcolorArray[ offset ]     = color.r;\n\t\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\t\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( customAttributes ) {\n\n\t\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\t\tif ( customAttribute.needsUpdate &&\n\t\t\t\t\t\t ( customAttribute.boundTo === undefined ||\n\t\t\t\t\t\t   customAttribute.boundTo === \"vertices\") ) {\n\n\t\t\t\t\t\tcal = customAttribute.value.length;\n\n\t\t\t\t\t\toffset = 0;\n\n\t\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\n\t\t\t\t\t\t\t\toffset += 2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\n\t\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\t\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\n\t\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ]      = value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\n\t\t\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyVertices || object.sortParticles ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyColors || object.sortParticles ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\n\t\t}\n\n\t\tif ( customAttributes ) {\n\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\tif ( customAttribute.needsUpdate || object.sortParticles ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t};\n\n\tfunction setLineBuffers ( geometry, hint ) {\n\n\t\tvar v, c, d, vertex, offset, color,\n\n\t\tvertices = geometry.vertices,\n\t\tcolors = geometry.colors,\n\t\tlineDistances = geometry.lineDistances,\n\n\t\tvl = vertices.length,\n\t\tcl = colors.length,\n\t\tdl = lineDistances.length,\n\n\t\tvertexArray = geometry.__vertexArray,\n\t\tcolorArray = geometry.__colorArray,\n\t\tlineDistanceArray = geometry.__lineDistanceArray,\n\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\t\tdirtyColors = geometry.colorsNeedUpdate,\n\t\tdirtyLineDistances = geometry.lineDistancesNeedUpdate,\n\n\t\tcustomAttributes = geometry.__webglCustomAttributesList,\n\n\t\ti, il,\n\t\ta, ca, cal, value,\n\t\tcustomAttribute;\n\n\t\tif ( dirtyVertices ) {\n\n\t\t\tfor ( v = 0; v < vl; v ++ ) {\n\n\t\t\t\tvertex = vertices[ v ];\n\n\t\t\t\toffset = v * 3;\n\n\t\t\t\tvertexArray[ offset ]     = vertex.x;\n\t\t\t\tvertexArray[ offset + 1 ] = vertex.y;\n\t\t\t\tvertexArray[ offset + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyColors ) {\n\n\t\t\tfor ( c = 0; c < cl; c ++ ) {\n\n\t\t\t\tcolor = colors[ c ];\n\n\t\t\t\toffset = c * 3;\n\n\t\t\t\tcolorArray[ offset ]     = color.r;\n\t\t\t\tcolorArray[ offset + 1 ] = color.g;\n\t\t\t\tcolorArray[ offset + 2 ] = color.b;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyLineDistances ) {\n\n\t\t\tfor ( d = 0; d < dl; d ++ ) {\n\n\t\t\t\tlineDistanceArray[ d ] = lineDistances[ d ];\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );\n\n\t\t}\n\n\t\tif ( customAttributes ) {\n\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\tif ( customAttribute.needsUpdate &&\n\t\t\t\t\t ( customAttribute.boundTo === undefined ||\n\t\t\t\t\t   customAttribute.boundTo === \"vertices\" ) ) {\n\n\t\t\t\t\toffset = 0;\n\n\t\t\t\t\tcal = customAttribute.value.length;\n\n\t\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tcustomAttribute.array[ ca ] = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\n\t\t\t\t\t\t\toffset += 2;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.r;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.g;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.b;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t= value.x;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1 ] = value.y;\n\t\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2 ] = value.z;\n\n\t\t\t\t\t\t\t\toffset += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\t\tfor ( ca = 0; ca < cal; ca ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ ca ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset ] \t = value.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 1  ] = value.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 2  ] = value.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset + 3  ] = value.w;\n\n\t\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction setMeshBuffers( geometryGroup, object, hint, dispose, material ) {\n\n\t\tif ( ! geometryGroup.__inittedArrays ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar normalType = bufferGuessNormalType( material ),\n\t\tvertexColorType = bufferGuessVertexColorType( material ),\n\t\tuvType = bufferGuessUVType( material ),\n\n\t\tneedsSmoothNormals = ( normalType === THREE.SmoothShading );\n\n\t\tvar f, fl, fi, face,\n\t\tvertexNormals, faceNormal, normal,\n\t\tvertexColors, faceColor,\n\t\tvertexTangents,\n\t\tuv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,\n\t\tc1, c2, c3, c4,\n\t\tsw1, sw2, sw3, sw4,\n\t\tsi1, si2, si3, si4,\n\t\tsa1, sa2, sa3, sa4,\n\t\tsb1, sb2, sb3, sb4,\n\t\tm, ml, i, il,\n\t\tvn, uvi, uv2i,\n\t\tvk, vkl, vka,\n\t\tnka, chf, faceVertexNormals,\n\t\ta,\n\n\t\tvertexIndex = 0,\n\n\t\toffset = 0,\n\t\toffset_uv = 0,\n\t\toffset_uv2 = 0,\n\t\toffset_face = 0,\n\t\toffset_normal = 0,\n\t\toffset_tangent = 0,\n\t\toffset_line = 0,\n\t\toffset_color = 0,\n\t\toffset_skin = 0,\n\t\toffset_morphTarget = 0,\n\t\toffset_custom = 0,\n\t\toffset_customSrc = 0,\n\n\t\tvalue,\n\n\t\tvertexArray = geometryGroup.__vertexArray,\n\t\tuvArray = geometryGroup.__uvArray,\n\t\tuv2Array = geometryGroup.__uv2Array,\n\t\tnormalArray = geometryGroup.__normalArray,\n\t\ttangentArray = geometryGroup.__tangentArray,\n\t\tcolorArray = geometryGroup.__colorArray,\n\n\t\tskinIndexArray = geometryGroup.__skinIndexArray,\n\t\tskinWeightArray = geometryGroup.__skinWeightArray,\n\n\t\tmorphTargetsArrays = geometryGroup.__morphTargetsArrays,\n\t\tmorphNormalsArrays = geometryGroup.__morphNormalsArrays,\n\n\t\tcustomAttributes = geometryGroup.__webglCustomAttributesList,\n\t\tcustomAttribute,\n\n\t\tfaceArray = geometryGroup.__faceArray,\n\t\tlineArray = geometryGroup.__lineArray,\n\n\t\tgeometry = object.geometry, // this is shared for all chunks\n\n\t\tdirtyVertices = geometry.verticesNeedUpdate,\n\t\tdirtyElements = geometry.elementsNeedUpdate,\n\t\tdirtyUvs = geometry.uvsNeedUpdate,\n\t\tdirtyNormals = geometry.normalsNeedUpdate,\n\t\tdirtyTangents = geometry.tangentsNeedUpdate,\n\t\tdirtyColors = geometry.colorsNeedUpdate,\n\t\tdirtyMorphTargets = geometry.morphTargetsNeedUpdate,\n\n\t\tvertices = geometry.vertices,\n\t\tchunk_faces3 = geometryGroup.faces3,\n\t\tobj_faces = geometry.faces,\n\n\t\tobj_uvs  = geometry.faceVertexUvs[ 0 ],\n\t\tobj_uvs2 = geometry.faceVertexUvs[ 1 ],\n\n\t\tobj_colors = geometry.colors,\n\n\t\tobj_skinIndices = geometry.skinIndices,\n\t\tobj_skinWeights = geometry.skinWeights,\n\n\t\tmorphTargets = geometry.morphTargets,\n\t\tmorphNormals = geometry.morphNormals;\n\n\t\tif ( dirtyVertices ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ] ];\n\n\t\t\t\tv1 = vertices[ face.a ];\n\t\t\t\tv2 = vertices[ face.b ];\n\t\t\t\tv3 = vertices[ face.c ];\n\n\t\t\t\tvertexArray[ offset ]     = v1.x;\n\t\t\t\tvertexArray[ offset + 1 ] = v1.y;\n\t\t\t\tvertexArray[ offset + 2 ] = v1.z;\n\n\t\t\t\tvertexArray[ offset + 3 ] = v2.x;\n\t\t\t\tvertexArray[ offset + 4 ] = v2.y;\n\t\t\t\tvertexArray[ offset + 5 ] = v2.z;\n\n\t\t\t\tvertexArray[ offset + 6 ] = v3.x;\n\t\t\t\tvertexArray[ offset + 7 ] = v3.y;\n\t\t\t\tvertexArray[ offset + 8 ] = v3.z;\n\n\t\t\t\toffset += 9;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyMorphTargets ) {\n\n\t\t\tfor ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {\n\n\t\t\t\toffset_morphTarget = 0;\n\n\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\tchf = chunk_faces3[ f ];\n\t\t\t\t\tface = obj_faces[ chf ];\n\n\t\t\t\t\t// morph positions\n\n\t\t\t\t\tv1 = morphTargets[ vk ].vertices[ face.a ];\n\t\t\t\t\tv2 = morphTargets[ vk ].vertices[ face.b ];\n\t\t\t\t\tv3 = morphTargets[ vk ].vertices[ face.c ];\n\n\t\t\t\t\tvka = morphTargetsArrays[ vk ];\n\n\t\t\t\t\tvka[ offset_morphTarget ] \t  = v1.x;\n\t\t\t\t\tvka[ offset_morphTarget + 1 ] = v1.y;\n\t\t\t\t\tvka[ offset_morphTarget + 2 ] = v1.z;\n\n\t\t\t\t\tvka[ offset_morphTarget + 3 ] = v2.x;\n\t\t\t\t\tvka[ offset_morphTarget + 4 ] = v2.y;\n\t\t\t\t\tvka[ offset_morphTarget + 5 ] = v2.z;\n\n\t\t\t\t\tvka[ offset_morphTarget + 6 ] = v3.x;\n\t\t\t\t\tvka[ offset_morphTarget + 7 ] = v3.y;\n\t\t\t\t\tvka[ offset_morphTarget + 8 ] = v3.z;\n\n\t\t\t\t\t// morph normals\n\n\t\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t\tif ( needsSmoothNormals ) {\n\n\t\t\t\t\t\t\tfaceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\n\n\t\t\t\t\t\t\tn1 = faceVertexNormals.a;\n\t\t\t\t\t\t\tn2 = faceVertexNormals.b;\n\t\t\t\t\t\t\tn3 = faceVertexNormals.c;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tn1 = morphNormals[ vk ].faceNormals[ chf ];\n\t\t\t\t\t\t\tn2 = n1;\n\t\t\t\t\t\t\tn3 = n1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnka = morphNormalsArrays[ vk ];\n\n\t\t\t\t\t\tnka[ offset_morphTarget ] \t  = n1.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 1 ] = n1.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 2 ] = n1.z;\n\n\t\t\t\t\t\tnka[ offset_morphTarget + 3 ] = n2.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 4 ] = n2.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 5 ] = n2.z;\n\n\t\t\t\t\t\tnka[ offset_morphTarget + 6 ] = n3.x;\n\t\t\t\t\t\tnka[ offset_morphTarget + 7 ] = n3.y;\n\t\t\t\t\t\tnka[ offset_morphTarget + 8 ] = n3.z;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t//\n\n\t\t\t\t\toffset_morphTarget += 9;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );\n\n\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( obj_skinWeights.length ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t// weights\n\n\t\t\t\tsw1 = obj_skinWeights[ face.a ];\n\t\t\t\tsw2 = obj_skinWeights[ face.b ];\n\t\t\t\tsw3 = obj_skinWeights[ face.c ];\n\n\t\t\t\tskinWeightArray[ offset_skin ]     = sw1.x;\n\t\t\t\tskinWeightArray[ offset_skin + 1 ] = sw1.y;\n\t\t\t\tskinWeightArray[ offset_skin + 2 ] = sw1.z;\n\t\t\t\tskinWeightArray[ offset_skin + 3 ] = sw1.w;\n\n\t\t\t\tskinWeightArray[ offset_skin + 4 ] = sw2.x;\n\t\t\t\tskinWeightArray[ offset_skin + 5 ] = sw2.y;\n\t\t\t\tskinWeightArray[ offset_skin + 6 ] = sw2.z;\n\t\t\t\tskinWeightArray[ offset_skin + 7 ] = sw2.w;\n\n\t\t\t\tskinWeightArray[ offset_skin + 8 ]  = sw3.x;\n\t\t\t\tskinWeightArray[ offset_skin + 9 ]  = sw3.y;\n\t\t\t\tskinWeightArray[ offset_skin + 10 ] = sw3.z;\n\t\t\t\tskinWeightArray[ offset_skin + 11 ] = sw3.w;\n\n\t\t\t\t// indices\n\n\t\t\t\tsi1 = obj_skinIndices[ face.a ];\n\t\t\t\tsi2 = obj_skinIndices[ face.b ];\n\t\t\t\tsi3 = obj_skinIndices[ face.c ];\n\n\t\t\t\tskinIndexArray[ offset_skin ]     = si1.x;\n\t\t\t\tskinIndexArray[ offset_skin + 1 ] = si1.y;\n\t\t\t\tskinIndexArray[ offset_skin + 2 ] = si1.z;\n\t\t\t\tskinIndexArray[ offset_skin + 3 ] = si1.w;\n\n\t\t\t\tskinIndexArray[ offset_skin + 4 ] = si2.x;\n\t\t\t\tskinIndexArray[ offset_skin + 5 ] = si2.y;\n\t\t\t\tskinIndexArray[ offset_skin + 6 ] = si2.z;\n\t\t\t\tskinIndexArray[ offset_skin + 7 ] = si2.w;\n\n\t\t\t\tskinIndexArray[ offset_skin + 8 ]  = si3.x;\n\t\t\t\tskinIndexArray[ offset_skin + 9 ]  = si3.y;\n\t\t\t\tskinIndexArray[ offset_skin + 10 ] = si3.z;\n\t\t\t\tskinIndexArray[ offset_skin + 11 ] = si3.w;\n\n\t\t\t\toffset_skin += 12;\n\n\t\t\t}\n\n\t\t\tif ( offset_skin > 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyColors && vertexColorType ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\tvertexColors = face.vertexColors;\n\t\t\t\tfaceColor = face.color;\n\n\t\t\t\tif ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {\n\n\t\t\t\t\tc1 = vertexColors[ 0 ];\n\t\t\t\t\tc2 = vertexColors[ 1 ];\n\t\t\t\t\tc3 = vertexColors[ 2 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tc1 = faceColor;\n\t\t\t\t\tc2 = faceColor;\n\t\t\t\t\tc3 = faceColor;\n\n\t\t\t\t}\n\n\t\t\t\tcolorArray[ offset_color ]     = c1.r;\n\t\t\t\tcolorArray[ offset_color + 1 ] = c1.g;\n\t\t\t\tcolorArray[ offset_color + 2 ] = c1.b;\n\n\t\t\t\tcolorArray[ offset_color + 3 ] = c2.r;\n\t\t\t\tcolorArray[ offset_color + 4 ] = c2.g;\n\t\t\t\tcolorArray[ offset_color + 5 ] = c2.b;\n\n\t\t\t\tcolorArray[ offset_color + 6 ] = c3.r;\n\t\t\t\tcolorArray[ offset_color + 7 ] = c3.g;\n\t\t\t\tcolorArray[ offset_color + 8 ] = c3.b;\n\n\t\t\t\toffset_color += 9;\n\n\t\t\t}\n\n\t\t\tif ( offset_color > 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyTangents && geometry.hasTangents ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\tvertexTangents = face.vertexTangents;\n\n\t\t\t\tt1 = vertexTangents[ 0 ];\n\t\t\t\tt2 = vertexTangents[ 1 ];\n\t\t\t\tt3 = vertexTangents[ 2 ];\n\n\t\t\t\ttangentArray[ offset_tangent ]     = t1.x;\n\t\t\t\ttangentArray[ offset_tangent + 1 ] = t1.y;\n\t\t\t\ttangentArray[ offset_tangent + 2 ] = t1.z;\n\t\t\t\ttangentArray[ offset_tangent + 3 ] = t1.w;\n\n\t\t\t\ttangentArray[ offset_tangent + 4 ] = t2.x;\n\t\t\t\ttangentArray[ offset_tangent + 5 ] = t2.y;\n\t\t\t\ttangentArray[ offset_tangent + 6 ] = t2.z;\n\t\t\t\ttangentArray[ offset_tangent + 7 ] = t2.w;\n\n\t\t\t\ttangentArray[ offset_tangent + 8 ]  = t3.x;\n\t\t\t\ttangentArray[ offset_tangent + 9 ]  = t3.y;\n\t\t\t\ttangentArray[ offset_tangent + 10 ] = t3.z;\n\t\t\t\ttangentArray[ offset_tangent + 11 ] = t3.w;\n\n\t\t\t\toffset_tangent += 12;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyNormals && normalType ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\tvertexNormals = face.vertexNormals;\n\t\t\t\tfaceNormal = face.normal;\n\n\t\t\t\tif ( vertexNormals.length === 3 && needsSmoothNormals ) {\n\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tvn = vertexNormals[ i ];\n\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = vn.x;\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = vn.y;\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = vn.z;\n\n\t\t\t\t\t\toffset_normal += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tnormalArray[ offset_normal ]     = faceNormal.x;\n\t\t\t\t\t\tnormalArray[ offset_normal + 1 ] = faceNormal.y;\n\t\t\t\t\t\tnormalArray[ offset_normal + 2 ] = faceNormal.z;\n\n\t\t\t\t\t\toffset_normal += 3;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\n\n\t\t}\n\n\t\tif ( dirtyUvs && obj_uvs && uvType ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tfi = chunk_faces3[ f ];\n\n\t\t\t\tuv = obj_uvs[ fi ];\n\n\t\t\t\tif ( uv === undefined ) continue;\n\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tuvi = uv[ i ];\n\n\t\t\t\t\tuvArray[ offset_uv ]     = uvi.x;\n\t\t\t\t\tuvArray[ offset_uv + 1 ] = uvi.y;\n\n\t\t\t\t\toffset_uv += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( offset_uv > 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyUvs && obj_uvs2 && uvType ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tfi = chunk_faces3[ f ];\n\n\t\t\t\tuv2 = obj_uvs2[ fi ];\n\n\t\t\t\tif ( uv2 === undefined ) continue;\n\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tuv2i = uv2[ i ];\n\n\t\t\t\t\tuv2Array[ offset_uv2 ]     = uv2i.x;\n\t\t\t\t\tuv2Array[ offset_uv2 + 1 ] = uv2i.y;\n\n\t\t\t\t\toffset_uv2 += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( offset_uv2 > 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dirtyElements ) {\n\n\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\tfaceArray[ offset_face ] \t = vertexIndex;\n\t\t\t\tfaceArray[ offset_face + 1 ] = vertexIndex + 1;\n\t\t\t\tfaceArray[ offset_face + 2 ] = vertexIndex + 2;\n\n\t\t\t\toffset_face += 3;\n\n\t\t\t\tlineArray[ offset_line ]     = vertexIndex;\n\t\t\t\tlineArray[ offset_line + 1 ] = vertexIndex + 1;\n\n\t\t\t\tlineArray[ offset_line + 2 ] = vertexIndex;\n\t\t\t\tlineArray[ offset_line + 3 ] = vertexIndex + 2;\n\n\t\t\t\tlineArray[ offset_line + 4 ] = vertexIndex + 1;\n\t\t\t\tlineArray[ offset_line + 5 ] = vertexIndex + 2;\n\n\t\t\t\toffset_line += 6;\n\n\t\t\t\tvertexIndex += 3;\n\n\t\t\t}\n\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );\n\n\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\n\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );\n\n\t\t}\n\n\t\tif ( customAttributes ) {\n\n\t\t\tfor ( i = 0, il = customAttributes.length; i < il; i ++ ) {\n\n\t\t\t\tcustomAttribute = customAttributes[ i ];\n\n\t\t\t\tif ( ! customAttribute.__original.needsUpdate ) continue;\n\n\t\t\t\toffset_custom = 0;\n\t\t\t\toffset_customSrc = 0;\n\n\t\t\t\tif ( customAttribute.size === 1 ) {\n\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\n\n\t\t\t\t\t\t\toffset_custom += 3;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = value;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = value;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = value;\n\n\t\t\t\t\t\t\toffset_custom += 3;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( customAttribute.size === 2 ) {\n\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\n\n\t\t\t\t\t\t\toffset_custom += 6;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2.y;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v3.y;\n\n\t\t\t\t\t\t\toffset_custom += 6;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( customAttribute.size === 3 ) {\n\n\t\t\t\t\tvar pp;\n\n\t\t\t\t\tif ( customAttribute.type === \"c\" ) {\n\n\t\t\t\t\t\tpp = [ \"r\", \"g\", \"b\" ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpp = [ \"x\", \"y\", \"z\" ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 9;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 9;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faceVertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value[ 0 ];\n\t\t\t\t\t\t\tv2 = value[ 1 ];\n\t\t\t\t\t\t\tv3 = value[ 2 ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom ] \t   = v1[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\n\n\t\t\t\t\t\t\toffset_custom += 9;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( customAttribute.size === 4 ) {\n\n\t\t\t\t\tif ( customAttribute.boundTo === undefined || customAttribute.boundTo === \"vertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tface = obj_faces[ chunk_faces3[ f ]\t];\n\n\t\t\t\t\t\t\tv1 = customAttribute.value[ face.a ];\n\t\t\t\t\t\t\tv2 = customAttribute.value[ face.b ];\n\t\t\t\t\t\t\tv3 = customAttribute.value[ face.c ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faces\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value;\n\t\t\t\t\t\t\tv2 = value;\n\t\t\t\t\t\t\tv3 = value;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( customAttribute.boundTo === \"faceVertices\" ) {\n\n\t\t\t\t\t\tfor ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\n\n\t\t\t\t\t\t\tvalue = customAttribute.value[ chunk_faces3[ f ] ];\n\n\t\t\t\t\t\t\tv1 = value[ 0 ];\n\t\t\t\t\t\t\tv2 = value[ 1 ];\n\t\t\t\t\t\t\tv3 = value[ 2 ];\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom  ] \t= v1.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 1  ] = v1.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 2  ] = v1.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 3  ] = v1.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 4  ] = v2.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 5  ] = v2.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 6  ] = v2.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 7  ] = v2.w;\n\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 8  ] = v3.x;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 9  ] = v3.y;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 10 ] = v3.z;\n\t\t\t\t\t\t\tcustomAttribute.array[ offset_custom + 11 ] = v3.w;\n\n\t\t\t\t\t\t\toffset_custom += 12;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( dispose ) {\n\n\t\t\tdelete geometryGroup.__inittedArrays;\n\t\t\tdelete geometryGroup.__colorArray;\n\t\t\tdelete geometryGroup.__normalArray;\n\t\t\tdelete geometryGroup.__tangentArray;\n\t\t\tdelete geometryGroup.__uvArray;\n\t\t\tdelete geometryGroup.__uv2Array;\n\t\t\tdelete geometryGroup.__faceArray;\n\t\t\tdelete geometryGroup.__vertexArray;\n\t\t\tdelete geometryGroup.__lineArray;\n\t\t\tdelete geometryGroup.__skinIndexArray;\n\t\t\tdelete geometryGroup.__skinWeightArray;\n\n\t\t}\n\n\t};\n\n\tfunction setDirectBuffers ( geometry, hint, dispose ) {\n\n\t\tvar attributes = geometry.attributes;\n\n\t\tvar attributeName, attributeItem;\n\n\t\tfor ( attributeName in attributes ) {\n\n\t\t\tattributeItem = attributes[ attributeName ];\n\n\t\t\tif ( attributeItem.needsUpdate ) {\n\n\t\t\t\tif ( attributeName === 'index' ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.buffer );\n\t\t\t\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.array, hint );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\n\t\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, attributeItem.array, hint );\n\n\t\t\t\t}\n\n\t\t\t\tattributeItem.needsUpdate = false;\n\n\t\t\t}\n\n\t\t\tif ( dispose && ! attributeItem.dynamic ) {\n\n\t\t\t\tattributeItem.array = null;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Buffer rendering\n\n\tthis.renderBufferImmediate = function ( object, program, material ) {\n\n\t\tif ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();\n\t\tif ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();\n\t\tif ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();\n\t\tif ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();\n\n\t\tif ( object.hasPositions ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\n\t\t\t_gl.enableVertexAttribArray( program.attributes.position );\n\t\t\t_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasNormals ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );\n\n\t\t\tif ( material.shading === THREE.FlatShading ) {\n\n\t\t\t\tvar nx, ny, nz,\n\t\t\t\t\tnax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,\n\t\t\t\t\tnormalArray,\n\t\t\t\t\ti, il = object.count * 3;\n\n\t\t\t\tfor( i = 0; i < il; i += 9 ) {\n\n\t\t\t\t\tnormalArray = object.normalArray;\n\n\t\t\t\t\tnax  = normalArray[ i ];\n\t\t\t\t\tnay  = normalArray[ i + 1 ];\n\t\t\t\t\tnaz  = normalArray[ i + 2 ];\n\n\t\t\t\t\tnbx  = normalArray[ i + 3 ];\n\t\t\t\t\tnby  = normalArray[ i + 4 ];\n\t\t\t\t\tnbz  = normalArray[ i + 5 ];\n\n\t\t\t\t\tncx  = normalArray[ i + 6 ];\n\t\t\t\t\tncy  = normalArray[ i + 7 ];\n\t\t\t\t\tncz  = normalArray[ i + 8 ];\n\n\t\t\t\t\tnx = ( nax + nbx + ncx ) / 3;\n\t\t\t\t\tny = ( nay + nby + ncy ) / 3;\n\t\t\t\t\tnz = ( naz + nbz + ncz ) / 3;\n\n\t\t\t\t\tnormalArray[ i ] \t = nx;\n\t\t\t\t\tnormalArray[ i + 1 ] = ny;\n\t\t\t\t\tnormalArray[ i + 2 ] = nz;\n\n\t\t\t\t\tnormalArray[ i + 3 ] = nx;\n\t\t\t\t\tnormalArray[ i + 4 ] = ny;\n\t\t\t\t\tnormalArray[ i + 5 ] = nz;\n\n\t\t\t\t\tnormalArray[ i + 6 ] = nx;\n\t\t\t\t\tnormalArray[ i + 7 ] = ny;\n\t\t\t\t\tnormalArray[ i + 8 ] = nz;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\n\t\t\t_gl.enableVertexAttribArray( program.attributes.normal );\n\t\t\t_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasUvs && material.map ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\n\t\t\t_gl.enableVertexAttribArray( program.attributes.uv );\n\t\t\t_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\n\t\t\t_gl.enableVertexAttribArray( program.attributes.color );\n\t\t\t_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\n\n\t\tobject.count = 0;\n\n\t};\n\n\tthis.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {\n\n\t\tif ( material.visible === false ) return;\n\n\t\tvar linewidth, a, attribute;\n\t\tvar attributeItem, attributeName, attributePointer, attributeSize;\n\n\t\tvar program = setProgram( camera, lights, fog, material, object );\n\n\t\tvar programAttributes = program.attributes;\n\t\tvar geometryAttributes = geometry.attributes;\n\n\t\tvar updateBuffers = false,\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\n\t\t\tgeometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;\n\n\t\tif ( geometryHash !== _currentGeometryGroupHash ) {\n\n\t\t\t_currentGeometryGroupHash = geometryHash;\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tdisableAttributes();\n\n\t\t}\n\n\t\t// render mesh\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\tvar index = geometryAttributes[ \"index\" ];\n\n\t\t\t// indexed triangles\n\n\t\t\tif ( index ) {\n\n\t\t\t\tvar offsets = geometry.offsets;\n\n\t\t\t\t// if there is more than 1 chunk\n\t\t\t\t// must set attribute pointers to use new offsets for each chunk\n\t\t\t\t// even if geometry and materials didn't change\n\n\t\t\t\tif ( offsets.length > 1 ) updateBuffers = true;\n\n\t\t\t\tfor ( var i = 0, il = offsets.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar startIndex = offsets[ i ].index;\n\n\t\t\t\t\tif ( updateBuffers ) {\n\n\t\t\t\t\t\tfor ( attributeName in programAttributes ) {\n\n\t\t\t\t\t\t\tattributePointer = programAttributes[ attributeName ];\n\t\t\t\t\t\t\tattributeItem = geometryAttributes[ attributeName ];\n\n\t\t\t\t\t\t\tif ( attributePointer >= 0 ) {\n\n\t\t\t\t\t\t\t\tif ( attributeItem ) {\n\n\t\t\t\t\t\t\t\t\tattributeSize = attributeItem.itemSize;\n\t\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\n\t\t\t\t\t\t\t\t\tenableAttribute( attributePointer );\n\t\t\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, startIndex * attributeSize * 4 ); // 4 bytes per Float32\n\n\t\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues ) {\n\n\t\t\t\t\t\t\t\t\tif ( material.defaultAttributeValues[ attributeName ].length === 2 ) {\n\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\n\t\t\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// indices\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// render indexed triangles\n\n\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16\n\n\t\t\t\t\t_this.info.render.calls ++;\n\t\t\t\t\t_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\n\t\t\t\t\t_this.info.render.faces += offsets[ i ].count / 3;\n\n\t\t\t\t}\n\n\t\t\t// non-indexed triangles\n\n\t\t\t} else {\n\n\t\t\t\tif ( updateBuffers ) {\n\n\t\t\t\t\tfor ( attributeName in programAttributes ) {\n\n\t\t\t\t\t\tif ( attributeName === 'index') continue;\n\n\t\t\t\t\t\tattributePointer = programAttributes[ attributeName ];\n\t\t\t\t\t\tattributeItem = geometryAttributes[ attributeName ];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( attributePointer >= 0 ) {\n\n\t\t\t\t\t\t\tif ( attributeItem ) {\n\n\t\t\t\t\t\t\t\tattributeSize = attributeItem.itemSize;\n\t\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\n\t\t\t\t\t\t\t\tenableAttribute( attributePointer );\n\t\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {\n\n\t\t\t\t\t\t\t\tif ( material.defaultAttributeValues[ attributeName ].length === 2 ) {\n\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\n\t\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {\n\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar position = geometry.attributes[ \"position\" ];\n\n\t\t\t\t// render non-indexed triangles\n\n\t\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, position.numItems / 3 );\n\n\t\t\t\t_this.info.render.calls ++;\n\t\t\t\t_this.info.render.vertices += position.numItems / 3;\n\t\t\t\t_this.info.render.faces += position.numItems / 3 / 3;\n\n\t\t\t}\n\n\t\t// render particles\n\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\tfor ( attributeName in programAttributes ) {\n\n\t\t\t\t\tattributePointer = programAttributes[ attributeName ];\n\t\t\t\t\tattributeItem = geometryAttributes[ attributeName ];\n\t\t\t\t\t\n\t\t\t\t\tif ( attributePointer >= 0 ) {\n\n\t\t\t\t\t\tif ( attributeItem ) {\n\n\t\t\t\t\t\t\tattributeSize = attributeItem.itemSize;\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\n\t\t\t\t\t\t\tenableAttribute( attributePointer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t\t} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {\n\n\t\t\t\t\t\t\tif ( material.defaultAttributeValues[ attributeName ].length === 2 ) {\n\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\n\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {\n\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar position = geometryAttributes[ \"position\" ];\n\n\t\t\t// render particles\n\n\t\t\t_gl.drawArrays( _gl.POINTS, 0, position.numItems / 3 );\n\n\t\t\t_this.info.render.calls ++;\n\t\t\t_this.info.render.points += position.numItems / 3;\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\tfor ( attributeName in programAttributes ) {\n\n\t\t\t\t\tattributePointer = programAttributes[ attributeName ];\n\t\t\t\t\tattributeItem = geometryAttributes[ attributeName ];\n\t\t\t\t\t\n\t\t\t\t\tif ( attributePointer >= 0 ) {\n\n\t\t\t\t\t\tif ( attributeItem ) {\n\n\t\t\t\t\t\t\tattributeSize = attributeItem.itemSize;\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );\n\t\t\t\t\t\t\tenableAttribute( attributePointer );\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t\t} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {\n\n\t\t\t\t\t\t\tif ( material.defaultAttributeValues[ attributeName ].length === 2 ) {\n\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\n\t\t\t\t\t\t\t} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {\n\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// render lines\n\n\t\t\tvar primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\n\n\t\t\tsetLineWidth( material.linewidth );\n\n\t\t\tvar position = geometryAttributes[ \"position\" ];\n\n\t\t\t_gl.drawArrays( primitives, 0, position.numItems / 3 );\n\n\t\t\t_this.info.render.calls ++;\n\t\t\t_this.info.render.points += position.numItems;\n\n\t\t}\n\n\t};\n\n\tthis.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {\n\n\t\tif ( material.visible === false ) return;\n\n\t\tvar linewidth, a, attribute, i, il;\n\n\t\tvar program = setProgram( camera, lights, fog, material, object );\n\n\t\tvar attributes = program.attributes;\n\n\t\tvar updateBuffers = false,\n\t\t\twireframeBit = material.wireframe ? 1 : 0,\n\t\t\tgeometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;\n\n\t\tif ( geometryGroupHash !== _currentGeometryGroupHash ) {\n\n\t\t\t_currentGeometryGroupHash = geometryGroupHash;\n\t\t\tupdateBuffers = true;\n\n\t\t}\n\n\t\tif ( updateBuffers ) {\n\n\t\t\tdisableAttributes();\n\n\t\t}\n\n\t\t// vertices\n\n\t\tif ( !material.morphTargets && attributes.position >= 0 ) {\n\n\t\t\tif ( updateBuffers ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\n\t\t\t\tenableAttribute( attributes.position );\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( object.morphTargetBase ) {\n\n\t\t\t\tsetupMorphTargets( material, geometryGroup, object );\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tif ( updateBuffers ) {\n\n\t\t\t// custom attributes\n\n\t\t\t// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers\n\n\t\t\tif ( geometryGroup.__webglCustomAttributesList ) {\n\n\t\t\t\tfor ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {\n\n\t\t\t\t\tattribute = geometryGroup.__webglCustomAttributesList[ i ];\n\n\t\t\t\t\tif ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );\n\t\t\t\t\t\tenableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// colors\n\n\t\t\tif ( attributes.color >= 0 ) {\n\n\t\t\t\tif ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\n\t\t\t\t\tenableAttribute( attributes.color );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t} else if ( material.defaultAttributeValues ) {\n\n\n\t\t\t\t\t_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// normals\n\n\t\t\tif ( attributes.normal >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\n\t\t\t\tenableAttribute( attributes.normal );\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\t// tangents\n\n\t\t\tif ( attributes.tangent >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\n\t\t\t\tenableAttribute( attributes.tangent );\n\t\t\t\t_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\t// uvs\n\n\t\t\tif ( attributes.uv >= 0 ) {\n\n\t\t\t\tif ( object.geometry.faceVertexUvs[0] ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\n\t\t\t\t\tenableAttribute( attributes.uv );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t} else if ( material.defaultAttributeValues ) {\n\n\n\t\t\t\t\t_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( attributes.uv2 >= 0 ) {\n\n\t\t\t\tif ( object.geometry.faceVertexUvs[1] ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\n\t\t\t\t\tenableAttribute( attributes.uv2 );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t} else if ( material.defaultAttributeValues ) {\n\n\n\t\t\t\t\t_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material.skinning &&\n\t\t\t\t attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\n\t\t\t\tenableAttribute( attributes.skinIndex );\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\n\t\t\t\tenableAttribute( attributes.skinWeight );\n\t\t\t\t_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t\t// line distances\n\n\t\t\tif ( attributes.lineDistance >= 0 ) {\n\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );\n\t\t\t\tenableAttribute( attributes.lineDistance );\n\t\t\t\t_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// render mesh\n\n\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t// wireframe\n\n\t\t\tif ( material.wireframe ) {\n\n\t\t\t\tsetLineWidth( material.wireframeLinewidth );\n\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\n\t\t\t\t_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t// triangles\n\n\t\t\t} else {\n\n\t\t\t\tif ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t}\n\n\t\t\t_this.info.render.calls ++;\n\t\t\t_this.info.render.vertices += geometryGroup.__webglFaceCount;\n\t\t\t_this.info.render.faces += geometryGroup.__webglFaceCount / 3;\n\n\t\t// render lines\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tvar primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\n\n\t\t\tsetLineWidth( material.linewidth );\n\n\t\t\t_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );\n\n\t\t\t_this.info.render.calls ++;\n\n\t\t// render particles\n\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\t_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );\n\n\t\t\t_this.info.render.calls ++;\n\t\t\t_this.info.render.points += geometryGroup.__webglParticleCount;\n\n\t\t}\n\n\t};\n\n\tfunction enableAttribute( attribute ) {\n\n\t\tif ( ! _enabledAttributes[ attribute ] ) {\n\n\t\t\t_gl.enableVertexAttribArray( attribute );\n\t\t\t_enabledAttributes[ attribute ] = true;\n\n\t\t}\n\n\t};\n\n\tfunction disableAttributes() {\n\n\t\tfor ( var attribute in _enabledAttributes ) {\n\n\t\t\tif ( _enabledAttributes[ attribute ] ) {\n\n\t\t\t\t_gl.disableVertexAttribArray( attribute );\n\t\t\t\t_enabledAttributes[ attribute ] = false;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction setupMorphTargets ( material, geometryGroup, object ) {\n\n\t\t// set base\n\n\t\tvar attributes = material.program.attributes;\n\n\t\tif ( object.morphTargetBase !== -1 && attributes.position >= 0 ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );\n\t\t\tenableAttribute( attributes.position );\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t} else if ( attributes.position >= 0 ) {\n\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\n\t\t\tenableAttribute( attributes.position );\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t}\n\n\t\tif ( object.morphTargetForcedOrder.length ) {\n\n\t\t\t// set forced order\n\n\t\t\tvar m = 0;\n\t\t\tvar order = object.morphTargetForcedOrder;\n\t\t\tvar influences = object.morphTargetInfluences;\n\n\t\t\twhile ( m < material.numSupportedMorphTargets && m < order.length ) {\n\n\t\t\t\tif ( attributes[ \"morphTarget\" + m ] >= 0 ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );\n\t\t\t\t\tenableAttribute( attributes[ \"morphTarget\" + m ] );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tif ( attributes[ \"morphNormal\" + m ] >= 0 && material.morphNormals ) {\n\n\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );\n\t\t\t\t\tenableAttribute( attributes[ \"morphNormal\" + m ] );\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];\n\n\t\t\t\tm ++;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// find the most influencing\n\n\t\t\tvar influence, activeInfluenceIndices = [];\n\t\t\tvar influences = object.morphTargetInfluences;\n\t\t\tvar i, il = influences.length;\n\n\t\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\t\tinfluence = influences[ i ];\n\n\t\t\t\tif ( influence > 0 ) {\n\n\t\t\t\t\tactiveInfluenceIndices.push( [ influence, i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {\n\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\n\t\t\t\tactiveInfluenceIndices.length = material.numSupportedMorphTargets;\n\n\t\t\t} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {\n\n\t\t\t\tactiveInfluenceIndices.sort( numericalSort );\n\n\t\t\t} else if ( activeInfluenceIndices.length === 0 ) {\n\n\t\t\t\tactiveInfluenceIndices.push( [ 0, 0 ] );\n\n\t\t\t};\n\n\t\t\tvar influenceIndex, m = 0;\n\n\t\t\twhile ( m < material.numSupportedMorphTargets ) {\n\n\t\t\t\tif ( activeInfluenceIndices[ m ] ) {\n\n\t\t\t\t\tinfluenceIndex = activeInfluenceIndices[ m ][ 1 ];\n\n\t\t\t\t\tif ( attributes[ \"morphTarget\" + m ] >= 0 ) {\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );\n\t\t\t\t\t\tenableAttribute( attributes[ \"morphTarget\" + m ] );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( attributes[ \"morphNormal\" + m ] >= 0 && material.morphNormals ) {\n\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );\n\t\t\t\t\t\tenableAttribute( attributes[ \"morphNormal\" + m ] );\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\t/*\n\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\tif ( material.morphNormals ) {\n\n\t\t\t\t\t\t_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\n\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\n\t\t\t\t\tobject.__webglMorphTargetInfluences[ m ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tm ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// load updated influences uniform\n\n\t\tif ( material.program.uniforms.morphTargetInfluences !== null ) {\n\n\t\t\t_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );\n\n\t\t}\n\n\t};\n\n\t// Sorting\n\n\tfunction painterSortStable ( a, b ) {\n\n\t\tif ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn a.id - b.id;\n\n\t\t}\n\n\t};\n\n\tfunction numericalSort ( a, b ) {\n\n\t\treturn b[ 0 ] - a[ 0 ];\n\n\t};\n\n\n\t// Rendering\n\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\n\n\t\tif ( camera instanceof THREE.Camera === false ) {\n\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar i, il,\n\n\t\twebglObject, object,\n\t\trenderList,\n\n\t\tlights = scene.__lights,\n\t\tfog = scene.fog;\n\n\t\t// reset caching for this frame\n\n\t\t_currentMaterialId = -1;\n\t\t_lightsNeedUpdate = true;\n\n\t\t// update scene graph\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t// update WebGL objects\n\n\t\tif ( this.autoUpdateObjects ) this.initWebGLObjects( scene );\n\n\t\t// custom render plugins (pre pass)\n\n\t\trenderPlugins( this.renderPluginsPre, scene, camera );\n\n\t\t//\n\n\t\t_this.info.render.calls = 0;\n\t\t_this.info.render.vertices = 0;\n\t\t_this.info.render.faces = 0;\n\t\t_this.info.render.points = 0;\n\n\t\tthis.setRenderTarget( renderTarget );\n\n\t\tif ( this.autoClear || forceClear ) {\n\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\n\n\t\t}\n\n\t\t// set matrices for regular objects (frustum culled)\n\n\t\trenderList = scene.__webglObjects;\n\n\t\tfor ( i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\twebglObject = renderList[ i ];\n\t\t\tobject = webglObject.object;\n\n\t\t\twebglObject.id = i;\n\t\t\twebglObject.render = false;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\tsetupMatrices( object, camera );\n\n\t\t\t\t\tunrollBufferMaterial( webglObject );\n\n\t\t\t\t\twebglObject.render = true;\n\n\t\t\t\t\tif ( this.sortObjects === true ) {\n\n\t\t\t\t\t\tif ( object.renderDepth !== null ) {\n\n\t\t\t\t\t\t\twebglObject.z = object.renderDepth;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\n\n\t\t\t\t\t\t\twebglObject.z = _vector3.z;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.sortObjects ) {\n\n\t\t\trenderList.sort( painterSortStable );\n\n\t\t}\n\n\t\t// set matrices for immediate objects\n\n\t\trenderList = scene.__webglObjectsImmediate;\n\n\t\tfor ( i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\twebglObject = renderList[ i ];\n\t\t\tobject = webglObject.object;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tsetupMatrices( object, camera );\n\n\t\t\t\tunrollImmediateBufferMaterial( webglObject );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( scene.overrideMaterial ) {\n\n\t\t\tvar material = scene.overrideMaterial;\n\n\t\t\tthis.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\tthis.setDepthTest( material.depthTest );\n\t\t\tthis.setDepthWrite( material.depthWrite );\n\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t\trenderObjects( scene.__webglObjects, false, \"\", camera, lights, fog, true, material );\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"\", camera, lights, fog, false, material );\n\n\t\t} else {\n\n\t\t\tvar material = null;\n\n\t\t\t// opaque pass (front-to-back order)\n\n\t\t\tthis.setBlending( THREE.NoBlending );\n\n\t\t\trenderObjects( scene.__webglObjects, true, \"opaque\", camera, lights, fog, false, material );\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"opaque\", camera, lights, fog, false, material );\n\n\t\t\t// transparent pass (back-to-front order)\n\n\t\t\trenderObjects( scene.__webglObjects, false, \"transparent\", camera, lights, fog, true, material );\n\t\t\trenderObjectsImmediate( scene.__webglObjectsImmediate, \"transparent\", camera, lights, fog, true, material );\n\n\t\t}\n\n\t\t// custom render plugins (post pass)\n\n\t\trenderPlugins( this.renderPluginsPost, scene, camera );\n\n\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\n\n\t\tif ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {\n\n\t\t\tupdateRenderTargetMipmap( renderTarget );\n\n\t\t}\n\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\n\n\t\tthis.setDepthTest( true );\n\t\tthis.setDepthWrite( true );\n\n\t\t// _gl.finish();\n\n\t};\n\n\tfunction renderPlugins( plugins, scene, camera ) {\n\n\t\tif ( ! plugins.length ) return;\n\n\t\tfor ( var i = 0, il = plugins.length; i < il; i ++ ) {\n\n\t\t\t// reset state for plugin (to start from clean slate)\n\n\t\t\t_currentProgram = null;\n\t\t\t_currentCamera = null;\n\n\t\t\t_oldBlending = -1;\n\t\t\t_oldDepthTest = -1;\n\t\t\t_oldDepthWrite = -1;\n\t\t\t_oldDoubleSided = -1;\n\t\t\t_oldFlipSided = -1;\n\t\t\t_currentGeometryGroupHash = -1;\n\t\t\t_currentMaterialId = -1;\n\n\t\t\t_lightsNeedUpdate = true;\n\n\t\t\tplugins[ i ].render( scene, camera, _currentWidth, _currentHeight );\n\n\t\t\t// reset state after plugin (anything could have changed)\n\n\t\t\t_currentProgram = null;\n\t\t\t_currentCamera = null;\n\n\t\t\t_oldBlending = -1;\n\t\t\t_oldDepthTest = -1;\n\t\t\t_oldDepthWrite = -1;\n\t\t\t_oldDoubleSided = -1;\n\t\t\t_oldFlipSided = -1;\n\t\t\t_currentGeometryGroupHash = -1;\n\t\t\t_currentMaterialId = -1;\n\n\t\t\t_lightsNeedUpdate = true;\n\n\t\t}\n\n\t};\n\n\tfunction renderObjects ( renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\n\n\t\tvar webglObject, object, buffer, material, start, end, delta;\n\n\t\tif ( reverse ) {\n\n\t\t\tstart = renderList.length - 1;\n\t\t\tend = -1;\n\t\t\tdelta = -1;\n\n\t\t} else {\n\n\t\t\tstart = 0;\n\t\t\tend = renderList.length;\n\t\t\tdelta = 1;\n\t\t}\n\n\t\tfor ( var i = start; i !== end; i += delta ) {\n\n\t\t\twebglObject = renderList[ i ];\n\n\t\t\tif ( webglObject.render ) {\n\n\t\t\t\tobject = webglObject.object;\n\t\t\t\tbuffer = webglObject.buffer;\n\n\t\t\t\tif ( overrideMaterial ) {\n\n\t\t\t\t\tmaterial = overrideMaterial;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial = webglObject[ materialType ];\n\n\t\t\t\t\tif ( ! material ) continue;\n\n\t\t\t\t\tif ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\n\t\t\t\t\t_this.setDepthTest( material.depthTest );\n\t\t\t\t\t_this.setDepthWrite( material.depthWrite );\n\t\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t\t\t}\n\n\t\t\t\t_this.setMaterialFaces( material );\n\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t_this.renderBufferDirect( camera, lights, fog, material, buffer, object );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_this.renderBuffer( camera, lights, fog, material, buffer, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\n\n\t\tvar webglObject, object, material, program;\n\n\t\tfor ( var i = 0, il = renderList.length; i < il; i ++ ) {\n\n\t\t\twebglObject = renderList[ i ];\n\t\t\tobject = webglObject.object;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tif ( overrideMaterial ) {\n\n\t\t\t\t\tmaterial = overrideMaterial;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial = webglObject[ materialType ];\n\n\t\t\t\t\tif ( ! material ) continue;\n\n\t\t\t\t\tif ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\n\t\t\t\t\t_this.setDepthTest( material.depthTest );\n\t\t\t\t\t_this.setDepthWrite( material.depthWrite );\n\t\t\t\t\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\n\n\t\t\t\t}\n\n\t\t\t\t_this.renderImmediateObject( camera, lights, fog, material, object );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.renderImmediateObject = function ( camera, lights, fog, material, object ) {\n\n\t\tvar program = setProgram( camera, lights, fog, material, object );\n\n\t\t_currentGeometryGroupHash = -1;\n\n\t\t_this.setMaterialFaces( material );\n\n\t\tif ( object.immediateRenderCallback ) {\n\n\t\t\tobject.immediateRenderCallback( program, _gl, _frustum );\n\n\t\t} else {\n\n\t\t\tobject.render( function( object ) { _this.renderBufferImmediate( object, program, material ); } );\n\n\t\t}\n\n\t};\n\n\tfunction unrollImmediateBufferMaterial ( globject ) {\n\n\t\tvar object = globject.object,\n\t\t\tmaterial = object.material;\n\n\t\tif ( material.transparent ) {\n\n\t\t\tglobject.transparent = material;\n\t\t\tglobject.opaque = null;\n\n\t\t} else {\n\n\t\t\tglobject.opaque = material;\n\t\t\tglobject.transparent = null;\n\n\t\t}\n\n\t};\n\n\tfunction unrollBufferMaterial ( globject ) {\n\n\t\tvar object = globject.object,\n\t\t\tbuffer = globject.buffer,\n\t\t\tmaterial, materialIndex, meshMaterial;\n\n\t\tmeshMaterial = object.material;\n\n\t\tif ( meshMaterial instanceof THREE.MeshFaceMaterial ) {\n\n\t\t\tmaterialIndex = buffer.materialIndex;\n\n\t\t\tmaterial = meshMaterial.materials[ materialIndex ];\n\n\t\t\tif ( material.transparent ) {\n\n\t\t\t\tglobject.transparent = material;\n\t\t\t\tglobject.opaque = null;\n\n\t\t\t} else {\n\n\t\t\t\tglobject.opaque = material;\n\t\t\t\tglobject.transparent = null;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmaterial = meshMaterial;\n\n\t\t\tif ( material ) {\n\n\t\t\t\tif ( material.transparent ) {\n\n\t\t\t\t\tglobject.transparent = material;\n\t\t\t\t\tglobject.opaque = null;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tglobject.opaque = material;\n\t\t\t\t\tglobject.transparent = null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Geometry splitting\n\n\tfunction sortFacesByMaterial ( geometry, material ) {\n\n\t\tvar f, fl, face, materialIndex, vertices,\n\t\t\tgroupHash, hash_map = {};\n\n\t\tvar numMorphTargets = geometry.morphTargets.length;\n\t\tvar numMorphNormals = geometry.morphNormals.length;\n\n\t\tvar usesFaceMaterial = material instanceof THREE.MeshFaceMaterial;\n\n\t\tgeometry.geometryGroups = {};\n\n\t\tfor ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\n\n\t\t\tface = geometry.faces[ f ];\n\t\t\tmaterialIndex = usesFaceMaterial ? face.materialIndex : 0;\n\n\t\t\tif ( hash_map[ materialIndex ] === undefined ) {\n\n\t\t\t\thash_map[ materialIndex ] = { 'hash': materialIndex, 'counter': 0 };\n\n\t\t\t}\n\n\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\n\n\t\t\tif ( geometry.geometryGroups[ groupHash ] === undefined ) {\n\n\t\t\t\tgeometry.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };\n\n\t\t\t}\n\n\t\t\tvertices = 3;\n\n\t\t\tif ( geometry.geometryGroups[ groupHash ].vertices + vertices > 65535 ) {\n\n\t\t\t\thash_map[ materialIndex ].counter += 1;\n\t\t\t\tgroupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\n\n\t\t\t\tif ( geometry.geometryGroups[ groupHash ] === undefined ) {\n\n\t\t\t\t\tgeometry.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.geometryGroups[ groupHash ].faces3.push( f );\n\t\t\tgeometry.geometryGroups[ groupHash ].vertices += vertices;\n\n\t\t}\n\n\t\tgeometry.geometryGroupsList = [];\n\n\t\tfor ( var g in geometry.geometryGroups ) {\n\n\t\t\tgeometry.geometryGroups[ g ].id = _geometryGroupCounter ++;\n\n\t\t\tgeometry.geometryGroupsList.push( geometry.geometryGroups[ g ] );\n\n\t\t}\n\n\t};\n\n\t// Objects refresh\n\n\tthis.initWebGLObjects = function ( scene ) {\n\n\t\tif ( !scene.__webglObjects ) {\n\n\t\t\tscene.__webglObjects = [];\n\t\t\tscene.__webglObjectsImmediate = [];\n\t\t\tscene.__webglSprites = [];\n\t\t\tscene.__webglFlares = [];\n\n\t\t}\n\n\t\twhile ( scene.__objectsAdded.length ) {\n\n\t\t\taddObject( scene.__objectsAdded[ 0 ], scene );\n\t\t\tscene.__objectsAdded.splice( 0, 1 );\n\n\t\t}\n\n\t\twhile ( scene.__objectsRemoved.length ) {\n\n\t\t\tremoveObject( scene.__objectsRemoved[ 0 ], scene );\n\t\t\tscene.__objectsRemoved.splice( 0, 1 );\n\n\t\t}\n\n\t\t// update must be called after objects adding / removal\n\n\t\tfor ( var o = 0, ol = scene.__webglObjects.length; o < ol; o ++ ) {\n\n\t\t\tvar object = scene.__webglObjects[ o ].object;\n\n\t\t\t// TODO: Remove this hack (WebGLRenderer refactoring)\n\n\t\t\tif ( object.__webglInit === undefined ) {\n\n\t\t\t\tif ( object.__webglActive !== undefined ) {\n\n\t\t\t\t\tremoveObject( object, scene );\n\n\t\t\t\t}\n\n\t\t\t\taddObject( object, scene );\n\n\t\t\t}\n\n\t\t\tupdateObject( object );\n\n\t\t}\n\n\t};\n\n\t// Objects adding\n\n\tfunction addObject( object, scene ) {\n\n\t\tvar g, geometry, material, geometryGroup;\n\n\t\tif ( object.__webglInit === undefined ) {\n\n\t\t\tobject.__webglInit = true;\n\n\t\t\tobject._modelViewMatrix = new THREE.Matrix4();\n\t\t\tobject._normalMatrix = new THREE.Matrix3();\n\n\t\t\tif ( object.geometry !== undefined && object.geometry.__webglInit === undefined ) {\n\n\t\t\t\tobject.geometry.__webglInit = true;\n\t\t\t\tobject.geometry.addEventListener( 'dispose', onGeometryDispose );\n\n\t\t\t}\n\n\t\t\tgeometry = object.geometry;\n\n\t\t\tif ( geometry === undefined ) {\n\n\t\t\t\t// fail silently for now\n\n\t\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\tinitDirectBuffers( geometry );\n\n\t\t\t} else if ( object instanceof THREE.Mesh ) {\n\n\t\t\t\tmaterial = object.material;\n\n\t\t\t\tif ( geometry.geometryGroups === undefined ) {\n\n\t\t\t\t\tsortFacesByMaterial( geometry, material );\n\n\t\t\t\t}\n\n\t\t\t\t// create separate VBOs per geometry chunk\n\n\t\t\t\tfor ( g in geometry.geometryGroups ) {\n\n\t\t\t\t\tgeometryGroup = geometry.geometryGroups[ g ];\n\n\t\t\t\t\t// initialise VBO on the first access\n\n\t\t\t\t\tif ( ! geometryGroup.__webglVertexBuffer ) {\n\n\t\t\t\t\t\tcreateMeshBuffers( geometryGroup );\n\t\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\n\n\t\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\t\tgeometry.morphTargetsNeedUpdate = true;\n\t\t\t\t\t\tgeometry.elementsNeedUpdate = true;\n\t\t\t\t\t\tgeometry.uvsNeedUpdate = true;\n\t\t\t\t\t\tgeometry.normalsNeedUpdate = true;\n\t\t\t\t\t\tgeometry.tangentsNeedUpdate = true;\n\t\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\n\n\t\t\t\t\tcreateLineBuffers( geometry );\n\t\t\t\t\tinitLineBuffers( geometry, object );\n\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\t\t\t\t\tgeometry.lineDistancesNeedUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\t\tif ( ! geometry.__webglVertexBuffer ) {\n\n\t\t\t\t\tcreateParticleBuffers( geometry );\n\t\t\t\t\tinitParticleBuffers( geometry, object );\n\n\t\t\t\t\tgeometry.verticesNeedUpdate = true;\n\t\t\t\t\tgeometry.colorsNeedUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( object.__webglActive === undefined ) {\n\n\t\t\tif ( object instanceof THREE.Mesh ) {\n\n\t\t\t\tgeometry = object.geometry;\n\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\taddBuffer( scene.__webglObjects, geometry, object );\n\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\n\n\t\t\t\t\tfor ( g in geometry.geometryGroups ) {\n\n\t\t\t\t\t\tgeometryGroup = geometry.geometryGroups[ g ];\n\n\t\t\t\t\t\taddBuffer( scene.__webglObjects, geometryGroup, object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( object instanceof THREE.Line ||\n\t\t\t\t\t\tobject instanceof THREE.ParticleSystem ) {\n\n\t\t\t\tgeometry = object.geometry;\n\t\t\t\taddBuffer( scene.__webglObjects, geometry, object );\n\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\n\n\t\t\t\taddBufferImmediate( scene.__webglObjectsImmediate, object );\n\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\t\tscene.__webglSprites.push( object );\n\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\n\n\t\t\t\tscene.__webglFlares.push( object );\n\n\t\t\t}\n\n\t\t\tobject.__webglActive = true;\n\n\t\t}\n\n\t};\n\n\tfunction addBuffer( objlist, buffer, object ) {\n\n\t\tobjlist.push(\n\t\t\t{\n\t\t\t\tid: null,\n\t\t\t\tbuffer: buffer,\n\t\t\t\tobject: object,\n\t\t\t\topaque: null,\n\t\t\t\ttransparent: null,\n\t\t\t\tz: 0\n\t\t\t}\n\t\t);\n\n\t};\n\n\tfunction addBufferImmediate( objlist, object ) {\n\n\t\tobjlist.push(\n\t\t\t{\n\t\t\t\tid: null,\n\t\t\t\tobject: object,\n\t\t\t\topaque: null,\n\t\t\t\ttransparent: null,\n\t\t\t\tz: 0\n\t\t\t}\n\t\t);\n\n\t};\n\n\t// Objects updates\n\n\tfunction updateObject( object ) {\n\n\t\tvar geometry = object.geometry,\n\t\t\tgeometryGroup, customAttributesDirty, material;\n\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\n\n\t\t\tsetDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );\n\n\t\t} else if ( object instanceof THREE.Mesh ) {\n\n\t\t\t// check all geometry groups\n\n\t\t\tfor( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {\n\n\t\t\t\tgeometryGroup = geometry.geometryGroupsList[ i ];\n\n\t\t\t\tmaterial = getBufferMaterial( object, geometryGroup );\n\n\t\t\t\tif ( geometry.buffersNeedUpdate ) {\n\n\t\t\t\t\tinitMeshBuffers( geometryGroup, object );\n\n\t\t\t\t}\n\n\t\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\n\t\t\t\tif ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||\n\t\t\t\t\t geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\n\t\t\t\t\t geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {\n\n\t\t\t\t\tsetMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.morphTargetsNeedUpdate = false;\n\t\t\tgeometry.elementsNeedUpdate = false;\n\t\t\tgeometry.uvsNeedUpdate = false;\n\t\t\tgeometry.normalsNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\tgeometry.tangentsNeedUpdate = false;\n\n\t\t\tgeometry.buffersNeedUpdate = false;\n\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\n\n\t\t} else if ( object instanceof THREE.Line ) {\n\n\t\t\tmaterial = getBufferMaterial( object, geometry );\n\n\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\n\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {\n\n\t\t\t\tsetLineBuffers( geometry, _gl.DYNAMIC_DRAW );\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\n\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\n\n\n\t\t} else if ( object instanceof THREE.ParticleSystem ) {\n\n\t\t\tmaterial = getBufferMaterial( object, geometry );\n\n\t\t\tcustomAttributesDirty = material.attributes && areCustomAttributesDirty( material );\n\n\t\t\tif ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {\n\n\t\t\t\tsetParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );\n\n\t\t\t}\n\n\t\t\tgeometry.verticesNeedUpdate = false;\n\t\t\tgeometry.colorsNeedUpdate = false;\n\n\t\t\tmaterial.attributes && clearCustomAttributes( material );\n\n\t\t}\n\n\t};\n\n\t// Objects updates - custom attributes check\n\n\tfunction areCustomAttributesDirty( material ) {\n\n\t\tfor ( var a in material.attributes ) {\n\n\t\t\tif ( material.attributes[ a ].needsUpdate ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n\tfunction clearCustomAttributes( material ) {\n\n\t\tfor ( var a in material.attributes ) {\n\n\t\t\tmaterial.attributes[ a ].needsUpdate = false;\n\n\t\t}\n\n\t};\n\n\t// Objects removal\n\n\tfunction removeObject( object, scene ) {\n\n\t\tif ( object instanceof THREE.Mesh  ||\n\t\t\t object instanceof THREE.ParticleSystem ||\n\t\t\t object instanceof THREE.Line ) {\n\n\t\t\tremoveInstances( scene.__webglObjects, object );\n\n\t\t} else if ( object instanceof THREE.Sprite ) {\n\n\t\t\tremoveInstancesDirect( scene.__webglSprites, object );\n\n\t\t} else if ( object instanceof THREE.LensFlare ) {\n\n\t\t\tremoveInstancesDirect( scene.__webglFlares, object );\n\n\t\t} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\n\n\t\t\tremoveInstances( scene.__webglObjectsImmediate, object );\n\n\t\t}\n\n\t\tdelete object.__webglActive;\n\n\t};\n\n\tfunction removeInstances( objlist, object ) {\n\n\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\n\n\t\t\tif ( objlist[ o ].object === object ) {\n\n\t\t\t\tobjlist.splice( o, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction removeInstancesDirect( objlist, object ) {\n\n\t\tfor ( var o = objlist.length - 1; o >= 0; o -- ) {\n\n\t\t\tif ( objlist[ o ] === object ) {\n\n\t\t\t\tobjlist.splice( o, 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Materials\n\n\tthis.initMaterial = function ( material, lights, fog, object ) {\n\n\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\n\n\t\tvar u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;\n\n\t\tif ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\tshaderID = 'depth';\n\n\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\tshaderID = 'normal';\n\n\t\t} else if ( material instanceof THREE.MeshBasicMaterial ) {\n\n\t\t\tshaderID = 'basic';\n\n\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\tshaderID = 'lambert';\n\n\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\tshaderID = 'phong';\n\n\t\t} else if ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\tshaderID = 'basic';\n\n\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\n\t\t\tshaderID = 'dashed';\n\n\t\t} else if ( material instanceof THREE.ParticleSystemMaterial ) {\n\n\t\t\tshaderID = 'particle_basic';\n\n\t\t}\n\n\t\tif ( shaderID ) {\n\n\t\t\tsetMaterialShaders( material, THREE.ShaderLib[ shaderID ] );\n\n\t\t}\n\n\t\t// heuristics to create shader parameters according to lights in the scene\n\t\t// (not to blow over maxLights budget)\n\n\t\tmaxLightCount = allocateLights( lights );\n\n\t\tmaxShadows = allocateShadows( lights );\n\n\t\tmaxBones = allocateBones( object );\n\n\t\tparameters = {\n\n\t\t\tmap: !!material.map,\n\t\t\tenvMap: !!material.envMap,\n\t\t\tlightMap: !!material.lightMap,\n\t\t\tbumpMap: !!material.bumpMap,\n\t\t\tnormalMap: !!material.normalMap,\n\t\t\tspecularMap: !!material.specularMap,\n\n\t\t\tvertexColors: material.vertexColors,\n\n\t\t\tfog: fog,\n\t\t\tuseFog: material.fog,\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\n\n\t\t\tsizeAttenuation: material.sizeAttenuation,\n\n\t\t\tskinning: material.skinning,\n\t\t\tmaxBones: maxBones,\n\t\t\tuseVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,\n\n\t\t\tmorphTargets: material.morphTargets,\n\t\t\tmorphNormals: material.morphNormals,\n\t\t\tmaxMorphTargets: this.maxMorphTargets,\n\t\t\tmaxMorphNormals: this.maxMorphNormals,\n\n\t\t\tmaxDirLights: maxLightCount.directional,\n\t\t\tmaxPointLights: maxLightCount.point,\n\t\t\tmaxSpotLights: maxLightCount.spot,\n\t\t\tmaxHemiLights: maxLightCount.hemi,\n\n\t\t\tmaxShadows: maxShadows,\n\t\t\tshadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,\n\t\t\tshadowMapType: this.shadowMapType,\n\t\t\tshadowMapDebug: this.shadowMapDebug,\n\t\t\tshadowMapCascade: this.shadowMapCascade,\n\n\t\t\talphaTest: material.alphaTest,\n\t\t\tmetal: material.metal,\n\t\t\tperPixel: material.perPixel,\n\t\t\twrapAround: material.wrapAround,\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\n\t\t\tflipSided: material.side === THREE.BackSide\n\n\t\t};\n\n\t\tmaterial.program = buildProgram( shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters, material.index0AttributeName );\n\n\t\tvar attributes = material.program.attributes;\n\n\t\tif ( material.morphTargets ) {\n\n\t\t\tmaterial.numSupportedMorphTargets = 0;\n\n\t\t\tvar id, base = \"morphTarget\";\n\n\t\t\tfor ( i = 0; i < this.maxMorphTargets; i ++ ) {\n\n\t\t\t\tid = base + i;\n\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( material.morphNormals ) {\n\n\t\t\tmaterial.numSupportedMorphNormals = 0;\n\n\t\t\tvar id, base = \"morphNormal\";\n\n\t\t\tfor ( i = 0; i < this.maxMorphNormals; i ++ ) {\n\n\t\t\t\tid = base + i;\n\n\t\t\t\tif ( attributes[ id ] >= 0 ) {\n\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tmaterial.uniformsList = [];\n\n\t\tfor ( u in material.uniforms ) {\n\n\t\t\tmaterial.uniformsList.push( [ material.uniforms[ u ], u ] );\n\n\t\t}\n\n\t};\n\n\tfunction setMaterialShaders( material, shaders ) {\n\n\t\tmaterial.uniforms = THREE.UniformsUtils.clone( shaders.uniforms );\n\t\tmaterial.vertexShader = shaders.vertexShader;\n\t\tmaterial.fragmentShader = shaders.fragmentShader;\n\n\t};\n\n\tfunction setProgram( camera, lights, fog, material, object ) {\n\n\t\t_usedTextureUnits = 0;\n\n\t\tif ( material.needsUpdate ) {\n\n\t\t\tif ( material.program ) deallocateMaterial( material );\n\n\t\t\t_this.initMaterial( material, lights, fog, object );\n\t\t\tmaterial.needsUpdate = false;\n\n\t\t}\n\n\t\tif ( material.morphTargets ) {\n\n\t\t\tif ( ! object.__webglMorphTargetInfluences ) {\n\n\t\t\t\tobject.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar refreshMaterial = false;\n\n\t\tvar program = material.program,\n\t\t\tp_uniforms = program.uniforms,\n\t\t\tm_uniforms = material.uniforms;\n\n\t\tif ( program !== _currentProgram ) {\n\n\t\t\t_gl.useProgram( program );\n\t\t\t_currentProgram = program;\n\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( material.id !== _currentMaterialId ) {\n\n\t\t\t_currentMaterialId = material.id;\n\t\t\trefreshMaterial = true;\n\n\t\t}\n\n\t\tif ( refreshMaterial || camera !== _currentCamera ) {\n\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\t\tif ( camera !== _currentCamera ) _currentCamera = camera;\n\n\t\t}\n\n\t\t// skinning uniforms must be set even if material didn't change\n\t\t// auto-setting of texture unit for bone texture must go before other textures\n\t\t// not sure why, but otherwise weird things happen\n\n\t\tif ( material.skinning ) {\n\n\t\t\tif ( _supportsBoneTextures && object.useVertexTexture ) {\n\n\t\t\t\tif ( p_uniforms.boneTexture !== null ) {\n\n\t\t\t\t\tvar textureUnit = getTextureUnit();\n\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\n\t\t\t\t\t_this.setTexture( object.boneTexture, textureUnit );\n\n\t\t\t\t}\n\n\t\t\t\tif ( p_uniforms.boneTextureWidth !== null ) {\n\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureWidth, object.boneTextureWidth );\n\n\t\t\t\t}\n\n\t\t\t\tif ( p_uniforms.boneTextureHeight !== null ) {\n\n\t\t\t\t\t_gl.uniform1i( p_uniforms.boneTextureHeight, object.boneTextureHeight );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( p_uniforms.boneGlobalMatrices !== null ) {\n\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( refreshMaterial ) {\n\n\t\t\t// refresh uniforms common to several materials\n\n\t\t\tif ( fog && material.fog ) {\n\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material.lights ) {\n\n\t\t\t\tif ( _lightsNeedUpdate ) {\n\n\t\t\t\t\tsetupLights( program, lights );\n\t\t\t\t\t_lightsNeedUpdate = false;\n\n\t\t\t\t}\n\n\t\t\t\trefreshUniformsLights( m_uniforms, _lights );\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\n\n\t\t\t}\n\n\t\t\t// refresh single material specific uniforms\n\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\n\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.ParticleSystemMaterial ) {\n\n\t\t\t\trefreshUniformsParticle( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\n\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\n\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\n\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\n\n\t\t\t\tm_uniforms.mNear.value = camera.near;\n\t\t\t\tm_uniforms.mFar.value = camera.far;\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\n\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\n\n\t\t\t}\n\n\t\t\tif ( object.receiveShadow && ! material._shadowPass ) {\n\n\t\t\t\trefreshUniformsShadow( m_uniforms, lights );\n\n\t\t\t}\n\n\t\t\t// load common uniforms\n\n\t\t\tloadUniformsGeneric( program, material.uniformsList );\n\n\t\t\t// load material specific uniforms\n\t\t\t// (shader material also gets them for the sake of genericity)\n\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material.envMap ) {\n\n\t\t\t\tif ( p_uniforms.cameraPosition !== null ) {\n\n\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld );\n\t\t\t\t\t_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\n\t\t\t\t material.skinning ) {\n\n\t\t\t\tif ( p_uniforms.viewMatrix !== null ) {\n\n\t\t\t\t\t_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tloadUniformsMatrices( p_uniforms, object );\n\n\t\tif ( p_uniforms.modelMatrix !== null ) {\n\n\t\t\t_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\n\n\t\t}\n\n\t\treturn program;\n\n\t};\n\n\t// Uniforms (refresh uniforms objects)\n\n\tfunction refreshUniformsCommon ( uniforms, material ) {\n\n\t\tuniforms.opacity.value = material.opacity;\n\n\t\tif ( _this.gammaInput ) {\n\n\t\t\tuniforms.diffuse.value.copyGammaToLinear( material.color );\n\n\t\t} else {\n\n\t\t\tuniforms.diffuse.value = material.color;\n\n\t\t}\n\n\t\tuniforms.map.value = material.map;\n\t\tuniforms.lightMap.value = material.lightMap;\n\t\tuniforms.specularMap.value = material.specularMap;\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\n\n\t\t}\n\n\t\tif ( material.normalMap ) {\n\n\t\t\tuniforms.normalMap.value = material.normalMap;\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\n\n\t\t}\n\n\t\t// uv repeat and offset setting priorities\n\t\t//\t1. color map\n\t\t//\t2. specular map\n\t\t//\t3. normal map\n\t\t//\t4. bump map\n\n\t\tvar uvScaleMap;\n\n\t\tif ( material.map ) {\n\n\t\t\tuvScaleMap = material.map;\n\n\t\t} else if ( material.specularMap ) {\n\n\t\t\tuvScaleMap = material.specularMap;\n\n\t\t} else if ( material.normalMap ) {\n\n\t\t\tuvScaleMap = material.normalMap;\n\n\t\t} else if ( material.bumpMap ) {\n\n\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t}\n\n\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\tvar offset = uvScaleMap.offset;\n\t\t\tvar repeat = uvScaleMap.repeat;\n\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\n\n\t\t}\n\n\t\tuniforms.envMap.value = material.envMap;\n\t\tuniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;\n\n\t\tif ( _this.gammaInput ) {\n\n\t\t\t//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\n\t\t} else {\n\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\n\n\t\t}\n\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\t\tuniforms.combine.value = material.combine;\n\t\tuniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;\n\n\t};\n\n\tfunction refreshUniformsLine ( uniforms, material ) {\n\n\t\tuniforms.diffuse.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\n\t};\n\n\tfunction refreshUniformsDash ( uniforms, material ) {\n\n\t\tuniforms.dashSize.value = material.dashSize;\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\n\t\tuniforms.scale.value = material.scale;\n\n\t};\n\n\tfunction refreshUniformsParticle ( uniforms, material ) {\n\n\t\tuniforms.psColor.value = material.color;\n\t\tuniforms.opacity.value = material.opacity;\n\t\tuniforms.size.value = material.size;\n\t\tuniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.\n\n\t\tuniforms.map.value = material.map;\n\n\t};\n\n\tfunction refreshUniformsFog ( uniforms, fog ) {\n\n\t\tuniforms.fogColor.value = fog.color;\n\n\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\tuniforms.fogNear.value = fog.near;\n\t\t\tuniforms.fogFar.value = fog.far;\n\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\tuniforms.fogDensity.value = fog.density;\n\n\t\t}\n\n\t};\n\n\tfunction refreshUniformsPhong ( uniforms, material ) {\n\n\t\tuniforms.shininess.value = material.shininess;\n\n\t\tif ( _this.gammaInput ) {\n\n\t\t\tuniforms.ambient.value.copyGammaToLinear( material.ambient );\n\t\t\tuniforms.emissive.value.copyGammaToLinear( material.emissive );\n\t\t\tuniforms.specular.value.copyGammaToLinear( material.specular );\n\n\t\t} else {\n\n\t\t\tuniforms.ambient.value = material.ambient;\n\t\t\tuniforms.emissive.value = material.emissive;\n\t\t\tuniforms.specular.value = material.specular;\n\n\t\t}\n\n\t\tif ( material.wrapAround ) {\n\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\n\n\t\t}\n\n\t};\n\n\tfunction refreshUniformsLambert ( uniforms, material ) {\n\n\t\tif ( _this.gammaInput ) {\n\n\t\t\tuniforms.ambient.value.copyGammaToLinear( material.ambient );\n\t\t\tuniforms.emissive.value.copyGammaToLinear( material.emissive );\n\n\t\t} else {\n\n\t\t\tuniforms.ambient.value = material.ambient;\n\t\t\tuniforms.emissive.value = material.emissive;\n\n\t\t}\n\n\t\tif ( material.wrapAround ) {\n\n\t\t\tuniforms.wrapRGB.value.copy( material.wrapRGB );\n\n\t\t}\n\n\t};\n\n\tfunction refreshUniformsLights ( uniforms, lights ) {\n\n\t\tuniforms.ambientLightColor.value = lights.ambient;\n\n\t\tuniforms.directionalLightColor.value = lights.directional.colors;\n\t\tuniforms.directionalLightDirection.value = lights.directional.positions;\n\n\t\tuniforms.pointLightColor.value = lights.point.colors;\n\t\tuniforms.pointLightPosition.value = lights.point.positions;\n\t\tuniforms.pointLightDistance.value = lights.point.distances;\n\n\t\tuniforms.spotLightColor.value = lights.spot.colors;\n\t\tuniforms.spotLightPosition.value = lights.spot.positions;\n\t\tuniforms.spotLightDistance.value = lights.spot.distances;\n\t\tuniforms.spotLightDirection.value = lights.spot.directions;\n\t\tuniforms.spotLightAngleCos.value = lights.spot.anglesCos;\n\t\tuniforms.spotLightExponent.value = lights.spot.exponents;\n\n\t\tuniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;\n\t\tuniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;\n\t\tuniforms.hemisphereLightDirection.value = lights.hemi.positions;\n\n\t};\n\n\tfunction refreshUniformsShadow ( uniforms, lights ) {\n\n\t\tif ( uniforms.shadowMatrix ) {\n\n\t\t\tvar j = 0;\n\n\t\t\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\t\tvar light = lights[ i ];\n\n\t\t\t\tif ( ! light.castShadow ) continue;\n\n\t\t\t\tif ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {\n\n\t\t\t\t\tuniforms.shadowMap.value[ j ] = light.shadowMap;\n\t\t\t\t\tuniforms.shadowMapSize.value[ j ] = light.shadowMapSize;\n\n\t\t\t\t\tuniforms.shadowMatrix.value[ j ] = light.shadowMatrix;\n\n\t\t\t\t\tuniforms.shadowDarkness.value[ j ] = light.shadowDarkness;\n\t\t\t\t\tuniforms.shadowBias.value[ j ] = light.shadowBias;\n\n\t\t\t\t\tj ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Uniforms (load to GPU)\n\n\tfunction loadUniformsMatrices ( uniforms, object ) {\n\n\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );\n\n\t\tif ( uniforms.normalMatrix ) {\n\n\t\t\t_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );\n\n\t\t}\n\n\t};\n\n\tfunction getTextureUnit() {\n\n\t\tvar textureUnit = _usedTextureUnits;\n\n\t\tif ( textureUnit >= _maxTextures ) {\n\n\t\t\tconsole.warn( \"WebGLRenderer: trying to use \" + textureUnit + \" texture units while this GPU supports only \" + _maxTextures );\n\n\t\t}\n\n\t\t_usedTextureUnits += 1;\n\n\t\treturn textureUnit;\n\n\t};\n\n\tfunction loadUniformsGeneric ( program, uniforms ) {\n\n\t\tvar uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;\n\n\t\tfor ( j = 0, jl = uniforms.length; j < jl; j ++ ) {\n\n\t\t\tlocation = program.uniforms[ uniforms[ j ][ 1 ] ];\n\t\t\tif ( !location ) continue;\n\n\t\t\tuniform = uniforms[ j ][ 0 ];\n\n\t\t\ttype = uniform.type;\n\t\t\tvalue = uniform.value;\n\n\t\t\tif ( type === \"i\" ) { // single integer\n\n\t\t\t\t_gl.uniform1i( location, value );\n\n\t\t\t} else if ( type === \"f\" ) { // single float\n\n\t\t\t\t_gl.uniform1f( location, value );\n\n\t\t\t} else if ( type === \"v2\" ) { // single THREE.Vector2\n\n\t\t\t\t_gl.uniform2f( location, value.x, value.y );\n\n\t\t\t} else if ( type === \"v3\" ) { // single THREE.Vector3\n\n\t\t\t\t_gl.uniform3f( location, value.x, value.y, value.z );\n\n\t\t\t} else if ( type === \"v4\" ) { // single THREE.Vector4\n\n\t\t\t\t_gl.uniform4f( location, value.x, value.y, value.z, value.w );\n\n\t\t\t} else if ( type === \"c\" ) { // single THREE.Color\n\n\t\t\t\t_gl.uniform3f( location, value.r, value.g, value.b );\n\n\t\t\t} else if ( type === \"iv1\" ) { // flat array of integers (JS or typed array)\n\n\t\t\t\t_gl.uniform1iv( location, value );\n\n\t\t\t} else if ( type === \"iv\" ) { // flat array of integers with 3 x N size (JS or typed array)\n\n\t\t\t\t_gl.uniform3iv( location, value );\n\n\t\t\t} else if ( type === \"fv1\" ) { // flat array of floats (JS or typed array)\n\n\t\t\t\t_gl.uniform1fv( location, value );\n\n\t\t\t} else if ( type === \"fv\" ) { // flat array of floats with 3 x N size (JS or typed array)\n\n\t\t\t\t_gl.uniform3fv( location, value );\n\n\t\t\t} else if ( type === \"v2v\" ) { // array of THREE.Vector2\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 2 * value.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\n\t\t\t\t\toffset = i * 2;\n\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniform2fv( location, uniform._array );\n\n\t\t\t} else if ( type === \"v3v\" ) { // array of THREE.Vector3\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 3 * value.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\n\t\t\t\t\toffset = i * 3;\n\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\n\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniform3fv( location, uniform._array );\n\n\t\t\t} else if ( type === \"v4v\" ) { // array of THREE.Vector4\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 4 * value.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\n\t\t\t\t\toffset = i * 4;\n\n\t\t\t\t\tuniform._array[ offset ] \t = value[ i ].x;\n\t\t\t\t\tuniform._array[ offset + 1 ] = value[ i ].y;\n\t\t\t\t\tuniform._array[ offset + 2 ] = value[ i ].z;\n\t\t\t\t\tuniform._array[ offset + 3 ] = value[ i ].w;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniform4fv( location, uniform._array );\n\n\t\t\t} else if ( type === \"m4\") { // single THREE.Matrix4\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 16 );\n\n\t\t\t\t}\n\n\t\t\t\tvalue.flattenToArray( uniform._array );\n\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\n\n\t\t\t} else if ( type === \"m4v\" ) { // array of THREE.Matrix4\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = new Float32Array( 16 * value.length );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( i = 0, il = value.length; i < il; i ++ ) {\n\n\t\t\t\t\tvalue[ i ].flattenToArrayOffset( uniform._array, i * 16 );\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniformMatrix4fv( location, false, uniform._array );\n\n\t\t\t} else if ( type === \"t\" ) { // single THREE.Texture (2d or cube)\n\n\t\t\t\ttexture = value;\n\t\t\t\ttextureUnit = getTextureUnit();\n\n\t\t\t\t_gl.uniform1i( location, textureUnit );\n\n\t\t\t\tif ( !texture ) continue;\n\n\t\t\t\tif ( texture.image instanceof Array && texture.image.length === 6 ) {\n\n\t\t\t\t\tsetCubeTexture( texture, textureUnit );\n\n\t\t\t\t} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\t\t\tsetCubeTextureDynamic( texture, textureUnit );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_this.setTexture( texture, textureUnit );\n\n\t\t\t\t}\n\n\t\t\t} else if ( type === \"tv\" ) { // array of THREE.Texture (2d)\n\n\t\t\t\tif ( uniform._array === undefined ) {\n\n\t\t\t\t\tuniform._array = [];\n\n\t\t\t\t}\n\n\t\t\t\tfor( i = 0, il = uniform.value.length; i < il; i ++ ) {\n\n\t\t\t\t\tuniform._array[ i ] = getTextureUnit();\n\n\t\t\t\t}\n\n\t\t\t\t_gl.uniform1iv( location, uniform._array );\n\n\t\t\t\tfor( i = 0, il = uniform.value.length; i < il; i ++ ) {\n\n\t\t\t\t\ttexture = uniform.value[ i ];\n\t\t\t\t\ttextureUnit = uniform._array[ i ];\n\n\t\t\t\t\tif ( !texture ) continue;\n\n\t\t\t\t\t_this.setTexture( texture, textureUnit );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction setupMatrices ( object, camera ) {\n\n\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\t\tobject._normalMatrix.getNormalMatrix( object._modelViewMatrix );\n\n\t};\n\n\t//\n\n\tfunction setColorGamma( array, offset, color, intensitySq ) {\n\n\t\tarray[ offset ]     = color.r * color.r * intensitySq;\n\t\tarray[ offset + 1 ] = color.g * color.g * intensitySq;\n\t\tarray[ offset + 2 ] = color.b * color.b * intensitySq;\n\n\t};\n\n\tfunction setColorLinear( array, offset, color, intensity ) {\n\n\t\tarray[ offset ]     = color.r * intensity;\n\t\tarray[ offset + 1 ] = color.g * intensity;\n\t\tarray[ offset + 2 ] = color.b * intensity;\n\n\t};\n\n\tfunction setupLights ( program, lights ) {\n\n\t\tvar l, ll, light, n,\n\t\tr = 0, g = 0, b = 0,\n\t\tcolor, skyColor, groundColor,\n\t\tintensity,  intensitySq,\n\t\tposition,\n\t\tdistance,\n\n\t\tzlights = _lights,\n\n\t\tdirColors = zlights.directional.colors,\n\t\tdirPositions = zlights.directional.positions,\n\n\t\tpointColors = zlights.point.colors,\n\t\tpointPositions = zlights.point.positions,\n\t\tpointDistances = zlights.point.distances,\n\n\t\tspotColors = zlights.spot.colors,\n\t\tspotPositions = zlights.spot.positions,\n\t\tspotDistances = zlights.spot.distances,\n\t\tspotDirections = zlights.spot.directions,\n\t\tspotAnglesCos = zlights.spot.anglesCos,\n\t\tspotExponents = zlights.spot.exponents,\n\n\t\themiSkyColors = zlights.hemi.skyColors,\n\t\themiGroundColors = zlights.hemi.groundColors,\n\t\themiPositions = zlights.hemi.positions,\n\n\t\tdirLength = 0,\n\t\tpointLength = 0,\n\t\tspotLength = 0,\n\t\themiLength = 0,\n\n\t\tdirCount = 0,\n\t\tpointCount = 0,\n\t\tspotCount = 0,\n\t\themiCount = 0,\n\n\t\tdirOffset = 0,\n\t\tpointOffset = 0,\n\t\tspotOffset = 0,\n\t\themiOffset = 0;\n\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\tlight = lights[ l ];\n\n\t\t\tif ( light.onlyShadow ) continue;\n\n\t\t\tcolor = light.color;\n\t\t\tintensity = light.intensity;\n\t\t\tdistance = light.distance;\n\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\n\n\t\t\t\tif ( ! light.visible ) continue;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tr += color.r * color.r;\n\t\t\t\t\tg += color.g * color.g;\n\t\t\t\t\tb += color.b * color.b;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tr += color.r;\n\t\t\t\t\tg += color.g;\n\t\t\t\t\tb += color.b;\n\n\t\t\t\t}\n\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\tdirCount += 1;\n\n\t\t\t\tif ( ! light.visible ) continue;\n\n\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t_direction.sub( _vector3 );\n\t\t\t\t_direction.normalize();\n\n\t\t\t\t// skip lights with undefined direction\n\t\t\t\t// these create troubles in OpenGL (making pixel black)\n\n\t\t\t\tif ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;\n\n\t\t\t\tdirOffset = dirLength * 3;\n\n\t\t\t\tdirPositions[ dirOffset ]     = _direction.x;\n\t\t\t\tdirPositions[ dirOffset + 1 ] = _direction.y;\n\t\t\t\tdirPositions[ dirOffset + 2 ] = _direction.z;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tsetColorGamma( dirColors, dirOffset, color, intensity * intensity );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetColorLinear( dirColors, dirOffset, color, intensity );\n\n\t\t\t\t}\n\n\t\t\t\tdirLength += 1;\n\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\n\n\t\t\t\tpointCount += 1;\n\n\t\t\t\tif ( ! light.visible ) continue;\n\n\t\t\t\tpointOffset = pointLength * 3;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tsetColorGamma( pointColors, pointOffset, color, intensity * intensity );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetColorLinear( pointColors, pointOffset, color, intensity );\n\n\t\t\t\t}\n\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld );\n\n\t\t\t\tpointPositions[ pointOffset ]     = _vector3.x;\n\t\t\t\tpointPositions[ pointOffset + 1 ] = _vector3.y;\n\t\t\t\tpointPositions[ pointOffset + 2 ] = _vector3.z;\n\n\t\t\t\tpointDistances[ pointLength ] = distance;\n\n\t\t\t\tpointLength += 1;\n\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\n\n\t\t\t\tspotCount += 1;\n\n\t\t\t\tif ( ! light.visible ) continue;\n\n\t\t\t\tspotOffset = spotLength * 3;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tsetColorGamma( spotColors, spotOffset, color, intensity * intensity );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetColorLinear( spotColors, spotOffset, color, intensity );\n\n\t\t\t\t}\n\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld );\n\n\t\t\t\tspotPositions[ spotOffset ]     = _vector3.x;\n\t\t\t\tspotPositions[ spotOffset + 1 ] = _vector3.y;\n\t\t\t\tspotPositions[ spotOffset + 2 ] = _vector3.z;\n\n\t\t\t\tspotDistances[ spotLength ] = distance;\n\n\t\t\t\t_direction.copy( _vector3 );\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\t\t_direction.sub( _vector3 );\n\t\t\t\t_direction.normalize();\n\n\t\t\t\tspotDirections[ spotOffset ]     = _direction.x;\n\t\t\t\tspotDirections[ spotOffset + 1 ] = _direction.y;\n\t\t\t\tspotDirections[ spotOffset + 2 ] = _direction.z;\n\n\t\t\t\tspotAnglesCos[ spotLength ] = Math.cos( light.angle );\n\t\t\t\tspotExponents[ spotLength ] = light.exponent;\n\n\t\t\t\tspotLength += 1;\n\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\n\n\t\t\t\themiCount += 1;\n\n\t\t\t\tif ( ! light.visible ) continue;\n\n\t\t\t\t_direction.setFromMatrixPosition( light.matrixWorld );\n\t\t\t\t_direction.normalize();\n\n\t\t\t\t// skip lights with undefined direction\n\t\t\t\t// these create troubles in OpenGL (making pixel black)\n\n\t\t\t\tif ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;\n\n\t\t\t\themiOffset = hemiLength * 3;\n\n\t\t\t\themiPositions[ hemiOffset ]     = _direction.x;\n\t\t\t\themiPositions[ hemiOffset + 1 ] = _direction.y;\n\t\t\t\themiPositions[ hemiOffset + 2 ] = _direction.z;\n\n\t\t\t\tskyColor = light.color;\n\t\t\t\tgroundColor = light.groundColor;\n\n\t\t\t\tif ( _this.gammaInput ) {\n\n\t\t\t\t\tintensitySq = intensity * intensity;\n\n\t\t\t\t\tsetColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );\n\t\t\t\t\tsetColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );\n\t\t\t\t\tsetColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );\n\n\t\t\t\t}\n\n\t\t\t\themiLength += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// null eventual remains from removed lights\n\t\t// (this is to avoid if in shader)\n\n\t\tfor ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;\n\t\tfor ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;\n\t\tfor ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;\n\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;\n\t\tfor ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;\n\n\t\tzlights.directional.length = dirLength;\n\t\tzlights.point.length = pointLength;\n\t\tzlights.spot.length = spotLength;\n\t\tzlights.hemi.length = hemiLength;\n\n\t\tzlights.ambient[ 0 ] = r;\n\t\tzlights.ambient[ 1 ] = g;\n\t\tzlights.ambient[ 2 ] = b;\n\n\t};\n\n\t// GL state setting\n\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\n\n\t\tif ( cullFace === THREE.CullFaceNone ) {\n\n\t\t\t_gl.disable( _gl.CULL_FACE );\n\n\t\t} else {\n\n\t\t\tif ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\n\n\t\t\t\t_gl.frontFace( _gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.frontFace( _gl.CCW );\n\n\t\t\t}\n\n\t\t\tif ( cullFace === THREE.CullFaceBack ) {\n\n\t\t\t\t_gl.cullFace( _gl.BACK );\n\n\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\n\n\t\t\t\t_gl.cullFace( _gl.FRONT );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.cullFace( _gl.FRONT_AND_BACK );\n\n\t\t\t}\n\n\t\t\t_gl.enable( _gl.CULL_FACE );\n\n\t\t}\n\n\t};\n\n\tthis.setMaterialFaces = function ( material ) {\n\n\t\tvar doubleSided = material.side === THREE.DoubleSide;\n\t\tvar flipSided = material.side === THREE.BackSide;\n\n\t\tif ( _oldDoubleSided !== doubleSided ) {\n\n\t\t\tif ( doubleSided ) {\n\n\t\t\t\t_gl.disable( _gl.CULL_FACE );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.enable( _gl.CULL_FACE );\n\n\t\t\t}\n\n\t\t\t_oldDoubleSided = doubleSided;\n\n\t\t}\n\n\t\tif ( _oldFlipSided !== flipSided ) {\n\n\t\t\tif ( flipSided ) {\n\n\t\t\t\t_gl.frontFace( _gl.CW );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.frontFace( _gl.CCW );\n\n\t\t\t}\n\n\t\t\t_oldFlipSided = flipSided;\n\n\t\t}\n\n\t};\n\n\tthis.setDepthTest = function ( depthTest ) {\n\n\t\tif ( _oldDepthTest !== depthTest ) {\n\n\t\t\tif ( depthTest ) {\n\n\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\n\n\t\t\t}\n\n\t\t\t_oldDepthTest = depthTest;\n\n\t\t}\n\n\t};\n\n\tthis.setDepthWrite = function ( depthWrite ) {\n\n\t\tif ( _oldDepthWrite !== depthWrite ) {\n\n\t\t\t_gl.depthMask( depthWrite );\n\t\t\t_oldDepthWrite = depthWrite;\n\n\t\t}\n\n\t};\n\n\tfunction setLineWidth ( width ) {\n\n\t\tif ( width !== _oldLineWidth ) {\n\n\t\t\t_gl.lineWidth( width );\n\n\t\t\t_oldLineWidth = width;\n\n\t\t}\n\n\t};\n\n\tfunction setPolygonOffset ( polygonoffset, factor, units ) {\n\n\t\tif ( _oldPolygonOffset !== polygonoffset ) {\n\n\t\t\tif ( polygonoffset ) {\n\n\t\t\t\t_gl.enable( _gl.POLYGON_OFFSET_FILL );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.disable( _gl.POLYGON_OFFSET_FILL );\n\n\t\t\t}\n\n\t\t\t_oldPolygonOffset = polygonoffset;\n\n\t\t}\n\n\t\tif ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {\n\n\t\t\t_gl.polygonOffset( factor, units );\n\n\t\t\t_oldPolygonOffsetFactor = factor;\n\t\t\t_oldPolygonOffsetUnits = units;\n\n\t\t}\n\n\t};\n\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {\n\n\t\tif ( blending !== _oldBlending ) {\n\n\t\t\tif ( blending === THREE.NoBlending ) {\n\n\t\t\t\t_gl.disable( _gl.BLEND );\n\n\t\t\t} else if ( blending === THREE.AdditiveBlending ) {\n\n\t\t\t\t_gl.enable( _gl.BLEND );\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\t\t\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );\n\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\n\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\n\t\t\t\t_gl.enable( _gl.BLEND );\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\t\t\t\t_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );\n\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\n\n\t\t\t\t// TODO: Find blendFuncSeparate() combination\n\t\t\t\t_gl.enable( _gl.BLEND );\n\t\t\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\t\t\t\t_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );\n\n\t\t\t} else if ( blending === THREE.CustomBlending ) {\n\n\t\t\t\t_gl.enable( _gl.BLEND );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.enable( _gl.BLEND );\n\t\t\t\t_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );\n\t\t\t\t_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t\t}\n\n\t\t\t_oldBlending = blending;\n\n\t\t}\n\n\t\tif ( blending === THREE.CustomBlending ) {\n\n\t\t\tif ( blendEquation !== _oldBlendEquation ) {\n\n\t\t\t\t_gl.blendEquation( paramThreeToGL( blendEquation ) );\n\n\t\t\t\t_oldBlendEquation = blendEquation;\n\n\t\t\t}\n\n\t\t\tif ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {\n\n\t\t\t\t_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );\n\n\t\t\t\t_oldBlendSrc = blendSrc;\n\t\t\t\t_oldBlendDst = blendDst;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_oldBlendEquation = null;\n\t\t\t_oldBlendSrc = null;\n\t\t\t_oldBlendDst = null;\n\n\t\t}\n\n\t};\n\n\t// Defines\n\n\tfunction generateDefines ( defines ) {\n\n\t\tvar value, chunk, chunks = [];\n\n\t\tfor ( var d in defines ) {\n\n\t\t\tvalue = defines[ d ];\n\t\t\tif ( value === false ) continue;\n\n\t\t\tchunk = \"#define \" + d + \" \" + value;\n\t\t\tchunks.push( chunk );\n\n\t\t}\n\n\t\treturn chunks.join( \"\\n\" );\n\n\t};\n\n\t// Shaders\n\n\tfunction buildProgram ( shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters, index0AttributeName ) {\n\n\t\tvar p, pl, d, program, code;\n\t\tvar chunks = [];\n\n\t\t// Generate code\n\n\t\tif ( shaderID ) {\n\n\t\t\tchunks.push( shaderID );\n\n\t\t} else {\n\n\t\t\tchunks.push( fragmentShader );\n\t\t\tchunks.push( vertexShader );\n\n\t\t}\n\n\t\tfor ( d in defines ) {\n\n\t\t\tchunks.push( d );\n\t\t\tchunks.push( defines[ d ] );\n\n\t\t}\n\n\t\tfor ( p in parameters ) {\n\n\t\t\tchunks.push( p );\n\t\t\tchunks.push( parameters[ p ] );\n\n\t\t}\n\n\t\tcode = chunks.join();\n\n\t\t// Check if code has been already compiled\n\n\t\tfor ( p = 0, pl = _programs.length; p < pl; p ++ ) {\n\n\t\t\tvar programInfo = _programs[ p ];\n\n\t\t\tif ( programInfo.code === code ) {\n\n\t\t\t\t// console.log( \"Code already compiled.\" /*: \\n\\n\" + code*/ );\n\n\t\t\t\tprogramInfo.usedTimes ++;\n\n\t\t\t\treturn programInfo.program;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar shadowMapTypeDefine = \"SHADOWMAP_TYPE_BASIC\";\n\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF\";\n\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\n\n\t\t\tshadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF_SOFT\";\n\n\t\t}\n\n\t\t// console.log( \"building new program \" );\n\n\t\t//\n\n\t\tvar customDefines = generateDefines( defines );\n\n\t\t//\n\n\t\tprogram = _gl.createProgram();\n\n\t\tvar prefix_vertex = [\n\n\t\t\t\"precision \" + _precision + \" float;\",\n\t\t\t\"precision \" + _precision + \" int;\",\n\n\t\t\tcustomDefines,\n\n\t\t\t_supportsVertexTextures ? \"#define VERTEX_TEXTURES\" : \"\",\n\n\t\t\t_this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\n\t\t\t_this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\n\n\t\t\t\"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\n\t\t\t\"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\n\t\t\t\"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\n\t\t\t\"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\n\n\t\t\t\"#define MAX_SHADOWS \" + parameters.maxShadows,\n\n\t\t\t\"#define MAX_BONES \" + parameters.maxBones,\n\n\t\t\tparameters.map ? \"#define USE_MAP\" : \"\",\n\t\t\tparameters.envMap ? \"#define USE_ENVMAP\" : \"\",\n\t\t\tparameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n\t\t\tparameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n\t\t\tparameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n\t\t\tparameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n\t\t\tparameters.vertexColors ? \"#define USE_COLOR\" : \"\",\n\n\t\t\tparameters.skinning ? \"#define USE_SKINNING\" : \"\",\n\t\t\tparameters.useVertexTexture ? \"#define BONE_TEXTURE\" : \"\",\n\n\t\t\tparameters.morphTargets ? \"#define USE_MORPHTARGETS\" : \"\",\n\t\t\tparameters.morphNormals ? \"#define USE_MORPHNORMALS\" : \"\",\n\t\t\tparameters.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\",\n\t\t\tparameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\n\t\t\tparameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n\t\t\tparameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n\n\t\t\tparameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n\t\t\tparameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\n\t\t\tparameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\n\t\t\tparameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\n\n\t\t\tparameters.sizeAttenuation ? \"#define USE_SIZEATTENUATION\" : \"\",\n\n\t\t\t\"uniform mat4 modelMatrix;\",\n\t\t\t\"uniform mat4 modelViewMatrix;\",\n\t\t\t\"uniform mat4 projectionMatrix;\",\n\t\t\t\"uniform mat4 viewMatrix;\",\n\t\t\t\"uniform mat3 normalMatrix;\",\n\t\t\t\"uniform vec3 cameraPosition;\",\n\n\t\t\t\"attribute vec3 position;\",\n\t\t\t\"attribute vec3 normal;\",\n\t\t\t\"attribute vec2 uv;\",\n\t\t\t\"attribute vec2 uv2;\",\n\n\t\t\t\"#ifdef USE_COLOR\",\n\n\t\t\t\t\"attribute vec3 color;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef USE_MORPHTARGETS\",\n\n\t\t\t\t\"attribute vec3 morphTarget0;\",\n\t\t\t\t\"attribute vec3 morphTarget1;\",\n\t\t\t\t\"attribute vec3 morphTarget2;\",\n\t\t\t\t\"attribute vec3 morphTarget3;\",\n\n\t\t\t\t\"#ifdef USE_MORPHNORMALS\",\n\n\t\t\t\t\t\"attribute vec3 morphNormal0;\",\n\t\t\t\t\t\"attribute vec3 morphNormal1;\",\n\t\t\t\t\t\"attribute vec3 morphNormal2;\",\n\t\t\t\t\t\"attribute vec3 morphNormal3;\",\n\n\t\t\t\t\"#else\",\n\n\t\t\t\t\t\"attribute vec3 morphTarget4;\",\n\t\t\t\t\t\"attribute vec3 morphTarget5;\",\n\t\t\t\t\t\"attribute vec3 morphTarget6;\",\n\t\t\t\t\t\"attribute vec3 morphTarget7;\",\n\n\t\t\t\t\"#endif\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"#ifdef USE_SKINNING\",\n\n\t\t\t\t\"attribute vec4 skinIndex;\",\n\t\t\t\t\"attribute vec4 skinWeight;\",\n\n\t\t\t\"#endif\",\n\n\t\t\t\"\"\n\n\t\t].join(\"\\n\");\n\n\t\tvar prefix_fragment = [\n\n\t\t\t\"precision \" + _precision + \" float;\",\n\t\t\t\"precision \" + _precision + \" int;\",\n\n\t\t\t( parameters.bumpMap || parameters.normalMap ) ? \"#extension GL_OES_standard_derivatives : enable\" : \"\",\n\n\t\t\tcustomDefines,\n\n\t\t\t\"#define MAX_DIR_LIGHTS \" + parameters.maxDirLights,\n\t\t\t\"#define MAX_POINT_LIGHTS \" + parameters.maxPointLights,\n\t\t\t\"#define MAX_SPOT_LIGHTS \" + parameters.maxSpotLights,\n\t\t\t\"#define MAX_HEMI_LIGHTS \" + parameters.maxHemiLights,\n\n\t\t\t\"#define MAX_SHADOWS \" + parameters.maxShadows,\n\n\t\t\tparameters.alphaTest ? \"#define ALPHATEST \" + parameters.alphaTest: \"\",\n\n\t\t\t_this.gammaInput ? \"#define GAMMA_INPUT\" : \"\",\n\t\t\t_this.gammaOutput ? \"#define GAMMA_OUTPUT\" : \"\",\n\n\t\t\t( parameters.useFog && parameters.fog ) ? \"#define USE_FOG\" : \"\",\n\t\t\t( parameters.useFog && parameters.fogExp ) ? \"#define FOG_EXP2\" : \"\",\n\n\t\t\tparameters.map ? \"#define USE_MAP\" : \"\",\n\t\t\tparameters.envMap ? \"#define USE_ENVMAP\" : \"\",\n\t\t\tparameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n\t\t\tparameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n\t\t\tparameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n\t\t\tparameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n\t\t\tparameters.vertexColors ? \"#define USE_COLOR\" : \"\",\n\n\t\t\tparameters.metal ? \"#define METAL\" : \"\",\n\t\t\tparameters.perPixel ? \"#define PHONG_PER_PIXEL\" : \"\",\n\t\t\tparameters.wrapAround ? \"#define WRAP_AROUND\" : \"\",\n\t\t\tparameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n\t\t\tparameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n\n\t\t\tparameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n\t\t\tparameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\n\t\t\tparameters.shadowMapDebug ? \"#define SHADOWMAP_DEBUG\" : \"\",\n\t\t\tparameters.shadowMapCascade ? \"#define SHADOWMAP_CASCADE\" : \"\",\n\n\t\t\t\"uniform mat4 viewMatrix;\",\n\t\t\t\"uniform vec3 cameraPosition;\",\n\t\t\t\"\"\n\n\t\t].join(\"\\n\");\n\n\t\tvar glVertexShader = getShader( \"vertex\", prefix_vertex + vertexShader );\n\t\tvar glFragmentShader = getShader( \"fragment\", prefix_fragment + fragmentShader );\n\n\t\t_gl.attachShader( program, glVertexShader );\n\t\t_gl.attachShader( program, glFragmentShader );\n\n\t\t//Force a particular attribute to index 0.\n\t\t// because potentially expensive emulation is done by browser if attribute 0 is disabled.\n\t\t//And, color, for example is often automatically bound to index 0 so disabling it\n\t\tif ( index0AttributeName ) {\n\t\t\t_gl.bindAttribLocation( program, 0, index0AttributeName );\n\t\t}\n\n\t\t_gl.linkProgram( program );\n\n\t\tif ( !_gl.getProgramParameter( program, _gl.LINK_STATUS ) ) {\n\n\t\t\tconsole.error( \"Could not initialise shader\\n\" + \"VALIDATE_STATUS: \" + _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) + \", gl error [\" + _gl.getError() + \"]\" );\n\t\t\tconsole.error( \"Program Info Log: \" + _gl.getProgramInfoLog( program ) );\n\t\t}\n\n\t\t// clean up\n\n\t\t_gl.deleteShader( glFragmentShader );\n\t\t_gl.deleteShader( glVertexShader );\n\n\t\t// console.log( prefix_fragment + fragmentShader );\n\t\t// console.log( prefix_vertex + vertexShader );\n\n\t\tprogram.uniforms = {};\n\t\tprogram.attributes = {};\n\n\t\tvar identifiers, u, a, i;\n\n\t\t// cache uniform locations\n\n\t\tidentifiers = [\n\n\t\t\t'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',\n\t\t\t'morphTargetInfluences'\n\n\t\t];\n\n\t\tif ( parameters.useVertexTexture ) {\n\n\t\t\tidentifiers.push( 'boneTexture' );\n\t\t\tidentifiers.push( 'boneTextureWidth' );\n\t\t\tidentifiers.push( 'boneTextureHeight' );\n\n\t\t} else {\n\n\t\t\tidentifiers.push( 'boneGlobalMatrices' );\n\n\t\t}\n\n\t\tfor ( u in uniforms ) {\n\n\t\t\tidentifiers.push( u );\n\n\t\t}\n\n\t\tcacheUniformLocations( program, identifiers );\n\n\t\t// cache attributes locations\n\n\t\tidentifiers = [\n\n\t\t\t\"position\", \"normal\", \"uv\", \"uv2\", \"tangent\", \"color\",\n\t\t\t\"skinIndex\", \"skinWeight\", \"lineDistance\"\n\n\t\t];\n\n\t\tfor ( i = 0; i < parameters.maxMorphTargets; i ++ ) {\n\n\t\t\tidentifiers.push( \"morphTarget\" + i );\n\n\t\t}\n\n\t\tfor ( i = 0; i < parameters.maxMorphNormals; i ++ ) {\n\n\t\t\tidentifiers.push( \"morphNormal\" + i );\n\n\t\t}\n\n\t\tfor ( a in attributes ) {\n\n\t\t\tidentifiers.push( a );\n\n\t\t}\n\n\t\tcacheAttributeLocations( program, identifiers );\n\n\t\tprogram.id = _programs_counter ++;\n\n\t\t_programs.push( { program: program, code: code, usedTimes: 1 } );\n\n\t\t_this.info.memory.programs = _programs.length;\n\n\t\treturn program;\n\n\t};\n\n\t// Shader parameters cache\n\n\tfunction cacheUniformLocations ( program, identifiers ) {\n\n\t\tvar i, l, id;\n\n\t\tfor( i = 0, l = identifiers.length; i < l; i ++ ) {\n\n\t\t\tid = identifiers[ i ];\n\t\t\tprogram.uniforms[ id ] = _gl.getUniformLocation( program, id );\n\n\t\t}\n\n\t};\n\n\tfunction cacheAttributeLocations ( program, identifiers ) {\n\n\t\tvar i, l, id;\n\n\t\tfor( i = 0, l = identifiers.length; i < l; i ++ ) {\n\n\t\t\tid = identifiers[ i ];\n\t\t\tprogram.attributes[ id ] = _gl.getAttribLocation( program, id );\n\n\t\t}\n\n\t};\n\n\tfunction addLineNumbers ( string ) {\n\n\t\tvar chunks = string.split( \"\\n\" );\n\n\t\tfor ( var i = 0, il = chunks.length; i < il; i ++ ) {\n\n\t\t\t// Chrome reports shader errors on lines\n\t\t\t// starting counting from 1\n\n\t\t\tchunks[ i ] = ( i + 1 ) + \": \" + chunks[ i ];\n\n\t\t}\n\n\t\treturn chunks.join( \"\\n\" );\n\n\t};\n\n\tfunction getShader ( type, string ) {\n\n\t\tvar shader;\n\n\t\tif ( type === \"fragment\" ) {\n\n\t\t\tshader = _gl.createShader( _gl.FRAGMENT_SHADER );\n\n\t\t} else if ( type === \"vertex\" ) {\n\n\t\t\tshader = _gl.createShader( _gl.VERTEX_SHADER );\n\n\t\t}\n\n\t\t_gl.shaderSource( shader, string );\n\t\t_gl.compileShader( shader );\n\n\t\tif ( !_gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {\n\n\t\t\tconsole.error( _gl.getShaderInfoLog( shader ) );\n\t\t\tconsole.error( addLineNumbers( string ) );\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn shader;\n\n\t};\n\n\t// Textures\n\n\n\tfunction isPowerOfTwo ( value ) {\n\n\t\treturn ( value & ( value - 1 ) ) === 0;\n\n\t};\n\n\tfunction setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {\n\n\t\tif ( isImagePowerOfTwo ) {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\n\n\t\t} else {\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\n\n\t\t}\n\n\t\tif ( _glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType ) {\n\n\t\t\tif ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {\n\n\t\t\t\t_gl.texParameterf( textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _maxAnisotropy ) );\n\t\t\t\ttexture.__oldAnisotropy = texture.anisotropy;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.setTexture = function ( texture, slot ) {\n\n\t\tif ( texture.needsUpdate ) {\n\n\t\t\tif ( ! texture.__webglInit ) {\n\n\t\t\t\ttexture.__webglInit = true;\n\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\ttexture.__webglTexture = _gl.createTexture();\n\n\t\t\t\t_this.info.memory.textures ++;\n\n\t\t\t}\n\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\n\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\n\n\t\t\tvar image = texture.image,\n\t\t\tisImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),\n\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );\n\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\n\n\t\t\tif ( texture instanceof THREE.DataTexture ) {\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\n\n\t\t\t\t}\n\n\t\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\n\n\t\t\t\tfor( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\tif ( texture.format!==THREE.RGBAFormat ) {\n\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\t\t\t\t\t} else {\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else { // regular Texture (image, video, canvas)\n\n\t\t\t\t// use manually created mipmaps if available\n\t\t\t\t// if there are no manual mipmaps\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\n\n\t\t\t\tif ( mipmaps.length > 0 && isImagePowerOfTwo ) {\n\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.generateMipmaps = false;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\ttexture.needsUpdate = false;\n\n\t\t\tif ( texture.onUpdate ) texture.onUpdate();\n\n\t\t} else {\n\n\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\n\n\t\t}\n\n\t};\n\n\tfunction clampToMaxSize ( image, maxSize ) {\n\n\t\tif ( image.width <= maxSize && image.height <= maxSize ) {\n\n\t\t\treturn image;\n\n\t\t}\n\n\t\t// Warning: Scaling through the canvas will only work with images that use\n\t\t// premultiplied alpha.\n\n\t\tvar maxDimension = Math.max( image.width, image.height );\n\t\tvar newWidth = Math.floor( image.width * maxSize / maxDimension );\n\t\tvar newHeight = Math.floor( image.height * maxSize / maxDimension );\n\n\t\tvar canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = newWidth;\n\t\tcanvas.height = newHeight;\n\n\t\tvar ctx = canvas.getContext( \"2d\" );\n\t\tctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );\n\n\t\treturn canvas;\n\n\t}\n\n\tfunction setCubeTexture ( texture, slot ) {\n\n\t\tif ( texture.image.length === 6 ) {\n\n\t\t\tif ( texture.needsUpdate ) {\n\n\t\t\t\tif ( ! texture.image.__webglTextureCube ) {\n\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\n\n\t\t\t\t\ttexture.image.__webglTextureCube = _gl.createTexture();\n\n\t\t\t\t\t_this.info.memory.textures ++;\n\n\t\t\t\t}\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\n\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\n\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\n\n\t\t\t\tvar cubeImage = [];\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed ) {\n\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tcubeImage[ i ] = texture.image[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar image = cubeImage[ 0 ],\n\t\t\t\tisImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\n\t\t\t\tglType = paramThreeToGL( texture.type );\n\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\tif( !isCompressed ) {\n\n\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\n\n\t\t\t\t\t\tfor( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\n\t\t\t\t\t\t\tif ( texture.format!==THREE.RGBAFormat ) {\n\n\t\t\t\t\t\t\t\t_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\n\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( texture.generateMipmaps && isImagePowerOfTwo ) {\n\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t\t}\n\n\t\t\t\ttexture.needsUpdate = false;\n\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate();\n\n\t\t\t} else {\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction setCubeTextureDynamic ( texture, slot ) {\n\n\t\t_gl.activeTexture( _gl.TEXTURE0 + slot );\n\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );\n\n\t};\n\n\t// Render targets\n\n\tfunction setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {\n\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );\n\n\t};\n\n\tfunction setupRenderBuffer ( renderbuffer, renderTarget  ) {\n\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\n\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t/* For some reason this is not working. Defaulting to RGBA4.\n\t\t} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\t\t*/\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\n\n\t\t} else {\n\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\n\n\t\t}\n\n\t};\n\n\tthis.setRenderTarget = function ( renderTarget ) {\n\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\n\n\t\tif ( renderTarget && ! renderTarget.__webglFramebuffer ) {\n\n\t\t\tif ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;\n\t\t\tif ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;\n\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\n\n\t\t\trenderTarget.__webglTexture = _gl.createTexture();\n\n\t\t\t_this.info.memory.textures ++;\n\n\t\t\t// Setup texture, create render and frame buffers\n\n\t\t\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget.width ) && isPowerOfTwo( renderTarget.height ),\n\t\t\t\tglFormat = paramThreeToGL( renderTarget.format ),\n\t\t\t\tglType = paramThreeToGL( renderTarget.type );\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\trenderTarget.__webglFramebuffer = [];\n\t\t\t\trenderTarget.__webglRenderbuffer = [];\n\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );\n\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\n\n\t\t\t\t\trenderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();\n\t\t\t\t\trenderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();\n\n\t\t\t\t\t_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\n\t\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\n\t\t\t} else {\n\n\t\t\t\trenderTarget.__webglFramebuffer = _gl.createFramebuffer();\n\n\t\t\t\tif ( renderTarget.shareDepthFrom ) {\n\n\t\t\t\t\trenderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;\n\n\t\t\t\t} else {\n\n\t\t\t\t\trenderTarget.__webglRenderbuffer = _gl.createRenderbuffer();\n\n\t\t\t\t}\n\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );\n\n\t\t\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\n\n\t\t\t\tsetupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );\n\n\t\t\t\tif ( renderTarget.shareDepthFrom ) {\n\n\t\t\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\n\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\n\n\t\t\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\n\n\t\t\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tsetupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );\n\n\t\t\t\t}\n\n\t\t\t\tif ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\n\n\t\t\t}\n\n\t\t\t// Release everything\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t\t}\n\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\n\n\t\t}\n\n\t\tvar framebuffer, width, height, vx, vy;\n\n\t\tif ( renderTarget ) {\n\n\t\t\tif ( isCube ) {\n\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];\n\n\t\t\t} else {\n\n\t\t\t\tframebuffer = renderTarget.__webglFramebuffer;\n\n\t\t\t}\n\n\t\t\twidth = renderTarget.width;\n\t\t\theight = renderTarget.height;\n\n\t\t\tvx = 0;\n\t\t\tvy = 0;\n\n\t\t} else {\n\n\t\t\tframebuffer = null;\n\n\t\t\twidth = _viewportWidth;\n\t\t\theight = _viewportHeight;\n\n\t\t\tvx = _viewportX;\n\t\t\tvy = _viewportY;\n\n\t\t}\n\n\t\tif ( framebuffer !== _currentFramebuffer ) {\n\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\n\t\t\t_gl.viewport( vx, vy, width, height );\n\n\t\t\t_currentFramebuffer = framebuffer;\n\n\t\t}\n\n\t\t_currentWidth = width;\n\t\t_currentHeight = height;\n\n\t};\n\n\tfunction updateRenderTargetMipmap ( renderTarget ) {\n\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\n\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\n\t\t\t_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\n\n\t\t} else {\n\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\n\t\t\t_gl.generateMipmap( _gl.TEXTURE_2D );\n\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, null );\n\n\t\t}\n\n\t};\n\n\t// Fallback filters for non-power-of-2 textures\n\n\tfunction filterFallback ( f ) {\n\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\n\n\t\t\treturn _gl.NEAREST;\n\n\t\t}\n\n\t\treturn _gl.LINEAR;\n\n\t};\n\n\t// Map three.js constants to WebGL constants\n\n\tfunction paramThreeToGL ( p ) {\n\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\n\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\n\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\n\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\n\t\tif ( p === THREE.IntType ) return _gl.INT;\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\n\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\n\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\n\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\n\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\n\n\t\tif ( _glExtensionCompressedTextureS3TC !== undefined ) {\n\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\n\t\t}\n\n\t\treturn 0;\n\n\t};\n\n\t// Allocations\n\n\tfunction allocateBones ( object ) {\n\n\t\tif ( _supportsBoneTextures && object && object.useVertexTexture ) {\n\n\t\t\treturn 1024;\n\n\t\t} else {\n\n\t\t\t// default for when object is not specified\n\t\t\t// ( for example when prebuilding shader\n\t\t\t//   to be used with multiple objects )\n\t\t\t//\n\t\t\t// \t- leave some extra space for other uniforms\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\n\t\t\t//    (up to 54 should be safe)\n\n\t\t\tvar nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\n\n\t\t\tvar maxBones = nVertexMatrices;\n\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\n\n\t\t\t\tmaxBones = Math.min( object.bones.length, maxBones );\n\n\t\t\t\tif ( maxBones < object.bones.length ) {\n\n\t\t\t\t\tconsole.warn( \"WebGLRenderer: too many bones - \" + object.bones.length + \", this GPU supports just \" + maxBones + \" (try OpenGL instead of ANGLE)\" );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn maxBones;\n\n\t\t}\n\n\t};\n\n\tfunction allocateLights( lights ) {\n\n\t\tvar dirLights = 0;\n\t\tvar pointLights = 0;\n\t\tvar spotLights = 0;\n\t\tvar hemiLights = 0;\n\n\t\tfor ( var l = 0, ll = lights.length; l < ll; l ++ ) {\n\n\t\t\tvar light = lights[ l ];\n\n\t\t\tif ( light.onlyShadow ) continue;\n\n\t\t\tif ( light instanceof THREE.DirectionalLight ) dirLights ++;\n\t\t\tif ( light instanceof THREE.PointLight ) pointLights ++;\n\t\t\tif ( light instanceof THREE.SpotLight ) spotLights ++;\n\t\t\tif ( light instanceof THREE.HemisphereLight ) hemiLights ++;\n\n\t\t}\n\n\t\treturn { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi': hemiLights };\n\n\t};\n\n\tfunction allocateShadows( lights ) {\n\n\t\tvar maxShadows = 0;\n\n\t\tfor ( var l = 0, ll = lights.length; l < ll; l++ ) {\n\n\t\t\tvar light = lights[ l ];\n\n\t\t\tif ( ! light.castShadow ) continue;\n\n\t\t\tif ( light instanceof THREE.SpotLight ) maxShadows ++;\n\t\t\tif ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;\n\n\t\t}\n\n\t\treturn maxShadows;\n\n\t};\n\n\t// Initialization\n\n\tfunction initGL() {\n\n\t\ttry {\n\n\t\t\tvar attributes = {\n\t\t\t\talpha: _alpha,\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\n\t\t\t\tantialias: _antialias,\n\t\t\t\tstencil: _stencil,\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\n\t\t\t};\n\n\t\t\t_gl = _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\n\n\t\t\tif ( _gl === null ) {\n\n\t\t\t\tthrow 'Error creating WebGL context.';\n\n\t\t\t}\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.error( error );\n\n\t\t}\n\n\t\t_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );\n\t\t_glExtensionTextureFloatLinear = _gl.getExtension( 'OES_texture_float_linear' );\n\t\t_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );\n\n\t\t_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\n\n\t\t_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\n\n\t\tif ( ! _glExtensionTextureFloat ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Float textures not supported.' );\n\n\t\t}\n\n\t\tif ( ! _glExtensionStandardDerivatives ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Standard derivatives not supported.' );\n\n\t\t}\n\n\t\tif ( ! _glExtensionTextureFilterAnisotropic ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );\n\n\t\t}\n\n\t\tif ( ! _glExtensionCompressedTextureS3TC ) {\n\n\t\t\tconsole.log( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );\n\n\t\t}\n\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\n\n\t\t\t_gl.getShaderPrecisionFormat = function() {\n\n\t\t\t\treturn {\n\t\t\t\t\t\"rangeMin\"  : 1,\n\t\t\t\t\t\"rangeMax\"  : 1,\n\t\t\t\t\t\"precision\" : 1\n\t\t\t\t};\n\n\t\t\t}\n\t\t}\n\n\t};\n\n\tfunction setDefaultGLState () {\n\n\t\t_gl.clearColor( 0, 0, 0, 1 );\n\t\t_gl.clearDepth( 1 );\n\t\t_gl.clearStencil( 0 );\n\n\t\t_gl.enable( _gl.DEPTH_TEST );\n\t\t_gl.depthFunc( _gl.LEQUAL );\n\n\t\t_gl.frontFace( _gl.CCW );\n\t\t_gl.cullFace( _gl.BACK );\n\t\t_gl.enable( _gl.CULL_FACE );\n\n\t\t_gl.enable( _gl.BLEND );\n\t\t_gl.blendEquation( _gl.FUNC_ADD );\n\t\t_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );\n\n\t\t_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\n\t\t\n\t\t_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\n\n\t};\n\n\t// default plugins (order is important)\n\n\tthis.shadowMapPlugin = new THREE.ShadowMapPlugin();\n\tthis.addPrePlugin( this.shadowMapPlugin );\n\n\tthis.addPostPlugin( new THREE.SpritePlugin() );\n\tthis.addPostPlugin( new THREE.LensFlarePlugin() );\n\n};\n\n/**\n * @author szimek / https://github.com/szimek/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\n\n\tthis.width = width;\n\tthis.height = height;\n\n\toptions = options || {};\n\n\tthis.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;\n\tthis.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;\n\n\tthis.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;\n\tthis.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;\n\n\tthis.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;\n\n\tthis.offset = new THREE.Vector2( 0, 0 );\n\tthis.repeat = new THREE.Vector2( 1, 1 );\n\n\tthis.format = options.format !== undefined ? options.format : THREE.RGBAFormat;\n\tthis.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;\n\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\n\n\tthis.generateMipmaps = true;\n\n\tthis.shareDepthFrom = null;\n\n};\n\nTHREE.WebGLRenderTarget.prototype = {\n\n\tconstructor: THREE.WebGLRenderTarget,\n\n\tclone: function () {\n\n\t\tvar tmp = new THREE.WebGLRenderTarget( this.width, this.height );\n\n\t\ttmp.wrapS = this.wrapS;\n\t\ttmp.wrapT = this.wrapT;\n\n\t\ttmp.magFilter = this.magFilter;\n\t\ttmp.minFilter = this.minFilter;\n\n\t\ttmp.anisotropy = this.anisotropy;\n\n\t\ttmp.offset.copy( this.offset );\n\t\ttmp.repeat.copy( this.repeat );\n\n\t\ttmp.format = this.format;\n\t\ttmp.type = this.type;\n\n\t\ttmp.depthBuffer = this.depthBuffer;\n\t\ttmp.stencilBuffer = this.stencilBuffer;\n\n\t\ttmp.generateMipmaps = this.generateMipmaps;\n\n\t\ttmp.shareDepthFrom = this.shareDepthFrom;\n\n\t\treturn tmp;\n\n\t},\n\n\tdispose: function () {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n};\n\nTHREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );\n\n/**\n * @author alteredq / http://alteredqualia.com\n */\n\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\n\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\n\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\n\n};\n\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableVertex = function () {\n\n\tthis.position = new THREE.Vector3();\n\tthis.positionWorld = new THREE.Vector3();\n\tthis.positionScreen = new THREE.Vector4();\n\n\tthis.visible = true;\n\n};\n\nTHREE.RenderableVertex.prototype.copy = function ( vertex ) {\n\n\tthis.positionWorld.copy( vertex.positionWorld );\n\tthis.positionScreen.copy( vertex.positionScreen );\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableFace3 = function () {\n\n\tthis.id = 0;\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\tthis.v3 = new THREE.RenderableVertex();\n\n\tthis.centroidModel = new THREE.Vector3();\n\n\tthis.normalModel = new THREE.Vector3();\n\tthis.normalModelView = new THREE.Vector3();\n\n\tthis.vertexNormalsLength = 0;\n\tthis.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\tthis.vertexNormalsModelView = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];\n\n\tthis.color = null;\n\tthis.material = null;\n\tthis.uvs = [[]];\n\n\tthis.z = 0;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableObject = function () {\n\n\tthis.id = 0;\n\n\tthis.object = null;\n\tthis.z = 0;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableSprite = function () {\n\n\tthis.id = 0;\n\n\tthis.object = null;\n\n\tthis.x = 0;\n\tthis.y = 0;\n\tthis.z = 0;\n\n\tthis.rotation = 0;\n\tthis.scale = new THREE.Vector2();\n\n\tthis.material = null;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.RenderableLine = function () {\n\n\tthis.id = 0;\n\n\tthis.v1 = new THREE.RenderableVertex();\n\tthis.v2 = new THREE.RenderableVertex();\n\n\tthis.vertexColors = [ new THREE.Color(), new THREE.Color() ];\n\tthis.material = null;\n\n\tthis.z = 0;\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.GeometryUtils = {\n\n\t// Merge two geometries or geometry and geometry from object (using object's transform)\n\n\tmerge: function ( geometry1, object2 /* mesh | geometry */, materialIndexOffset ) {\n\n\t\tvar matrix, normalMatrix,\n\t\tvertexOffset = geometry1.vertices.length,\n\t\tuvPosition = geometry1.faceVertexUvs[ 0 ].length,\n\t\tgeometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2,\n\t\tvertices1 = geometry1.vertices,\n\t\tvertices2 = geometry2.vertices,\n\t\tfaces1 = geometry1.faces,\n\t\tfaces2 = geometry2.faces,\n\t\tuvs1 = geometry1.faceVertexUvs[ 0 ],\n\t\tuvs2 = geometry2.faceVertexUvs[ 0 ];\n\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\n\n\t\tif ( object2 instanceof THREE.Mesh ) {\n\n\t\t\tobject2.matrixAutoUpdate && object2.updateMatrix();\n\n\t\t\tmatrix = object2.matrix;\n\n\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\n\n\t\t}\n\n\t\t// vertices\n\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\n\n\t\t\tvar vertex = vertices2[ i ];\n\n\t\t\tvar vertexCopy = vertex.clone();\n\n\t\t\tif ( matrix ) vertexCopy.applyMatrix4( matrix );\n\n\t\t\tvertices1.push( vertexCopy );\n\n\t\t}\n\n\t\t// faces\n\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\n\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\n\t\t\tfaceVertexNormals = face.vertexNormals,\n\t\t\tfaceVertexColors = face.vertexColors;\n\n\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\n\t\t\tfaceCopy.normal.copy( face.normal );\n\n\t\t\tif ( normalMatrix ) {\n\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t}\n\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\n\n\t\t\t\tif ( normalMatrix ) {\n\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\n\n\t\t\t\t}\n\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\n\n\t\t\t}\n\n\t\t\tfaceCopy.color.copy( face.color );\n\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\n\n\t\t\t\tcolor = faceVertexColors[ j ];\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\n\n\t\t\t}\n\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\n\n\t\t\tfaceCopy.centroid.copy( face.centroid );\n\n\t\t\tif ( matrix ) {\n\n\t\t\t\tfaceCopy.centroid.applyMatrix4( matrix );\n\n\t\t\t}\n\n\t\t\tfaces1.push( faceCopy );\n\n\t\t}\n\n\t\t// uvs\n\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\n\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\n\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\n\n\t\t\t\tuvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );\n\n\t\t\t}\n\n\t\t\tuvs1.push( uvCopy );\n\n\t\t}\n\n\t},\n\n\t// Get random point in triangle (via barycentric coordinates)\n\t// \t(uniform distribution)\n\t// \thttp://www.cgafaq.info/wiki/Random_Point_In_Triangle\n\n\trandomPointInTriangle: function () {\n\n\t\tvar vector = new THREE.Vector3();\n\n\t\treturn function ( vectorA, vectorB, vectorC ) {\n\n\t\t\tvar point = new THREE.Vector3();\n\n\t\t\tvar a = THREE.Math.random16();\n\t\t\tvar b = THREE.Math.random16();\n\n\t\t\tif ( ( a + b ) > 1 ) {\n\n\t\t\t\ta = 1 - a;\n\t\t\t\tb = 1 - b;\n\n\t\t\t}\n\n\t\t\tvar c = 1 - a - b;\n\n\t\t\tpoint.copy( vectorA );\n\t\t\tpoint.multiplyScalar( a );\n\n\t\t\tvector.copy( vectorB );\n\t\t\tvector.multiplyScalar( b );\n\n\t\t\tpoint.add( vector );\n\n\t\t\tvector.copy( vectorC );\n\t\t\tvector.multiplyScalar( c );\n\n\t\t\tpoint.add( vector );\n\n\t\t\treturn point;\n\n\t\t};\n\n\t}(),\n\n\t// Get random point in face (triangle / quad)\n\t// (uniform distribution)\n\n\trandomPointInFace: function ( face, geometry, useCachedAreas ) {\n\n\t\tvar vA, vB, vC, vD;\n\n\t\tvA = geometry.vertices[ face.a ];\n\t\tvB = geometry.vertices[ face.b ];\n\t\tvC = geometry.vertices[ face.c ];\n\n\t\treturn THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );\n\n\t},\n\n\t// Get uniformly distributed random points in mesh\n\t// \t- create array with cumulative sums of face areas\n\t//  - pick random number from 0 to total area\n\t//  - find corresponding place in area array by binary search\n\t//\t- get random point in face\n\n\trandomPointsInGeometry: function ( geometry, n ) {\n\n\t\tvar face, i,\n\t\t\tfaces = geometry.faces,\n\t\t\tvertices = geometry.vertices,\n\t\t\til = faces.length,\n\t\t\ttotalArea = 0,\n\t\t\tcumulativeAreas = [],\n\t\t\tvA, vB, vC, vD;\n\n\t\t// precompute face areas\n\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tface = faces[ i ];\n\n\t\t\tvA = vertices[ face.a ];\n\t\t\tvB = vertices[ face.b ];\n\t\t\tvC = vertices[ face.c ];\n\n\t\t\tface._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );\n\n\t\t\ttotalArea += face._area;\n\n\t\t\tcumulativeAreas[ i ] = totalArea;\n\n\t\t}\n\n\t\t// binary search cumulative areas array\n\n\t\tfunction binarySearchIndices( value ) {\n\n\t\t\tfunction binarySearch( start, end ) {\n\n\t\t\t\t// return closest larger index\n\t\t\t\t// if exact number is not found\n\n\t\t\t\tif ( end < start )\n\t\t\t\t\treturn start;\n\n\t\t\t\tvar mid = start + Math.floor( ( end - start ) / 2 );\n\n\t\t\t\tif ( cumulativeAreas[ mid ] > value ) {\n\n\t\t\t\t\treturn binarySearch( start, mid - 1 );\n\n\t\t\t\t} else if ( cumulativeAreas[ mid ] < value ) {\n\n\t\t\t\t\treturn binarySearch( mid + 1, end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn mid;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar result = binarySearch( 0, cumulativeAreas.length - 1 )\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// pick random face weighted by face area\n\n\t\tvar r, index,\n\t\t\tresult = [];\n\n\t\tvar stats = {};\n\n\t\tfor ( i = 0; i < n; i ++ ) {\n\n\t\t\tr = THREE.Math.random16() * totalArea;\n\n\t\t\tindex = binarySearchIndices( r );\n\n\t\t\tresult[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );\n\n\t\t\tif ( ! stats[ index ] ) {\n\n\t\t\t\tstats[ index ] = 1;\n\n\t\t\t} else {\n\n\t\t\t\tstats[ index ] += 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t},\n\n\t// Get triangle area (half of parallelogram)\n\t//\thttp://mathworld.wolfram.com/TriangleArea.html\n\n\ttriangleArea: function () {\n\n\t\tvar vector1 = new THREE.Vector3();\n\t\tvar vector2 = new THREE.Vector3();\n\n\t\treturn function ( vectorA, vectorB, vectorC ) {\n\n\t\t\tvector1.subVectors( vectorB, vectorA );\n\t\t\tvector2.subVectors( vectorC, vectorA );\n\t\t\tvector1.cross( vector2 );\n\n\t\t\treturn 0.5 * vector1.length();\n\n\t\t};\n\n\t}(),\n\n\t// Center geometry so that 0,0,0 is in center of bounding box\n\n\tcenter: function ( geometry ) {\n\n\t\tgeometry.computeBoundingBox();\n\n\t\tvar bb = geometry.boundingBox;\n\n\t\tvar offset = new THREE.Vector3();\n\n\t\toffset.addVectors( bb.min, bb.max );\n\t\toffset.multiplyScalar( -0.5 );\n\n\t\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );\n\t\tgeometry.computeBoundingBox();\n\n\t\treturn offset;\n\n\t},\n\n\ttriangulateQuads: function ( geometry ) {\n\n\t\tvar i, il, j, jl;\n\n\t\tvar faces = [];\n\t\tvar faceVertexUvs = [];\n\n\t\tfor ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {\n\n\t\t\tfaceVertexUvs[ i ] = [];\n\n\t\t}\n\n\t\tfor ( i = 0, il = geometry.faces.length; i < il; i ++ ) {\n\n\t\t\tvar face = geometry.faces[ i ];\n\n\t\t\tfaces.push( face );\n\n\t\t\tfor ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {\n\n\t\t\t\tfaceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.faces = faces;\n\t\tgeometry.faceVertexUvs = faceVertexUvs;\n\n\t\tgeometry.computeCentroids();\n\t\tgeometry.computeFaceNormals();\n\t\tgeometry.computeVertexNormals();\n\n\t\tif ( geometry.hasTangents ) geometry.computeTangents();\n\n\t}\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.ImageUtils = {\n\n\tcrossOrigin: undefined,\n\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tvar loader = new THREE.ImageLoader();\n\t\tloader.crossOrigin = this.crossOrigin;\n\n\t\tvar texture = new THREE.Texture( undefined, mapping );\n\n\t\tvar image = loader.load( url, function () {\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t} );\n\n\t\ttexture.image = image;\n\t\ttexture.sourceFile = url;\n\n\t\treturn texture;\n\n\t},\n\n\tloadCompressedTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tvar texture = new THREE.CompressedTexture();\n\t\ttexture.mapping = mapping;\n\n\t\tvar request = new XMLHttpRequest();\n\n\t\trequest.onload = function () {\n\n\t\t\tvar buffer = request.response;\n\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\n\n\t\t\ttexture.format = dds.format;\n\n\t\t\ttexture.mipmaps = dds.mipmaps;\n\t\t\ttexture.image.width = dds.width;\n\t\t\ttexture.image.height = dds.height;\n\n\t\t\t// gl.generateMipmap fails for compressed textures\n\t\t\t// mipmaps must be embedded in the DDS file\n\t\t\t// or texture filters must not use mipmapping\n\n\t\t\ttexture.generateMipmaps = false;\n\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t}\n\n\t\trequest.onerror = onError;\n\n\t\trequest.open( 'GET', url, true );\n\t\trequest.responseType = \"arraybuffer\";\n\t\trequest.send( null );\n\n\t\treturn texture;\n\n\t},\n\n\tloadTextureCube: function ( array, mapping, onLoad, onError ) {\n\n\t\tvar images = [];\n\t\timages.loadCount = 0;\n\n\t\tvar texture = new THREE.Texture();\n\t\ttexture.image = images;\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\t// no flipping needed for cube textures\n\n\t\ttexture.flipY = false;\n\n\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\n\n\t\t\tvar cubeImage = new Image();\n\t\t\timages[ i ] = cubeImage;\n\n\t\t\tcubeImage.onload = function () {\n\n\t\t\t\timages.loadCount += 1;\n\n\t\t\t\tif ( images.loadCount === 6 ) {\n\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tcubeImage.onerror = onError;\n\n\t\t\tcubeImage.crossOrigin = this.crossOrigin;\n\t\t\tcubeImage.src = array[ i ];\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tloadCompressedTextureCube: function ( array, mapping, onLoad, onError ) {\n\n\t\tvar images = [];\n\t\timages.loadCount = 0;\n\n\t\tvar texture = new THREE.CompressedTexture();\n\t\ttexture.image = images;\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\ttexture.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\ttexture.generateMipmaps = false;\n\n\t\tvar generateCubeFaceCallback = function ( rq, img ) {\n\n\t\t\treturn function () {\n\n\t\t\t\tvar buffer = rq.response;\n\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\n\n\t\t\t\timg.format = dds.format;\n\n\t\t\t\timg.mipmaps = dds.mipmaps;\n\t\t\t\timg.width = dds.width;\n\t\t\t\timg.height = dds.height;\n\n\t\t\t\timages.loadCount += 1;\n\n\t\t\t\tif ( images.loadCount === 6 ) {\n\n\t\t\t\t\ttexture.format = dds.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// compressed cubemap textures as 6 separate DDS files\n\n\t\tif ( array instanceof Array ) {\n\n\t\t\tfor ( var i = 0, il = array.length; i < il; ++ i ) {\n\n\t\t\t\tvar cubeImage = {};\n\t\t\t\timages[ i ] = cubeImage;\n\n\t\t\t\tvar request = new XMLHttpRequest();\n\n\t\t\t\trequest.onload = generateCubeFaceCallback( request, cubeImage );\n\t\t\t\trequest.onerror = onError;\n\n\t\t\t\tvar url = array[ i ];\n\n\t\t\t\trequest.open( 'GET', url, true );\n\t\t\t\trequest.responseType = \"arraybuffer\";\n\t\t\t\trequest.send( null );\n\n\t\t\t}\n\n\t\t// compressed cubemap texture stored in a single DDS file\n\n\t\t} else {\n\n\t\t\tvar url = array;\n\t\t\tvar request = new XMLHttpRequest();\n\n\t\t\trequest.onload = function( ) {\n\n\t\t\t\tvar buffer = request.response;\n\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\n\n\t\t\t\tif ( dds.isCubemap ) {\n\n\t\t\t\t\tvar faces = dds.mipmaps.length / dds.mipmapCount;\n\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\n\t\t\t\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = dds.format;\n\t\t\t\t\t\t\timages[ f ].width = dds.width;\n\t\t\t\t\t\t\timages[ f ].height = dds.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttexture.format = dds.format;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\trequest.onerror = onError;\n\n\t\t\trequest.open( 'GET', url, true );\n\t\t\trequest.responseType = \"arraybuffer\";\n\t\t\trequest.send( null );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tloadDDSTexture: function ( url, mapping, onLoad, onError ) {\n\n\t\tvar images = [];\n\t\timages.loadCount = 0;\n\n\t\tvar texture = new THREE.CompressedTexture();\n\t\ttexture.image = images;\n\t\tif ( mapping !== undefined ) texture.mapping = mapping;\n\n\t\t// no flipping for cube textures\n\t\t// (also flipping doesn't work for compressed textures )\n\n\t\ttexture.flipY = false;\n\n\t\t// can't generate mipmaps for compressed textures\n\t\t// mips must be embedded in DDS files\n\n\t\ttexture.generateMipmaps = false;\n\n\t\t{\n\t\t\tvar request = new XMLHttpRequest();\n\n\t\t\trequest.onload = function( ) {\n\n\t\t\t\tvar buffer = request.response;\n\t\t\t\tvar dds = THREE.ImageUtils.parseDDS( buffer, true );\n\n\t\t\t\tif ( dds.isCubemap ) {\n\n\t\t\t\t\tvar faces = dds.mipmaps.length / dds.mipmapCount;\n\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\n\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\n\n\t\t\t\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );\n\t\t\t\t\t\t\timages[ f ].format = dds.format;\n\t\t\t\t\t\t\timages[ f ].width = dds.width;\n\t\t\t\t\t\t\timages[ f ].height = dds.height;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else {\n\t\t\t\t\ttexture.image.width = dds.width;\n\t\t\t\t\ttexture.image.height = dds.height;\n\t\t\t\t\ttexture.mipmaps = dds.mipmaps;\n\t\t\t\t}\n\n\t\t\t\ttexture.format = dds.format;\n\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\tif ( onLoad ) onLoad( texture );\n\n\t\t\t}\n\n\t\t\trequest.onerror = onError;\n\n\t\t\trequest.open( 'GET', url, true );\n\t\t\trequest.responseType = \"arraybuffer\";\n\t\t\trequest.send( null );\n\n\t\t}\n\n\t\treturn texture;\n\n\t},\n\n\tparseDDS: function ( buffer, loadMipmaps ) {\n\n\t\tvar dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };\n\n\t\t// Adapted from @toji's DDS utils\n\t\t//\thttps://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js\n\n\t\t// All values and structures referenced from:\n\t\t// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\n\n\t\tvar DDS_MAGIC = 0x20534444;\n\n\t\tvar DDSD_CAPS = 0x1,\n\t\t\tDDSD_HEIGHT = 0x2,\n\t\t\tDDSD_WIDTH = 0x4,\n\t\t\tDDSD_PITCH = 0x8,\n\t\t\tDDSD_PIXELFORMAT = 0x1000,\n\t\t\tDDSD_MIPMAPCOUNT = 0x20000,\n\t\t\tDDSD_LINEARSIZE = 0x80000,\n\t\t\tDDSD_DEPTH = 0x800000;\n\n\t\tvar DDSCAPS_COMPLEX = 0x8,\n\t\t\tDDSCAPS_MIPMAP = 0x400000,\n\t\t\tDDSCAPS_TEXTURE = 0x1000;\n\n\t\tvar DDSCAPS2_CUBEMAP = 0x200,\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n\t\t\tDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n\t\t\tDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n\t\t\tDDSCAPS2_VOLUME = 0x200000;\n\n\t\tvar DDPF_ALPHAPIXELS = 0x1,\n\t\t\tDDPF_ALPHA = 0x2,\n\t\t\tDDPF_FOURCC = 0x4,\n\t\t\tDDPF_RGB = 0x40,\n\t\t\tDDPF_YUV = 0x200,\n\t\t\tDDPF_LUMINANCE = 0x20000;\n\n\t\tfunction fourCCToInt32( value ) {\n\n\t\t\treturn value.charCodeAt(0) +\n\t\t\t\t(value.charCodeAt(1) << 8) +\n\t\t\t\t(value.charCodeAt(2) << 16) +\n\t\t\t\t(value.charCodeAt(3) << 24);\n\n\t\t}\n\n\t\tfunction int32ToFourCC( value ) {\n\n\t\t\treturn String.fromCharCode(\n\t\t\t\tvalue & 0xff,\n\t\t\t\t(value >> 8) & 0xff,\n\t\t\t\t(value >> 16) & 0xff,\n\t\t\t\t(value >> 24) & 0xff\n\t\t\t);\n\t\t}\n\n\t\tfunction loadARGBMip( buffer, dataOffset, width, height ) {\n\t\t\tvar dataLength = width*height*4;\n\t\t\tvar srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );\n\t\t\tvar byteArray = new Uint8Array( dataLength );\n\t\t\tvar dst = 0;\n\t\t\tvar src = 0;\n\t\t\tfor ( var y = 0; y < height; y++ ) {\n\t\t\t\tfor ( var x = 0; x < width; x++ ) {\n\t\t\t\t\tvar b = srcBuffer[src]; src++;\n\t\t\t\t\tvar g = srcBuffer[src]; src++;\n\t\t\t\t\tvar r = srcBuffer[src]; src++;\n\t\t\t\t\tvar a = srcBuffer[src]; src++;\n\t\t\t\t\tbyteArray[dst] = r; dst++;\t//r\n\t\t\t\t\tbyteArray[dst] = g; dst++;\t//g\n\t\t\t\t\tbyteArray[dst] = b; dst++;\t//b\n\t\t\t\t\tbyteArray[dst] = a; dst++;\t//a\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn byteArray;\n\t\t}\n\n\t\tvar FOURCC_DXT1 = fourCCToInt32(\"DXT1\");\n\t\tvar FOURCC_DXT3 = fourCCToInt32(\"DXT3\");\n\t\tvar FOURCC_DXT5 = fourCCToInt32(\"DXT5\");\n\n\t\tvar headerLengthInt = 31; // The header length in 32 bit ints\n\n\t\t// Offsets into the header array\n\n\t\tvar off_magic = 0;\n\n\t\tvar off_size = 1;\n\t\tvar off_flags = 2;\n\t\tvar off_height = 3;\n\t\tvar off_width = 4;\n\n\t\tvar off_mipmapCount = 7;\n\n\t\tvar off_pfFlags = 20;\n\t\tvar off_pfFourCC = 21;\n\t\tvar off_RGBBitCount = 22;\n\t\tvar off_RBitMask = 23;\n\t\tvar off_GBitMask = 24;\n\t\tvar off_BBitMask = 25;\n\t\tvar off_ABitMask = 26;\n\n\t\tvar off_caps = 27;\n\t\tvar off_caps2 = 28;\n\t\tvar off_caps3 = 29;\n\t\tvar off_caps4 = 30;\n\n\t\t// Parse header\n\n\t\tvar header = new Int32Array( buffer, 0, headerLengthInt );\n\n\t\tif ( header[ off_magic ] !== DDS_MAGIC ) {\n\n\t\t\tconsole.error( \"ImageUtils.parseDDS(): Invalid magic number in DDS header\" );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tif ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {\n\n\t\t\tconsole.error( \"ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code\" );\n\t\t\treturn dds;\n\n\t\t}\n\n\t\tvar blockBytes;\n\n\t\tvar fourCC = header[ off_pfFourCC ];\n\n\t\tvar isRGBAUncompressed = false;\n\n\t\tswitch ( fourCC ) {\n\n\t\t\tcase FOURCC_DXT1:\n\n\t\t\t\tblockBytes = 8;\n\t\t\t\tdds.format = THREE.RGB_S3TC_DXT1_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DXT3:\n\n\t\t\t\tblockBytes = 16;\n\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT3_Format;\n\t\t\t\tbreak;\n\n\t\t\tcase FOURCC_DXT5:\n\n\t\t\t\tblockBytes = 16;\n\t\t\t\tdds.format = THREE.RGBA_S3TC_DXT5_Format;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tif( header[off_RGBBitCount] ==32 \n\t\t\t\t\t&& header[off_RBitMask]&0xff0000\n\t\t\t\t\t&& header[off_GBitMask]&0xff00 \n\t\t\t\t\t&& header[off_BBitMask]&0xff\n\t\t\t\t\t&& header[off_ABitMask]&0xff000000  ) {\n\t\t\t\t\tisRGBAUncompressed = true;\n\t\t\t\t\tblockBytes = 64;\n\t\t\t\t\tdds.format = THREE.RGBAFormat;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error( \"ImageUtils.parseDDS(): Unsupported FourCC code: \", int32ToFourCC( fourCC ) );\n\t\t\t\t\treturn dds;\n\t\t\t\t}\n\t\t}\n\n\t\tdds.mipmapCount = 1;\n\n\t\tif ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {\n\n\t\t\tdds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );\n\n\t\t}\n\n\t\t//TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.\n\n\t\tdds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;\n\n\t\tdds.width = header[ off_width ];\n\t\tdds.height = header[ off_height ];\n\n\t\tvar dataOffset = header[ off_size ] + 4;\n\n\t\t// Extract mipmaps buffers\n\n\t\tvar width = dds.width;\n\t\tvar height = dds.height;\n\n\t\tvar faces = dds.isCubemap ? 6 : 1;\n\n\t\tfor ( var face = 0; face < faces; face ++ ) {\n\n\t\t\tfor ( var i = 0; i < dds.mipmapCount; i ++ ) {\n\n\t\t\t\tif( isRGBAUncompressed ) {\n\t\t\t\t\tvar byteArray = loadARGBMip( buffer, dataOffset, width, height );\n\t\t\t\t\tvar dataLength = byteArray.length;\n\t\t\t\t} else {\n\t\t\t\t\tvar dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;\n\t\t\t\t\tvar byteArray = new Uint8Array( buffer, dataOffset, dataLength );\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar mipmap = { \"data\": byteArray, \"width\": width, \"height\": height };\n\t\t\t\tdds.mipmaps.push( mipmap );\n\n\t\t\t\tdataOffset += dataLength;\n\n\t\t\t\twidth = Math.max( width * 0.5, 1 );\n\t\t\t\theight = Math.max( height * 0.5, 1 );\n\n\t\t\t}\n\n\t\t\twidth = dds.width;\n\t\t\theight = dds.height;\n\n\t\t}\n\n\t\treturn dds;\n\n\t},\n\n\tgetNormalMap: function ( image, depth ) {\n\n\t\t// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/\n\n\t\tvar cross = function ( a, b ) {\n\n\t\t\treturn [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];\n\n\t\t}\n\n\t\tvar subtract = function ( a, b ) {\n\n\t\t\treturn [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];\n\n\t\t}\n\n\t\tvar normalize = function ( a ) {\n\n\t\t\tvar l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );\n\t\t\treturn [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];\n\n\t\t}\n\n\t\tdepth = depth | 1;\n\n\t\tvar width = image.width;\n\t\tvar height = image.height;\n\n\t\tvar canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tcontext.drawImage( image, 0, 0 );\n\n\t\tvar data = context.getImageData( 0, 0, width, height ).data;\n\t\tvar imageData = context.createImageData( width, height );\n\t\tvar output = imageData.data;\n\n\t\tfor ( var x = 0; x < width; x ++ ) {\n\n\t\t\tfor ( var y = 0; y < height; y ++ ) {\n\n\t\t\t\tvar ly = y - 1 < 0 ? 0 : y - 1;\n\t\t\t\tvar uy = y + 1 > height - 1 ? height - 1 : y + 1;\n\t\t\t\tvar lx = x - 1 < 0 ? 0 : x - 1;\n\t\t\t\tvar ux = x + 1 > width - 1 ? width - 1 : x + 1;\n\n\t\t\t\tvar points = [];\n\t\t\t\tvar origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];\n\t\t\t\tpoints.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );\n\t\t\t\tpoints.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );\n\n\t\t\t\tvar normals = [];\n\t\t\t\tvar num_points = points.length;\n\n\t\t\t\tfor ( var i = 0; i < num_points; i ++ ) {\n\n\t\t\t\t\tvar v1 = points[ i ];\n\t\t\t\t\tvar v2 = points[ ( i + 1 ) % num_points ];\n\t\t\t\t\tv1 = subtract( v1, origin );\n\t\t\t\t\tv2 = subtract( v2, origin );\n\t\t\t\t\tnormals.push( normalize( cross( v1, v2 ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tvar normal = [ 0, 0, 0 ];\n\n\t\t\t\tfor ( var i = 0; i < normals.length; i ++ ) {\n\n\t\t\t\t\tnormal[ 0 ] += normals[ i ][ 0 ];\n\t\t\t\t\tnormal[ 1 ] += normals[ i ][ 1 ];\n\t\t\t\t\tnormal[ 2 ] += normals[ i ][ 2 ];\n\n\t\t\t\t}\n\n\t\t\t\tnormal[ 0 ] /= normals.length;\n\t\t\t\tnormal[ 1 ] /= normals.length;\n\t\t\t\tnormal[ 2 ] /= normals.length;\n\n\t\t\t\tvar idx = ( y * width + x ) * 4;\n\n\t\t\t\toutput[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;\n\t\t\t\toutput[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;\n\t\t\t\toutput[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;\n\t\t\t\toutput[ idx + 3 ] = 255;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcontext.putImageData( imageData, 0, 0 );\n\n\t\treturn canvas;\n\n\t},\n\n\tgenerateDataTexture: function ( width, height, color ) {\n\n\t\tvar size = width * height;\n\t\tvar data = new Uint8Array( 3 * size );\n\n\t\tvar r = Math.floor( color.r * 255 );\n\t\tvar g = Math.floor( color.g * 255 );\n\t\tvar b = Math.floor( color.b * 255 );\n\n\t\tfor ( var i = 0; i < size; i ++ ) {\n\n\t\t\tdata[ i * 3 ] \t  = r;\n\t\t\tdata[ i * 3 + 1 ] = g;\n\t\t\tdata[ i * 3 + 2 ] = b;\n\n\t\t}\n\n\t\tvar texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );\n\t\ttexture.needsUpdate = true;\n\n\t\treturn texture;\n\n\t}\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SceneUtils = {\n\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\n\n\t\tvar group = new THREE.Object3D();\n\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t},\n\n\tdetach : function ( child, parent, scene ) {\n\n\t\tchild.applyMatrix( parent.matrixWorld );\n\t\tparent.remove( child );\n\t\tscene.add( child );\n\n\t},\n\n\tattach: function ( child, scene, parent ) {\n\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\n\t\tchild.applyMatrix( matrixWorldInverse );\n\n\t\tscene.remove( child );\n\t\tparent.add( child );\n\n\t}\n\n};\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * For Text operations in three.js (See TextGeometry)\n *\n * It uses techniques used in:\n *\n * \ttypeface.js and canvastext\n * \t\tFor converting fonts and rendering with javascript\n *\t\thttp://typeface.neocracy.org\n *\n *\tTriangulation ported from AS3\n *\t\tSimple Polygon Triangulation\n *\t\thttp://actionsnippet.com/?p=1462\n *\n * \tA Method to triangulate shapes with holes\n *\t\thttp://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/\n *\n */\n\nTHREE.FontUtils = {\n\n\tfaces : {},\n\n\t// Just for now. face[weight][style]\n\n\tface : \"helvetiker\",\n\tweight: \"normal\",\n\tstyle : \"normal\",\n\tsize : 150,\n\tdivisions : 10,\n\n\tgetFace : function() {\n\n\t\treturn this.faces[ this.face ][ this.weight ][ this.style ];\n\n\t},\n\n\tloadFace : function( data ) {\n\n\t\tvar family = data.familyName.toLowerCase();\n\n\t\tvar ThreeFont = this;\n\n\t\tThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};\n\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};\n\t\tThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\n\n\t\tvar face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\n\n\t\treturn data;\n\n\t},\n\n\tdrawText : function( text ) {\n\n\t\tvar characterPts = [], allPts = [];\n\n\t\t// RenderText\n\n\t\tvar i, p,\n\t\t\tface = this.getFace(),\n\t\t\tscale = this.size / face.resolution,\n\t\t\toffset = 0,\n\t\t\tchars = String( text ).split( '' ),\n\t\t\tlength = chars.length;\n\n\t\tvar fontPaths = [];\n\n\t\tfor ( i = 0; i < length; i ++ ) {\n\n\t\t\tvar path = new THREE.Path();\n\n\t\t\tvar ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );\n\t\t\toffset += ret.offset;\n\n\t\t\tfontPaths.push( ret.path );\n\n\t\t}\n\n\t\t// get the width\n\n\t\tvar width = offset / 2;\n\t\t//\n\t\t// for ( p = 0; p < allPts.length; p++ ) {\n\t\t//\n\t\t// \tallPts[ p ].x -= width;\n\t\t//\n\t\t// }\n\n\t\t//var extract = this.extractPoints( allPts, characterPts );\n\t\t//extract.contour = allPts;\n\n\t\t//extract.paths = fontPaths;\n\t\t//extract.offset = width;\n\n\t\treturn { paths : fontPaths, offset : width };\n\n\t},\n\n\n\n\n\textractGlyphPoints : function( c, face, scale, offset, path ) {\n\n\t\tvar pts = [];\n\n\t\tvar i, i2, divisions,\n\t\t\toutline, action, length,\n\t\t\tscaleX, scaleY,\n\t\t\tx, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,\n\t\t\tlaste,\n\t\t\tglyph = face.glyphs[ c ] || face.glyphs[ '?' ];\n\n\t\tif ( !glyph ) return;\n\n\t\tif ( glyph.o ) {\n\n\t\t\toutline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\n\t\t\tlength = outline.length;\n\n\t\t\tscaleX = scale;\n\t\t\tscaleY = scale;\n\n\t\t\tfor ( i = 0; i < length; ) {\n\n\t\t\t\taction = outline[ i ++ ];\n\n\t\t\t\t//console.log( action );\n\n\t\t\t\tswitch( action ) {\n\n\t\t\t\tcase 'm':\n\n\t\t\t\t\t// Move To\n\n\t\t\t\t\tx = outline[ i++ ] * scaleX + offset;\n\t\t\t\t\ty = outline[ i++ ] * scaleY;\n\n\t\t\t\t\tpath.moveTo( x, y );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'l':\n\n\t\t\t\t\t// Line To\n\n\t\t\t\t\tx = outline[ i++ ] * scaleX + offset;\n\t\t\t\t\ty = outline[ i++ ] * scaleY;\n\t\t\t\t\tpath.lineTo(x,y);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'q':\n\n\t\t\t\t\t// QuadraticCurveTo\n\n\t\t\t\t\tcpx  = outline[ i++ ] * scaleX + offset;\n\t\t\t\t\tcpy  = outline[ i++ ] * scaleY;\n\t\t\t\t\tcpx1 = outline[ i++ ] * scaleX + offset;\n\t\t\t\t\tcpy1 = outline[ i++ ] * scaleY;\n\n\t\t\t\t\tpath.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\tvar tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\n\t\t\t\t\t\t\tvar ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\n\t\t\t\t\t  }\n\n\t\t\t\t  }\n\n\t\t\t\t  break;\n\n\t\t\t\tcase 'b':\n\n\t\t\t\t\t// Cubic Bezier Curve\n\n\t\t\t\t\tcpx  = outline[ i++ ] *  scaleX + offset;\n\t\t\t\t\tcpy  = outline[ i++ ] *  scaleY;\n\t\t\t\t\tcpx1 = outline[ i++ ] *  scaleX + offset;\n\t\t\t\t\tcpy1 = outline[ i++ ] * -scaleY;\n\t\t\t\t\tcpx2 = outline[ i++ ] *  scaleX + offset;\n\t\t\t\t\tcpy2 = outline[ i++ ] * -scaleY;\n\n\t\t\t\t\tpath.bezierCurveTo( cpx, cpy, cpx1, cpy1, cpx2, cpy2 );\n\n\t\t\t\t\tlaste = pts[ pts.length - 1 ];\n\n\t\t\t\t\tif ( laste ) {\n\n\t\t\t\t\t\tcpx0 = laste.x;\n\t\t\t\t\t\tcpy0 = laste.y;\n\n\t\t\t\t\t\tfor ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\n\n\t\t\t\t\t\t\tvar t = i2 / divisions;\n\t\t\t\t\t\t\tvar tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\t\t\t\tvar ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\n\n\t\treturn { offset: glyph.ha*scale, path:path};\n\t}\n\n};\n\n\nTHREE.FontUtils.generateShapes = function( text, parameters ) {\n\n\t// Parameters \n\n\tparameters = parameters || {};\n\n\tvar size = parameters.size !== undefined ? parameters.size : 100;\n\tvar curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments: 4;\n\n\tvar font = parameters.font !== undefined ? parameters.font : \"helvetiker\";\n\tvar weight = parameters.weight !== undefined ? parameters.weight : \"normal\";\n\tvar style = parameters.style !== undefined ? parameters.style : \"normal\";\n\n\tTHREE.FontUtils.size = size;\n\tTHREE.FontUtils.divisions = curveSegments;\n\n\tTHREE.FontUtils.face = font;\n\tTHREE.FontUtils.weight = weight;\n\tTHREE.FontUtils.style = style;\n\n\t// Get a Font data json object\n\n\tvar data = THREE.FontUtils.drawText( text );\n\n\tvar paths = data.paths;\n\tvar shapes = [];\n\n\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\n\n\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\n\n\t}\n\n\treturn shapes;\n\n};\n\n\n/**\n * This code is a quick port of code written in C++ which was submitted to\n * flipcode.com by John W. Ratcliff  // July 22, 2000\n * See original code and more information here:\n * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\n *\n * ported to actionscript by Zevan Rosser\n * www.actionsnippet.com\n *\n * ported to javascript by Joshua Koo\n * http://www.lab4games.net/zz85/blog\n *\n */\n\n\n( function( namespace ) {\n\n\tvar EPSILON = 0.0000000001;\n\n\t// takes in an contour array and returns\n\n\tvar process = function( contour, indices ) {\n\n\t\tvar n = contour.length;\n\n\t\tif ( n < 3 ) return null;\n\n\t\tvar result = [],\n\t\t\tverts = [],\n\t\t\tvertIndices = [];\n\n\t\t/* we want a counter-clockwise polygon in verts */\n\n\t\tvar u, v, w;\n\n\t\tif ( area( contour ) > 0.0 ) {\n\n\t\t\tfor ( v = 0; v < n; v++ ) verts[ v ] = v;\n\n\t\t} else {\n\n\t\t\tfor ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;\n\n\t\t}\n\n\t\tvar nv = n;\n\n\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\n\n\t\tvar count = 2 * nv;   /* error detection */\n\n\t\tfor( v = nv - 1; nv > 2; ) {\n\n\t\t\t/* if we loop, it is probably a non-simple polygon */\n\n\t\t\tif ( ( count-- ) <= 0 ) {\n\n\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\n\n\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\n\t\t\t\t//return null;\n\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\n\t\t\t\tconsole.log( \"Warning, unable to triangulate polygon!\" );\n\n\t\t\t\tif ( indices ) return vertIndices;\n\t\t\t\treturn result;\n\n\t\t\t}\n\n\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\n\n\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\n\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\n\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\n\n\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\n\n\t\t\t\tvar a, b, c, s, t;\n\n\t\t\t\t/* true names of the vertices */\n\n\t\t\t\ta = verts[ u ];\n\t\t\t\tb = verts[ v ];\n\t\t\t\tc = verts[ w ];\n\n\t\t\t\t/* output Triangle */\n\n\t\t\t\tresult.push( [ contour[ a ],\n\t\t\t\t\tcontour[ b ],\n\t\t\t\t\tcontour[ c ] ] );\n\n\n\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\n\n\t\t\t\t/* remove v from the remaining polygon */\n\n\t\t\t\tfor( s = v, t = v + 1; t < nv; s++, t++ ) {\n\n\t\t\t\t\tverts[ s ] = verts[ t ];\n\n\t\t\t\t}\n\n\t\t\t\tnv--;\n\n\t\t\t\t/* reset error detection counter */\n\n\t\t\t\tcount = 2 * nv;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( indices ) return vertIndices;\n\t\treturn result;\n\n\t};\n\n\t// calculate area of the contour polygon\n\n\tvar area = function ( contour ) {\n\n\t\tvar n = contour.length;\n\t\tvar a = 0.0;\n\n\t\tfor( var p = n - 1, q = 0; q < n; p = q++ ) {\n\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\n\n\t\t}\n\n\t\treturn a * 0.5;\n\n\t};\n\n\tvar snip = function ( contour, u, v, w, n, verts ) {\n\n\t\tvar p;\n\t\tvar ax, ay, bx, by;\n\t\tvar cx, cy, px, py;\n\n\t\tax = contour[ verts[ u ] ].x;\n\t\tay = contour[ verts[ u ] ].y;\n\n\t\tbx = contour[ verts[ v ] ].x;\n\t\tby = contour[ verts[ v ] ].y;\n\n\t\tcx = contour[ verts[ w ] ].x;\n\t\tcy = contour[ verts[ w ] ].y;\n\n\t\tif ( EPSILON > (((bx-ax)*(cy-ay)) - ((by-ay)*(cx-ax))) ) return false;\n\n\t\tvar aX, aY, bX, bY, cX, cY;\n\t\tvar apx, apy, bpx, bpy, cpx, cpy;\n\t\tvar cCROSSap, bCROSScp, aCROSSbp;\n\n\t\taX = cx - bx;  aY = cy - by;\n\t\tbX = ax - cx;  bY = ay - cy;\n\t\tcX = bx - ax;  cY = by - ay;\n\n\t\tfor ( p = 0; p < n; p++ ) {\n\n\t\t\tif( (p === u) || (p === v) || (p === w) ) continue;\n\n\t\t\tpx = contour[ verts[ p ] ].x\n\t\t\tpy = contour[ verts[ p ] ].y\n\n\t\t\tapx = px - ax;  apy = py - ay;\n\t\t\tbpx = px - bx;  bpy = py - by;\n\t\t\tcpx = px - cx;  cpy = py - cy;\n\n\t\t\t// see if p is inside triangle abc\n\n\t\t\taCROSSbp = aX*bpy - aY*bpx;\n\t\t\tcCROSSap = cX*apy - cY*apx;\n\t\t\tbCROSScp = bX*cpy - bY*cpx;\n\n\t\t\tif ( (aCROSSbp >= -EPSILON) && (bCROSScp >= -EPSILON) && (cCROSSap >= -EPSILON) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n\n\tnamespace.Triangulate = process;\n\tnamespace.Triangulate.area = area;\n\n\treturn namespace;\n\n})(THREE.FontUtils);\n\n// To use the typeface.js face files, hook up the API\nself._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };\nTHREE.typeface_js = self._typeface_js;\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Extensible curve object\n *\n * Some common of Curve methods\n * .getPoint(t), getTangent(t)\n * .getPointAt(u), getTagentAt(u)\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following classes subclasses THREE.Curve:\n *\n * -- 2d classes --\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.CubicBezierCurve\n * THREE.SplineCurve\n * THREE.ArcCurve\n * THREE.EllipseCurve\n *\n * -- 3d classes --\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n * THREE.CubicBezierCurve3\n * THREE.SplineCurve3\n * THREE.ClosedSplineCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath\n *\n **/\n\n/**************************************************************\n *\tAbstract Curve base class\n **************************************************************/\n\nTHREE.Curve = function () {\n\n};\n\n// Virtual base class method to overwrite and implement in subclasses\n//\t- t [0 .. 1]\n\nTHREE.Curve.prototype.getPoint = function ( t ) {\n\n\tconsole.log( \"Warning, getPoint() not implemented!\" );\n\treturn null;\n\n};\n\n// Get point at relative position in curve according to arc length\n// - u [0 .. 1]\n\nTHREE.Curve.prototype.getPointAt = function ( u ) {\n\n\tvar t = this.getUtoTmapping( u );\n\treturn this.getPoint( t );\n\n};\n\n// Get sequence of points using getPoint( t )\n\nTHREE.Curve.prototype.getPoints = function ( divisions ) {\n\n\tif ( !divisions ) divisions = 5;\n\n\tvar d, pts = [];\n\n\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\tpts.push( this.getPoint( d / divisions ) );\n\n\t}\n\n\treturn pts;\n\n};\n\n// Get sequence of points using getPointAt( u )\n\nTHREE.Curve.prototype.getSpacedPoints = function ( divisions ) {\n\n\tif ( !divisions ) divisions = 5;\n\n\tvar d, pts = [];\n\n\tfor ( d = 0; d <= divisions; d ++ ) {\n\n\t\tpts.push( this.getPointAt( d / divisions ) );\n\n\t}\n\n\treturn pts;\n\n};\n\n// Get total curve arc length\n\nTHREE.Curve.prototype.getLength = function () {\n\n\tvar lengths = this.getLengths();\n\treturn lengths[ lengths.length - 1 ];\n\n};\n\n// Get list of cumulative segment lengths\n\nTHREE.Curve.prototype.getLengths = function ( divisions ) {\n\n\tif ( !divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;\n\n\tif ( this.cacheArcLengths\n\t\t&& ( this.cacheArcLengths.length == divisions + 1 )\n\t\t&& !this.needsUpdate) {\n\n\t\t//console.log( \"cached\", this.cacheArcLengths );\n\t\treturn this.cacheArcLengths;\n\n\t}\n\n\tthis.needsUpdate = false;\n\n\tvar cache = [];\n\tvar current, last = this.getPoint( 0 );\n\tvar p, sum = 0;\n\n\tcache.push( 0 );\n\n\tfor ( p = 1; p <= divisions; p ++ ) {\n\n\t\tcurrent = this.getPoint ( p / divisions );\n\t\tsum += current.distanceTo( last );\n\t\tcache.push( sum );\n\t\tlast = current;\n\n\t}\n\n\tthis.cacheArcLengths = cache;\n\n\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\n\n};\n\n\nTHREE.Curve.prototype.updateArcLengths = function() {\n\tthis.needsUpdate = true;\n\tthis.getLengths();\n};\n\n// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance\n\nTHREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {\n\n\tvar arcLengths = this.getLengths();\n\n\tvar i = 0, il = arcLengths.length;\n\n\tvar targetArcLength; // The targeted u distance value to get\n\n\tif ( distance ) {\n\n\t\ttargetArcLength = distance;\n\n\t} else {\n\n\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t}\n\n\t//var time = Date.now();\n\n\t// binary search for the index with largest value smaller than target u distance\n\n\tvar low = 0, high = il - 1, comparison;\n\n\twhile ( low <= high ) {\n\n\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\tif ( comparison < 0 ) {\n\n\t\t\tlow = i + 1;\n\t\t\tcontinue;\n\n\t\t} else if ( comparison > 0 ) {\n\n\t\t\thigh = i - 1;\n\t\t\tcontinue;\n\n\t\t} else {\n\n\t\t\thigh = i;\n\t\t\tbreak;\n\n\t\t\t// DONE\n\n\t\t}\n\n\t}\n\n\ti = high;\n\n\t//console.log('b' , i, low, high, Date.now()- time);\n\n\tif ( arcLengths[ i ] == targetArcLength ) {\n\n\t\tvar t = i / ( il - 1 );\n\t\treturn t;\n\n\t}\n\n\t// we could get finer grain at lengths, or use simple interpolatation between two points\n\n\tvar lengthBefore = arcLengths[ i ];\n    var lengthAfter = arcLengths[ i + 1 ];\n\n    var segmentLength = lengthAfter - lengthBefore;\n\n    // determine where we are between the 'before' and 'after' points\n\n    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n    // add that fractional amount to t\n\n    var t = ( i + segmentFraction ) / ( il -1 );\n\n\treturn t;\n\n};\n\n// Returns a unit vector tangent at t\n// In case any sub curve does not implement its tangent derivation,\n// 2 points a small delta apart will be used to find its gradient\n// which seems to give a reasonable approximation\n\nTHREE.Curve.prototype.getTangent = function( t ) {\n\n\tvar delta = 0.0001;\n\tvar t1 = t - delta;\n\tvar t2 = t + delta;\n\n\t// Capping in case of danger\n\n\tif ( t1 < 0 ) t1 = 0;\n\tif ( t2 > 1 ) t2 = 1;\n\n\tvar pt1 = this.getPoint( t1 );\n\tvar pt2 = this.getPoint( t2 );\n\n\tvar vec = pt2.clone().sub(pt1);\n\treturn vec.normalize();\n\n};\n\n\nTHREE.Curve.prototype.getTangentAt = function ( u ) {\n\n\tvar t = this.getUtoTmapping( u );\n\treturn this.getTangent( t );\n\n};\n\n\n\n\n\n/**************************************************************\n *\tUtils\n **************************************************************/\n\nTHREE.Curve.Utils = {\n\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\n\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\n\n\t},\n\n\t// Puay Bing, thanks for helping with this derivative!\n\n\ttangentCubicBezier: function (t, p0, p1, p2, p3 ) {\n\n\t\treturn -3 * p0 * (1 - t) * (1 - t)  +\n\t\t\t3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +\n\t\t\t6 * t *  p2 * (1-t) - 3 * t * t * p2 +\n\t\t\t3 * t * t * p3;\n\t},\n\n\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\n\n\t\t// To check if my formulas are correct\n\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3  3t^2 + 1\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t\n\t\tvar h01 = -6 * t * t + 6 * t; \t//  2t3 + 3t2\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3  t2\n\n\t\treturn h00 + h10 + h01 + h11;\n\n\t},\n\n\t// Catmull-Rom\n\n\tinterpolate: function( p0, p1, p2, p3, t ) {\n\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\n\t\tvar t2 = t * t;\n\t\tvar t3 = t * t2;\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n\t}\n\n};\n\n\n// TODO: Transformation for Curves?\n\n/**************************************************************\n *\t3D Curves\n **************************************************************/\n\n// A Factory method for creating new curve subclasses\n\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\n\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\n\tconstructor.prototype.getPoint = getPointFunc;\n\n\treturn constructor;\n\n};\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n **/\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nTHREE.CurvePath = function () {\n\n\tthis.curves = [];\n\tthis.bends = [];\n\t\n\tthis.autoClose = false; // Automatically closes the path\n};\n\nTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.CurvePath.prototype.add = function ( curve ) {\n\n\tthis.curves.push( curve );\n\n};\n\nTHREE.CurvePath.prototype.checkConnection = function() {\n\t// TODO\n\t// If the ending of curve is not connected to the starting\n\t// or the next curve, then, this is not a real path\n};\n\nTHREE.CurvePath.prototype.closePath = function() {\n\t// TODO Test\n\t// and verify for vector3 (needs to implement equals)\n\t// Add a line curve if start and end of lines are not connected\n\tvar startPoint = this.curves[0].getPoint(0);\n\tvar endPoint = this.curves[this.curves.length-1].getPoint(1);\n\t\n\tif (!startPoint.equals(endPoint)) {\n\t\tthis.curves.push( new THREE.LineCurve(endPoint, startPoint) );\n\t}\n\t\n};\n\n// To get accurate point with reference to\n// entire path distance at time t,\n// following has to be done:\n\n// 1. Length of each sub path have to be known\n// 2. Locate and identify type of curve\n// 3. Get t for the curve\n// 4. Return curve.getPointAt(t')\n\nTHREE.CurvePath.prototype.getPoint = function( t ) {\n\n\tvar d = t * this.getLength();\n\tvar curveLengths = this.getCurveLengths();\n\tvar i = 0, diff, curve;\n\n\t// To think about boundaries points.\n\n\twhile ( i < curveLengths.length ) {\n\n\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\tdiff = curveLengths[ i ] - d;\n\t\t\tcurve = this.curves[ i ];\n\n\t\t\tvar u = 1 - diff / curve.getLength();\n\n\t\t\treturn curve.getPointAt( u );\n\n\t\t\tbreak;\n\t\t}\n\n\t\ti ++;\n\n\t}\n\n\treturn null;\n\n\t// loop where sum != 0, sum > d , sum+1 <d\n\n};\n\n/*\nTHREE.CurvePath.prototype.getTangent = function( t ) {\n};*/\n\n\n// We cannot use the default THREE.Curve getPoint() with getLength() because in\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n// getPoint() depends on getLength\n\nTHREE.CurvePath.prototype.getLength = function() {\n\n\tvar lens = this.getCurveLengths();\n\treturn lens[ lens.length - 1 ];\n\n};\n\n// Compute lengths and cache them\n// We cannot overwrite getLengths() because UtoT mapping uses it.\n\nTHREE.CurvePath.prototype.getCurveLengths = function() {\n\n\t// We use cache values if curves and cache array are same length\n\n\tif ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {\n\n\t\treturn this.cacheLengths;\n\n\t};\n\n\t// Get length of subsurve\n\t// Push sums into cached array\n\n\tvar lengths = [], sums = 0;\n\tvar i, il = this.curves.length;\n\n\tfor ( i = 0; i < il; i ++ ) {\n\n\t\tsums += this.curves[ i ].getLength();\n\t\tlengths.push( sums );\n\n\t}\n\n\tthis.cacheLengths = lengths;\n\n\treturn lengths;\n\n};\n\n\n\n// Returns min and max coordinates, as well as centroid\n\nTHREE.CurvePath.prototype.getBoundingBox = function () {\n\n\tvar points = this.getPoints();\n\n\tvar maxX, maxY, maxZ;\n\tvar minX, minY, minZ;\n\n\tmaxX = maxY = Number.NEGATIVE_INFINITY;\n\tminX = minY = Number.POSITIVE_INFINITY;\n\n\tvar p, i, il, sum;\n\n\tvar v3 = points[0] instanceof THREE.Vector3;\n\n\tsum = v3 ? new THREE.Vector3() : new THREE.Vector2();\n\n\tfor ( i = 0, il = points.length; i < il; i ++ ) {\n\n\t\tp = points[ i ];\n\n\t\tif ( p.x > maxX ) maxX = p.x;\n\t\telse if ( p.x < minX ) minX = p.x;\n\n\t\tif ( p.y > maxY ) maxY = p.y;\n\t\telse if ( p.y < minY ) minY = p.y;\n\n\t\tif ( v3 ) {\n\n\t\t\tif ( p.z > maxZ ) maxZ = p.z;\n\t\t\telse if ( p.z < minZ ) minZ = p.z;\n\n\t\t}\n\n\t\tsum.add( p );\n\n\t}\n\n\tvar ret = {\n\n\t\tminX: minX,\n\t\tminY: minY,\n\t\tmaxX: maxX,\n\t\tmaxY: maxY,\n\t\tcentroid: sum.divideScalar( il )\n\n\t};\n\n\tif ( v3 ) {\n\n\t\tret.maxZ = maxZ;\n\t\tret.minZ = minZ;\n\n\t}\n\n\treturn ret;\n\n};\n\n/**************************************************************\n *\tCreate Geometries Helpers\n **************************************************************/\n\n/// Generate geometry from path points (for Line or ParticleSystem objects)\n\nTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\n\n\tvar pts = this.getPoints( divisions, true );\n\treturn this.createGeometry( pts );\n\n};\n\n// Generate geometry from equidistance sampling along the path\n\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\n\n\tvar pts = this.getSpacedPoints( divisions, true );\n\treturn this.createGeometry( pts );\n\n};\n\nTHREE.CurvePath.prototype.createGeometry = function( points ) {\n\n\tvar geometry = new THREE.Geometry();\n\n\tfor ( var i = 0; i < points.length; i ++ ) {\n\n\t\tgeometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );\n\n\t}\n\n\treturn geometry;\n\n};\n\n\n/**************************************************************\n *\tBend / Wrap Helper Methods\n **************************************************************/\n\n// Wrap path / Bend modifiers?\n\nTHREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {\n\n\tthis.bends.push( bendpath );\n\n};\n\nTHREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {\n\n\tvar oldPts = this.getPoints( segments ); // getPoints getSpacedPoints\n\tvar i, il;\n\n\tif ( !bends ) {\n\n\t\tbends = this.bends;\n\n\t}\n\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\n\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\n\n\t}\n\n\treturn oldPts;\n\n};\n\nTHREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {\n\n\tvar oldPts = this.getSpacedPoints( segments );\n\n\tvar i, il;\n\n\tif ( !bends ) {\n\n\t\tbends = this.bends;\n\n\t}\n\n\tfor ( i = 0, il = bends.length; i < il; i ++ ) {\n\n\t\toldPts = this.getWrapPoints( oldPts, bends[ i ] );\n\n\t}\n\n\treturn oldPts;\n\n};\n\n// This returns getPoints() bend/wrapped around the contour of a path.\n// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html\n\nTHREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {\n\n\tvar bounds = this.getBoundingBox();\n\n\tvar i, il, p, oldX, oldY, xNorm;\n\n\tfor ( i = 0, il = oldPts.length; i < il; i ++ ) {\n\n\t\tp = oldPts[ i ];\n\n\t\toldX = p.x;\n\t\toldY = p.y;\n\n\t\txNorm = oldX / bounds.maxX;\n\n\t\t// If using actual distance, for length > path, requires line extrusions\n\t\t//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance\n\n\t\txNorm = path.getUtoTmapping( xNorm, oldX );\n\n\t\t// check for out of bounds?\n\n\t\tvar pathPt = path.getPoint( xNorm );\n\t\tvar normal = path.getTangent( xNorm );\n\t\tnormal.set( -normal.y, normal.x ).multiplyScalar( oldY );\n\n\t\tp.x = pathPt.x + normal.x;\n\t\tp.y = pathPt.y + normal.y;\n\n\t}\n\n\treturn oldPts;\n\n};\n\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Gyroscope = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n};\r\n\r\nTHREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );\r\n\r\nTHREE.Gyroscope.prototype.updateMatrixWorld = function ( force ) {\r\n\r\n\tthis.matrixAutoUpdate && this.updateMatrix();\r\n\r\n\t// update matrixWorld\r\n\r\n\tif ( this.matrixWorldNeedsUpdate || force ) {\r\n\r\n\t\tif ( this.parent ) {\r\n\r\n\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\tthis.matrixWorld.decompose( this.translationWorld, this.quaternionWorld, this.scaleWorld );\r\n\t\t\tthis.matrix.decompose( this.translationObject, this.quaternionObject, this.scaleObject );\r\n\r\n\t\t\tthis.matrixWorld.compose( this.translationWorld, this.quaternionObject, this.scaleWorld );\r\n\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t}\r\n\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\tforce = true;\r\n\r\n\t}\r\n\r\n\t// update children\r\n\r\n\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();\r\nTHREE.Gyroscope.prototype.translationObject = new THREE.Vector3();\r\nTHREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion();\r\nTHREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion();\r\nTHREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();\r\nTHREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();\r\n\r\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Creates free form 2d path using series of points, lines or curves.\n *\n **/\n\nTHREE.Path = function ( points ) {\n\n\tTHREE.CurvePath.call(this);\n\n\tthis.actions = [];\n\n\tif ( points ) {\n\n\t\tthis.fromPoints( points );\n\n\t}\n\n};\n\nTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\n\nTHREE.PathActions = {\n\n\tMOVE_TO: 'moveTo',\n\tLINE_TO: 'lineTo',\n\tQUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve\n\tBEZIER_CURVE_TO: 'bezierCurveTo', \t\t// Bezier cubic curve\n\tCSPLINE_THRU: 'splineThru',\t\t\t\t// Catmull-rom spline\n\tARC: 'arc',\t\t\t\t\t\t\t\t// Circle\n\tELLIPSE: 'ellipse'\n};\n\n// TODO Clean up PATH API\n\n// Create path using straight lines to connect all points\n// - vectors: array of Vector2\n\nTHREE.Path.prototype.fromPoints = function ( vectors ) {\n\n\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\n\n\tfor ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {\n\n\t\tthis.lineTo( vectors[ v ].x, vectors[ v ].y );\n\n\t};\n\n};\n\n// startPath() endPath()?\n\nTHREE.Path.prototype.moveTo = function ( x, y ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\tthis.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );\n\n};\n\nTHREE.Path.prototype.lineTo = function ( x, y ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\n\tthis.curves.push( curve );\n\n\tthis.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );\n\n};\n\nTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tvar curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCPx, aCPy ),\n\t\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\n\tthis.curves.push( curve );\n\n\tthis.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );\n\n};\n\nTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,\n\t\t\t\t\t\t\t\t\t\t\t   aCP2x, aCP2y,\n\t\t\t\t\t\t\t\t\t\t\t   aX, aY ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tvar curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\n\t\t\t\t\t\t\t\t\t\t\tnew THREE.Vector2( aX, aY ) );\n\tthis.curves.push( curve );\n\n\tthis.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );\n\n};\n\nTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\n\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n//---\n\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\n\tArray.prototype.push.apply( npts, pts );\n\n\tvar curve = new THREE.SplineCurve( npts );\n\tthis.curves.push( curve );\n\n\tthis.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );\n\n};\n\n// FUTURE: Change the API or follow canvas API?\n\nTHREE.Path.prototype.arc = function ( aX, aY, aRadius,\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tthis.absarc(aX + x0, aY + y0, aRadius,\n\t\taStartAngle, aEndAngle, aClockwise );\n\n };\n\n THREE.Path.prototype.absarc = function ( aX, aY, aRadius,\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\tthis.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n };\n\nTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\n\tvar lastargs = this.actions[ this.actions.length - 1].args;\n\tvar x0 = lastargs[ lastargs.length - 2 ];\n\tvar y0 = lastargs[ lastargs.length - 1 ];\n\n\tthis.absellipse(aX + x0, aY + y0, xRadius, yRadius,\n\t\taStartAngle, aEndAngle, aClockwise );\n\n };\n\n\nTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,\n\t\t\t\t\t\t\t\t\t  aStartAngle, aEndAngle, aClockwise ) {\n\n\tvar args = Array.prototype.slice.call( arguments );\n\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,\n\t\t\t\t\t\t\t\t\taStartAngle, aEndAngle, aClockwise );\n\tthis.curves.push( curve );\n\n\tvar lastPoint = curve.getPoint(1);\n\targs.push(lastPoint.x);\n\targs.push(lastPoint.y);\n\n\tthis.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );\n\n };\n\nTHREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {\n\n\tif ( ! divisions ) divisions = 40;\n\n\tvar points = [];\n\n\tfor ( var i = 0; i < divisions; i ++ ) {\n\n\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t//if( !this.getPoint( i / divisions ) ) throw \"DIE\";\n\n\t}\n\n\t// if ( closedPath ) {\n\t//\n\t// \tpoints.push( points[ 0 ] );\n\t//\n\t// }\n\n\treturn points;\n\n};\n\n/* Return an array of vectors based on contour of the path */\n\nTHREE.Path.prototype.getPoints = function( divisions, closedPath ) {\n\n\tif (this.useSpacedPoints) {\n\t\tconsole.log('tata');\n\t\treturn this.getSpacedPoints( divisions, closedPath );\n\t}\n\n\tdivisions = divisions || 12;\n\n\tvar points = [];\n\n\tvar i, il, item, action, args;\n\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\n\t\tlaste, j,\n\t\tt, tx, ty;\n\n\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\n\n\t\titem = this.actions[ i ];\n\n\t\taction = item.action;\n\t\targs = item.args;\n\n\t\tswitch( action ) {\n\n\t\tcase THREE.PathActions.MOVE_TO:\n\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.LINE_TO:\n\n\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.QUADRATIC_CURVE_TO:\n\n\t\t\tcpx  = args[ 2 ];\n\t\t\tcpy  = args[ 3 ];\n\n\t\t\tcpx1 = args[ 0 ];\n\t\t\tcpy1 = args[ 1 ];\n\n\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\tcpx0 = laste.x;\n\t\t\t\tcpy0 = laste.y;\n\n\t\t\t} else {\n\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t}\n\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\tt = j / divisions;\n\n\t\t\t\ttx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\n\t\t\t\tty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\n\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.BEZIER_CURVE_TO:\n\n\t\t\tcpx  = args[ 4 ];\n\t\t\tcpy  = args[ 5 ];\n\n\t\t\tcpx1 = args[ 0 ];\n\t\t\tcpy1 = args[ 1 ];\n\n\t\t\tcpx2 = args[ 2 ];\n\t\t\tcpy2 = args[ 3 ];\n\n\t\t\tif ( points.length > 0 ) {\n\n\t\t\t\tlaste = points[ points.length - 1 ];\n\n\t\t\t\tcpx0 = laste.x;\n\t\t\t\tcpy0 = laste.y;\n\n\t\t\t} else {\n\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\t\tcpx0 = laste[ laste.length - 2 ];\n\t\t\t\tcpy0 = laste[ laste.length - 1 ];\n\n\t\t\t}\n\n\n\t\t\tfor ( j = 1; j <= divisions; j ++ ) {\n\n\t\t\t\tt = j / divisions;\n\n\t\t\t\ttx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\n\t\t\t\tty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\n\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.CSPLINE_THRU:\n\n\t\t\tlaste = this.actions[ i - 1 ].args;\n\n\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\n\t\t\tvar spts = [ last ];\n\n\t\t\tvar n = divisions * args[ 0 ].length;\n\n\t\t\tspts = spts.concat( args[ 0 ] );\n\n\t\t\tvar spline = new THREE.SplineCurve( spts );\n\n\t\t\tfor ( j = 1; j <= n; j ++ ) {\n\n\t\t\t\tpoints.push( spline.getPointAt( j / n ) ) ;\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase THREE.PathActions.ARC:\n\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\taRadius = args[ 2 ],\n\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\n\t\t\t\taClockwise = !!args[ 5 ];\n\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\tvar angle;\n\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\tt = j / tdivisions;\n\n\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t}\n\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\ttx = aX + aRadius * Math.cos( angle );\n\t\t\t\tty = aY + aRadius * Math.sin( angle );\n\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t}\n\n\t\t\t//console.log(points);\n\n\t\t  break;\n\t\t  \n\t\tcase THREE.PathActions.ELLIPSE:\n\n\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\n\t\t\t\txRadius = args[ 2 ],\n\t\t\t\tyRadius = args[ 3 ],\n\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\n\t\t\t\taClockwise = !!args[ 6 ];\n\n\n\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\n\t\t\tvar angle;\n\t\t\tvar tdivisions = divisions * 2;\n\n\t\t\tfor ( j = 1; j <= tdivisions; j ++ ) {\n\n\t\t\t\tt = j / tdivisions;\n\n\t\t\t\tif ( ! aClockwise ) {\n\n\t\t\t\t\tt = 1 - t;\n\n\t\t\t\t}\n\n\t\t\t\tangle = aStartAngle + t * deltaAngle;\n\n\t\t\t\ttx = aX + xRadius * Math.cos( angle );\n\t\t\t\tty = aY + yRadius * Math.sin( angle );\n\n\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\n\n\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\n\n\t\t\t}\n\n\t\t\t//console.log(points);\n\n\t\t  break;\n\n\t\t} // end switch\n\n\t}\n\n\n\n\t// Normalize to remove the closing point by default.\n\tvar lastPoint = points[ points.length - 1];\n\tvar EPSILON = 0.0000000001;\n\tif ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&\n\t\t\t Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)\n\t\tpoints.splice( points.length - 1, 1);\n\tif ( closedPath ) {\n\n\t\tpoints.push( points[ 0 ] );\n\n\t}\n\n\treturn points;\n\n};\n\n// Breaks path into shapes\n\nTHREE.Path.prototype.toShapes = function( isCCW ) {\n\n\tvar i, il, item, action, args;\n\n\tvar subPaths = [], lastPath = new THREE.Path();\n\n\tfor ( i = 0, il = this.actions.length; i < il; i ++ ) {\n\n\t\titem = this.actions[ i ];\n\n\t\targs = item.args;\n\t\taction = item.action;\n\n\t\tif ( action == THREE.PathActions.MOVE_TO ) {\n\n\t\t\tif ( lastPath.actions.length != 0 ) {\n\n\t\t\t\tsubPaths.push( lastPath );\n\t\t\t\tlastPath = new THREE.Path();\n\n\t\t\t}\n\n\t\t}\n\n\t\tlastPath[ action ].apply( lastPath, args );\n\n\t}\n\n\tif ( lastPath.actions.length != 0 ) {\n\n\t\tsubPaths.push( lastPath );\n\n\t}\n\n\t// console.log(subPaths);\n\n\tif ( subPaths.length == 0 ) return [];\n\n\tvar solid, tmpPath, tmpShape, shapes = [];\n\n\tif ( subPaths.length == 1) {\n\n\t\ttmpPath = subPaths[0];\n\t\ttmpShape = new THREE.Shape();\n\t\ttmpShape.actions = tmpPath.actions;\n\t\ttmpShape.curves = tmpPath.curves;\n\t\tshapes.push( tmpShape );\n\t\treturn shapes;\n\n\t}\n\n\tvar holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );\n\tholesFirst = isCCW ? !holesFirst : holesFirst;\n\n\t// console.log(\"Holes first\", holesFirst);\n\n\tif ( holesFirst ) {\n\n\t\ttmpShape = new THREE.Shape();\n\n\t\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\tsolid = THREE.Shape.Utils.isClockWise( tmpPath.getPoints() );\n\t\t\tsolid = isCCW ? !solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t\tshapes.push( tmpShape );\n\t\t\t\ttmpShape = new THREE.Shape();\n\n\t\t\t\t//console.log('cw', i);\n\n\t\t\t} else {\n\n\t\t\t\ttmpShape.holes.push( tmpPath );\n\n\t\t\t\t//console.log('ccw', i);\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\t// Shapes first\n\t\ttmpShape = undefined;\n\n\t\tfor ( i = 0, il = subPaths.length; i < il; i ++ ) {\n\n\t\t\ttmpPath = subPaths[ i ];\n\t\t\tsolid = THREE.Shape.Utils.isClockWise( tmpPath.getPoints() );\n\t\t\tsolid = isCCW ? !solid : solid;\n\n\t\t\tif ( solid ) {\n\n\t\t\t\tif ( tmpShape ) shapes.push( tmpShape );\n\n\t\t\t\ttmpShape = new THREE.Shape();\n\t\t\t\ttmpShape.actions = tmpPath.actions;\n\t\t\t\ttmpShape.curves = tmpPath.curves;\n\n\t\t\t} else {\n\n\t\t\t\ttmpShape.holes.push( tmpPath );\n\n\t\t\t}\n\n\t\t}\n\n\t\tshapes.push( tmpShape );\n\n\t}\n\n\t//console.log(\"shape\", shapes);\n\n\treturn shapes;\n\n};\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * Defines a 2d shape plane using paths.\n **/\n\n// STEP 1 Create a path.\n// STEP 2 Turn path into shape.\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\n// STEP 3a - Extract points from each shape, turn to vertices\n// STEP 3b - Triangulate each shape, add faces.\n\nTHREE.Shape = function () {\n\n\tTHREE.Path.apply( this, arguments );\n\tthis.holes = [];\n\n};\n\nTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\n\n// Convenience method to return ExtrudeGeometry\n\nTHREE.Shape.prototype.extrude = function ( options ) {\n\n\tvar extruded = new THREE.ExtrudeGeometry( this, options );\n\treturn extruded;\n\n};\n\n// Convenience method to return ShapeGeometry\n\nTHREE.Shape.prototype.makeGeometry = function ( options ) {\n\n\tvar geometry = new THREE.ShapeGeometry( this, options );\n\treturn geometry;\n\n};\n\n// Get points of holes\n\nTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\n\n\tvar i, il = this.holes.length, holesPts = [];\n\n\tfor ( i = 0; i < il; i ++ ) {\n\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );\n\n\t}\n\n\treturn holesPts;\n\n};\n\n// Get points of holes (spaced by regular distance)\n\nTHREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {\n\n\tvar i, il = this.holes.length, holesPts = [];\n\n\tfor ( i = 0; i < il; i ++ ) {\n\n\t\tholesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );\n\n\t}\n\n\treturn holesPts;\n\n};\n\n\n// Get points of shape and holes (keypoints based on segments parameter)\n\nTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\n\n\treturn {\n\n\t\tshape: this.getTransformedPoints( divisions ),\n\t\tholes: this.getPointsHoles( divisions )\n\n\t};\n\n};\n\nTHREE.Shape.prototype.extractPoints = function ( divisions ) {\n\n\tif (this.useSpacedPoints) {\n\t\treturn this.extractAllSpacedPoints(divisions);\n\t}\n\n\treturn this.extractAllPoints(divisions);\n\n};\n\n//\n// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {\n//\n// \treturn {\n//\n// \t\tshape: this.transform( bend, divisions ),\n// \t\tholes: this.getPointsHoles( divisions, bend )\n//\n// \t};\n//\n// };\n\n// Get points of shape and holes (spaced by regular distance)\n\nTHREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {\n\n\treturn {\n\n\t\tshape: this.getTransformedSpacedPoints( divisions ),\n\t\tholes: this.getSpacedPointsHoles( divisions )\n\n\t};\n\n};\n\n/**************************************************************\n *\tUtils\n **************************************************************/\n\nTHREE.Shape.Utils = {\n\n\t/*\n\t\tcontour - array of vector2 for contour\n\t\tholes   - array of array of vector2\n\t*/\n\n\tremoveHoles: function ( contour, holes ) {\n\n\t\tvar shape = contour.concat(); // work on this shape\n\t\tvar allpoints = shape.concat();\n\n\t\t/* For each isolated shape, find the closest points and break to the hole to allow triangulation */\n\n\n\t\tvar prevShapeVert, nextShapeVert,\n\t\t\tprevHoleVert, nextHoleVert,\n\t\t\tholeIndex, shapeIndex,\n\t\t\tshapeId, shapeGroup,\n\t\t\th, h2,\n\t\t\thole, shortest, d,\n\t\t\tp, pts1, pts2,\n\t\t\ttmpShape1, tmpShape2,\n\t\t\ttmpHole1, tmpHole2,\n\t\t\tverts = [];\n\n\t\tfor ( h = 0; h < holes.length; h ++ ) {\n\n\t\t\thole = holes[ h ];\n\n\t\t\t/*\n\t\t\tshapeholes[ h ].concat(); // preserves original\n\t\t\tholes.push( hole );\n\t\t\t*/\n\n\t\t\tArray.prototype.push.apply( allpoints, hole );\n\n\t\t\tshortest = Number.POSITIVE_INFINITY;\n\n\n\t\t\t// Find the shortest pair of pts between shape and hole\n\n\t\t\t// Note: Actually, I'm not sure now if we could optimize this to be faster than O(m*n)\n\t\t\t// Using distanceToSquared() intead of distanceTo() should speed a little\n\t\t\t// since running square roots operations are reduced.\n\n\t\t\tfor ( h2 = 0; h2 < hole.length; h2 ++ ) {\n\n\t\t\t\tpts1 = hole[ h2 ];\n\t\t\t\tvar dist = [];\n\n\t\t\t\tfor ( p = 0; p < shape.length; p++ ) {\n\n\t\t\t\t\tpts2 = shape[ p ];\n\t\t\t\t\td = pts1.distanceToSquared( pts2 );\n\t\t\t\t\tdist.push( d );\n\n\t\t\t\t\tif ( d < shortest ) {\n\n\t\t\t\t\t\tshortest = d;\n\t\t\t\t\t\tholeIndex = h2;\n\t\t\t\t\t\tshapeIndex = p;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//console.log(\"shortest\", shortest, dist);\n\n\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\n\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\n\n\t\t\tvar areaapts = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\tshape[ shapeIndex ],\n\t\t\t\tshape[ prevShapeVert ]\n\n\t\t\t];\n\n\t\t\tvar areaa = THREE.FontUtils.Triangulate.area( areaapts );\n\n\t\t\tvar areabpts = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\thole[ prevHoleVert ],\n\t\t\t\tshape[ shapeIndex ]\n\n\t\t\t];\n\n\t\t\tvar areab = THREE.FontUtils.Triangulate.area( areabpts );\n\n\t\t\tvar shapeOffset = 1;\n\t\t\tvar holeOffset = -1;\n\n\t\t\tvar oldShapeIndex = shapeIndex, oldHoleIndex = holeIndex;\n\t\t\tshapeIndex += shapeOffset;\n\t\t\tholeIndex += holeOffset;\n\n\t\t\tif ( shapeIndex < 0 ) { shapeIndex += shape.length;  }\n\t\t\tshapeIndex %= shape.length;\n\n\t\t\tif ( holeIndex < 0 ) { holeIndex += hole.length;  }\n\t\t\tholeIndex %= hole.length;\n\n\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\n\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\n\n\t\t\tareaapts = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\tshape[ shapeIndex ],\n\t\t\t\tshape[ prevShapeVert ]\n\n\t\t\t];\n\n\t\t\tvar areaa2 = THREE.FontUtils.Triangulate.area( areaapts );\n\n\t\t\tareabpts = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\thole[ prevHoleVert ],\n\t\t\t\tshape[ shapeIndex ]\n\n\t\t\t];\n\n\t\t\tvar areab2 = THREE.FontUtils.Triangulate.area( areabpts );\n\t\t\t//console.log(areaa,areab ,areaa2,areab2, ( areaa + areab ),  ( areaa2 + areab2 ));\n\n\t\t\tif ( ( areaa + areab ) > ( areaa2 + areab2 ) ) {\n\n\t\t\t\t// In case areas are not correct.\n\t\t\t\t//console.log(\"USE THIS\");\n\n\t\t\t\tshapeIndex = oldShapeIndex;\n\t\t\t\tholeIndex = oldHoleIndex ;\n\n\t\t\t\tif ( shapeIndex < 0 ) { shapeIndex += shape.length;  }\n\t\t\t\tshapeIndex %= shape.length;\n\n\t\t\t\tif ( holeIndex < 0 ) { holeIndex += hole.length;  }\n\t\t\t\tholeIndex %= hole.length;\n\n\t\t\t\tprevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;\n\t\t\t\tprevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;\n\n\t\t\t} else {\n\n\t\t\t\t//console.log(\"USE THAT \")\n\n\t\t\t}\n\n\t\t\ttmpShape1 = shape.slice( 0, shapeIndex );\n\t\t\ttmpShape2 = shape.slice( shapeIndex );\n\t\t\ttmpHole1 = hole.slice( holeIndex );\n\t\t\ttmpHole2 = hole.slice( 0, holeIndex );\n\n\t\t\t// Should check orders here again?\n\n\t\t\tvar trianglea = [\n\n\t\t\t\thole[ holeIndex ],\n\t\t\t\tshape[ shapeIndex ],\n\t\t\t\tshape[ prevShapeVert ]\n\n\t\t\t];\n\n\t\t\tvar triangleb = [\n\n\t\t\t\thole[ holeIndex ] ,\n\t\t\t\thole[ prevHoleVert ],\n\t\t\t\tshape[ shapeIndex ]\n\n\t\t\t];\n\n\t\t\tverts.push( trianglea );\n\t\t\tverts.push( triangleb );\n\n\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tshape:shape, \t\t/* shape with no holes */\n\t\t\tisolatedPts: verts, /* isolated faces */\n\t\t\tallpoints: allpoints\n\n\t\t}\n\n\n\t},\n\n\ttriangulateShape: function ( contour, holes ) {\n\n\t\tvar shapeWithoutHoles = THREE.Shape.Utils.removeHoles( contour, holes );\n\n\t\tvar shape = shapeWithoutHoles.shape,\n\t\t\tallpoints = shapeWithoutHoles.allpoints,\n\t\t\tisolatedPts = shapeWithoutHoles.isolatedPts;\n\n\t\tvar triangles = THREE.FontUtils.Triangulate( shape, false ); // True returns indices for points of spooled shape\n\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\n\n\t\t//console.log( \"triangles\",triangles, triangles.length );\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\n\n\t\tvar i, il, f, face,\n\t\t\tkey, index,\n\t\t\tallPointsMap = {},\n\t\t\tisolatedPointsMap = {};\n\n\t\t// prepare all points map\n\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\n\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\n\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\n\n\t\t\t\tconsole.log( \"Duplicate point\", key );\n\n\t\t\t}\n\n\t\t\tallPointsMap[ key ] = i;\n\n\t\t}\n\n\t\t// check all face vertices against all points map\n\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\n\n\t\t\tface = triangles[ i ];\n\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check isolated points vertices against all points map\n\n\t\tfor ( i = 0, il = isolatedPts.length; i < il; i ++ ) {\n\n\t\t\tface = isolatedPts[ i ];\n\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\n\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\n\n\t\t\t\tindex = allPointsMap[ key ];\n\n\t\t\t\tif ( index !== undefined ) {\n\n\t\t\t\t\tface[ f ] = index;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn triangles.concat( isolatedPts );\n\n\t}, // end triangulate shapes\n\n\t/*\n\ttriangulate2 : function( pts, holes ) {\n\n\t\t// For use with Poly2Tri.js\n\n\t\tvar allpts = pts.concat();\n\t\tvar shape = [];\n\t\tfor (var p in pts) {\n\t\t\tshape.push(new js.poly2tri.Point(pts[p].x, pts[p].y));\n\t\t}\n\n\t\tvar swctx = new js.poly2tri.SweepContext(shape);\n\n\t\tfor (var h in holes) {\n\t\t\tvar aHole = holes[h];\n\t\t\tvar newHole = []\n\t\t\tfor (i in aHole) {\n\t\t\t\tnewHole.push(new js.poly2tri.Point(aHole[i].x, aHole[i].y));\n\t\t\t\tallpts.push(aHole[i]);\n\t\t\t}\n\t\t\tswctx.AddHole(newHole);\n\t\t}\n\n\t\tvar find;\n\t\tvar findIndexForPt = function (pt) {\n\t\t\tfind = new THREE.Vector2(pt.x, pt.y);\n\t\t\tvar p;\n\t\t\tfor (p=0, pl = allpts.length; p<pl; p++) {\n\t\t\t\tif (allpts[p].equals(find)) return p;\n\t\t\t}\n\t\t\treturn -1;\n\t\t};\n\n\t\t// triangulate\n\t\tjs.poly2tri.sweep.Triangulate(swctx);\n\n\t\tvar triangles =  swctx.GetTriangles();\n\t\tvar tr ;\n\t\tvar facesPts = [];\n\t\tfor (var t in triangles) {\n\t\t\ttr =  triangles[t];\n\t\t\tfacesPts.push([\n\t\t\t\tfindIndexForPt(tr.GetPoint(0)),\n\t\t\t\tfindIndexForPt(tr.GetPoint(1)),\n\t\t\t\tfindIndexForPt(tr.GetPoint(2))\n\t\t\t\t\t]);\n\t\t}\n\n\n\t//\tconsole.log(facesPts);\n\t//\tconsole.log(\"triangles\", triangles.length, triangles);\n\n\t\t// Returns array of faces with 3 element each\n\treturn facesPts;\n\t},\n*/\n\n\tisClockWise: function ( pts ) {\n\n\t\treturn THREE.FontUtils.Triangulate.area( pts ) < 0;\n\n\t},\n\n\t// Bezier Curves formulas obtained from\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\n\n\t// Quad Bezier Functions\n\n\tb2p0: function ( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn k * k * p;\n\n\t},\n\n\tb2p1: function ( t, p ) {\n\n\t\treturn 2 * ( 1 - t ) * t * p;\n\n\t},\n\n\tb2p2: function ( t, p ) {\n\n\t\treturn t * t * p;\n\n\t},\n\n\tb2: function ( t, p0, p1, p2 ) {\n\n\t\treturn this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );\n\n\t},\n\n\t// Cubic Bezier Functions\n\n\tb3p0: function ( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn k * k * k * p;\n\n\t},\n\n\tb3p1: function ( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn 3 * k * k * t * p;\n\n\t},\n\n\tb3p2: function ( t, p ) {\n\n\t\tvar k = 1 - t;\n\t\treturn 3 * k * t * t * p;\n\n\t},\n\n\tb3p3: function ( t, p ) {\n\n\t\treturn t * t * t * p;\n\n\t},\n\n\tb3: function ( t, p0, p1, p2, p3 ) {\n\n\t\treturn this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );\n\n\t}\n\n};\n\n\n/**************************************************************\n *\tLine\n **************************************************************/\n\nTHREE.LineCurve = function ( v1, v2 ) {\n\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\n\n\tvar point = this.v2.clone().sub(this.v1);\n\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\treturn point;\n\n};\n\n// Line curve is linear, so we can overwrite default getPointAt\n\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\n\n\treturn this.getPoint( u );\n\n};\n\nTHREE.LineCurve.prototype.getTangent = function( t ) {\n\n\tvar tangent = this.v2.clone().sub(this.v1);\n\n\treturn tangent.normalize();\n\n};\n/**************************************************************\n *\tQuadratic Bezier curve\n **************************************************************/\n\n\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\n};\n\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\n\n\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar tx, ty;\n\n\ttx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\n\tty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\n\n\treturn new THREE.Vector2( tx, ty );\n\n};\n\n\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tx, ty;\n\n\ttx = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );\n\tty = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );\n\n\t// returns unit vector\n\n\tvar tangent = new THREE.Vector2( tx, ty );\n\ttangent.normalize();\n\n\treturn tangent;\n\n};\n/**************************************************************\n *\tCubic Bezier curve\n **************************************************************/\n\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\n\n\tthis.v0 = v0;\n\tthis.v1 = v1;\n\tthis.v2 = v2;\n\tthis.v3 = v3;\n\n};\n\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\n\n\tvar tx, ty;\n\n\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\n\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\n\n\treturn new THREE.Vector2( tx, ty );\n\n};\n\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\n\n\tvar tx, ty;\n\n\ttx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\n\tty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\n\n\tvar tangent = new THREE.Vector2( tx, ty );\n\ttangent.normalize();\n\n\treturn tangent;\n\n};\n/**************************************************************\n *\tSpline curve\n **************************************************************/\n\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\n\n\tthis.points = (points == undefined) ? [] : points;\n\n};\n\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\n\n\tvar v = new THREE.Vector2();\n\tvar c = [];\n\tvar points = this.points, point, intPoint, weight;\n\tpoint = ( points.length - 1 ) * t;\n\n\tintPoint = Math.floor( point );\n\tweight = point - intPoint;\n\n\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\n\tc[ 1 ] = intPoint;\n\tc[ 2 ] = intPoint  > points.length - 2 ? points.length -1 : intPoint + 1;\n\tc[ 3 ] = intPoint  > points.length - 3 ? points.length -1 : intPoint + 2;\n\n\tv.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );\n\tv.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );\n\n\treturn v;\n\n};\n/**************************************************************\n *\tEllipse curve\n **************************************************************/\n\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\tthis.aX = aX;\n\tthis.aY = aY;\n\n\tthis.xRadius = xRadius;\n\tthis.yRadius = yRadius;\n\n\tthis.aStartAngle = aStartAngle;\n\tthis.aEndAngle = aEndAngle;\n\n\tthis.aClockwise = aClockwise;\n\n};\n\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\n\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\n\n\tvar angle;\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\n\n\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\n\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\n\n\tif ( this.aClockwise === true ) {\n\n\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\n\n\t} else {\n\n\t\tangle = this.aStartAngle + t * deltaAngle;\n\n\t}\n\n\tvar tx = this.aX + this.xRadius * Math.cos( angle );\n\tvar ty = this.aY + this.yRadius * Math.sin( angle );\n\n\treturn new THREE.Vector2( tx, ty );\n\n};\n\n/**************************************************************\n *\tArc curve\n **************************************************************/\n\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n};\n\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\n/**************************************************************\n *\tLine3D\n **************************************************************/\n\nTHREE.LineCurve3 = THREE.Curve.create(\n\n\tfunction ( v1, v2 ) {\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar r = new THREE.Vector3();\n\n\n\t\tr.subVectors( this.v2, this.v1 ); // diff\n\t\tr.multiplyScalar( t );\n\t\tr.add( this.v1 );\n\n\t\treturn r;\n\n\t}\n\n);\n\n/**************************************************************\n *\tQuadratic Bezier 3D curve\n **************************************************************/\n\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar tx, ty, tz;\n\n\t\ttx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\n\t\tty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\n\t\ttz = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );\n\n\t\treturn new THREE.Vector3( tx, ty, tz );\n\n\t}\n\n);\n/**************************************************************\n *\tCubic Bezier 3D curve\n **************************************************************/\n\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\n\n\tfunction ( v0, v1, v2, v3 ) {\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar tx, ty, tz;\n\n\t\ttx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\n\t\tty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\n\t\ttz = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );\n\n\t\treturn new THREE.Vector3( tx, ty, tz );\n\n\t}\n\n);\n/**************************************************************\n *\tSpline 3D curve\n **************************************************************/\n\n\nTHREE.SplineCurve3 = THREE.Curve.create(\n\n\tfunction ( points /* array of Vector3 */) {\n\n\t\tthis.points = (points == undefined) ? [] : points;\n\n\t},\n\n\tfunction ( t ) {\n\n\t\tvar v = new THREE.Vector3();\n\t\tvar c = [];\n\t\tvar points = this.points, point, intPoint, weight;\n\t\tpoint = ( points.length - 1 ) * t;\n\n\t\tintPoint = Math.floor( point );\n\t\tweight = point - intPoint;\n\n\t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\n\t\tc[ 1 ] = intPoint;\n\t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\n\t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\n\n\t\tvar pt0 = points[ c[0] ],\n\t\t\tpt1 = points[ c[1] ],\n\t\t\tpt2 = points[ c[2] ],\n\t\t\tpt3 = points[ c[3] ];\n\n\t\tv.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);\n\t\tv.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);\n\t\tv.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);\n\n\t\treturn v;\n\n\t}\n\n);\n\n\n// THREE.SplineCurve3.prototype.getTangent = function(t) {\n// \t\tvar v = new THREE.Vector3();\n// \t\tvar c = [];\n// \t\tvar points = this.points, point, intPoint, weight;\n// \t\tpoint = ( points.length - 1 ) * t;\n\n// \t\tintPoint = Math.floor( point );\n// \t\tweight = point - intPoint;\n\n// \t\tc[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;\n// \t\tc[ 1 ] = intPoint;\n// \t\tc[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;\n// \t\tc[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;\n\n// \t\tvar pt0 = points[ c[0] ],\n// \t\t\tpt1 = points[ c[1] ],\n// \t\t\tpt2 = points[ c[2] ],\n// \t\t\tpt3 = points[ c[3] ];\n\n// \t// t = weight;\n// \tv.x = THREE.Curve.Utils.tangentSpline( t, pt0.x, pt1.x, pt2.x, pt3.x );\n// \tv.y = THREE.Curve.Utils.tangentSpline( t, pt0.y, pt1.y, pt2.y, pt3.y );\n// \tv.z = THREE.Curve.Utils.tangentSpline( t, pt0.z, pt1.z, pt2.z, pt3.z );\n\n// \treturn v;\n\n// }\n/**************************************************************\n *\tClosed Spline 3D curve\n **************************************************************/\n\n\nTHREE.ClosedSplineCurve3 = THREE.Curve.create(\n\n\tfunction ( points /* array of Vector3 */) {\n\n\t\tthis.points = (points == undefined) ? [] : points;\n\n\t},\n\n    function ( t ) {\n\n        var v = new THREE.Vector3();\n        var c = [];\n        var points = this.points, point, intPoint, weight;\n        point = ( points.length - 0 ) * t;\n            // This needs to be from 0-length +1\n\n        intPoint = Math.floor( point );\n        weight = point - intPoint;\n\n        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\n        c[ 0 ] = ( intPoint - 1 ) % points.length;\n        c[ 1 ] = ( intPoint ) % points.length;\n        c[ 2 ] = ( intPoint + 1 ) % points.length;\n        c[ 3 ] = ( intPoint + 2 ) % points.length;\n\n        v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );\n        v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );\n        v.z = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].z, points[ c[ 1 ] ].z, points[ c[ 2 ] ].z, points[ c[ 3 ] ].z, weight );\n\n        return v;\n\n    }\n\n);\n/**\n * @author mikael emtinger / http://gomo.se/\n */\n\nTHREE.AnimationHandler = (function() {\n\n\tvar playing = [];\n\tvar library = {};\n\tvar that    = {};\n\n\n\t//--- update ---\n\n\tthat.update = function( deltaTimeMS ) {\n\n\t\tfor( var i = 0; i < playing.length; i ++ )\n\t\t\tplaying[ i ].update( deltaTimeMS );\n\n\t};\n\n\n\t//--- add ---\n\n\tthat.addToUpdate = function( animation ) {\n\n\t\tif ( playing.indexOf( animation ) === -1 )\n\t\t\tplaying.push( animation );\n\n\t};\n\n\n\t//--- remove ---\n\n\tthat.removeFromUpdate = function( animation ) {\n\n\t\tvar index = playing.indexOf( animation );\n\n\t\tif( index !== -1 )\n\t\t\tplaying.splice( index, 1 );\n\n\t};\n\n\n\t//--- add ---\n\n\tthat.add = function( data ) {\n\n\t\tif ( library[ data.name ] !== undefined )\n\t\t\tconsole.log( \"THREE.AnimationHandler.add: Warning! \" + data.name + \" already exists in library. Overwriting.\" );\n\n\t\tlibrary[ data.name ] = data;\n\t\tinitData( data );\n\n\t};\n\n\n\t//--- get ---\n\n\tthat.get = function( name ) {\n\n\t\tif ( typeof name === \"string\" ) {\n\n\t\t\tif ( library[ name ] ) {\n\n\t\t\t\treturn library[ name ];\n\n\t\t\t} else {\n\n\t\t\t\tconsole.log( \"THREE.AnimationHandler.get: Couldn't find animation \" + name );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// todo: add simple tween library\n\n\t\t}\n\n\t};\n\n\t//--- parse ---\n\n\tthat.parse = function( root ) {\n\n\t\t// setup hierarchy\n\n\t\tvar hierarchy = [];\n\n\t\tif ( root instanceof THREE.SkinnedMesh ) {\n\n\t\t\tfor( var b = 0; b < root.bones.length; b++ ) {\n\n\t\t\t\thierarchy.push( root.bones[ b ] );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tparseRecurseHierarchy( root, hierarchy );\n\n\t\t}\n\n\t\treturn hierarchy;\n\n\t};\n\n\tvar parseRecurseHierarchy = function( root, hierarchy ) {\n\n\t\thierarchy.push( root );\n\n\t\tfor( var c = 0; c < root.children.length; c++ )\n\t\t\tparseRecurseHierarchy( root.children[ c ], hierarchy );\n\n\t}\n\n\n\t//--- init data ---\n\n\tvar initData = function( data ) {\n\n\t\tif( data.initialized === true )\n\t\t\treturn;\n\n\n\t\t// loop through all keys\n\n\t\tfor( var h = 0; h < data.hierarchy.length; h ++ ) {\n\n\t\t\tfor( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\t// remove minus times\n\n\t\t\t\tif( data.hierarchy[ h ].keys[ k ].time < 0 )\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].time = 0;\n\n\n\t\t\t\t// create quaternions\n\n\t\t\t\tif( data.hierarchy[ h ].keys[ k ].rot !== undefined &&\n\t\t\t\t !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {\n\n\t\t\t\t\tvar quat = data.hierarchy[ h ].keys[ k ].rot;\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion( quat[0], quat[1], quat[2], quat[3] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// prepare morph target keys\n\n\t\t\tif( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {\n\n\t\t\t\t// get all used\n\n\t\t\t\tvar usedMorphTargets = {};\n\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\tvar morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];\n\t\t\t\t\t\tusedMorphTargets[ morphTargetName ] = -1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tdata.hierarchy[ h ].usedMorphTargets = usedMorphTargets;\n\n\n\t\t\t\t// set all used on all frames\n\n\t\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\t\tvar influences = {};\n\n\t\t\t\t\tfor ( var morphTargetName in usedMorphTargets ) {\n\n\t\t\t\t\t\tfor ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\n\n\t\t\t\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {\n\n\t\t\t\t\t\t\t\tinfluences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {\n\n\t\t\t\t\t\t\tinfluences[ morphTargetName ] = 0;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tdata.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// remove all keys that are on the same time\n\n\t\t\tfor ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\tif ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {\n\n\t\t\t\t\tdata.hierarchy[ h ].keys.splice( k, 1 );\n\t\t\t\t\tk --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t// set index\n\n\t\t\tfor ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\n\n\t\t\t\tdata.hierarchy[ h ].keys[ k ].index = k;\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// JIT\n\n\t\tvar lengthInFrames = parseInt( data.length * data.fps, 10 );\n\n\t\tdata.JIT = {};\n\t\tdata.JIT.hierarchy = [];\n\n\t\tfor( var h = 0; h < data.hierarchy.length; h ++ )\n\t\t\tdata.JIT.hierarchy.push( new Array( lengthInFrames ) );\n\n\n\t\t// done\n\n\t\tdata.initialized = true;\n\n\t};\n\n\n\t// interpolation types\n\n\tthat.LINEAR = 0;\n\tthat.CATMULLROM = 1;\n\tthat.CATMULLROM_FORWARD = 2;\n\n\treturn that;\n\n}());\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.Animation = function ( root, name, interpolationType ) {\n\n\tthis.root = root;\n\tthis.data = THREE.AnimationHandler.get( name );\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\n\n\tthis.currentTime = 0;\n\tthis.timeScale = 1;\n\n\tthis.isPlaying = false;\n\tthis.isPaused = true;\n\tthis.loop = true;\n\n\tthis.interpolationType = interpolationType !== undefined ? interpolationType : THREE.AnimationHandler.LINEAR;\n\n\tthis.points = [];\n\tthis.target = new THREE.Vector3();\n\n};\n\nTHREE.Animation.prototype.play = function ( loop, startTimeMS ) {\n\n\tif ( this.isPlaying === false ) {\n\n\t\tthis.isPlaying = true;\n\t\tthis.loop = loop !== undefined ? loop : true;\n\t\tthis.currentTime = startTimeMS !== undefined ? startTimeMS : 0;\n\n\t\t// reset key cache\n\n\t\tvar h, hl = this.hierarchy.length,\n\t\t\tobject;\n\n\t\tfor ( h = 0; h < hl; h ++ ) {\n\n\t\t\tobject = this.hierarchy[ h ];\n\n\t\t\tobject.matrixAutoUpdate = true;\n\n\t\t\tif ( object.animationCache === undefined ) {\n\n\t\t\t\tobject.animationCache = {};\n\t\t\t\tobject.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 };\n\t\t\t\tobject.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 };\n\t\t\t\tobject.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\n\n\t\t\t}\n\n\t\t\tvar prevKey = object.animationCache.prevKey;\n\t\t\tvar nextKey = object.animationCache.nextKey;\n\n\t\t\tprevKey.pos = this.data.hierarchy[ h ].keys[ 0 ];\n\t\t\tprevKey.rot = this.data.hierarchy[ h ].keys[ 0 ];\n\t\t\tprevKey.scl = this.data.hierarchy[ h ].keys[ 0 ];\n\n\t\t\tnextKey.pos = this.getNextKeyWith( \"pos\", h, 1 );\n\t\t\tnextKey.rot = this.getNextKeyWith( \"rot\", h, 1 );\n\t\t\tnextKey.scl = this.getNextKeyWith( \"scl\", h, 1 );\n\n\t\t}\n\n\t\tthis.update( 0 );\n\n\t}\n\n\tthis.isPaused = false;\n\n\tTHREE.AnimationHandler.addToUpdate( this );\n\n};\n\n\nTHREE.Animation.prototype.pause = function() {\n\n\tif ( this.isPaused === true ) {\n\n\t\tTHREE.AnimationHandler.addToUpdate( this );\n\n\t} else {\n\n\t\tTHREE.AnimationHandler.removeFromUpdate( this );\n\n\t}\n\n\tthis.isPaused = !this.isPaused;\n\n};\n\n\nTHREE.Animation.prototype.stop = function() {\n\n\tthis.isPlaying = false;\n\tthis.isPaused  = false;\n\tTHREE.AnimationHandler.removeFromUpdate( this );\n\n};\n\n\nTHREE.Animation.prototype.update = function ( deltaTimeMS ) {\n\n\t// early out\n\n\tif ( this.isPlaying === false ) return;\n\n\n\t// vars\n\n\tvar types = [ \"pos\", \"rot\", \"scl\" ];\n\tvar type;\n\tvar scale;\n\tvar vector;\n\tvar prevXYZ, nextXYZ;\n\tvar prevKey, nextKey;\n\tvar object;\n\tvar animationCache;\n\tvar frame;\n\tvar JIThierarchy = this.data.JIT.hierarchy;\n\tvar currentTime, unloopedCurrentTime;\n\tvar currentPoint, forwardPoint, angle;\n\n\n\tthis.currentTime += deltaTimeMS * this.timeScale;\n\n\tunloopedCurrentTime = this.currentTime;\n\n\t// Mod operation fails on floats\n\t// was this supposed to be in frames?\n\twhile ( this.currentTime > this.data.length ) {\n\n\t\tthis.currentTime -= this.data.length;\n\n\t}\n\n\tcurrentTime = this.currentTime = this.currentTime % this.data.length;\n\n\t\n\tframe = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );\n\n\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\n\n\t\tobject = this.hierarchy[ h ];\n\t\tanimationCache = object.animationCache;\n\n\t\t// loop through pos/rot/scl\n\n\t\tfor ( var t = 0; t < 3; t ++ ) {\n\n\t\t\t// get keys\n\n\t\t\ttype    = types[ t ];\n\t\t\tprevKey = animationCache.prevKey[ type ];\n\t\t\tnextKey = animationCache.nextKey[ type ];\n\n\t\t\t// switch keys?\n\t\t\t\n\t\t\tif ( nextKey.time <= unloopedCurrentTime ) {\n\n\t\t\t\t// did we loop?\n\n\t\t\t\tif ( currentTime <= unloopedCurrentTime ) {\n\n\t\t\t\t\tif ( this.loop ) {\n\n\t\t\t\t\t\tprevKey = this.data.hierarchy[ h ].keys[ 0 ];\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, 1 );\n\n\t\t\t\t\t\t// if ( nextKey.index < prevKey.index ) then we have wrapped over the end, and nextKey.time < currentTime will loop forever\n\t\t\t\t\t\twhile ( nextKey !== null && nextKey.time < currentTime && nextKey.index > prevKey.index) {\n\n\t\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\tnextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\n\n\t\t\t\t\t} while ( nextKey !== null && nextKey.time < currentTime && nextKey.index > prevKey.index )\n\t\t\t\t\t// if ( nextKey.index < prevKey.index ) then we have wrapped over the end, and nextKey.time < currentTime will loop forever\n\n\t\t\t\t}\n\n\t\t\t\tanimationCache.prevKey[ type ] = prevKey;\n\t\t\t\tanimationCache.nextKey[ type ] = nextKey;\n\n\t\t\t}\n\n\n\t\t\tobject.matrixAutoUpdate = true;\n\t\t\tobject.matrixWorldNeedsUpdate = true;\n\n\t\t\tscale = ( currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );\n\t\t\tprevXYZ = prevKey[ type ];\n\t\t\tnextXYZ = nextKey[ type ];\n\n\n\t\t\t// check scale error\n\n\t\t\tif ( scale < 0 || scale > 1 ) {\n\n\t\t\t\tconsole.log( \"THREE.Animation.update: Warning! Scale out of bounds:\" + scale + \" on bone \" + h );\n\t\t\t\tscale = scale < 0 ? 0 : 1;\n\n\t\t\t}\n\n\t\t\t// interpolate\n\n\t\t\tif ( type === \"pos\" ) {\n\n\t\t\t\tvector = object.position;\n\n\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {\n\n\t\t\t\t\tvector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\n\t\t\t\t\tvector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\n\t\t\t\t\tvector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\n\n\t\t\t\t} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\t\t\t\t\t\t    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\t\t\t\tthis.points[ 0 ] = this.getPrevKeyWith( \"pos\", h, prevKey.index - 1 )[ \"pos\" ];\n\t\t\t\t\tthis.points[ 1 ] = prevXYZ;\n\t\t\t\t\tthis.points[ 2 ] = nextXYZ;\n\t\t\t\t\tthis.points[ 3 ] = this.getNextKeyWith( \"pos\", h, nextKey.index + 1 )[ \"pos\" ];\n\n\t\t\t\t\tscale = scale * 0.33 + 0.33;\n\n\t\t\t\t\tcurrentPoint = this.interpolateCatmullRom( this.points, scale );\n\n\t\t\t\t\tvector.x = currentPoint[ 0 ];\n\t\t\t\t\tvector.y = currentPoint[ 1 ];\n\t\t\t\t\tvector.z = currentPoint[ 2 ];\n\n\t\t\t\t\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\t\t\t\t\tforwardPoint = this.interpolateCatmullRom( this.points, scale * 1.01 );\n\n\t\t\t\t\t\tthis.target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );\n\t\t\t\t\t\tthis.target.sub( vector );\n\t\t\t\t\t\tthis.target.y = 0;\n\t\t\t\t\t\tthis.target.normalize();\n\n\t\t\t\t\t\tangle = Math.atan2( this.target.x, this.target.z );\n\t\t\t\t\t\tobject.rotation.set( 0, angle, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( type === \"rot\" ) {\n\n\t\t\t\tTHREE.Quaternion.slerp( prevXYZ, nextXYZ, object.quaternion, scale );\n\n\t\t\t} else if ( type === \"scl\" ) {\n\n\t\t\t\tvector = object.scale;\n\n\t\t\t\tvector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\n\t\t\t\tvector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\n\t\t\t\tvector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n// Catmull-Rom spline\n\nTHREE.Animation.prototype.interpolateCatmullRom = function ( points, scale ) {\n\n\tvar c = [], v3 = [],\n\tpoint, intPoint, weight, w2, w3,\n\tpa, pb, pc, pd;\n\n\tpoint = ( points.length - 1 ) * scale;\n\tintPoint = Math.floor( point );\n\tweight = point - intPoint;\n\n\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\n\tc[ 1 ] = intPoint;\n\tc[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\n\tc[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\n\n\tpa = points[ c[ 0 ] ];\n\tpb = points[ c[ 1 ] ];\n\tpc = points[ c[ 2 ] ];\n\tpd = points[ c[ 3 ] ];\n\n\tw2 = weight * weight;\n\tw3 = weight * w2;\n\n\tv3[ 0 ] = this.interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );\n\tv3[ 1 ] = this.interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );\n\tv3[ 2 ] = this.interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );\n\n\treturn v3;\n\n};\n\nTHREE.Animation.prototype.interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {\n\n\tvar v0 = ( p2 - p0 ) * 0.5,\n\t\tv1 = ( p3 - p1 ) * 0.5;\n\n\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n};\n\n\n\n// Get next key with\n\nTHREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {\n\n\tvar keys = this.data.hierarchy[ h ].keys;\n\n\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\tkey = key < keys.length - 1 ? key : keys.length - 1;\n\n\t} else {\n\n\t\tkey = key % keys.length;\n\n\t}\n\n\tfor ( ; key < keys.length; key++ ) {\n\n\t\tif ( keys[ key ][ type ] !== undefined ) {\n\n\t\t\treturn keys[ key ];\n\n\t\t}\n\n\t}\n\n\treturn this.data.hierarchy[ h ].keys[ 0 ];\n\n};\n\n// Get previous key with\n\nTHREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {\n\n\tvar keys = this.data.hierarchy[ h ].keys;\n\n\tif ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\n\t\t this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\n\n\t\tkey = key > 0 ? key : 0;\n\n\t} else {\n\n\t\tkey = key >= 0 ? key : key + keys.length;\n\n\t}\n\n\n\tfor ( ; key >= 0; key -- ) {\n\n\t\tif ( keys[ key ][ type ] !== undefined ) {\n\n\t\t\treturn keys[ key ];\n\n\t\t}\n\n\t}\n\n\treturn this.data.hierarchy[ h ].keys[ keys.length - 1 ];\n\n};\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author khang duong\n * @author erik kitson\n */\n\nTHREE.KeyFrameAnimation = function( root, data, JITCompile ) {\n\n\tthis.root = root;\n\tthis.data = THREE.AnimationHandler.get( data );\n\tthis.hierarchy = THREE.AnimationHandler.parse( root );\n\tthis.currentTime = 0;\n\tthis.timeScale = 0.001;\n\tthis.isPlaying = false;\n\tthis.isPaused = true;\n\tthis.loop = true;\n\tthis.JITCompile = JITCompile !== undefined ? JITCompile : true;\n\n\t// initialize to first keyframes\n\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\n\n\t\tvar keys = this.data.hierarchy[h].keys,\n\t\t\tsids = this.data.hierarchy[h].sids,\n\t\t\tobj = this.hierarchy[h];\n\n\t\tif ( keys.length && sids ) {\n\n\t\t\tfor ( var s = 0; s < sids.length; s++ ) {\n\n\t\t\t\tvar sid = sids[ s ],\n\t\t\t\t\tnext = this.getNextKeyWith( sid, h, 0 );\n\n\t\t\t\tif ( next ) {\n\n\t\t\t\t\tnext.apply( sid );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tobj.matrixAutoUpdate = false;\n\t\t\tthis.data.hierarchy[h].node.updateMatrix();\n\t\t\tobj.matrixWorldNeedsUpdate = true;\n\n\t\t}\n\n\t}\n\n};\n\n// Play\n\nTHREE.KeyFrameAnimation.prototype.play = function( loop, startTimeMS ) {\n\n\tif( !this.isPlaying ) {\n\n\t\tthis.isPlaying = true;\n\t\tthis.loop = loop !== undefined ? loop : true;\n\t\tthis.currentTime = startTimeMS !== undefined ? startTimeMS : 0;\n\t\tthis.startTimeMs = startTimeMS;\n\t\tthis.startTime = 10000000;\n\t\tthis.endTime = -this.startTime;\n\n\n\t\t// reset key cache\n\n\t\tvar h, hl = this.hierarchy.length,\n\t\t\tobject,\n\t\t\tnode;\n\n\t\tfor ( h = 0; h < hl; h++ ) {\n\n\t\t\tobject = this.hierarchy[ h ];\n\t\t\tnode = this.data.hierarchy[ h ];\n\n\t\t\tif ( node.animationCache === undefined ) {\n\n\t\t\t\tnode.animationCache = {};\n\t\t\t\tnode.animationCache.prevKey = null;\n\t\t\t\tnode.animationCache.nextKey = null;\n\t\t\t\tnode.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;\n\n\t\t\t}\n\n\t\t\tvar keys = this.data.hierarchy[h].keys;\n\n\t\t\tif (keys.length) {\n\n\t\t\t\tnode.animationCache.prevKey = keys[ 0 ];\n\t\t\t\tnode.animationCache.nextKey = keys[ 1 ];\n\n\t\t\t\tthis.startTime = Math.min( keys[0].time, this.startTime );\n\t\t\t\tthis.endTime = Math.max( keys[keys.length - 1].time, this.endTime );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.update( 0 );\n\n\t}\n\n\tthis.isPaused = false;\n\n\tTHREE.AnimationHandler.addToUpdate( this );\n\n};\n\n\n\n// Pause\n\nTHREE.KeyFrameAnimation.prototype.pause = function() {\n\n\tif( this.isPaused ) {\n\n\t\tTHREE.AnimationHandler.addToUpdate( this );\n\n\t} else {\n\n\t\tTHREE.AnimationHandler.removeFromUpdate( this );\n\n\t}\n\n\tthis.isPaused = !this.isPaused;\n\n};\n\n\n// Stop\n\nTHREE.KeyFrameAnimation.prototype.stop = function() {\n\n\tthis.isPlaying = false;\n\tthis.isPaused  = false;\n\tTHREE.AnimationHandler.removeFromUpdate( this );\n\n\n\t// reset JIT matrix and remove cache\n\n\tfor ( var h = 0; h < this.data.hierarchy.length; h++ ) {\n        \n        var obj = this.hierarchy[ h ];\n\t\tvar node = this.data.hierarchy[ h ];\n\n\t\tif ( node.animationCache !== undefined ) {\n\n\t\t\tvar original = node.animationCache.originalMatrix;\n\n\t\t\tif( obj instanceof THREE.Bone ) {\n\n\t\t\t\toriginal.copy( obj.skinMatrix );\n\t\t\t\tobj.skinMatrix = original;\n\n\t\t\t} else {\n\n\t\t\t\toriginal.copy( obj.matrix );\n\t\t\t\tobj.matrix = original;\n\n\t\t\t}\n\n\t\t\tdelete node.animationCache;\n\n\t\t}\n\n\t}\n\n};\n\n\n// Update\n\nTHREE.KeyFrameAnimation.prototype.update = function( deltaTimeMS ) {\n\n\t// early out\n\n\tif( !this.isPlaying ) return;\n\n\n\t// vars\n\n\tvar prevKey, nextKey;\n\tvar object;\n\tvar node;\n\tvar frame;\n\tvar JIThierarchy = this.data.JIT.hierarchy;\n\tvar currentTime, unloopedCurrentTime;\n\tvar looped;\n\n\n\t// update\n\n\tthis.currentTime += deltaTimeMS * this.timeScale;\n\n\tunloopedCurrentTime = this.currentTime;\n\tcurrentTime         = this.currentTime = this.currentTime % this.data.length;\n\n\t// if looped around, the current time should be based on the startTime\n\tif ( currentTime < this.startTimeMs ) {\n\n\t\tcurrentTime = this.currentTime = this.startTimeMs + currentTime;\n\n\t}\n\n\tframe               = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );\n\tlooped \t\t\t\t= currentTime < unloopedCurrentTime;\n\n\tif ( looped && !this.loop ) {\n\n\t\t// Set the animation to the last keyframes and stop\n\t\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\n\n\t\t\tvar keys = this.data.hierarchy[h].keys,\n\t\t\t\tsids = this.data.hierarchy[h].sids,\n\t\t\t\tend = keys.length-1,\n\t\t\t\tobj = this.hierarchy[h];\n\n\t\t\tif ( keys.length ) {\n\n\t\t\t\tfor ( var s = 0; s < sids.length; s++ ) {\n\n\t\t\t\t\tvar sid = sids[ s ],\n\t\t\t\t\t\tprev = this.getPrevKeyWith( sid, h, end );\n\n\t\t\t\t\tif ( prev ) {\n\t\t\t\t\t\tprev.apply( sid );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tthis.data.hierarchy[h].node.updateMatrix();\n\t\t\t\tobj.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.stop();\n\t\treturn;\n\n\t}\n\n\t// check pre-infinity\n\tif ( currentTime < this.startTime ) {\n\n\t\treturn;\n\n\t}\n\n\t// update\n\n\tfor ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {\n\n\t\tobject = this.hierarchy[ h ];\n\t\tnode = this.data.hierarchy[ h ];\n\n\t\tvar keys = node.keys,\n\t\t\tanimationCache = node.animationCache;\n\n\t\t// use JIT?\n\n\t\tif ( this.JITCompile && JIThierarchy[ h ][ frame ] !== undefined ) {\n\n\t\t\tif( object instanceof THREE.Bone ) {\n\n\t\t\t\tobject.skinMatrix = JIThierarchy[ h ][ frame ];\n\t\t\t\tobject.matrixWorldNeedsUpdate = false;\n\n\t\t\t} else {\n\n\t\t\t\tobject.matrix = JIThierarchy[ h ][ frame ];\n\t\t\t\tobject.matrixWorldNeedsUpdate = true;\n\n\t\t\t}\n\n\t\t// use interpolation\n\n\t\t} else if ( keys.length ) {\n\n\t\t\t// make sure so original matrix and not JIT matrix is set\n\n\t\t\tif ( this.JITCompile && animationCache ) {\n\n\t\t\t\tif( object instanceof THREE.Bone ) {\n\n\t\t\t\t\tobject.skinMatrix = animationCache.originalMatrix;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject.matrix = animationCache.originalMatrix;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tprevKey = animationCache.prevKey;\n\t\t\tnextKey = animationCache.nextKey;\n\n\t\t\tif ( prevKey && nextKey ) {\n\n\t\t\t\t// switch keys?\n\n\t\t\t\tif ( nextKey.time <= unloopedCurrentTime ) {\n\n\t\t\t\t\t// did we loop?\n\n\t\t\t\t\tif ( looped && this.loop ) {\n\n\t\t\t\t\t\tprevKey = keys[ 0 ];\n\t\t\t\t\t\tnextKey = keys[ 1 ];\n\n\t\t\t\t\t\twhile ( nextKey.time < currentTime ) {\n\n\t\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( !looped ) {\n\n\t\t\t\t\t\tvar lastIndex = keys.length - 1;\n\n\t\t\t\t\t\twhile ( nextKey.time < currentTime && nextKey.index !== lastIndex ) {\n\n\t\t\t\t\t\t\tprevKey = nextKey;\n\t\t\t\t\t\t\tnextKey = keys[ prevKey.index + 1 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimationCache.prevKey = prevKey;\n\t\t\t\t\tanimationCache.nextKey = nextKey;\n\n\t\t\t\t}\n                if(nextKey.time >= currentTime)\n                    prevKey.interpolate( nextKey, currentTime );\n                else\n                    prevKey.interpolate( nextKey, nextKey.time);\n\n\t\t\t}\n\n\t\t\tthis.data.hierarchy[h].node.updateMatrix();\n\t\t\tobject.matrixWorldNeedsUpdate = true;\n\n\t\t}\n\n\t}\n\n\t// update JIT?\n\n\tif ( this.JITCompile ) {\n\n\t\tif ( JIThierarchy[ 0 ][ frame ] === undefined ) {\n\n\t\t\tthis.hierarchy[ 0 ].updateMatrixWorld( true );\n\n\t\t\tfor ( var h = 0; h < this.hierarchy.length; h++ ) {\n\n\t\t\t\tif( this.hierarchy[ h ] instanceof THREE.Bone ) {\n\n\t\t\t\t\tJIThierarchy[ h ][ frame ] = this.hierarchy[ h ].skinMatrix.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tJIThierarchy[ h ][ frame ] = this.hierarchy[ h ].matrix.clone();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n};\n\n// Get next key with\n\nTHREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {\n\n\tvar keys = this.data.hierarchy[ h ].keys;\n\tkey = key % keys.length;\n\n\tfor ( ; key < keys.length; key++ ) {\n\n\t\tif ( keys[ key ].hasTarget( sid ) ) {\n\n\t\t\treturn keys[ key ];\n\n\t\t}\n\n\t}\n\n\treturn keys[ 0 ];\n\n};\n\n// Get previous key with\n\nTHREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {\n\n\tvar keys = this.data.hierarchy[ h ].keys;\n\tkey = key >= 0 ? key : key + keys.length;\n\n\tfor ( ; key >= 0; key-- ) {\n\n\t\tif ( keys[ key ].hasTarget( sid ) ) {\n\n\t\t\treturn keys[ key ];\n\n\t\t}\n\n\t}\n\n\treturn keys[ keys.length - 1 ];\n\n};\n\n/**\n * Camera for rendering cube maps\n *\t- renders scene into axis-aligned cube\n *\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\n\n\tTHREE.Object3D.call( this );\n\n\tvar fov = 90, aspect = 1;\n\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPX.up.set( 0, -1, 0 );\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\n\tthis.add( cameraPX );\n\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNX.up.set( 0, -1, 0 );\n\tcameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );\n\tthis.add( cameraNX );\n\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPY.up.set( 0, 0, 1 );\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\n\tthis.add( cameraPY );\n\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNY.up.set( 0, 0, -1 );\n\tcameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );\n\tthis.add( cameraNY );\n\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraPZ.up.set( 0, -1, 0 );\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\n\tthis.add( cameraPZ );\n\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\n\tcameraNZ.up.set( 0, -1, 0 );\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );\n\tthis.add( cameraNZ );\n\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );\n\n\tthis.updateCubeMap = function ( renderer, scene ) {\n\n\t\tvar renderTarget = this.renderTarget;\n\t\tvar generateMipmaps = renderTarget.generateMipmaps;\n\n\t\trenderTarget.generateMipmaps = false;\n\n\t\trenderTarget.activeCubeFace = 0;\n\t\trenderer.render( scene, cameraPX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 1;\n\t\trenderer.render( scene, cameraNX, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 2;\n\t\trenderer.render( scene, cameraPY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 3;\n\t\trenderer.render( scene, cameraNY, renderTarget );\n\n\t\trenderTarget.activeCubeFace = 4;\n\t\trenderer.render( scene, cameraPZ, renderTarget );\n\n\t\trenderTarget.generateMipmaps = generateMipmaps;\n\n\t\trenderTarget.activeCubeFace = 5;\n\t\trenderer.render( scene, cameraNZ, renderTarget );\n\n\t};\n\n};\n\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\n\n/**\n *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n *\n *\tA general perpose camera, for setting FOV, Lens Focal Length,\n *\t\tand switching between perspective and orthographic views easily.\n *\t\tUse this only if you do not wish to manage\n *\t\tboth a Orthographic and Perspective Camera\n *\n */\n\n\nTHREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.fov = fov;\n\n\tthis.left = -width / 2;\n\tthis.right = width / 2\n\tthis.top = height / 2;\n\tthis.bottom = -height / 2;\n\n\t// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects\n\n\tthis.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, \torthoNear, orthoFar );\n\tthis.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );\n\n\tthis.zoom = 1;\n\n\tthis.toPerspective();\n\n\tvar aspect = width/height;\n\n};\n\nTHREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );\n\nTHREE.CombinedCamera.prototype.toPerspective = function () {\n\n\t// Switches to the Perspective Camera\n\n\tthis.near = this.cameraP.near;\n\tthis.far = this.cameraP.far;\n\n\tthis.cameraP.fov =  this.fov / this.zoom ;\n\n\tthis.cameraP.updateProjectionMatrix();\n\n\tthis.projectionMatrix = this.cameraP.projectionMatrix;\n\n\tthis.inPerspectiveMode = true;\n\tthis.inOrthographicMode = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toOrthographic = function () {\n\n\t// Switches to the Orthographic camera estimating viewport from Perspective\n\n\tvar fov = this.fov;\n\tvar aspect = this.cameraP.aspect;\n\tvar near = this.cameraP.near;\n\tvar far = this.cameraP.far;\n\n\t// The size that we set is the mid plane of the viewing frustum\n\n\tvar hyperfocus = ( near + far ) / 2;\n\n\tvar halfHeight = Math.tan( fov / 2 ) * hyperfocus;\n\tvar planeHeight = 2 * halfHeight;\n\tvar planeWidth = planeHeight * aspect;\n\tvar halfWidth = planeWidth / 2;\n\n\thalfHeight /= this.zoom;\n\thalfWidth /= this.zoom;\n\n\tthis.cameraO.left = -halfWidth;\n\tthis.cameraO.right = halfWidth;\n\tthis.cameraO.top = halfHeight;\n\tthis.cameraO.bottom = -halfHeight;\n\n\t// this.cameraO.left = -farHalfWidth;\n\t// this.cameraO.right = farHalfWidth;\n\t// this.cameraO.top = farHalfHeight;\n\t// this.cameraO.bottom = -farHalfHeight;\n\n\t// this.cameraO.left = this.left / this.zoom;\n\t// this.cameraO.right = this.right / this.zoom;\n\t// this.cameraO.top = this.top / this.zoom;\n\t// this.cameraO.bottom = this.bottom / this.zoom;\n\n\tthis.cameraO.updateProjectionMatrix();\n\n\tthis.near = this.cameraO.near;\n\tthis.far = this.cameraO.far;\n\tthis.projectionMatrix = this.cameraO.projectionMatrix;\n\n\tthis.inPerspectiveMode = false;\n\tthis.inOrthographicMode = true;\n\n};\n\n\nTHREE.CombinedCamera.prototype.setSize = function( width, height ) {\n\n\tthis.cameraP.aspect = width / height;\n\tthis.left = -width / 2;\n\tthis.right = width / 2\n\tthis.top = height / 2;\n\tthis.bottom = -height / 2;\n\n};\n\n\nTHREE.CombinedCamera.prototype.setFov = function( fov ) {\n\n\tthis.fov = fov;\n\n\tif ( this.inPerspectiveMode ) {\n\n\t\tthis.toPerspective();\n\n\t} else {\n\n\t\tthis.toOrthographic();\n\n\t}\n\n};\n\n// For mantaining similar API with PerspectiveCamera\n\nTHREE.CombinedCamera.prototype.updateProjectionMatrix = function() {\n\n\tif ( this.inPerspectiveMode ) {\n\n\t\tthis.toPerspective();\n\n\t} else {\n\n\t\tthis.toPerspective();\n\t\tthis.toOrthographic();\n\n\t}\n\n};\n\n/*\n* Uses Focal Length (in mm) to estimate and set FOV\n* 35mm (fullframe) camera is used if frame size is not specified;\n* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\n*/\nTHREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {\n\n\tif ( frameHeight === undefined ) frameHeight = 24;\n\n\tvar fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\n\n\tthis.setFov( fov );\n\n\treturn fov;\n};\n\n\nTHREE.CombinedCamera.prototype.setZoom = function( zoom ) {\n\n\tthis.zoom = zoom;\n\n\tif ( this.inPerspectiveMode ) {\n\n\t\tthis.toPerspective();\n\n\t} else {\n\n\t\tthis.toOrthographic();\n\n\t}\n\n};\n\nTHREE.CombinedCamera.prototype.toFrontView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = 0;\n\tthis.rotation.z = 0;\n\n\t// should we be modifing the matrix instead?\n\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toBackView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = Math.PI;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toLeftView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = - Math.PI / 2;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toRightView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = Math.PI / 2;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toTopView = function() {\n\n\tthis.rotation.x = - Math.PI / 2;\n\tthis.rotation.y = 0;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toBottomView = function() {\n\n\tthis.rotation.x = Math.PI / 2;\n\tthis.rotation.y = 0;\n\tthis.rotation.z = 0;\n\tthis.rotationAutoUpdate = false;\n\n};\n\n/**\n * @author hughes\n */\n\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.radius = radius = radius || 50;\n\tthis.segments = segments = segments !== undefined ? Math.max( 3, segments ) : 8;\n\n\tthis.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthis.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tvar i, uvs = [],\n\tcenter = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );\n\n\tthis.vertices.push(center);\n\tuvs.push( centerUV );\n\n\tfor ( i = 0; i <= segments; i ++ ) {\n\n\t\tvar vertex = new THREE.Vector3();\n\t\tvar segment = thetaStart + i / segments * thetaLength;\n\n\t\tvertex.x = radius * Math.cos( segment );\n\t\tvertex.y = radius * Math.sin( segment );\n\n\t\tthis.vertices.push( vertex );\n\t\tuvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );\n\n\t}\n\n\tvar n = new THREE.Vector3( 0, 0, 1 );\n\n\tfor ( i = 1; i <= segments; i ++ ) {\n\n\t\tvar v1 = i;\n\t\tvar v2 = i + 1 ;\n\t\tvar v3 = 0;\n\n\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\n\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\n */\n\nTHREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar scope = this;\n\n\tthis.width = width;\n\tthis.height = height;\n\tthis.depth = depth;\n\n\tthis.widthSegments = widthSegments || 1;\n\tthis.heightSegments = heightSegments || 1;\n\tthis.depthSegments = depthSegments || 1;\n\n\tvar width_half = this.width / 2;\n\tvar height_half = this.height / 2;\n\tvar depth_half = this.depth / 2;\n\n\tbuildPlane( 'z', 'y', - 1, - 1, this.depth, this.height, width_half, 0 ); // px\n\tbuildPlane( 'z', 'y',   1, - 1, this.depth, this.height, - width_half, 1 ); // nx\n\tbuildPlane( 'x', 'z',   1,   1, this.width, this.depth, height_half, 2 ); // py\n\tbuildPlane( 'x', 'z',   1, - 1, this.width, this.depth, - height_half, 3 ); // ny\n\tbuildPlane( 'x', 'y',   1, - 1, this.width, this.height, depth_half, 4 ); // pz\n\tbuildPlane( 'x', 'y', - 1, - 1, this.width, this.height, - depth_half, 5 ); // nz\n\n\tfunction buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {\n\n\t\tvar w, ix, iy,\n\t\tgridX = scope.widthSegments,\n\t\tgridY = scope.heightSegments,\n\t\twidth_half = width / 2,\n\t\theight_half = height / 2,\n\t\toffset = scope.vertices.length;\n\n\t\tif ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {\n\n\t\t\tw = 'z';\n\n\t\t} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {\n\n\t\t\tw = 'y';\n\t\t\tgridY = scope.depthSegments;\n\n\t\t} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {\n\n\t\t\tw = 'x';\n\t\t\tgridX = scope.depthSegments;\n\n\t\t}\n\n\t\tvar gridX1 = gridX + 1,\n\t\tgridY1 = gridY + 1,\n\t\tsegment_width = width / gridX,\n\t\tsegment_height = height / gridY,\n\t\tnormal = new THREE.Vector3();\n\n\t\tnormal[ w ] = depth > 0 ? 1 : - 1;\n\n\t\tfor ( iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\tvar vector = new THREE.Vector3();\n\t\t\t\tvector[ u ] = ( ix * segment_width - width_half ) * udir;\n\t\t\t\tvector[ v ] = ( iy * segment_height - height_half ) * vdir;\n\t\t\t\tvector[ w ] = depth;\n\n\t\t\t\tscope.vertices.push( vector );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( iy = 0; iy < gridY; iy++ ) {\n\n\t\t\tfor ( ix = 0; ix < gridX; ix++ ) {\n\n\t\t\t\tvar a = ix + gridX1 * iy;\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\tvar uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );\n\t\t\t\tvar uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );\n\t\t\t\tvar uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );\n\t\t\t\tvar uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );\n\n\t\t\t\tvar face = new THREE.Face3( a + offset, b + offset, d + offset );\n\t\t\t\tface.normal.copy( normal );\n\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\n\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\tscope.faces.push( face );\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\n\t\t\t\tface = new THREE.Face3( b + offset, c + offset, d + offset );\n\t\t\t\tface.normal.copy( normal );\n\t\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\n\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\tscope.faces.push( face );\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.mergeVertices();\n\n};\n\nTHREE.CubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.radiusTop = radiusTop = radiusTop !== undefined ? radiusTop : 20;\n\tthis.radiusBottom = radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\n\tthis.height = height = height !== undefined ? height : 100;\n\n\tthis.radialSegments = radialSegments = radialSegments || 8;\n\tthis.heightSegments = heightSegments = heightSegments || 1;\n\n\tthis.openEnded = openEnded = openEnded !== undefined ? openEnded : false;\n\n\tvar heightHalf = height / 2;\n\n\tvar x, y, vertices = [], uvs = [];\n\n\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\tvar verticesRow = [];\n\t\tvar uvsRow = [];\n\n\t\tvar v = y / heightSegments;\n\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\n\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\n\n\t\t\tvar u = x / radialSegments;\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvertex.x = radius * Math.sin( u * Math.PI * 2 );\n\t\t\tvertex.y = - v * height + heightHalf;\n\t\t\tvertex.z = radius * Math.cos( u * Math.PI * 2 );\n\n\t\t\tthis.vertices.push( vertex );\n\n\t\t\tverticesRow.push( this.vertices.length - 1 );\n\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\n\n\t\t}\n\n\t\tvertices.push( verticesRow );\n\t\tuvs.push( uvsRow );\n\n\t}\n\n\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\n\tvar na, nb;\n\n\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\tif ( radiusTop !== 0 ) {\n\n\t\t\tna = this.vertices[ vertices[ 0 ][ x ] ].clone();\n\t\t\tnb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();\n\n\t\t} else {\n\n\t\t\tna = this.vertices[ vertices[ 1 ][ x ] ].clone();\n\t\t\tnb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();\n\n\t\t}\n\n\t\tna.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();\n\t\tnb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();\n\n\t\tfor ( y = 0; y < heightSegments; y ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x ];\n\t\t\tvar v2 = vertices[ y + 1 ][ x ];\n\t\t\tvar v3 = vertices[ y + 1 ][ x + 1 ];\n\t\t\tvar v4 = vertices[ y ][ x + 1 ];\n\n\t\t\tvar n1 = na.clone();\n\t\t\tvar n2 = na.clone();\n\t\t\tvar n3 = nb.clone();\n\t\t\tvar n4 = nb.clone();\n\n\t\t\tvar uv1 = uvs[ y ][ x ].clone();\n\t\t\tvar uv2 = uvs[ y + 1 ][ x ].clone();\n\t\t\tvar uv3 = uvs[ y + 1 ][ x + 1 ].clone();\n\t\t\tvar uv4 = uvs[ y ][ x + 1 ].clone();\n\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\n\n\t\t\tthis.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\n\n\t\t}\n\n\t}\n\n\t// top cap\n\n\tif ( openEnded === false && radiusTop > 0 ) {\n\n\t\tthis.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tvar v1 = vertices[ 0 ][ x ];\n\t\t\tvar v2 = vertices[ 0 ][ x + 1 ];\n\t\t\tvar v3 = this.vertices.length - 1;\n\n\t\t\tvar n1 = new THREE.Vector3( 0, 1, 0 );\n\t\t\tvar n2 = new THREE.Vector3( 0, 1, 0 );\n\t\t\tvar n3 = new THREE.Vector3( 0, 1, 0 );\n\n\t\t\tvar uv1 = uvs[ 0 ][ x ].clone();\n\t\t\tvar uv2 = uvs[ 0 ][ x + 1 ].clone();\n\t\t\tvar uv3 = new THREE.Vector2( uv2.x, 0 );\n\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\n\n\t\t}\n\n\t}\n\n\t// bottom cap\n\n\tif ( openEnded === false && radiusBottom > 0 ) {\n\n\t\tthis.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );\n\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\tvar v3 = this.vertices.length - 1;\n\n\t\t\tvar n1 = new THREE.Vector3( 0, - 1, 0 );\n\t\t\tvar n2 = new THREE.Vector3( 0, - 1, 0 );\n\t\t\tvar n3 = new THREE.Vector3( 0, - 1, 0 );\n\n\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\n\t\t\tvar uv2 = uvs[ y ][ x ].clone();\n\t\t\tvar uv3 = new THREE.Vector2( uv2.x, 1 );\n\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n}\n\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Creates extruded geometry from a path shape.\n *\n * parameters = {\n *\n *  curveSegments: <int>, // number of points on the curves\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too\n *  amount: <int>, // Depth to extrude the shape\n *\n *  bevelEnabled: <bool>, // turn on bevel\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\n *  bevelSize: <float>, // how far from shape outline is bevel\n *  bevelSegments: <int>, // number of bevel layers\n *\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\n *\n *  material: <int> // material index for front and back faces\n *  extrudeMaterial: <int> // material index for extrusion and beveled faces\n *  uvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\n\n\tif ( typeof( shapes ) === \"undefined\" ) {\n\t\tshapes = [];\n\t\treturn;\n\t}\n\n\tTHREE.Geometry.call( this );\n\n\tshapes = shapes instanceof Array ? shapes : [ shapes ];\n\n\tthis.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n\t// can't really use automatic vertex normals\n\t// as then front and back sides get smoothed too\n\t// should do separate smoothing just for sides\n\n\t//this.computeVertexNormals();\n\n\t//console.log( \"took\", ( Date.now() - startTime ) );\n\n};\n\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\tvar sl = shapes.length;\n\n\tfor ( var s = 0; s < sl; s ++ ) {\n\t\tvar shape = shapes[ s ];\n\t\tthis.addShape( shape, options );\n\t}\n};\n\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tvar amount = options.amount !== undefined ? options.amount : 100;\n\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\n\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\n\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar steps = options.steps !== undefined ? options.steps : 1;\n\n\tvar extrudePath = options.extrudePath;\n\tvar extrudePts, extrudeByPath = false;\n\n\tvar material = options.material;\n\tvar extrudeMaterial = options.extrudeMaterial;\n\n\t// Use default WorldUVGenerator if no UV generators are specified.\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\n\n\tvar shapebb = this.shapebb;\n\t//shapebb = shape.getBoundingBox();\n\n\n\n\tvar splineTube, binormal, normal, position2;\n\tif ( extrudePath ) {\n\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\n\n\t\textrudeByPath = true;\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\n\n\t\t// SETUP TNB variables\n\n\t\t// Reuse TNB from TubeGeomtry for now.\n\t\t// TODO1 - have a .isClosed in spline?\n\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);\n\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\n\n\t\tbinormal = new THREE.Vector3();\n\t\tnormal = new THREE.Vector3();\n\t\tposition2 = new THREE.Vector3();\n\n\t}\n\n\t// Safeguards if bevels are not enabled\n\n\tif ( ! bevelEnabled ) {\n\n\t\tbevelSegments = 0;\n\t\tbevelThickness = 0;\n\t\tbevelSize = 0;\n\n\t}\n\n\t// Variables initalization\n\n\tvar ahole, h, hl; // looping of holes\n\tvar scope = this;\n\tvar bevelPoints = [];\n\n\tvar shapesOffset = this.vertices.length;\n\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = !THREE.Shape.Utils.isClockWise( vertices ) ;\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\n\t\t\tif ( THREE.Shape.Utils.isClockWise( ahole ) ) {\n\n\t\t\t\tholes[ h ] = ahole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\n\n\t}\n\n\n\tvar faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );\n\n\t/* Vertices */\n\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\n\n\tfor ( h = 0, hl = holes.length;  h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\tvertices = vertices.concat( ahole );\n\n\t}\n\n\n\tfunction scalePt2 ( pt, vec, size ) {\n\n\t\tif ( !vec ) console.log( \"die\" );\n\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\n\n\t}\n\n\tvar b, bs, t, z,\n\t\tvert, vlen = vertices.length,\n\t\tface, flen = faces.length,\n\t\tcont, clen = contour.length;\n\n\n\t// Find directions for point movement\n\n\tvar RAD_TO_DEGREES = 180 / Math.PI;\n\n\n\tfunction getBevelVec( pt_i, pt_j, pt_k ) {\n\n\t\t// Algorithm 2\n\n\t\treturn getBevelVec2( pt_i, pt_j, pt_k );\n\n\t}\n\n\tfunction getBevelVec1( pt_i, pt_j, pt_k ) {\n\n\t\tvar anglea = Math.atan2( pt_j.y - pt_i.y, pt_j.x - pt_i.x );\n\t\tvar angleb = Math.atan2( pt_k.y - pt_i.y, pt_k.x - pt_i.x );\n\n\t\tif ( anglea > angleb ) {\n\n\t\t\tangleb += Math.PI * 2;\n\n\t\t}\n\n\t\tvar anglec = ( anglea + angleb ) / 2;\n\n\n\t\t//console.log('angle1', anglea * RAD_TO_DEGREES,'angle2', angleb * RAD_TO_DEGREES, 'anglec', anglec *RAD_TO_DEGREES);\n\n\t\tvar x = - Math.cos( anglec );\n\t\tvar y = - Math.sin( anglec );\n\n\t\tvar vec = new THREE.Vector2( x, y ); //.normalize();\n\n\t\treturn vec;\n\n\t}\n\n\tfunction getBevelVec2( pt_i, pt_j, pt_k ) {\n\n\t\tvar a = THREE.ExtrudeGeometry.__v1,\n\t\t\tb = THREE.ExtrudeGeometry.__v2,\n\t\t\tv_hat = THREE.ExtrudeGeometry.__v3,\n\t\t\tw_hat = THREE.ExtrudeGeometry.__v4,\n\t\t\tp = THREE.ExtrudeGeometry.__v5,\n\t\t\tq = THREE.ExtrudeGeometry.__v6,\n\t\t\tv, w,\n\t\t\tv_dot_w_hat, q_sub_p_dot_w_hat,\n\t\t\ts, intersection;\n\n\t\t// good reading for line-line intersection\n\t\t// http://sputsoft.com/blog/2010/03/line-line-intersection.html\n\n\t\t// define a as vector j->i\n\t\t// define b as vectot k->i\n\n\t\ta.set( pt_i.x - pt_j.x, pt_i.y - pt_j.y );\n\t\tb.set( pt_i.x - pt_k.x, pt_i.y - pt_k.y );\n\n\t\t// get unit vectors\n\n\t\tv = a.normalize();\n\t\tw = b.normalize();\n\n\t\t// normals from pt i\n\n\t\tv_hat.set( -v.y, v.x );\n\t\tw_hat.set( w.y, -w.x );\n\n\t\t// pts from i\n\n\t\tp.copy( pt_i ).add( v_hat );\n\t\tq.copy( pt_i ).add( w_hat );\n\n\t\tif ( p.equals( q ) ) {\n\n\t\t\t//console.log(\"Warning: lines are straight\");\n\t\t\treturn w_hat.clone();\n\n\t\t}\n\n\t\t// Points from j, k. helps prevents points cross overover most of the time\n\n\t\tp.copy( pt_j ).add( v_hat );\n\t\tq.copy( pt_k ).add( w_hat );\n\n\t\tv_dot_w_hat = v.dot( w_hat );\n\t\tq_sub_p_dot_w_hat = q.sub( p ).dot( w_hat );\n\n\t\t// We should not reach these conditions\n\n\t\tif ( v_dot_w_hat === 0 ) {\n\n\t\t\tconsole.log( \"Either infinite or no solutions!\" );\n\n\t\t\tif ( q_sub_p_dot_w_hat === 0 ) {\n\n\t\t\t\tconsole.log( \"Its finite solutions.\" );\n\n\t\t\t} else {\n\n\t\t\t\tconsole.log( \"Too bad, no solutions.\" );\n\n\t\t\t}\n\n\t\t}\n\n\t\ts = q_sub_p_dot_w_hat / v_dot_w_hat;\n\n\t\tif ( s < 0 ) {\n\n\t\t\t// in case of emergecy, revert to algorithm 1.\n\n\t\t\treturn getBevelVec1( pt_i, pt_j, pt_k );\n\n\t\t}\n\n\t\tintersection = v.multiplyScalar( s ).add( p );\n\n\t\treturn intersection.sub( pt_i ).clone(); // Don't normalize!, otherwise sharp corners become ugly\n\n\t}\n\n\tvar contourMovements = [];\n\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\tif ( j === il ) j = 0;\n\t\tif ( k === il ) k = 0;\n\n\t\t//  (j)---(i)---(k)\n\t\t// console.log('i,j,k', i, j , k)\n\n\t\tvar pt_i = contour[ i ];\n\t\tvar pt_j = contour[ j ];\n\t\tvar pt_k = contour[ k ];\n\n\t\tcontourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\n\n\t}\n\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\n\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\tahole = holes[ h ];\n\n\t\toneHoleMovements = [];\n\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\n\n\t\t\tif ( j === il ) j = 0;\n\t\t\tif ( k === il ) k = 0;\n\n\t\t\t//  (j)---(i)---(k)\n\t\t\toneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\n\n\t\t}\n\n\t\tholesMovements.push( oneHoleMovements );\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\n\n\t}\n\n\n\t// Loop bevelSegments, 1 for the front, 1 for the back\n\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\n\t//for ( b = bevelSegments; b > 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\n\t\t//z = bevelThickness * t;\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved\n\t\t//bs = bevelSize * t ; // linear\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\t//vert = scalePt( contour[ i ], contourCentroid, bs, false );\n\t\t\tv( vert.x, vert.y,  - z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\t\t\t\t//vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );\n\n\t\t\t\tv( vert.x, vert.y,  -z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tbs = bevelSize;\n\n\t// Back facing vertices\n\n\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\tif ( !extrudeByPath ) {\n\n\t\t\tv( vert.x, vert.y, 0 );\n\n\t\t} else {\n\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\n\n\t\t\tnormal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);\n\t\t\tbinormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);\n\n\t\t\tposition2.copy( extrudePts[0] ).add(normal).add(binormal);\n\n\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t}\n\n\t}\n\n\t// Add stepped vertices...\n\t// Including front facing vertices\n\n\tvar s;\n\n\tfor ( s = 1; s <= steps; s ++ ) {\n\n\t\tfor ( i = 0; i < vlen; i ++ ) {\n\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\n\n\t\t\tif ( !extrudeByPath ) {\n\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\n\n\t\t\t} else {\n\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\n\n\t\t\t\tnormal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );\n\t\t\t\tbinormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );\n\n\t\t\t\tposition2.copy( extrudePts[s] ).add( normal ).add( binormal );\n\n\t\t\t\tv( position2.x, position2.y, position2.z );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Add bevel segments planes\n\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\n\n\t\tt = b / bevelSegments;\n\t\tz = bevelThickness * ( 1 - t );\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\n\t\tbs = bevelSize * Math.sin ( t * Math.PI/2 ) ;\n\n\t\t// contract shape\n\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\n\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\n\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t}\n\n\t\t// expand holes\n\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\toneHoleMovements = holesMovements[ h ];\n\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\n\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\n\n\t\t\t\tif ( !extrudeByPath ) {\n\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Faces */\n\n\t// Top and bottom faces\n\n\tbuildLidFaces();\n\n\t// Sides faces\n\n\tbuildSideFaces();\n\n\n\t/////  Internal functions\n\n\tfunction buildLidFaces() {\n\n\t\tif ( bevelEnabled ) {\n\n\t\t\tvar layer = 0 ; // steps + 1\n\t\t\tvar offset = vlen * layer;\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset, true );\n\n\t\t\t}\n\n\t\t\tlayer = steps + bevelSegments * 2;\n\t\t\toffset = vlen * layer;\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset, false );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Bottom faces\n\n\t\t\tfor ( i = 0; i < flen; i++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ], true );\n\n\t\t\t}\n\n\t\t\t// Top faces\n\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\n\n\t\t\t\tface = faces[ i ];\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps, false );\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\t// Create faces for the z-sides of the shape\n\n\tfunction buildSideFaces() {\n\n\t\tvar layeroffset = 0;\n\t\tsidewalls( contour, layeroffset );\n\t\tlayeroffset += contour.length;\n\n\t\tfor ( h = 0, hl = holes.length;  h < hl; h ++ ) {\n\n\t\t\tahole = holes[ h ];\n\t\t\tsidewalls( ahole, layeroffset );\n\n\t\t\t//, true\n\t\t\tlayeroffset += ahole.length;\n\n\t\t}\n\n\t}\n\n\tfunction sidewalls( contour, layeroffset ) {\n\n\t\tvar j, k;\n\t\ti = contour.length;\n\n\t\twhile ( --i >= 0 ) {\n\n\t\t\tj = i;\n\t\t\tk = i - 1;\n\t\t\tif ( k < 0 ) k = contour.length - 1;\n\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\n\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\n\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\n\n\t\t\t\tvar slen1 = vlen * s;\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\n\n\t\t\t\tvar a = layeroffset + j + slen1,\n\t\t\t\t\tb = layeroffset + k + slen1,\n\t\t\t\t\tc = layeroffset + k + slen2,\n\t\t\t\t\td = layeroffset + j + slen2;\n\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\n\tfunction v( x, y, z ) {\n\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\n\n\t}\n\n\tfunction f3( a, b, c, isBottom ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\n\t\t// normal, color, material\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\n\t\tvar uvs = isBottom ? uvgen.generateBottomUV( scope, shape, options, a, b, c ) : uvgen.generateTopUV( scope, shape, options, a, b, c );\n\n \t\tscope.faceVertexUvs[ 0 ].push( uvs );\n\n\t}\n\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\n\n\t\ta += shapesOffset;\n\t\tb += shapesOffset;\n\t\tc += shapesOffset;\n\t\td += shapesOffset;\n\n \t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );\n \t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );\n\n \t\tvar uvs = uvgen.generateSideWallUV( scope, shape, wallContour, options, a, b, c, d,\n \t\t                                    stepIndex, stepsLength, contourIndex1, contourIndex2 );\n\n \t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\n \t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\n\n\t}\n\n};\n\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\n\n\tgenerateTopUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {\n\t\tvar ax = geometry.vertices[ indexA ].x,\n\t\t\tay = geometry.vertices[ indexA ].y,\n\n\t\t\tbx = geometry.vertices[ indexB ].x,\n\t\t\tby = geometry.vertices[ indexB ].y,\n\n\t\t\tcx = geometry.vertices[ indexC ].x,\n\t\t\tcy = geometry.vertices[ indexC ].y;\n\n\t\treturn [\n\t\t\tnew THREE.Vector2( ax, ay ),\n\t\t\tnew THREE.Vector2( bx, by ),\n\t\t\tnew THREE.Vector2( cx, cy )\n\t\t];\n\n\t},\n\n\tgenerateBottomUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {\n\n\t\treturn this.generateTopUV( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC );\n\n\t},\n\n\tgenerateSideWallUV: function( geometry, extrudedShape, wallContour, extrudeOptions,\n\t                              indexA, indexB, indexC, indexD, stepIndex, stepsLength,\n\t                              contourIndex1, contourIndex2 ) {\n\n\t\tvar ax = geometry.vertices[ indexA ].x,\n\t\t\tay = geometry.vertices[ indexA ].y,\n\t\t\taz = geometry.vertices[ indexA ].z,\n\n\t\t\tbx = geometry.vertices[ indexB ].x,\n\t\t\tby = geometry.vertices[ indexB ].y,\n\t\t\tbz = geometry.vertices[ indexB ].z,\n\n\t\t\tcx = geometry.vertices[ indexC ].x,\n\t\t\tcy = geometry.vertices[ indexC ].y,\n\t\t\tcz = geometry.vertices[ indexC ].z,\n\n\t\t\tdx = geometry.vertices[ indexD ].x,\n\t\t\tdy = geometry.vertices[ indexD ].y,\n\t\t\tdz = geometry.vertices[ indexD ].z;\n\n\t\tif ( Math.abs( ay - by ) < 0.01 ) {\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( ax, 1 - az ),\n\t\t\t\tnew THREE.Vector2( bx, 1 - bz ),\n\t\t\t\tnew THREE.Vector2( cx, 1 - cz ),\n\t\t\t\tnew THREE.Vector2( dx, 1 - dz )\n\t\t\t];\n\t\t} else {\n\t\t\treturn [\n\t\t\t\tnew THREE.Vector2( ay, 1 - az ),\n\t\t\t\tnew THREE.Vector2( by, 1 - bz ),\n\t\t\t\tnew THREE.Vector2( cy, 1 - cz ),\n\t\t\t\tnew THREE.Vector2( dy, 1 - dz )\n\t\t\t];\n\t\t}\n\t}\n};\n\nTHREE.ExtrudeGeometry.__v1 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v2 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v3 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v4 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v5 = new THREE.Vector2();\nTHREE.ExtrudeGeometry.__v6 = new THREE.Vector2();\n\n/**\n * @author jonobr1 / http://jonobr1.com\n *\n * Creates a one-sided polygonal geometry from a path shape. Similar to\n * ExtrudeGeometry.\n *\n * parameters = {\n *\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\n *\n *\tmaterial: <int> // material index for front and back faces\n *\tuvGenerator: <Object> // object that provides UV generator functions\n *\n * }\n **/\n\nTHREE.ShapeGeometry = function ( shapes, options ) {\n\n\tTHREE.Geometry.call( this );\n\n\tif ( shapes instanceof Array === false ) shapes = [ shapes ];\n\n\tthis.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();\n\n\tthis.addShapeList( shapes, options );\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n};\n\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * Add an array of shapes to THREE.ShapeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\n\n\tfor ( var i = 0, l = shapes.length; i < l; i++ ) {\n\n\t\tthis.addShape( shapes[ i ], options );\n\n\t}\n\n\treturn this;\n\n};\n\n/**\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\n */\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\n\n\tif ( options === undefined ) options = {};\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\n\n\tvar material = options.material;\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\n\n\tvar shapebb = this.shapebb;\n\n\t//\n\n\tvar i, l, hole, s;\n\n\tvar shapesOffset = this.vertices.length;\n\tvar shapePoints = shape.extractPoints( curveSegments );\n\n\tvar vertices = shapePoints.shape;\n\tvar holes = shapePoints.holes;\n\n\tvar reverse = !THREE.Shape.Utils.isClockWise( vertices );\n\n\tif ( reverse ) {\n\n\t\tvertices = vertices.reverse();\n\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\n\n\t\tfor ( i = 0, l = holes.length; i < l; i++ ) {\n\n\t\t\thole = holes[ i ];\n\n\t\t\tif ( THREE.Shape.Utils.isClockWise( hole ) ) {\n\n\t\t\t\tholes[ i ] = hole.reverse();\n\n\t\t\t}\n\n\t\t}\n\n\t\treverse = false;\n\n\t}\n\n\tvar faces = THREE.Shape.Utils.triangulateShape( vertices, holes );\n\n\t// Vertices\n\n\tvar contour = vertices;\n\n\tfor ( i = 0, l = holes.length; i < l; i++ ) {\n\n\t\thole = holes[ i ];\n\t\tvertices = vertices.concat( hole );\n\n\t}\n\n\t//\n\n\tvar vert, vlen = vertices.length;\n\tvar face, flen = faces.length;\n\tvar cont, clen = contour.length;\n\n\tfor ( i = 0; i < vlen; i++ ) {\n\n\t\tvert = vertices[ i ];\n\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\n\n\t}\n\n\tfor ( i = 0; i < flen; i++ ) {\n\n\t\tface = faces[ i ];\n\n\t\tvar a = face[ 0 ] + shapesOffset;\n\t\tvar b = face[ 1 ] + shapesOffset;\n\t\tvar c = face[ 2 ] + shapesOffset;\n\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateBottomUV( this, shape, options, a, b, c ) );\n\n\t}\n\n};\n\n/**\n * @author astrodud / http://astrodud.isgreat.org/\n * @author zz85 / https://github.com/zz85\n * @author bhouston / http://exocortex.com\n */\n\n// points - to create a closed torus, one must use a set of points \n//    like so: [ a, b, c, d, a ], see first is the same as last.\n// segments - the number of circumference segments to create\n// phiStart - the starting radian\n// phiLength - the radian (0 to 2*PI) range of the lathed section\n//    2*pi is a closed lathe, less than 2PI is a portion.\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tsegments = segments || 12;\n\tphiStart = phiStart || 0;\n\tphiLength = phiLength || 2 * Math.PI;\n\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\n\tvar inverseSegments = 1.0 / segments;\n\n\tfor ( var i = 0, il = segments; i <= il; i ++ ) {\n\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\n\n\t\tvar c = Math.cos( phi ),\n\t\t\ts = Math.sin( phi );\n\n\t\tfor ( var j = 0, jl = points.length; j < jl; j ++ ) {\n\n\t\t\tvar pt = points[ j ];\n\n\t\t\tvar vertex = new THREE.Vector3();\n\n\t\t\tvertex.x = c * pt.x - s * pt.y;\n\t\t\tvertex.y = s * pt.x + c * pt.y;\n\t\t\tvertex.z = pt.z;\n\n\t\t\tthis.vertices.push( vertex );\n\n\t\t}\n\n\t}\n\n\tvar np = points.length;\n\n\tfor ( var i = 0, il = segments; i < il; i ++ ) {\n\n\t\tfor ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {\n\n\t\t\tvar base = j + np * i;\n\t\t\tvar a = base;\n\t\t\tvar b = base + np;\n\t\t\tvar c = base + 1 + np;\n\t\t\tvar d = base + 1;\n\n\t\t\tvar u0 = i * inverseSegments;\n\t\t\tvar v0 = j * inversePointLength;\n\t\t\tvar u1 = u0 + inverseSegments;\n\t\t\tvar v1 = v0 + inversePointLength;\n\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\n\n\t\t\t\tnew THREE.Vector2( u0, v0 ),\n\t\t\t\tnew THREE.Vector2( u1, v0 ),\n\t\t\t\tnew THREE.Vector2( u0, v1 )\n\n\t\t\t] );\n\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\n\t\t\tthis.faceVertexUvs[ 0 ].push( [\n\n\t\t\t\tnew THREE.Vector2( u1, v0 ),\n\t\t\t\tnew THREE.Vector2( u1, v1 ),\n\t\t\t\tnew THREE.Vector2( u0, v1 )\n\n\t\t\t] );\n\n\n\t\t}\n\n\t}\n\n\tthis.mergeVertices();\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\n */\n\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.widthSegments = widthSegments || 1;\n\tthis.heightSegments = heightSegments || 1;\n\n\tvar ix, iz;\n\tvar width_half = width / 2;\n\tvar height_half = height / 2;\n\n\tvar gridX = this.widthSegments;\n\tvar gridZ = this.heightSegments;\n\n\tvar gridX1 = gridX + 1;\n\tvar gridZ1 = gridZ + 1;\n\n\tvar segment_width = this.width / gridX;\n\tvar segment_height = this.height / gridZ;\n\n\tvar normal = new THREE.Vector3( 0, 0, 1 );\n\n\tfor ( iz = 0; iz < gridZ1; iz ++ ) {\n\n\t\tfor ( ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\tvar x = ix * segment_width - width_half;\n\t\t\tvar y = iz * segment_height - height_half;\n\n\t\t\tthis.vertices.push( new THREE.Vector3( x, - y, 0 ) );\n\n\t\t}\n\n\t}\n\n\tfor ( iz = 0; iz < gridZ; iz ++ ) {\n\n\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\tvar a = ix + gridX1 * iz;\n\t\t\tvar b = ix + gridX1 * ( iz + 1 );\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iz + 1 );\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iz;\n\n\t\t\tvar uva = new THREE.Vector2( ix / gridX, 1 - iz / gridZ );\n\t\t\tvar uvb = new THREE.Vector2( ix / gridX, 1 - ( iz + 1 ) / gridZ );\n\t\t\tvar uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iz + 1 ) / gridZ );\n\t\t\tvar uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iz / gridZ );\n\n\t\t\tvar face = new THREE.Face3( a, b, d );\n\t\t\tface.normal.copy( normal );\n\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\n\n\t\t\tthis.faces.push( face );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\n\t\t\tface = new THREE.Face3( b, c, d );\n\t\t\tface.normal.copy( normal );\n\t\t\tface.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\n\n\t\t\tthis.faces.push( face );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\n};\n\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author Kaleb Murphy\n */\n\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tinnerRadius = innerRadius || 0;\n\touterRadius = outerRadius || 50;\n\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\n\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\n\tphiSegments = phiSegments !== undefined ? Math.max( 3, phiSegments ) : 8;\n\n\tvar i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\n\n\tfor ( i = 0; i <= phiSegments; i ++ ) { // concentric circles inside ring\n\n\t\tfor ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvar segment = thetaStart + o / thetaSegments * thetaLength;\n\n\t\t\tvertex.x = radius * Math.cos( segment );\n\t\t\tvertex.y = radius * Math.sin( segment );\n\n\t\t\tthis.vertices.push( vertex );\n\t\t\tuvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );\n\t\t}\n\n\t\tradius += radiusStep;\n\n\t}\n\n\tvar n = new THREE.Vector3( 0, 0, 1 );\n\n\tfor ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring\n\n\t\tvar thetaSegment = i * thetaSegments;\n\n\t\tfor ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle\n\n\t\t\tvar segment = o + thetaSegment;\n\n\t\t\tvar v1 = segment + i;\n\t\t\tvar v2 = segment + thetaSegments + i;\n\t\t\tvar v3 = segment + thetaSegments + 1 + i;\n\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);\n\n\t\t\tv1 = segment + i;\n\t\t\tv2 = segment + thetaSegments + 1 + i;\n\t\t\tv3 = segment + 1 + i;\n\n\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);\n\n\t\t}\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.radius = radius = radius || 50;\n\n\tthis.widthSegments = widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\n\tthis.heightSegments = heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\n\n\tthis.phiStart = phiStart = phiStart !== undefined ? phiStart : 0;\n\tthis.phiLength = phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\n\n\tthis.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;\n\tthis.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\n\n\tvar x, y, vertices = [], uvs = [];\n\n\tfor ( y = 0; y <= heightSegments; y ++ ) {\n\n\t\tvar verticesRow = [];\n\t\tvar uvsRow = [];\n\n\t\tfor ( x = 0; x <= widthSegments; x ++ ) {\n\n\t\t\tvar u = x / widthSegments;\n\t\t\tvar v = y / heightSegments;\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\tthis.vertices.push( vertex );\n\n\t\t\tverticesRow.push( this.vertices.length - 1 );\n\t\t\tuvsRow.push( new THREE.Vector2( u, 1 - v ) );\n\n\t\t}\n\n\t\tvertices.push( verticesRow );\n\t\tuvs.push( uvsRow );\n\n\t}\n\n\tfor ( y = 0; y < this.heightSegments; y ++ ) {\n\n\t\tfor ( x = 0; x < this.widthSegments; x ++ ) {\n\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\n\t\t\tvar v2 = vertices[ y ][ x ];\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\n\n\t\t\tvar n1 = this.vertices[ v1 ].clone().normalize();\n\t\t\tvar n2 = this.vertices[ v2 ].clone().normalize();\n\t\t\tvar n3 = this.vertices[ v3 ].clone().normalize();\n\t\t\tvar n4 = this.vertices[ v4 ].clone().normalize();\n\n\t\t\tvar uv1 = uvs[ y ][ x + 1 ].clone();\n\t\t\tvar uv2 = uvs[ y ][ x ].clone();\n\t\t\tvar uv3 = uvs[ y + 1 ][ x ].clone();\n\t\t\tvar uv4 = uvs[ y + 1 ][ x + 1 ].clone();\n\n\t\t\tif ( Math.abs( this.vertices[ v1 ].y ) === this.radius ) {\n\n\t\t\t\tuv1.x = ( uv1.x + uv2.x ) / 2;\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );\n\n\t\t\t} else if ( Math.abs( this.vertices[ v3 ].y ) === this.radius ) {\n\n\t\t\t\tuv3.x = ( uv3.x + uv4.x ) / 2;\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\n\n\t\t\t} else {\n\n\t\t\t\tthis.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\n\n\t\t\t\tthis.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n};\n\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n * @author alteredq / http://alteredqualia.com/\n *\n * For creating 3D text geometry in three.js\n *\n * Text = 3D Text\n *\n * parameters = {\n *  size: \t\t\t<float>, \t// size of the text\n *  height: \t\t<float>, \t// thickness to extrude text\n *  curveSegments: \t<int>,\t\t// number of points on the curves\n *\n *  font: \t\t\t<string>,\t\t// font name\n *  weight: \t\t<string>,\t\t// font weight (normal, bold)\n *  style: \t\t\t<string>,\t\t// font style  (normal, italics)\n *\n *  bevelEnabled:\t<bool>,\t\t\t// turn on bevel\n *  bevelThickness: <float>, \t\t// how deep into text bevel goes\n *  bevelSize:\t\t<float>, \t\t// how far from text outline is bevel\n *  }\n *\n */\n\n/*\tUsage Examples\n\n\t// TextGeometry wrapper\n\n\tvar text3d = new TextGeometry( text, options );\n\n\t// Complete manner\n\n\tvar textShapes = THREE.FontUtils.generateShapes( text, options );\n\tvar text3d = new ExtrudeGeometry( textShapes, options );\n\n*/\n\n\nTHREE.TextGeometry = function ( text, parameters ) {\n\n\tparameters = parameters || {};\n\n\tvar textShapes = THREE.FontUtils.generateShapes( text, parameters );\n\n\t// translate parameters to ExtrudeGeometry API\n\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\n\n\t// defaults\n\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\n\n\tTHREE.ExtrudeGeometry.call( this, textShapes, parameters );\n\n};\n\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\n\n/**\n * @author oosmoxiecode\n * @author mrdoob / http://mrdoob.com/\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\n */\n\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar scope = this;\n\n\tthis.radius = radius || 100;\n\tthis.tube = tube || 40;\n\tthis.radialSegments = radialSegments || 8;\n\tthis.tubularSegments = tubularSegments || 6;\n\tthis.arc = arc || Math.PI * 2;\n\n\tvar center = new THREE.Vector3(), uvs = [], normals = [];\n\n\tfor ( var j = 0; j <= this.radialSegments; j ++ ) {\n\n\t\tfor ( var i = 0; i <= this.tubularSegments; i ++ ) {\n\n\t\t\tvar u = i / this.tubularSegments * this.arc;\n\t\t\tvar v = j / this.radialSegments * Math.PI * 2;\n\n\t\t\tcenter.x = this.radius * Math.cos( u );\n\t\t\tcenter.y = this.radius * Math.sin( u );\n\n\t\t\tvar vertex = new THREE.Vector3();\n\t\t\tvertex.x = ( this.radius + this.tube * Math.cos( v ) ) * Math.cos( u );\n\t\t\tvertex.y = ( this.radius + this.tube * Math.cos( v ) ) * Math.sin( u );\n\t\t\tvertex.z = this.tube * Math.sin( v );\n\n\t\t\tthis.vertices.push( vertex );\n\n\t\t\tuvs.push( new THREE.Vector2( i / this.tubularSegments, j / this.radialSegments ) );\n\t\t\tnormals.push( vertex.clone().sub( center ).normalize() );\n\n\t\t}\n\n\t}\n\n\n\tfor ( var j = 1; j <= this.radialSegments; j ++ ) {\n\n\t\tfor ( var i = 1; i <= this.tubularSegments; i ++ ) {\n\n\t\t\tvar a = ( this.tubularSegments + 1 ) * j + i - 1;\n\t\t\tvar b = ( this.tubularSegments + 1 ) * ( j - 1 ) + i - 1;\n\t\t\tvar c = ( this.tubularSegments + 1 ) * ( j - 1 ) + i;\n\t\t\tvar d = ( this.tubularSegments + 1 ) * j + i;\n\n\t\t\tvar face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );\n\t\t\tthis.faces.push( face );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );\n\n\t\t\tface = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );\n\t\t\tthis.faces.push( face );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );\n\n\t\t}\n\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\n};\n\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author oosmoxiecode\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\n */\n\nTHREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar scope = this;\n\n\tthis.radius = radius || 100;\n\tthis.tube = tube || 40;\n\tthis.radialSegments = radialSegments || 64;\n\tthis.tubularSegments = tubularSegments || 8;\n\tthis.p = p || 2;\n\tthis.q = q || 3;\n\tthis.heightScale = heightScale || 1;\n\tthis.grid = new Array( this.radialSegments );\n\n\tvar tang = new THREE.Vector3();\n\tvar n = new THREE.Vector3();\n\tvar bitan = new THREE.Vector3();\n\n\tfor ( var i = 0; i < this.radialSegments; ++ i ) {\n\n\t\tthis.grid[ i ] = new Array( this.tubularSegments );\n\t\tvar u = i / this.radialSegments * 2 * this.p * Math.PI;\n\t\tvar p1 = getPos( u, this.q, this.p, this.radius, this.heightScale );\n\t\tvar p2 = getPos( u + 0.01, this.q, this.p, this.radius, this.heightScale );\n\t\ttang.subVectors( p2, p1 );\n\t\tn.addVectors( p2, p1 );\n\n\t\tbitan.crossVectors( tang, n );\n\t\tn.crossVectors( bitan, tang );\n\t\tbitan.normalize();\n\t\tn.normalize();\n\n\t\tfor ( var j = 0; j < this.tubularSegments; ++ j ) {\n\n\t\t\tvar v = j / this.tubularSegments * 2 * Math.PI;\n\t\t\tvar cx = - this.tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\t\t\tvar cy = this.tube * Math.sin( v );\n\n\t\t\tvar pos = new THREE.Vector3();\n\t\t\tpos.x = p1.x + cx * n.x + cy * bitan.x;\n\t\t\tpos.y = p1.y + cx * n.y + cy * bitan.y;\n\t\t\tpos.z = p1.z + cx * n.z + cy * bitan.z;\n\n\t\t\tthis.grid[ i ][ j ] = scope.vertices.push( pos ) - 1;\n\n\t\t}\n\n\t}\n\n\tfor ( var i = 0; i < this.radialSegments; ++ i ) {\n\n\t\tfor ( var j = 0; j < this.tubularSegments; ++ j ) {\n\n\t\t\tvar ip = ( i + 1 ) % this.radialSegments;\n\t\t\tvar jp = ( j + 1 ) % this.tubularSegments;\n\n\t\t\tvar a = this.grid[ i ][ j ];\n\t\t\tvar b = this.grid[ ip ][ j ];\n\t\t\tvar c = this.grid[ ip ][ jp ];\n\t\t\tvar d = this.grid[ i ][ jp ];\n\n\t\t\tvar uva = new THREE.Vector2( i / this.radialSegments, j / this.tubularSegments );\n\t\t\tvar uvb = new THREE.Vector2( ( i + 1 ) / this.radialSegments, j / this.tubularSegments );\n\t\t\tvar uvc = new THREE.Vector2( ( i + 1 ) / this.radialSegments, ( j + 1 ) / this.tubularSegments );\n\t\t\tvar uvd = new THREE.Vector2( i / this.radialSegments, ( j + 1 ) / this.tubularSegments );\n\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n\tfunction getPos( u, in_q, in_p, radius, heightScale ) {\n\n\t\tvar cu = Math.cos( u );\n\t\tvar su = Math.sin( u );\n\t\tvar quOverP = in_q / in_p * u;\n\t\tvar cs = Math.cos( quOverP );\n\n\t\tvar tx = radius * ( 2 + cs ) * 0.5 * cu;\n\t\tvar ty = radius * ( 2 + cs ) * su * 0.5;\n\t\tvar tz = heightScale * radius * Math.sin( quOverP ) * 0.5;\n\n\t\treturn new THREE.Vector3( tx, ty, tz );\n\n\t}\n\n};\n\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author WestLangley / https://github.com/WestLangley\n * @author zz85 / https://github.com/zz85\n * @author miningold / https://github.com/miningold\n *\n * Modified from the TorusKnotGeometry by @oosmoxiecode\n *\n * Creates a tube which extrudes along a 3d spline\n *\n * Uses parallel transport frames as described in\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n */\n\nTHREE.TubeGeometry = function( path, segments, radius, radialSegments, closed ) {\n\n\tTHREE.Geometry.call( this );\n\n\tthis.path = path;\n\tthis.segments = segments || 64;\n\tthis.radius = radius || 1;\n\tthis.radialSegments = radialSegments || 8;\n\tthis.closed = closed || false;\n\n\tthis.grid = [];\n\n\tvar scope = this,\n\n\t\ttangent,\n\t\tnormal,\n\t\tbinormal,\n\n\t\tnumpoints = this.segments + 1,\n\n\t\tx, y, z,\n\t\ttx, ty, tz,\n\t\tu, v,\n\n\t\tcx, cy,\n\t\tpos, pos2 = new THREE.Vector3(),\n\t\ti, j,\n\t\tip, jp,\n\t\ta, b, c, d,\n\t\tuva, uvb, uvc, uvd;\n\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( this.path, this.segments, this.closed ),\n\t\ttangents = frames.tangents,\n\t\tnormals = frames.normals,\n\t\tbinormals = frames.binormals;\n\n\t// proxy internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\tfunction vert( x, y, z ) {\n\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\n\n\t}\n\n\n\t// consruct the grid\n\n\tfor ( i = 0; i < numpoints; i++ ) {\n\n\t\tthis.grid[ i ] = [];\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\tpos = path.getPointAt( u );\n\n\t\ttangent = tangents[ i ];\n\t\tnormal = normals[ i ];\n\t\tbinormal = binormals[ i ];\n\n\t\tfor ( j = 0; j < this.radialSegments; j++ ) {\n\n\t\t\tv = j / this.radialSegments * 2 * Math.PI;\n\n\t\t\tcx = -this.radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\n\t\t\tcy = this.radius * Math.sin( v );\n\n\t\t\tpos2.copy( pos );\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\n\n\t\t\tthis.grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\n\n\t\t}\n\t}\n\n\n\t// construct the mesh\n\n\tfor ( i = 0; i < this.segments; i++ ) {\n\n\t\tfor ( j = 0; j < this.radialSegments; j++ ) {\n\n\t\t\tip = ( this.closed ) ? (i + 1) % this.segments : i + 1;\n\t\t\tjp = (j + 1) % this.radialSegments;\n\n\t\t\ta = this.grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\n\t\t\tb = this.grid[ ip ][ j ];\n\t\t\tc = this.grid[ ip ][ jp ];\n\t\t\td = this.grid[ i ][ jp ];\n\n\t\t\tuva = new THREE.Vector2( i / this.segments, j / this.radialSegments );\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / this.segments, j / this.radialSegments );\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / this.segments, ( j + 1 ) / this.radialSegments );\n\t\t\tuvd = new THREE.Vector2( i / this.segments, ( j + 1 ) / this.radialSegments );\n\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\n\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\t}\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\nTHREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {\n\n\tvar\ttangent = new THREE.Vector3(),\n\t\tnormal = new THREE.Vector3(),\n\t\tbinormal = new THREE.Vector3(),\n\n\t\ttangents = [],\n\t\tnormals = [],\n\t\tbinormals = [],\n\n\t\tvec = new THREE.Vector3(),\n\t\tmat = new THREE.Matrix4(),\n\n\t\tnumpoints = segments + 1,\n\t\ttheta,\n\t\tepsilon = 0.0001,\n\t\tsmallest,\n\n\t\ttx, ty, tz,\n\t\ti, u, v;\n\n\n\t// expose internals\n\tthis.tangents = tangents;\n\tthis.normals = normals;\n\tthis.binormals = binormals;\n\n\t// compute the tangent vectors for each segment on the path\n\n\tfor ( i = 0; i < numpoints; i++ ) {\n\n\t\tu = i / ( numpoints - 1 );\n\n\t\ttangents[ i ] = path.getTangentAt( u );\n\t\ttangents[ i ].normalize();\n\n\t}\n\n\tinitialNormal3();\n\n\tfunction initialNormal1(lastBinormal) {\n\t\t// fixed start binormal. Has dangers of 0 vectors\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\t}\n\n\tfunction initialNormal2() {\n\n\t\t// This uses the Frenet-Serret formula for deriving binormal\n\t\tvar t2 = path.getTangentAt( epsilon );\n\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\n\n\t}\n\n\tfunction initialNormal3() {\n\t\t// select an initial normal vector perpenicular to the first tangent vector,\n\t\t// and in the direction of the smallest tangent xyz component\n\n\t\tnormals[ 0 ] = new THREE.Vector3();\n\t\tbinormals[ 0 ] = new THREE.Vector3();\n\t\tsmallest = Number.MAX_VALUE;\n\t\ttx = Math.abs( tangents[ 0 ].x );\n\t\tty = Math.abs( tangents[ 0 ].y );\n\t\ttz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= smallest ) {\n\t\t\tsmallest = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\t\t}\n\n\t\tif ( ty <= smallest ) {\n\t\t\tsmallest = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\t\t}\n\n\t\tif ( tz <= smallest ) {\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\t}\n\n\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\n\n\tfor ( i = 1; i < numpoints; i++ ) {\n\n\t\tnormals[ i ] = normals[ i-1 ].clone();\n\n\t\tbinormals[ i ] = binormals[ i-1 ].clone();\n\n\t\tvec.crossVectors( tangents[ i-1 ], tangents[ i ] );\n\n\t\tif ( vec.length() > epsilon ) {\n\n\t\t\tvec.normalize();\n\n\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i-1 ].dot( tangents[ i ] ), -1, 1 ) ); // clamp for floating pt errors\n\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t}\n\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t}\n\n\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\tif ( closed ) {\n\n\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints-1 ] ), -1, 1 ) );\n\t\ttheta /= ( numpoints - 1 );\n\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {\n\n\t\t\ttheta = -theta;\n\n\t\t}\n\n\t\tfor ( i = 1; i < numpoints; i++ ) {\n\n\t\t\t// twist a little...\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t}\n};\n\n/**\n * @author clockworkgeek / https://github.com/clockworkgeek\n * @author timothypratley / https://github.com/timothypratley\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.PolyhedronGeometry = function ( vertices, faces, radius, detail ) {\n\n\tTHREE.Geometry.call( this );\n\n\tradius = radius || 1;\n\tdetail = detail || 0;\n\n\tvar that = this;\n\n\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\tprepare( new THREE.Vector3( vertices[ i ][ 0 ], vertices[ i ][ 1 ], vertices[ i ][ 2 ] ) );\n\n\t}\n\n\tvar midpoints = [], p = this.vertices;\n\n\tvar f = [];\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar v1 = p[ faces[ i ][ 0 ] ];\n\t\tvar v2 = p[ faces[ i ][ 1 ] ];\n\t\tvar v3 = p[ faces[ i ][ 2 ] ];\n\n\t\tf[ i ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\n\t}\n\n\tfor ( var i = 0, l = f.length; i < l; i ++ ) {\n\n\t\tsubdivide(f[ i ], detail);\n\n\t}\n\n\n\t// Handle case when face straddles the seam\n\n\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\n\n\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\n\n\t\tvar x0 = uvs[ 0 ].x;\n\t\tvar x1 = uvs[ 1 ].x;\n\t\tvar x2 = uvs[ 2 ].x;\n\n\t\tvar max = Math.max( x0, Math.max( x1, x2 ) );\n\t\tvar min = Math.min( x0, Math.min( x1, x2 ) );\n\n\t\tif ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary\n\n\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\n\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\n\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\n\n\t\t}\n\n\t}\n\n\n\t// Apply radius\n\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\tthis.vertices[ i ].multiplyScalar( radius );\n\n\t}\n\n\n\t// Merge vertices\n\n\tthis.mergeVertices();\n\n\tthis.computeCentroids();\n\n\tthis.computeFaceNormals();\n\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\n\n\n\t// Project vector onto sphere's surface\n\n\tfunction prepare( vector ) {\n\n\t\tvar vertex = vector.normalize().clone();\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\n\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\n\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\n\n\t\treturn vertex;\n\n\t}\n\n\n\t// Approximate a curved face with recursively sub-divided triangles.\n\n\tfunction make( v1, v2, v3 ) {\n\n\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\n\t\tface.centroid.add( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\n\t\tthat.faces.push( face );\n\n\t\tvar azi = azimuth( face.centroid );\n\n\t\tthat.faceVertexUvs[ 0 ].push( [\n\t\t\tcorrectUV( v1.uv, v1, azi ),\n\t\t\tcorrectUV( v2.uv, v2, azi ),\n\t\t\tcorrectUV( v3.uv, v3, azi )\n\t\t] );\n\n\t}\n\n\n\t// Analytically subdivide a face to the required detail level.\n\n\tfunction subdivide(face, detail ) {\n\n\t\tvar cols = Math.pow(2, detail);\n\t\tvar cells = Math.pow(4, detail);\n\t\tvar a = prepare( that.vertices[ face.a ] );\n\t\tvar b = prepare( that.vertices[ face.b ] );\n\t\tvar c = prepare( that.vertices[ face.c ] );\n\t\tvar v = [];\n\n\t\t// Construct all of the vertices for this subdivision.\n\n\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\n\n\t\t\tv[ i ] = [];\n\n\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\n\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\n\t\t\tvar rows = cols - i;\n\n\t\t\tfor ( var j = 0; j <= rows; j ++) {\n\n\t\t\t\tif ( j == 0 && i == cols ) {\n\n\t\t\t\t\tv[ i ][ j ] = aj;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Construct all of the faces.\n\n\t\tfor ( var i = 0; i < cols ; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {\n\n\t\t\t\tvar k = Math.floor( j / 2 );\n\n\t\t\t\tif ( j % 2 == 0 ) {\n\n\t\t\t\t\tmake(\n\t\t\t\t\t\tv[ i ][ k + 1],\n\t\t\t\t\t\tv[ i + 1 ][ k ],\n\t\t\t\t\t\tv[ i ][ k ]\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmake(\n\t\t\t\t\t\tv[ i ][ k + 1 ],\n\t\t\t\t\t\tv[ i + 1][ k + 1],\n\t\t\t\t\t\tv[ i + 1 ][ k ]\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\t// Angle around the Y axis, counter-clockwise when looking from above.\n\n\tfunction azimuth( vector ) {\n\n\t\treturn Math.atan2( vector.z, -vector.x );\n\n\t}\n\n\n\t// Angle above the XZ plane.\n\n\tfunction inclination( vector ) {\n\n\t\treturn Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\n\n\t}\n\n\n\t// Texture fixing helper. Spheres have some odd behaviours.\n\n\tfunction correctUV( uv, vector, azimuth ) {\n\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\n\t\treturn uv.clone();\n\n\t}\n\n\n};\n\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\n\n\tthis.radius = radius;\n\tthis.detail = detail;\n\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\n\n\tvar vertices = [\n\t\t[ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],\n\t\t[  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],\n\t\t[  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]\n\t];\n\n\tvar faces = [\n\t\t[ 0, 11,  5 ], [ 0,  5,  1 ], [  0,  1,  7 ], [  0,  7, 10 ], [  0, 10, 11 ],\n\t\t[ 1,  5,  9 ], [ 5, 11,  4 ], [ 11, 10,  2 ], [ 10,  7,  6 ], [  7,  1,  8 ],\n\t\t[ 3,  9,  4 ], [ 3,  4,  2 ], [  3,  2,  6 ], [  3,  6,  8 ], [  3,  8,  9 ],\n\t\t[ 4,  9,  5 ], [ 2,  4, 11 ], [  6,  2, 10 ], [  8,  6,  7 ], [  9,  8,  1 ]\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\n\n};\n\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.OctahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t[ 1, 0, 0 ], [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 0, 0, 1 ], [ 0, 0, -1 ]\n\t];\n\n\tvar faces = [\n\t\t[ 0, 2, 4 ], [ 0, 4, 3 ], [ 0, 3, 5 ], [ 0, 5, 2 ], [ 1, 2, 5 ], [ 1, 5, 3 ], [ 1, 3, 4 ], [ 1, 4, 2 ]\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\n};\n\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author timothypratley / https://github.com/timothypratley\n */\n\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\n\n\tvar vertices = [\n\t\t[ 1,  1,  1 ], [ -1, -1, 1 ], [ -1, 1, -1 ], [ 1, -1, -1 ]\n\t];\n\n\tvar faces = [\n\t\t[ 2, 1, 0 ], [ 0, 3, 2 ], [ 1, 3, 0 ], [ 2, 3, 1 ]\n\t];\n\n\tTHREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );\n\n};\n\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author zz85 / https://github.com/zz85\n * Parametric Surfaces Geometry\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\n *\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\n *\n */\n\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\n\n\tTHREE.Geometry.call( this );\n\n\tvar verts = this.vertices;\n\tvar faces = this.faces;\n\tvar uvs = this.faceVertexUvs[ 0 ];\n\n\tvar i, il, j, p;\n\tvar u, v;\n\n\tvar stackCount = stacks + 1;\n\tvar sliceCount = slices + 1;\n\n\tfor ( i = 0; i <= stacks; i ++ ) {\n\n\t\tv = i / stacks;\n\n\t\tfor ( j = 0; j <= slices; j ++ ) {\n\n\t\t\tu = j / slices;\n\n\t\t\tp = func( u, v );\n\t\t\tverts.push( p );\n\n\t\t}\n\t}\n\n\tvar a, b, c, d;\n\tvar uva, uvb, uvc, uvd;\n\n\tfor ( i = 0; i < stacks; i ++ ) {\n\n\t\tfor ( j = 0; j < slices; j ++ ) {\n\n\t\t\ta = i * sliceCount + j;\n\t\t\tb = i * sliceCount + j + 1;\n\t\t\tc = (i + 1) * sliceCount + j + 1;\n\t\t\td = (i + 1) * sliceCount + j;\n\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\n\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\n\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\n\n\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\n\t\t\tuvs.push( [ uva, uvb, uvd ] );\n\n\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\n\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\n\n\t\t}\n\n\t}\n\n\t// console.log(this);\n\n\t// magic bullet\n\t// var diff = this.mergeVertices();\n\t// console.log('removed ', diff, ' vertices by merging');\n\n\tthis.computeCentroids();\n\tthis.computeFaceNormals();\n\tthis.computeVertexNormals();\n\n};\n\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\n/**\n * @author sroucheray / http://sroucheray.org/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.AxisHelper = function ( size ) {\n\n\tsize = size || 1;\n\n\tvar geometry = new THREE.Geometry();\n\n\tgeometry.vertices.push(\n\t\tnew THREE.Vector3(), new THREE.Vector3( size, 0, 0 ),\n\t\tnew THREE.Vector3(), new THREE.Vector3( 0, size, 0 ),\n\t\tnew THREE.Vector3(), new THREE.Vector3( 0, 0, size )\n\t);\n\n\tgeometry.colors.push(\n\t\tnew THREE.Color( 0xff0000 ), new THREE.Color( 0xffaa00 ),\n\t\tnew THREE.Color( 0x00ff00 ), new THREE.Color( 0xaaff00 ),\n\t\tnew THREE.Color( 0x0000ff ), new THREE.Color( 0x00aaff )\n\t);\n\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\n\n};\n\nTHREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n * @author zz85 / http://github.com/zz85\n * @author bhouston / http://exocortex.com\n *\n * Creates an arrow for visualizing directions\n *\n * Parameters:\n *  dir - Vector3\n *  origin - Vector3\n *  length - Number\n *  hex - color in hex value\n *  headLength - Number\n *  headWidth - Number\n */\n\nTHREE.ArrowHelper = function ( dir, origin, length, hex, headLength, headWidth ) {\n\n\t// dir is assumed to be normalized\n\n\tTHREE.Object3D.call( this );\n\n\tif ( hex === undefined ) hex = 0xffff00;\n\tif ( length === undefined ) length = 1;\n\tif ( headLength === undefined ) headLength = 0.2 * length;\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\tthis.position = origin;\n\n\tvar lineGeometry = new THREE.Geometry();\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );\n\tlineGeometry.vertices.push( new THREE.Vector3( 0, 1, 0 ) );\n\n\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: hex } ) );\n\tthis.line.matrixAutoUpdate = false;\n\tthis.add( this.line );\n\n\tvar coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );\n\tconeGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );\n\n\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: hex } ) );\n\tthis.cone.matrixAutoUpdate = false;\n\tthis.add( this.cone );\n\n\tthis.setDirection( dir );\n\tthis.setLength( length, headLength, headWidth );\n\n};\n\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.ArrowHelper.prototype.setDirection = function () {\n\n\tvar axis = new THREE.Vector3();\n\tvar radians;\n\n\treturn function ( dir ) {\n\n\t\t// dir is assumed to be normalized\n\n\t\tif ( dir.y > 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\n\n\t\t} else if ( dir.y < - 0.99999 ) {\n\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\n\n\t\t} else {\n\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\n\n\t\t\tradians = Math.acos( dir.y );\n\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\n\n\t\t}\n\n\t};\n\n}();\n\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\n\n\tif ( headLength === undefined ) headLength = 0.2 * length;\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\n\n\tthis.line.scale.set( 1, length, 1 );\n\tthis.line.updateMatrix();\n\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\n\tthis.cone.position.y = length;\n\tthis.cone.updateMatrix();\n\n};\n\nTHREE.ArrowHelper.prototype.setColor = function ( hex ) {\n\n\tthis.line.material.color.setHex( hex );\n\tthis.cone.material.color.setHex( hex );\n\n};\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.BoxHelper = function ( object ) {\n\n\t//   5____4\n\t// 1/___0/|\n\t// | 6__|_7\n\t// 2/___3/\n\n\tvar vertices = [\n\t\tnew THREE.Vector3(   1,   1,   1 ),\n\t\tnew THREE.Vector3( - 1,   1,   1 ),\n\t\tnew THREE.Vector3( - 1, - 1,   1 ),\n\t\tnew THREE.Vector3(   1, - 1,   1 ),\n\n\t\tnew THREE.Vector3(   1,   1, - 1 ),\n\t\tnew THREE.Vector3( - 1,   1, - 1 ),\n\t\tnew THREE.Vector3( - 1, - 1, - 1 ),\n\t\tnew THREE.Vector3(   1, - 1, - 1 )\n\t];\n\n\tthis.vertices = vertices;\n\n\t// TODO: Wouldn't be nice if Line had .segments?\n\n\tvar geometry = new THREE.Geometry();\n\tgeometry.vertices.push(\n\t\tvertices[ 0 ], vertices[ 1 ],\n\t\tvertices[ 1 ], vertices[ 2 ],\n\t\tvertices[ 2 ], vertices[ 3 ],\n\t\tvertices[ 3 ], vertices[ 0 ],\n\n\t\tvertices[ 4 ], vertices[ 5 ],\n\t\tvertices[ 5 ], vertices[ 6 ],\n\t\tvertices[ 6 ], vertices[ 7 ],\n\t\tvertices[ 7 ], vertices[ 4 ],\n\n\t\tvertices[ 0 ], vertices[ 4 ],\n\t\tvertices[ 1 ], vertices[ 5 ],\n\t\tvertices[ 2 ], vertices[ 6 ],\n\t\tvertices[ 3 ], vertices[ 7 ]\n\t);\n\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );\n\n\tif ( object !== undefined ) {\n\n\t\tthis.update( object );\n\n\t}\n\n};\n\nTHREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );\n\nTHREE.BoxHelper.prototype.update = function ( object ) {\n\n\tvar geometry = object.geometry;\n\n\tif ( geometry.boundingBox === null ) {\n\n\t\tgeometry.computeBoundingBox();\n\n\t}\n\n\tvar min = geometry.boundingBox.min;\n\tvar max = geometry.boundingBox.max;\n\tvar vertices = this.vertices;\n\n\tvertices[ 0 ].set( max.x, max.y, max.z );\n\tvertices[ 1 ].set( min.x, max.y, max.z );\n\tvertices[ 2 ].set( min.x, min.y, max.z );\n\tvertices[ 3 ].set( max.x, min.y, max.z );\n\tvertices[ 4 ].set( max.x, max.y, min.z );\n\tvertices[ 5 ].set( min.x, max.y, min.z );\n\tvertices[ 6 ].set( min.x, min.y, min.z );\n\tvertices[ 7 ].set( max.x, min.y, min.z );\n\n\tthis.geometry.computeBoundingSphere();\n\tthis.geometry.verticesNeedUpdate = true;\n\n\tthis.matrixAutoUpdate = false;\n\tthis.matrixWorld = object.matrixWorld;\n\n};\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\n// a helper to show the world-axis-aligned bounding box for an object\n\nTHREE.BoundingBoxHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0x888888;\n\n\tthis.object = object;\n\n\tthis.box = new THREE.Box3();\n\n\tTHREE.Mesh.call( this, new THREE.CubeGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\n\n};\n\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\n\nTHREE.BoundingBoxHelper.prototype.update = function () {\n\n\tthis.box.setFromObject( this.object );\n\n\tthis.box.size( this.scale );\n\n\tthis.box.center( this.position );\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n *\n *\t- shows frustum, line of sight and up of the camera\n *\t- suitable for fast updates\n * \t- based on frustum visualization in lightgl.js shadowmap example\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\n */\n\nTHREE.CameraHelper = function ( camera ) {\n\n\tvar geometry = new THREE.Geometry();\n\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\n\n\tvar pointMap = {};\n\n\t// colors\n\n\tvar hexFrustum = 0xffaa00;\n\tvar hexCone = 0xff0000;\n\tvar hexUp = 0x00aaff;\n\tvar hexTarget = 0xffffff;\n\tvar hexCross = 0x333333;\n\n\t// near\n\n\taddLine( \"n1\", \"n2\", hexFrustum );\n\taddLine( \"n2\", \"n4\", hexFrustum );\n\taddLine( \"n4\", \"n3\", hexFrustum );\n\taddLine( \"n3\", \"n1\", hexFrustum );\n\n\t// far\n\n\taddLine( \"f1\", \"f2\", hexFrustum );\n\taddLine( \"f2\", \"f4\", hexFrustum );\n\taddLine( \"f4\", \"f3\", hexFrustum );\n\taddLine( \"f3\", \"f1\", hexFrustum );\n\n\t// sides\n\n\taddLine( \"n1\", \"f1\", hexFrustum );\n\taddLine( \"n2\", \"f2\", hexFrustum );\n\taddLine( \"n3\", \"f3\", hexFrustum );\n\taddLine( \"n4\", \"f4\", hexFrustum );\n\n\t// cone\n\n\taddLine( \"p\", \"n1\", hexCone );\n\taddLine( \"p\", \"n2\", hexCone );\n\taddLine( \"p\", \"n3\", hexCone );\n\taddLine( \"p\", \"n4\", hexCone );\n\n\t// up\n\n\taddLine( \"u1\", \"u2\", hexUp );\n\taddLine( \"u2\", \"u3\", hexUp );\n\taddLine( \"u3\", \"u1\", hexUp );\n\n\t// target\n\n\taddLine( \"c\", \"t\", hexTarget );\n\taddLine( \"p\", \"c\", hexCross );\n\n\t// cross\n\n\taddLine( \"cn1\", \"cn2\", hexCross );\n\taddLine( \"cn3\", \"cn4\", hexCross );\n\n\taddLine( \"cf1\", \"cf2\", hexCross );\n\taddLine( \"cf3\", \"cf4\", hexCross );\n\n\tfunction addLine( a, b, hex ) {\n\n\t\taddPoint( a, hex );\n\t\taddPoint( b, hex );\n\n\t}\n\n\tfunction addPoint( id, hex ) {\n\n\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\tgeometry.colors.push( new THREE.Color( hex ) );\n\n\t\tif ( pointMap[ id ] === undefined ) {\n\n\t\t\tpointMap[ id ] = [];\n\n\t\t}\n\n\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\n\n\t}\n\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\n\n\tthis.camera = camera;\n\tthis.matrixWorld = camera.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.pointMap = pointMap;\n\n\tthis.update();\n\n};\n\nTHREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );\n\nTHREE.CameraHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\tvar camera = new THREE.Camera();\n\tvar projector = new THREE.Projector();\n\n\treturn function () {\n\n\t\tvar scope = this;\n\n\t\tvar w = 1, h = 1;\n\n\t\t// we need just camera projection matrix\n\t\t// world matrix must be identity\n\n\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\n\n\t\t// center / target\n\n\t\tsetPoint( \"c\", 0, 0, -1 );\n\t\tsetPoint( \"t\", 0, 0,  1 );\n\n\t\t// near\n\n\t\tsetPoint( \"n1\", -w, -h, -1 );\n\t\tsetPoint( \"n2\",  w, -h, -1 );\n\t\tsetPoint( \"n3\", -w,  h, -1 );\n\t\tsetPoint( \"n4\",  w,  h, -1 );\n\n\t\t// far\n\n\t\tsetPoint( \"f1\", -w, -h, 1 );\n\t\tsetPoint( \"f2\",  w, -h, 1 );\n\t\tsetPoint( \"f3\", -w,  h, 1 );\n\t\tsetPoint( \"f4\",  w,  h, 1 );\n\n\t\t// up\n\n\t\tsetPoint( \"u1\",  w * 0.7, h * 1.1, -1 );\n\t\tsetPoint( \"u2\", -w * 0.7, h * 1.1, -1 );\n\t\tsetPoint( \"u3\",        0, h * 2,   -1 );\n\n\t\t// cross\n\n\t\tsetPoint( \"cf1\", -w,  0, 1 );\n\t\tsetPoint( \"cf2\",  w,  0, 1 );\n\t\tsetPoint( \"cf3\",  0, -h, 1 );\n\t\tsetPoint( \"cf4\",  0,  h, 1 );\n\n\t\tsetPoint( \"cn1\", -w,  0, -1 );\n\t\tsetPoint( \"cn2\",  w,  0, -1 );\n\t\tsetPoint( \"cn3\",  0, -h, -1 );\n\t\tsetPoint( \"cn4\",  0,  h, -1 );\n\n\t\tfunction setPoint( point, x, y, z ) {\n\n\t\t\tvector.set( x, y, z );\n\t\t\tprojector.unprojectVector( vector, camera );\n\n\t\t\tvar points = scope.pointMap[ point ];\n\n\t\t\tif ( points !== undefined ) {\n\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\t\t\tscope.geometry.vertices[ points[ i ] ].copy( vector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.geometry.verticesNeedUpdate = true;\n\n\t};\n\n}();\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.DirectionalLightHelper = function ( light, size ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrixWorld = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tsize = size || 1;\n\tvar geometry = new THREE.PlaneGeometry( size, size );\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\tthis.lightPlane = new THREE.Mesh( geometry, material );\n\tthis.add( this.lightPlane );\n\n\tgeometry = new THREE.Geometry();\n\tgeometry.vertices.push( new THREE.Vector3() );\n\tgeometry.vertices.push( new THREE.Vector3() );\n\n\tmaterial = new THREE.LineBasicMaterial( { fog: false } );\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\tthis.targetLine = new THREE.Line( geometry, material );\n\tthis.add( this.targetLine );\n\n\tthis.update();\n\n};\n\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\n\t\n\tthis.lightPlane.geometry.dispose();\n\tthis.lightPlane.material.dispose();\n\tthis.targetLine.geometry.dispose();\n\tthis.targetLine.material.dispose();\n};\n\nTHREE.DirectionalLightHelper.prototype.update = function () {\n\n\tvar v1 = new THREE.Vector3();\n\tvar v2 = new THREE.Vector3();\n\tvar v3 = new THREE.Vector3();\n\n\treturn function () {\n\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\n\t\tv3.subVectors( v2, v1 );\n\n\t\tthis.lightPlane.lookAt( v3 );\n\t\tthis.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t\tthis.targetLine.geometry.vertices[ 1 ].copy( v3 );\n\t\tthis.targetLine.geometry.verticesNeedUpdate = true;\n\t\tthis.targetLine.material.color.copy( this.lightPlane.material.color );\n\n\t}\n\n}();\n\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n */\n\nTHREE.EdgesHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\n\tvar edge = [ 0, 0 ], hash = {};\n\tvar sortFunction = function ( a, b ) { return a - b };\n\n\tvar keys = [ 'a', 'b', 'c' ];\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar geometry2 = object.geometry.clone();\n\n\tgeometry2.mergeVertices();\n\tgeometry2.computeFaceNormals();\n\n\tvar vertices = geometry2.vertices;\n\tvar faces = geometry2.faces;\n\tvar numEdges = 0;\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar face = faces[ i ];\n\n\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\tedge.sort( sortFunction );\n\n\t\t\tvar key = edge.toString();\n\n\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\n\t\t\t\tnumEdges ++;\n\n\t\t\t} else {\n\n\t\t\t\thash[ key ].face2 = i;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tgeometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );\n\n\tvar coords = geometry.attributes.position.array;\n\n\tvar index = 0;\n\n\tfor ( var key in hash ) {\n\n\t\tvar h = hash[ key ];\n\n\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) < 0.9999 ) { // hardwired const OK\n\n\t\t\tvar vertex = vertices[ h.vert1 ];\n\t\t\tcoords[ index ++ ] = vertex.x;\n\t\t\tcoords[ index ++ ] = vertex.y;\n\t\t\tcoords[ index ++ ] = vertex.z;\n\n\t\t\tvertex = vertices[ h.vert2 ];\n\t\t\tcoords[ index ++ ] = vertex.x;\n\t\t\tcoords[ index ++ ] = vertex.y;\n\t\t\tcoords[ index ++ ] = vertex.z;\n\n\t\t}\n\n\t}\n\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );\n\n\tthis.matrixAutoUpdate = false;\n\tthis.matrixWorld = object.matrixWorld;\n\n};\n\nTHREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\tvar geometry = new THREE.Geometry();\n\n\tvar faces = this.object.geometry.faces;\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\tgeometry.vertices.push( new THREE.Vector3() );\n\n\t}\n\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.normalMatrix = new THREE.Matrix3();\n\n\tthis.update();\n\n};\n\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );\n\nTHREE.FaceNormalsHelper.prototype.update = ( function ( object ) {\n\n\tvar v1 = new THREE.Vector3();\n\n\treturn function ( object ) {\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tthis.normalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar vertices = this.geometry.vertices;\n\n\t\tvar faces = this.object.geometry.faces;\n\n\t\tvar worldMatrix = this.object.matrixWorld;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tv1.copy( face.normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );\n\n\t\t\tvar idx = 2 * i;\n\n\t\t\tvertices[ idx ].copy( face.centroid ).applyMatrix4( worldMatrix );\n\n\t\t\tvertices[ idx + 1 ].addVectors( vertices[ idx ], v1 );\n\n\t\t}\n\n\t\tthis.geometry.verticesNeedUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n}());\n\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.GridHelper = function ( size, step ) {\n\n\tvar geometry = new THREE.Geometry();\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\n\n\tthis.color1 = new THREE.Color( 0x444444 );\n\tthis.color2 = new THREE.Color( 0x888888 );\n\n\tfor ( var i = - size; i <= size; i += step ) {\n\n\t\tgeometry.vertices.push(\n\t\t\tnew THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),\n\t\t\tnew THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )\n\t\t);\n\n\t\tvar color = i === 0 ? this.color1 : this.color2;\n\n\t\tgeometry.colors.push( color, color, color, color );\n\n\t}\n\n\tTHREE.Line.call( this, geometry, material, THREE.LinePieces );\n\n};\n\nTHREE.GridHelper.prototype = Object.create( THREE.Line.prototype );\n\nTHREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {\n\n\tthis.color1.set( colorCenterLine );\n\tthis.color2.set( colorGrid );\n\n\tthis.geometry.colorsNeedUpdate = true;\n\n}\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrixWorld = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\n\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\n\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\n\n\tfor ( var i = 0, il = 8; i < il; i ++ ) {\n\n\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\n\n\t}\n\n\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\n\n\tthis.lightSphere = new THREE.Mesh( geometry, material );\n\tthis.add( this.lightSphere );\n\n\tthis.update();\n\n};\n\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\n\tthis.lightSphere.geometry.dispose();\n\tthis.lightSphere.material.dispose();\n};\n\nTHREE.HemisphereLightHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\n\treturn function () {\n\n\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\n\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\n\n\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\n\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\n\n\t}\n\n}();\n\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.PointLightHelper = function ( light, sphereSize ) {\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\tTHREE.Mesh.call( this, geometry, material );\n\n\tthis.matrixWorld = this.light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\t/*\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\n\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\n\n\tvar d = light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\n\tthis.add( this.lightDistance );\n\t*/\n\n};\n\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\n\nTHREE.PointLightHelper.prototype.dispose = function () {\n\t\n\tthis.geometry.dispose();\n\tthis.material.dispose();\n};\n\nTHREE.PointLightHelper.prototype.update = function () {\n\n\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t/*\n\tvar d = this.light.distance;\n\n\tif ( d === 0.0 ) {\n\n\t\tthis.lightDistance.visible = false;\n\n\t} else {\n\n\t\tthis.lightDistance.visible = true;\n\t\tthis.lightDistance.scale.set( d, d, d );\n\n\t}\n\t*/\n\n};\n\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.SpotLightHelper = function ( light ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.light = light;\n\tthis.light.updateMatrixWorld();\n\n\tthis.matrixWorld = light.matrixWorld;\n\tthis.matrixAutoUpdate = false;\n\n\tvar geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );\n\n\tgeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, -0.5, 0 ) );\n\tgeometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\n\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\n\t\n\tthis.cone = new THREE.Mesh( geometry, material );\n\tthis.add( this.cone );\n\n\tthis.update();\n\n};\n\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\n\nTHREE.SpotLightHelper.prototype.dispose = function () {\n\tthis.cone.geometry.dispose();\n\tthis.cone.material.dispose();\n};\n\nTHREE.SpotLightHelper.prototype.update = function () {\n\n\tvar vector = new THREE.Vector3();\n\tvar vector2 = new THREE.Vector3();\n\n\treturn function () {\n\n\t\tvar coneLength = this.light.distance ? this.light.distance : 10000;\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\n\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\n\n\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\n\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\n\n\t\tthis.cone.lookAt( vector2.sub( vector ) );\n\n\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\n\n\t};\n\n}();\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\tvar geometry = new THREE.Geometry();\n\n\tvar vertices = object.geometry.vertices;\n\n\tvar faces = object.geometry.faces;\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar face = faces[ i ];\n\n\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\n\t\t}\n\n\t}\n\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.normalMatrix = new THREE.Matrix3();\n\n\tthis.update();\n\n};\n\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );\n\nTHREE.VertexNormalsHelper.prototype.update = ( function ( object ) {\n\n\tvar v1 = new THREE.Vector3();\n\n\treturn function( object ) {\n\n\t\tvar keys = [ 'a', 'b', 'c', 'd' ];\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tthis.normalMatrix.getNormalMatrix( this.object.matrixWorld );\n\n\t\tvar vertices = this.geometry.vertices;\n\n\t\tvar verts = this.object.geometry.vertices;\n\n\t\tvar faces = this.object.geometry.faces;\n\n\t\tvar worldMatrix = this.object.matrixWorld;\n\n\t\tvar idx = 0;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\n\n\t\t\t\tvar vertexId = face[ keys[ j ] ];\n\t\t\t\tvar vertex = verts[ vertexId ];\n\n\t\t\t\tvar normal = face.vertexNormals[ j ];\n\n\t\t\t\tvertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\n\n\t\t\t\tv1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );\n\n\t\t\t\tv1.add( vertices[ idx ] );\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tvertices[ idx ].copy( v1 );\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.geometry.verticesNeedUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n}());\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n*/\n\nTHREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {\n\n\tthis.object = object;\n\n\tthis.size = ( size !== undefined ) ? size : 1;\n\n\tvar color = ( hex !== undefined ) ? hex : 0x0000ff;\n\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\n\n\tvar geometry = new THREE.Geometry();\n\n\tvar vertices = object.geometry.vertices;\n\n\tvar faces = object.geometry.faces;\n\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tvar face = faces[ i ];\n\n\t\tfor ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\n\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\n\n\t\t}\n\n\t}\n\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\n\n\tthis.matrixAutoUpdate = false;\n\n\tthis.update();\n\n};\n\nTHREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );\n\nTHREE.VertexTangentsHelper.prototype.update = ( function ( object ) {\n\n\tvar v1 = new THREE.Vector3();\n\n\treturn function( object ) {\n\n\t\tvar keys = [ 'a', 'b', 'c', 'd' ];\n\n\t\tthis.object.updateMatrixWorld( true );\n\n\t\tvar vertices = this.geometry.vertices;\n\n\t\tvar verts = this.object.geometry.vertices;\n\n\t\tvar faces = this.object.geometry.faces;\n\n\t\tvar worldMatrix = this.object.matrixWorld;\n\n\t\tvar idx = 0;\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\n\n\t\t\t\tvar vertexId = face[ keys[ j ] ];\n\t\t\t\tvar vertex = verts[ vertexId ];\n\n\t\t\t\tvar tangent = face.vertexTangents[ j ];\n\n\t\t\t\tvertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\n\n\t\t\t\tv1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );\n\n\t\t\t\tv1.add( vertices[ idx ] );\n\t\t\t\tidx = idx + 1;\n\n\t\t\t\tvertices[ idx ].copy( v1 );\n\t\t\t\tidx = idx + 1;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.geometry.verticesNeedUpdate = true;\n\n\t\treturn this;\n\n\t}\n\n}());\n\n/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.WireframeHelper = function ( object, hex ) {\n\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\n\n\tvar edge = [ 0, 0 ], hash = {};\n\tvar sortFunction = function ( a, b ) { return a - b };\n\n\tvar keys = [ 'a', 'b', 'c' ];\n\tvar geometry = new THREE.BufferGeometry();\n\n\tif ( object.geometry instanceof THREE.Geometry ) {\n\n\t\tvar vertices = object.geometry.vertices;\n\t\tvar faces = object.geometry.faces;\n\t\tvar numEdges = 0;\n\n\t\t// allocate maximal size\n\t\tvar edges = new Uint32Array( 6 * faces.length );\n\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\n\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\tvar key = edge.toString();\n\n\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );\n\n\t\tvar coords = geometry.attributes.position.array;\n\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j] ];\n\n\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\tcoords[ index + 0 ] = vertex.x;\n\t\t\t\tcoords[ index + 1 ] = vertex.y;\n\t\t\t\tcoords[ index + 2 ] = vertex.z;\n\n\t\t\t}\n\n\t\t}\n\n\t} else if ( object.geometry instanceof THREE.BufferGeometry && object.geometry.attributes.index !== undefined ) { // indexed BufferGeometry\n\n\t\tvar vertices = object.geometry.attributes.position.array;\n\t\tvar indices = object.geometry.attributes.index.array;\n\t\tvar offsets = object.geometry.offsets;\n\t\tvar numEdges = 0;\n\n\t\t// allocate maximal size\n\t\tvar edges = new Uint32Array( 2 * indices.length );\n\n\t\tfor ( var o = 0, ol = offsets.length; o < ol; ++ o ) {\n\n\t\t\tvar start = offsets[ o ].start;\n\t\t\tvar count = offsets[ o ].count;\n\t\t\tvar index = offsets[ o ].index;\n\n\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\n\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tedge[ 0 ] = index + indices[ i + j ];\n\t\t\t\t\tedge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];\n\t\t\t\t\tedge.sort( sortFunction );\n\n\t\t\t\t\tvar key = edge.toString();\n\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\n\n\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\n\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\n\t\t\t\t\t\thash[ key ] = true;\n\t\t\t\t\t\tnumEdges ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );\n\n\t\tvar coords = geometry.attributes.position.array;\n\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\n\n\t\t\t\tvar index = 6 * i + 3 * j;\n\t\t\t\tvar index2 = 3 * edges[ 2 * i + j];\n\t\t\t\tcoords[ index + 0 ] = vertices[ index2 ];\n\t\t\t\tcoords[ index + 1 ] = vertices[ index2 + 1 ];\n\t\t\t\tcoords[ index + 2 ] = vertices[ index2 + 2 ];\n\n\t\t\t}\n\n\t\t}\n\n\t} else if ( object.geometry instanceof THREE.BufferGeometry\t) { // non-indexed BufferGeometry\n\n\t\tvar vertices = object.geometry.attributes.position.array;\n\t\tvar numEdges = vertices.length / 3;\n\t\tvar numTris = numEdges / 3;\n\n\t\tgeometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );\n\n\t\tvar coords = geometry.attributes.position.array;\n\n\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\n\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\n\n\t\t\t\tvar index = 18 * i + 6 * j;\n\n\t\t\t\tvar index1 = 9 * i + 3 * j;\n\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\n\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\n\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\n\n\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\n\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\n\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\n\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tTHREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );\n\n\tthis.matrixAutoUpdate = false;\n\tthis.matrixWorld = object.matrixWorld;\n\n};\n\nTHREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ImmediateRenderObject = function () {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.render = function ( renderCallback ) { };\n\n};\n\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.lensFlares = [];\n\n\tthis.positionScreen = new THREE.Vector3();\n\tthis.customUpdateCallback = undefined;\n\n\tif( texture !== undefined ) {\n\n\t\tthis.add( texture, size, distance, blending, color );\n\n\t}\n\n};\n\nTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\n\n\n/*\n * Add: adds another flare\n */\n\nTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\n\n\tif( size === undefined ) size = -1;\n\tif( distance === undefined ) distance = 0;\n\tif( opacity === undefined ) opacity = 1;\n\tif( color === undefined ) color = new THREE.Color( 0xffffff );\n\tif( blending === undefined ) blending = THREE.NormalBlending;\n\n\tdistance = Math.min( distance, Math.max( 0, distance ) );\n\n\tthis.lensFlares.push( { texture: texture, \t\t\t// THREE.Texture\n\t\t                    size: size, \t\t\t\t// size in pixels (-1 = use texture.width)\n\t\t                    distance: distance, \t\t// distance (0-1) from light source (0=at light source)\n\t\t                    x: 0, y: 0, z: 0,\t\t\t// screen position (-1 => 1) z = 0 is ontop z = 1 is back\n\t\t                    scale: 1, \t\t\t\t\t// scale\n\t\t                    rotation: 1, \t\t\t\t// rotation\n\t\t                    opacity: opacity,\t\t\t// opacity\n\t\t\t\t\t\t\tcolor: color,\t\t\t\t// color\n\t\t                    blending: blending } );\t\t// blending\n\n};\n\n\n/*\n * Update lens flares update positions on all flares based on the screen position\n * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\n */\n\nTHREE.LensFlare.prototype.updateLensFlares = function () {\n\n\tvar f, fl = this.lensFlares.length;\n\tvar flare;\n\tvar vecX = -this.positionScreen.x * 2;\n\tvar vecY = -this.positionScreen.y * 2;\n\n\tfor( f = 0; f < fl; f ++ ) {\n\n\t\tflare = this.lensFlares[ f ];\n\n\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\n\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\n\n\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\n\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\n\n\t}\n\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.animationsMap = {};\r\n\tthis.animationsList = [];\r\n\r\n\t// prepare default animation\r\n\t// (all frames played together in 1 second)\r\n\r\n\tvar numFrames = this.geometry.morphTargets.length;\r\n\r\n\tvar name = \"__default\";\r\n\r\n\tvar startFrame = 0;\r\n\tvar endFrame = numFrames - 1;\r\n\r\n\tvar fps = numFrames / 1;\r\n\r\n\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\tthis.setAnimationWeight( name, 1 );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\r\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n\tvar animation = {\r\n\r\n\t\tstartFrame: start,\r\n\t\tendFrame: end,\r\n\r\n\t\tlength: end - start + 1,\r\n\r\n\t\tfps: fps,\r\n\t\tduration: ( end - start ) / fps,\r\n\r\n\t\tlastFrame: 0,\r\n\t\tcurrentFrame: 0,\r\n\r\n\t\tactive: false,\r\n\r\n\t\ttime: 0,\r\n\t\tdirection: 1,\r\n\t\tweight: 1,\r\n\r\n\t\tdirectionBackwards: false,\r\n\t\tmirroredLoop: false\r\n\r\n\t};\r\n\r\n\tthis.animationsMap[ name ] = animation;\r\n\tthis.animationsList.push( animation );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n\tvar pattern = /([a-z]+)(\\d+)/;\r\n\r\n\tvar firstAnimation, frameRanges = {};\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\tvar chunks = morph.name.match( pattern );\r\n\r\n\t\tif ( chunks && chunks.length > 1 ) {\r\n\r\n\t\t\tvar name = chunks[ 1 ];\r\n\t\t\tvar num = chunks[ 2 ];\r\n\r\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: -Infinity };\r\n\r\n\t\t\tvar range = frameRanges[ name ];\r\n\r\n\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\tif ( i > range.end ) range.end = i;\r\n\r\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var name in frameRanges ) {\r\n\r\n\t\tvar range = frameRanges[ name ];\r\n\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\r\n\t}\r\n\r\n\tthis.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = 1;\r\n\t\tanimation.directionBackwards = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = -1;\r\n\t\tanimation.directionBackwards = true;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.fps = fps;\r\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.duration = duration;\r\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.weight = weight;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = time;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n\tvar time = 0;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\ttime = animation.time;\r\n\r\n\t}\r\n\r\n\treturn time;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n\tvar duration = -1;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tduration = animation.duration;\r\n\r\n\t}\r\n\r\n\treturn duration;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = 0;\r\n\t\tanimation.active = true;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"animation[\" + name + \"] undefined\" );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.active = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n\t\tvar animation = this.animationsList[ i ];\r\n\r\n\t\tif ( ! animation.active ) continue;\r\n\r\n\t\tvar frameTime = animation.duration / animation.length;\r\n\r\n\t\tanimation.time += animation.direction * delta;\r\n\r\n\t\tif ( animation.mirroredLoop ) {\r\n\r\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n\t\t\t\tanimation.direction *= -1;\r\n\r\n\t\t\t\tif ( animation.time > animation.duration ) {\r\n\r\n\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( animation.time < 0 ) {\r\n\r\n\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tanimation.time = animation.time % animation.duration;\r\n\r\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n\t\t}\r\n\r\n\t\tvar keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\tvar weight = animation.weight;\r\n\r\n\t\tif ( keyframe !== animation.currentFrame ) {\r\n\r\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\tanimation.currentFrame = keyframe;\r\n\r\n\t\t}\r\n\r\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n\t}\r\n\r\n};\r\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.LensFlarePlugin = function () {\n\n\tvar _gl, _renderer, _precision, _lensFlare = {};\n\n\tthis.init = function ( renderer ) {\n\n\t\t_gl = renderer.context;\n\t\t_renderer = renderer;\n\n\t\t_precision = renderer.getPrecision();\n\n\t\t_lensFlare.vertices = new Float32Array( 8 + 8 );\n\t\t_lensFlare.faces = new Uint16Array( 6 );\n\n\t\tvar i = 0;\n\t\t_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = -1;\t// vertex\n\t\t_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 0;\t// uv... etc.\n\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = -1;\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 0;\n\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;\n\t\t_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;\n\n\t\t_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = 1;\n\t\t_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 1;\n\n\t\ti = 0;\n\t\t_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 1; _lensFlare.faces[ i++ ] = 2;\n\t\t_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 2; _lensFlare.faces[ i++ ] = 3;\n\n\t\t// buffers\n\n\t\t_lensFlare.vertexBuffer     = _gl.createBuffer();\n\t\t_lensFlare.elementBuffer    = _gl.createBuffer();\n\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );\n\t\t_gl.bufferData( _gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW );\n\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );\n\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW );\n\n\t\t// textures\n\n\t\t_lensFlare.tempTexture      = _gl.createTexture();\n\t\t_lensFlare.occlusionTexture = _gl.createTexture();\n\n\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\n\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );\n\n\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );\n\t\t_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );\n\t\t_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );\n\n\t\tif ( _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) <= 0 ) {\n\n\t\t\t_lensFlare.hasVertexTexture = false;\n\t\t\t_lensFlare.program = createProgram( THREE.ShaderFlares[ \"lensFlare\" ], _precision );\n\n\t\t} else {\n\n\t\t\t_lensFlare.hasVertexTexture = true;\n\t\t\t_lensFlare.program = createProgram( THREE.ShaderFlares[ \"lensFlareVertexTexture\" ], _precision );\n\n\t\t}\n\n\t\t_lensFlare.attributes = {};\n\t\t_lensFlare.uniforms = {};\n\n\t\t_lensFlare.attributes.vertex       = _gl.getAttribLocation ( _lensFlare.program, \"position\" );\n\t\t_lensFlare.attributes.uv           = _gl.getAttribLocation ( _lensFlare.program, \"uv\" );\n\n\t\t_lensFlare.uniforms.renderType     = _gl.getUniformLocation( _lensFlare.program, \"renderType\" );\n\t\t_lensFlare.uniforms.map            = _gl.getUniformLocation( _lensFlare.program, \"map\" );\n\t\t_lensFlare.uniforms.occlusionMap   = _gl.getUniformLocation( _lensFlare.program, \"occlusionMap\" );\n\t\t_lensFlare.uniforms.opacity        = _gl.getUniformLocation( _lensFlare.program, \"opacity\" );\n\t\t_lensFlare.uniforms.color          = _gl.getUniformLocation( _lensFlare.program, \"color\" );\n\t\t_lensFlare.uniforms.scale          = _gl.getUniformLocation( _lensFlare.program, \"scale\" );\n\t\t_lensFlare.uniforms.rotation       = _gl.getUniformLocation( _lensFlare.program, \"rotation\" );\n\t\t_lensFlare.uniforms.screenPosition = _gl.getUniformLocation( _lensFlare.program, \"screenPosition\" );\n\n\t};\n\n\n\t/*\n\t * Render lens flares\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\n\t *         reads these back and calculates occlusion.\n\t *         Then _lensFlare.update_lensFlares() is called to re-position and\n\t *         update transparency of flares. Then they are rendered.\n\t *\n\t */\n\n\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\n\n\t\tvar flares = scene.__webglFlares,\n\t\t\tnFlares = flares.length;\n\n\t\tif ( ! nFlares ) return;\n\n\t\tvar tempPosition = new THREE.Vector3();\n\n\t\tvar invAspect = viewportHeight / viewportWidth,\n\t\t\thalfViewportWidth = viewportWidth * 0.5,\n\t\t\thalfViewportHeight = viewportHeight * 0.5;\n\n\t\tvar size = 16 / viewportHeight,\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\n\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\n\n\t\tvar uniforms = _lensFlare.uniforms,\n\t\t\tattributes = _lensFlare.attributes;\n\n\t\t// set _lensFlare program and reset blending\n\n\t\t_gl.useProgram( _lensFlare.program );\n\n\t\t_gl.enableVertexAttribArray( _lensFlare.attributes.vertex );\n\t\t_gl.enableVertexAttribArray( _lensFlare.attributes.uv );\n\n\t\t// loop through all lens flares to update their occlusion and positions\n\t\t// setup gl and common used attribs/unforms\n\n\t\t_gl.uniform1i( uniforms.occlusionMap, 0 );\n\t\t_gl.uniform1i( uniforms.map, 1 );\n\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );\n\t\t_gl.vertexAttribPointer( attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0 );\n\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );\n\n\t\t_gl.disable( _gl.CULL_FACE );\n\t\t_gl.depthMask( false );\n\n\t\tvar i, j, jl, flare, sprite;\n\n\t\tfor ( i = 0; i < nFlares; i ++ ) {\n\n\t\t\tsize = 16 / viewportHeight;\n\t\t\tscale.set( size * invAspect, size );\n\n\t\t\t// calc object screen position\n\n\t\t\tflare = flares[ i ];\n\n\t\t\ttempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );\n\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\n\n\t\t\t// setup arrays for gl programs\n\n\t\t\tscreenPosition.copy( tempPosition )\n\n\t\t\tscreenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\n\t\t\tscreenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\n\n\t\t\t// screen cull\n\n\t\t\tif ( _lensFlare.hasVertexTexture || (\n\t\t\t\tscreenPositionPixels.x > 0 &&\n\t\t\t\tscreenPositionPixels.x < viewportWidth &&\n\t\t\t\tscreenPositionPixels.y > 0 &&\n\t\t\t\tscreenPositionPixels.y < viewportHeight ) ) {\n\n\t\t\t\t// save current RGB to temp texture\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE1 );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\n\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\n\n\n\t\t\t\t// render pink quad\n\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 0 );\n\t\t\t\t_gl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\n\t\t\t\t_gl.disable( _gl.BLEND );\n\t\t\t\t_gl.enable( _gl.DEPTH_TEST );\n\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// copy result to occlusionMap\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE0 );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );\n\t\t\t\t_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\n\n\n\t\t\t\t// restore graphics\n\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 1 );\n\t\t\t\t_gl.disable( _gl.DEPTH_TEST );\n\n\t\t\t\t_gl.activeTexture( _gl.TEXTURE1 );\n\t\t\t\t_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );\n\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\n\n\t\t\t\t// update object positions\n\n\t\t\t\tflare.positionScreen.copy( screenPosition )\n\n\t\t\t\tif ( flare.customUpdateCallback ) {\n\n\t\t\t\t\tflare.customUpdateCallback( flare );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tflare.updateLensFlares();\n\n\t\t\t\t}\n\n\t\t\t\t// render flares\n\n\t\t\t\t_gl.uniform1i( uniforms.renderType, 2 );\n\t\t\t\t_gl.enable( _gl.BLEND );\n\n\t\t\t\tfor ( j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\n\n\t\t\t\t\tsprite = flare.lensFlares[ j ];\n\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\n\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\n\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewportHeight;\n\n\t\t\t\t\t\tscale.x = size * invAspect;\n\t\t\t\t\t\tscale.y = size;\n\n\t\t\t\t\t\t_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\n\t\t\t\t\t\t_gl.uniform2f( uniforms.scale, scale.x, scale.y );\n\t\t\t\t\t\t_gl.uniform1f( uniforms.rotation, sprite.rotation );\n\n\t\t\t\t\t\t_gl.uniform1f( uniforms.opacity, sprite.opacity );\n\t\t\t\t\t\t_gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\n\n\t\t\t\t\t\t_renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\n\t\t\t\t\t\t_renderer.setTexture( sprite.texture, 1 );\n\n\t\t\t\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore gl\n\n\t\t_gl.enable( _gl.CULL_FACE );\n\t\t_gl.enable( _gl.DEPTH_TEST );\n\t\t_gl.depthMask( true );\n\n\t};\n\n\tfunction createProgram ( shader, precision ) {\n\n\t\tvar program = _gl.createProgram();\n\n\t\tvar fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );\n\t\tvar vertexShader = _gl.createShader( _gl.VERTEX_SHADER );\n\n\t\tvar prefix = \"precision \" + precision + \" float;\\n\";\n\n\t\t_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\n\t\t_gl.shaderSource( vertexShader, prefix + shader.vertexShader );\n\n\t\t_gl.compileShader( fragmentShader );\n\t\t_gl.compileShader( vertexShader );\n\n\t\t_gl.attachShader( program, fragmentShader );\n\t\t_gl.attachShader( program, vertexShader );\n\n\t\t_gl.linkProgram( program );\n\n\t\treturn program;\n\n\t};\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ShadowMapPlugin = function () {\n\n\tvar _gl,\n\t_renderer,\n\t_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\n\n\t_frustum = new THREE.Frustum(),\n\t_projScreenMatrix = new THREE.Matrix4(),\n\n\t_min = new THREE.Vector3(),\n\t_max = new THREE.Vector3(),\n\n\t_matrixPosition = new THREE.Vector3();\n\n\tthis.init = function ( renderer ) {\n\n\t\t_gl = renderer.context;\n\t\t_renderer = renderer;\n\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\n\n\t\t_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\n\t\t_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );\n\t\t_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );\n\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );\n\n\t\t_depthMaterial._shadowPass = true;\n\t\t_depthMaterialMorph._shadowPass = true;\n\t\t_depthMaterialSkin._shadowPass = true;\n\t\t_depthMaterialMorphSkin._shadowPass = true;\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( ! ( _renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate ) ) return;\n\n\t\tthis.update( scene, camera );\n\n\t};\n\n\tthis.update = function ( scene, camera ) {\n\n\t\tvar i, il, j, jl, n,\n\n\t\tshadowMap, shadowMatrix, shadowCamera,\n\t\tprogram, buffer, material,\n\t\twebglObject, object, light,\n\t\trenderList,\n\n\t\tlights = [],\n\t\tk = 0,\n\n\t\tfog = null;\n\n\t\t// set GL state for depth map\n\n\t\t_gl.clearColor( 1, 1, 1, 1 );\n\t\t_gl.disable( _gl.BLEND );\n\n\t\t_gl.enable( _gl.CULL_FACE );\n\t\t_gl.frontFace( _gl.CCW );\n\n\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\n\n\t\t\t_gl.cullFace( _gl.FRONT );\n\n\t\t} else {\n\n\t\t\t_gl.cullFace( _gl.BACK );\n\n\t\t}\n\n\t\t_renderer.setDepthTest( true );\n\n\t\t// preprocess lights\n\t\t// \t- skip lights that are not casting shadows\n\t\t//\t- create virtual lights for cascaded shadow maps\n\n\t\tfor ( i = 0, il = scene.__lights.length; i < il; i ++ ) {\n\n\t\t\tlight = scene.__lights[ i ];\n\n\t\t\tif ( ! light.castShadow ) continue;\n\n\t\t\tif ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {\n\n\t\t\t\tfor ( n = 0; n < light.shadowCascadeCount; n ++ ) {\n\n\t\t\t\t\tvar virtualLight;\n\n\t\t\t\t\tif ( ! light.shadowCascadeArray[ n ] ) {\n\n\t\t\t\t\t\tvirtualLight = createVirtualLight( light, n );\n\t\t\t\t\t\tvirtualLight.originalCamera = camera;\n\n\t\t\t\t\t\tvar gyro = new THREE.Gyroscope();\n\t\t\t\t\t\tgyro.position = light.shadowCascadeOffset;\n\n\t\t\t\t\t\tgyro.add( virtualLight );\n\t\t\t\t\t\tgyro.add( virtualLight.target );\n\n\t\t\t\t\t\tcamera.add( gyro );\n\n\t\t\t\t\t\tlight.shadowCascadeArray[ n ] = virtualLight;\n\n\t\t\t\t\t\tconsole.log( \"Created virtualLight\", virtualLight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvirtualLight = light.shadowCascadeArray[ n ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tupdateVirtualLight( light, n );\n\n\t\t\t\t\tlights[ k ] = virtualLight;\n\t\t\t\t\tk ++;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tlights[ k ] = light;\n\t\t\t\tk ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// render depth map\n\n\t\tfor ( i = 0, il = lights.length; i < il; i ++ ) {\n\n\t\t\tlight = lights[ i ];\n\n\t\t\tif ( ! light.shadowMap ) {\n\n\t\t\t\tvar shadowFilter = THREE.LinearFilter;\n\n\t\t\t\tif ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {\n\n\t\t\t\t\tshadowFilter = THREE.NearestFilter;\n\n\t\t\t\t}\n\n\t\t\t\tvar pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };\n\n\t\t\t\tlight.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );\n\t\t\t\tlight.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );\n\n\t\t\t\tlight.shadowMatrix = new THREE.Matrix4();\n\n\t\t\t}\n\n\t\t\tif ( ! light.shadowCamera ) {\n\n\t\t\t\tif ( light instanceof THREE.SpotLight ) {\n\n\t\t\t\t\tlight.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );\n\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\n\n\t\t\t\t\tlight.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( \"Unsupported light type for shadow\" );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tscene.add( light.shadowCamera );\n\n\t\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t\t}\n\n\t\t\tif ( light.shadowCameraVisible && ! light.cameraHelper ) {\n\n\t\t\t\tlight.cameraHelper = new THREE.CameraHelper( light.shadowCamera );\n\t\t\t\tlight.shadowCamera.add( light.cameraHelper );\n\n\t\t\t}\n\n\t\t\tif ( light.isVirtual && virtualLight.originalCamera == camera ) {\n\n\t\t\t\tupdateShadowCamera( camera, light );\n\n\t\t\t}\n\n\t\t\tshadowMap = light.shadowMap;\n\t\t\tshadowMatrix = light.shadowMatrix;\n\t\t\tshadowCamera = light.shadowCamera;\n\n\t\t\tshadowCamera.position.setFromMatrixPosition( light.matrixWorld );\n\t\t\t_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );\n\t\t\tshadowCamera.lookAt( _matrixPosition );\n\t\t\tshadowCamera.updateMatrixWorld();\n\n\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\n\n\t\t\tif ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;\n\t\t\tif ( light.shadowCameraVisible ) light.cameraHelper.update();\n\n\t\t\t// compute shadow matrix\n\n\t\t\tshadowMatrix.set( 0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t\t  0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t\t  0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t\t  0.0, 0.0, 0.0, 1.0 );\n\n\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\n\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\n\n\t\t\t// update camera matrices and frustum\n\n\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t\t// render shadow map\n\n\t\t\t_renderer.setRenderTarget( shadowMap );\n\t\t\t_renderer.clear();\n\n\t\t\t// set object matrices & frustum culling\n\n\t\t\trenderList = scene.__webglObjects;\n\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\t\twebglObject = renderList[ j ];\n\t\t\t\tobject = webglObject.object;\n\n\t\t\t\twebglObject.render = false;\n\n\t\t\t\tif ( object.visible && object.castShadow ) {\n\n\t\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\t\t\twebglObject.render = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// render regular objects\n\n\t\t\tvar objectMaterial, useMorphing, useSkinning;\n\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\t\twebglObject = renderList[ j ];\n\n\t\t\t\tif ( webglObject.render ) {\n\n\t\t\t\t\tobject = webglObject.object;\n\t\t\t\t\tbuffer = webglObject.buffer;\n\n\t\t\t\t\t// culling is overriden globally for all objects\n\t\t\t\t\t// while rendering depth map\n\n\t\t\t\t\t// need to deal with MeshFaceMaterial somehow\n\t\t\t\t\t// in that case just use the first of material.materials for now\n\t\t\t\t\t// (proper solution would require to break objects by materials\n\t\t\t\t\t//  similarly to regular rendering and then set corresponding\n\t\t\t\t\t//  depth materials per each chunk instead of just once per object)\n\n\t\t\t\t\tobjectMaterial = getObjectMaterial( object );\n\n\t\t\t\t\tuseMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\n\t\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\n\n\t\t\t\t\tif ( object.customDepthMaterial ) {\n\n\t\t\t\t\t\tmaterial = object.customDepthMaterial;\n\n\t\t\t\t\t} else if ( useSkinning ) {\n\n\t\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\n\n\t\t\t\t\t} else if ( useMorphing ) {\n\n\t\t\t\t\t\tmaterial = _depthMaterialMorph;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterial = _depthMaterial;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, scene.__lights, fog, material, buffer, object );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_renderer.renderBuffer( shadowCamera, scene.__lights, fog, material, buffer, object );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// set matrices and render immediate objects\n\n\t\t\trenderList = scene.__webglObjectsImmediate;\n\n\t\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\t\twebglObject = renderList[ j ];\n\t\t\t\tobject = webglObject.object;\n\n\t\t\t\tif ( object.visible && object.castShadow ) {\n\n\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\t\t_renderer.renderImmediateObject( shadowCamera, scene.__lights, fog, _depthMaterial, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore GL state\n\n\t\tvar clearColor = _renderer.getClearColor(),\n\t\tclearAlpha = _renderer.getClearAlpha();\n\n\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\n\t\t_gl.enable( _gl.BLEND );\n\n\t\tif ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\n\n\t\t\t_gl.cullFace( _gl.BACK );\n\n\t\t}\n\n\t};\n\n\tfunction createVirtualLight( light, cascade ) {\n\n\t\tvar virtualLight = new THREE.DirectionalLight();\n\n\t\tvirtualLight.isVirtual = true;\n\n\t\tvirtualLight.onlyShadow = true;\n\t\tvirtualLight.castShadow = true;\n\n\t\tvirtualLight.shadowCameraNear = light.shadowCameraNear;\n\t\tvirtualLight.shadowCameraFar = light.shadowCameraFar;\n\n\t\tvirtualLight.shadowCameraLeft = light.shadowCameraLeft;\n\t\tvirtualLight.shadowCameraRight = light.shadowCameraRight;\n\t\tvirtualLight.shadowCameraBottom = light.shadowCameraBottom;\n\t\tvirtualLight.shadowCameraTop = light.shadowCameraTop;\n\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\n\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\n\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\n\t\tvirtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];\n\t\tvirtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];\n\n\t\tvirtualLight.pointsWorld = [];\n\t\tvirtualLight.pointsFrustum = [];\n\n\t\tvar pointsWorld = virtualLight.pointsWorld,\n\t\t\tpointsFrustum = virtualLight.pointsFrustum;\n\n\t\tfor ( var i = 0; i < 8; i ++ ) {\n\n\t\t\tpointsWorld[ i ] = new THREE.Vector3();\n\t\t\tpointsFrustum[ i ] = new THREE.Vector3();\n\n\t\t}\n\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\n\n\t\tpointsFrustum[ 0 ].set( -1, -1, nearZ );\n\t\tpointsFrustum[ 1 ].set(  1, -1, nearZ );\n\t\tpointsFrustum[ 2 ].set( -1,  1, nearZ );\n\t\tpointsFrustum[ 3 ].set(  1,  1, nearZ );\n\n\t\tpointsFrustum[ 4 ].set( -1, -1, farZ );\n\t\tpointsFrustum[ 5 ].set(  1, -1, farZ );\n\t\tpointsFrustum[ 6 ].set( -1,  1, farZ );\n\t\tpointsFrustum[ 7 ].set(  1,  1, farZ );\n\n\t\treturn virtualLight;\n\n\t}\n\n\t// Synchronize virtual light with the original light\n\n\tfunction updateVirtualLight( light, cascade ) {\n\n\t\tvar virtualLight = light.shadowCascadeArray[ cascade ];\n\n\t\tvirtualLight.position.copy( light.position );\n\t\tvirtualLight.target.position.copy( light.target.position );\n\t\tvirtualLight.lookAt( virtualLight.target );\n\n\t\tvirtualLight.shadowCameraVisible = light.shadowCameraVisible;\n\t\tvirtualLight.shadowDarkness = light.shadowDarkness;\n\n\t\tvirtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\n\n\t\tvar nearZ = light.shadowCascadeNearZ[ cascade ];\n\t\tvar farZ = light.shadowCascadeFarZ[ cascade ];\n\n\t\tvar pointsFrustum = virtualLight.pointsFrustum;\n\n\t\tpointsFrustum[ 0 ].z = nearZ;\n\t\tpointsFrustum[ 1 ].z = nearZ;\n\t\tpointsFrustum[ 2 ].z = nearZ;\n\t\tpointsFrustum[ 3 ].z = nearZ;\n\n\t\tpointsFrustum[ 4 ].z = farZ;\n\t\tpointsFrustum[ 5 ].z = farZ;\n\t\tpointsFrustum[ 6 ].z = farZ;\n\t\tpointsFrustum[ 7 ].z = farZ;\n\n\t}\n\n\t// Fit shadow camera's ortho frustum to camera frustum\n\n\tfunction updateShadowCamera( camera, light ) {\n\n\t\tvar shadowCamera = light.shadowCamera,\n\t\t\tpointsFrustum = light.pointsFrustum,\n\t\t\tpointsWorld = light.pointsWorld;\n\n\t\t_min.set( Infinity, Infinity, Infinity );\n\t\t_max.set( -Infinity, -Infinity, -Infinity );\n\n\t\tfor ( var i = 0; i < 8; i ++ ) {\n\n\t\t\tvar p = pointsWorld[ i ];\n\n\t\t\tp.copy( pointsFrustum[ i ] );\n\t\t\tTHREE.ShadowMapPlugin.__projector.unprojectVector( p, camera );\n\n\t\t\tp.applyMatrix4( shadowCamera.matrixWorldInverse );\n\n\t\t\tif ( p.x < _min.x ) _min.x = p.x;\n\t\t\tif ( p.x > _max.x ) _max.x = p.x;\n\n\t\t\tif ( p.y < _min.y ) _min.y = p.y;\n\t\t\tif ( p.y > _max.y ) _max.y = p.y;\n\n\t\t\tif ( p.z < _min.z ) _min.z = p.z;\n\t\t\tif ( p.z > _max.z ) _max.z = p.z;\n\n\t\t}\n\n\t\tshadowCamera.left = _min.x;\n\t\tshadowCamera.right = _max.x;\n\t\tshadowCamera.top = _max.y;\n\t\tshadowCamera.bottom = _min.y;\n\n\t\t// can't really fit near/far\n\t\t//shadowCamera.near = _min.z;\n\t\t//shadowCamera.far = _max.z;\n\n\t\tshadowCamera.updateProjectionMatrix();\n\n\t}\n\n\t// For the moment just ignore objects that have multiple materials with different animation methods\n\t// Only the first material will be taken into account for deciding which depth material to use for shadow maps\n\n\tfunction getObjectMaterial( object ) {\n\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\n\t\t\t? object.material.materials[ 0 ]\n\t\t\t: object.material;\n\n\t};\n\n};\n\nTHREE.ShadowMapPlugin.__projector = new THREE.Projector();\n\n/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SpritePlugin = function () {\n\n\tvar _gl, _renderer, _texture;\n\n\tvar vertices, faces, vertexBuffer, elementBuffer;\n\tvar program, attributes, uniforms;\n\n\tthis.init = function ( renderer ) {\n\n\t\t_gl = renderer.context;\n\t\t_renderer = renderer;\n\n\t\tvertices = new Float32Array( [\n\t\t\t- 0.5, - 0.5, 0, 0, \n\t\t\t  0.5, - 0.5, 1, 0,\n\t\t\t  0.5,   0.5, 1, 1,\n\t\t\t- 0.5,   0.5, 0, 1\n\t\t] );\n\n\t\tfaces = new Uint16Array( [\n\t\t\t0, 1, 2,\n\t\t\t0, 2, 3\n\t\t] );\n\n\t\tvertexBuffer  = _gl.createBuffer();\n\t\telementBuffer = _gl.createBuffer();\n\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );\n\t\t_gl.bufferData( _gl.ARRAY_BUFFER, vertices, _gl.STATIC_DRAW );\n\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\t\t_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faces, _gl.STATIC_DRAW );\n\n\t\tprogram = createProgram();\n\n\t\tattributes = {\n\t\t\tposition:\t\t\t_gl.getAttribLocation ( program, 'position' ),\n\t\t\tuv:\t\t\t\t\t_gl.getAttribLocation ( program, 'uv' )\n\t\t};\n\n\t\tuniforms = {\n\t\t\tuvOffset:\t\t\t_gl.getUniformLocation( program, 'uvOffset' ),\n\t\t\tuvScale:\t\t\t_gl.getUniformLocation( program, 'uvScale' ),\n\n\t\t\trotation:\t\t\t_gl.getUniformLocation( program, 'rotation' ),\n\t\t\tscale:\t\t\t\t_gl.getUniformLocation( program, 'scale' ),\n\n\t\t\tcolor:\t\t\t\t_gl.getUniformLocation( program, 'color' ),\n\t\t\tmap:\t\t\t\t_gl.getUniformLocation( program, 'map' ),\n\t\t\topacity:\t\t\t_gl.getUniformLocation( program, 'opacity' ),\n\n\t\t\tmodelViewMatrix: \t_gl.getUniformLocation( program, 'modelViewMatrix' ),\n\t\t\tprojectionMatrix:\t_gl.getUniformLocation( program, 'projectionMatrix' ),\n\n\t\t\tfogType:\t\t\t_gl.getUniformLocation( program, 'fogType' ),\n\t\t\tfogDensity:\t\t\t_gl.getUniformLocation( program, 'fogDensity' ),\n\t\t\tfogNear:\t\t\t_gl.getUniformLocation( program, 'fogNear' ),\n\t\t\tfogFar:\t\t\t\t_gl.getUniformLocation( program, 'fogFar' ),\n\t\t\tfogColor:\t\t\t_gl.getUniformLocation( program, 'fogColor' ),\n\n\t\t\talphaTest:\t\t\t_gl.getUniformLocation( program, 'alphaTest' )\n\t\t};\n\n\t\tvar canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = 8;\n\t\tcanvas.height = 8;\n\n\t\tvar context = canvas.getContext( '2d' );\n\t\tcontext.fillStyle = '#ffffff';\n\t\tcontext.fillRect( 0, 0, canvas.width, canvas.height );\n\n\t\t_texture = new THREE.Texture( canvas );\n\t\t_texture.needsUpdate = true;\n\n\t};\n\n\tthis.render = function ( scene, camera, viewportWidth, viewportHeight ) {\n\n\t\tvar sprites = scene.__webglSprites,\n\t\t\tnSprites = sprites.length;\n\n\t\tif ( ! nSprites ) return;\n\n\t\t// setup gl\n\n\t\t_gl.useProgram( program );\n\n\t\t_gl.enableVertexAttribArray( attributes.position );\n\t\t_gl.enableVertexAttribArray( attributes.uv );\n\n\t\t_gl.disable( _gl.CULL_FACE );\n\t\t_gl.enable( _gl.BLEND );\n\n\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );\n\t\t_gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );\n\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );\n\n\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\n\n\t\t_gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\n\n\t\t_gl.activeTexture( _gl.TEXTURE0 );\n\t\t_gl.uniform1i( uniforms.map, 0 );\n\n\t\tvar oldFogType = 0;\n\t\tvar sceneFogType = 0;\n\t\tvar fog = scene.fog;\n\n\t\tif ( fog ) {\n\n\t\t\t_gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\n\n\t\t\tif ( fog instanceof THREE.Fog ) {\n\n\t\t\t\t_gl.uniform1f( uniforms.fogNear, fog.near );\n\t\t\t\t_gl.uniform1f( uniforms.fogFar, fog.far );\n\n\t\t\t\t_gl.uniform1i( uniforms.fogType, 1 );\n\t\t\t\toldFogType = 1;\n\t\t\t\tsceneFogType = 1;\n\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\n\n\t\t\t\t_gl.uniform1f( uniforms.fogDensity, fog.density );\n\n\t\t\t\t_gl.uniform1i( uniforms.fogType, 2 );\n\t\t\t\toldFogType = 2;\n\t\t\t\tsceneFogType = 2;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t_gl.uniform1i( uniforms.fogType, 0 );\n\t\t\toldFogType = 0;\n\t\t\tsceneFogType = 0;\n\n\t\t}\n\n\n\t\t// update positions and sort\n\n\t\tvar i, sprite, material, fogType, scale = [];\n\n\t\tfor( i = 0; i < nSprites; i ++ ) {\n\n\t\t\tsprite = sprites[ i ];\n\t\t\tmaterial = sprite.material;\n\n\t\t\tif ( sprite.visible === false ) continue;\n\n\t\t\tsprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\n\t\t\tsprite.z = - sprite._modelViewMatrix.elements[ 14 ];\n\n\t\t}\n\n\t\tsprites.sort( painterSortStable );\n\n\t\t// render all sprites\n\n\t\tfor( i = 0; i < nSprites; i ++ ) {\n\n\t\t\tsprite = sprites[ i ];\n\n\t\t\tif ( sprite.visible === false ) continue;\n\n\t\t\tmaterial = sprite.material;\n\n\t\t\t_gl.uniform1f( uniforms.alphaTest, material.alphaTest );\n\t\t\t_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );\n\n\t\t\tscale[ 0 ] = sprite.scale.x;\n\t\t\tscale[ 1 ] = sprite.scale.y;\n\n\t\t\tif ( scene.fog && material.fog ) {\n\n\t\t\t\tfogType = sceneFogType;\n\n\t\t\t} else {\n\n\t\t\t\tfogType = 0;\n\n\t\t\t}\n\n\t\t\tif ( oldFogType !== fogType ) {\n\n\t\t\t\t_gl.uniform1i( uniforms.fogType, fogType );\n\t\t\t\toldFogType = fogType;\n\n\t\t\t}\n\n\t\t\tif ( material.map !== null ) {\n\n\t\t\t\t_gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\n\t\t\t\t_gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\n\n\t\t\t} else {\n\n\t\t\t\t_gl.uniform2f( uniforms.uvOffset, 0, 0 );\n\t\t\t\t_gl.uniform2f( uniforms.uvScale, 1, 1 );\n\n\t\t\t}\n\n\t\t\t_gl.uniform1f( uniforms.opacity, material.opacity );\n\t\t\t_gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\n\n\t\t\t_gl.uniform1f( uniforms.rotation, material.rotation );\n\t\t\t_gl.uniform2fv( uniforms.scale, scale );\n\n\t\t\t_renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\n\t\t\t_renderer.setDepthTest( material.depthTest );\n\t\t\t_renderer.setDepthWrite( material.depthWrite );\n\n\t\t\tif ( material.map && material.map.image && material.map.image.width ) {\n\n\t\t\t\t_renderer.setTexture( material.map, 0 );\n\n\t\t\t} else {\n\n\t\t\t\t_renderer.setTexture( _texture, 0 );\n\n\t\t\t}\n\n\t\t\t_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );\n\n\t\t}\n\n\t\t// restore gl\n\n\t\t_gl.enable( _gl.CULL_FACE );\n\n\t};\n\n\tfunction createProgram () {\n\n\t\tvar program = _gl.createProgram();\n\n\t\tvar vertexShader = _gl.createShader( _gl.VERTEX_SHADER );\n\t\tvar fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );\n\n\t\t_gl.shaderSource( vertexShader, [\n\n\t\t\t'precision ' + _renderer.getPrecision() + ' float;',\n\n\t\t\t'uniform mat4 modelViewMatrix;',\n\t\t\t'uniform mat4 projectionMatrix;',\n\t\t\t'uniform float rotation;',\n\t\t\t'uniform vec2 scale;',\n\t\t\t'uniform vec2 uvOffset;',\n\t\t\t'uniform vec2 uvScale;',\n\n\t\t\t'attribute vec2 position;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t\t'vUV = uvOffset + uv * uvScale;',\n\n\t\t\t\t'vec2 alignedPosition = position * scale;',\n\n\t\t\t\t'vec2 rotatedPosition;',\n\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\n\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\n\n\t\t\t\t'vec4 finalPosition;',\n\n\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\n\t\t\t\t'finalPosition.xy += rotatedPosition;',\n\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\n\n\t\t\t\t'gl_Position = finalPosition;',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ) );\n\n\t\t_gl.shaderSource( fragmentShader, [\n\n\t\t\t'precision ' + _renderer.getPrecision() + ' float;',\n\n\t\t\t'uniform vec3 color;',\n\t\t\t'uniform sampler2D map;',\n\t\t\t'uniform float opacity;',\n\n\t\t\t'uniform int fogType;',\n\t\t\t'uniform vec3 fogColor;',\n\t\t\t'uniform float fogDensity;',\n\t\t\t'uniform float fogNear;',\n\t\t\t'uniform float fogFar;',\n\t\t\t'uniform float alphaTest;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t\t'vec4 texture = texture2D( map, vUV );',\n\n\t\t\t\t'if ( texture.a < alphaTest ) discard;',\n\n\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\n\n\t\t\t\t'if ( fogType > 0 ) {',\n\n\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\n\t\t\t\t\t'float fogFactor = 0.0;',\n\n\t\t\t\t\t'if ( fogType == 1 ) {',\n\n\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\n\n\t\t\t\t\t'} else {',\n\n\t\t\t\t\t\t'const float LOG2 = 1.442695;',\n\t\t\t\t\t\t'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\n\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\n\n\t\t\t\t\t'}',\n\n\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\n\n\t\t\t\t'}',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ) );\n\n\t\t_gl.compileShader( vertexShader );\n\t\t_gl.compileShader( fragmentShader );\n\n\t\t_gl.attachShader( program, vertexShader );\n\t\t_gl.attachShader( program, fragmentShader );\n\n\t\t_gl.linkProgram( program );\n\n\t\treturn program;\n\n\t};\n\n\tfunction painterSortStable ( a, b ) {\n\n\t\tif ( a.z !== b.z ) {\n\n\t\t\treturn b.z - a.z;\n\n\t\t} else {\n\n\t\t\treturn b.id - a.id;\n\n\t\t}\n\n\t};\n\n};\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DepthPassPlugin = function () {\n\n\tthis.enabled = false;\n\tthis.renderTarget = null;\n\n\tvar _gl,\n\t_renderer,\n\t_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\n\n\t_frustum = new THREE.Frustum(),\n\t_projScreenMatrix = new THREE.Matrix4();\n\n\tthis.init = function ( renderer ) {\n\n\t\t_gl = renderer.context;\n\t\t_renderer = renderer;\n\n\t\tvar depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\n\t\tvar depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\n\n\t\t_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );\n\t\t_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );\n\t\t_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );\n\t\t_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );\n\n\t\t_depthMaterial._shadowPass = true;\n\t\t_depthMaterialMorph._shadowPass = true;\n\t\t_depthMaterialSkin._shadowPass = true;\n\t\t_depthMaterialMorphSkin._shadowPass = true;\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tif ( ! this.enabled ) return;\n\n\t\tthis.update( scene, camera );\n\n\t};\n\n\tthis.update = function ( scene, camera ) {\n\n\t\tvar i, il, j, jl, n,\n\n\t\tprogram, buffer, material,\n\t\twebglObject, object, light,\n\t\trenderList,\n\n\t\tfog = null;\n\n\t\t// set GL state for depth map\n\n\t\t_gl.clearColor( 1, 1, 1, 1 );\n\t\t_gl.disable( _gl.BLEND );\n\n\t\t_renderer.setDepthTest( true );\n\n\t\t// update scene\n\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\n\n\t\t// update camera matrices and frustum\n\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\n\n\t\t// render depth map\n\n\t\t_renderer.setRenderTarget( this.renderTarget );\n\t\t_renderer.clear();\n\n\t\t// set object matrices & frustum culling\n\n\t\trenderList = scene.__webglObjects;\n\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\twebglObject = renderList[ j ];\n\t\t\tobject = webglObject.object;\n\n\t\t\twebglObject.render = false;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tif ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {\n\n\t\t\t\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\t\twebglObject.render = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// render regular objects\n\n\t\tvar objectMaterial, useMorphing, useSkinning;\n\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\twebglObject = renderList[ j ];\n\n\t\t\tif ( webglObject.render ) {\n\n\t\t\t\tobject = webglObject.object;\n\t\t\t\tbuffer = webglObject.buffer;\n\n\t\t\t\t// todo: create proper depth material for particles\n\n\t\t\t\tif ( object instanceof THREE.ParticleSystem && !object.customDepthMaterial ) continue;\n\n\t\t\t\tobjectMaterial = getObjectMaterial( object );\n\n\t\t\t\tif ( objectMaterial ) _renderer.setMaterialFaces( object.material );\n\n\t\t\t\tuseMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\n\t\t\t\tuseSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\n\n\t\t\t\tif ( object.customDepthMaterial ) {\n\n\t\t\t\t\tmaterial = object.customDepthMaterial;\n\n\t\t\t\t} else if ( useSkinning ) {\n\n\t\t\t\t\tmaterial = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\n\n\t\t\t\t} else if ( useMorphing ) {\n\n\t\t\t\t\tmaterial = _depthMaterialMorph;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterial = _depthMaterial;\n\n\t\t\t\t}\n\n\t\t\t\tif ( buffer instanceof THREE.BufferGeometry ) {\n\n\t\t\t\t\t_renderer.renderBufferDirect( camera, scene.__lights, fog, material, buffer, object );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_renderer.renderBuffer( camera, scene.__lights, fog, material, buffer, object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// set matrices and render immediate objects\n\n\t\trenderList = scene.__webglObjectsImmediate;\n\n\t\tfor ( j = 0, jl = renderList.length; j < jl; j ++ ) {\n\n\t\t\twebglObject = renderList[ j ];\n\t\t\tobject = webglObject.object;\n\n\t\t\tif ( object.visible ) {\n\n\t\t\t\tobject._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\n\n\t\t\t\t_renderer.renderImmediateObject( camera, scene.__lights, fog, _depthMaterial, object );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// restore GL state\n\n\t\tvar clearColor = _renderer.getClearColor(),\n\t\tclearAlpha = _renderer.getClearAlpha();\n\n\t\t_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\n\t\t_gl.enable( _gl.BLEND );\n\n\t};\n\n\t// For the moment just ignore objects that have multiple materials with different animation methods\n\t// Only the first material will be taken into account for deciding which depth material to use\n\n\tfunction getObjectMaterial( object ) {\n\n\t\treturn object.material instanceof THREE.MeshFaceMaterial\n\t\t\t? object.material.materials[ 0 ]\n\t\t\t: object.material;\n\n\t};\n\n};\n\n\n/**\n * @author mikael emtinger / http://gomo.se/\n */\n\nTHREE.ShaderFlares = {\n\n\t'lensFlareVertexTexture': {\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\"uniform vec2 scale;\",\n\t\t\t\"uniform float rotation;\",\n\n\t\t\t\"uniform sampler2D occlusionMap;\",\n\n\t\t\t\"attribute vec2 position;\",\n\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\"if( renderType == 2 ) {\",\n\n\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\n\n\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\n\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\n\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\n\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\n\n\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\"uniform sampler2D map;\",\n\t\t\t\"uniform float opacity;\",\n\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\t\t\t\"varying float vVisibility;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t// pink square\n\n\t\t\t\t\"if( renderType == 0 ) {\",\n\n\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\n\n\t\t\t\t// restore\n\n\t\t\t\t\"} else if( renderType == 1 ) {\",\n\n\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t// flare\n\n\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\n\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\"\n\t\t].join( \"\\n\" )\n\n\t},\n\n\n\t'lensFlare': {\n\n\t\tvertexShader: [\n\n\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\"uniform vec3 screenPosition;\",\n\t\t\t\"uniform vec2 scale;\",\n\t\t\t\"uniform float rotation;\",\n\n\t\t\t\"attribute vec2 position;\",\n\t\t\t\"attribute vec2 uv;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t\"vUV = uv;\",\n\n\t\t\t\t\"vec2 pos = position;\",\n\n\t\t\t\t\"if( renderType == 2 ) {\",\n\n\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\n\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" ),\n\n\t\tfragmentShader: [\n\n\t\t\t\"precision mediump float;\",\n\n\t\t\t\"uniform lowp int renderType;\",\n\n\t\t\t\"uniform sampler2D map;\",\n\t\t\t\"uniform sampler2D occlusionMap;\",\n\t\t\t\"uniform float opacity;\",\n\t\t\t\"uniform vec3 color;\",\n\n\t\t\t\"varying vec2 vUV;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\t// pink square\n\n\t\t\t\t\"if( renderType == 0 ) {\",\n\n\t\t\t\t\t\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\n\n\t\t\t\t// restore\n\n\t\t\t\t\"} else if( renderType == 1 ) {\",\n\n\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\n\n\t\t\t\t// flare\n\n\t\t\t\t\"} else {\",\n\n\t\t\t\t\t\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\",\n\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\n\t\t\t\t\t\"visibility = ( 1.0 - visibility / 4.0 );\",\n\n\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\n\t\t\t\t\t\"texture.a *= opacity * visibility;\",\n\t\t\t\t\t\"gl_FragColor = texture;\",\n\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\n\n\t\t\t\t\"}\",\n\n\t\t\t\"}\"\n\n\t\t].join( \"\\n\" )\n\n\t}\n\n};\n\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "three.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-three",
      "url": "/js/three.js",
      "urls": [
        "/js/three.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/three.min.js",
      "relativePath": "js/three.min.js",
      "basename": "three",
      "outBasename": "three",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "min",
        "js"
      ],
      "filename": "three.min.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/three.min.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js",
      "outFilename": "three.min.js",
      "relativeOutPath": "js/three.min.js",
      "relativeDirPath": "js",
      "relativeOutDirPath": "js",
      "relativeBase": "js/three",
      "relativeOutBase": "js/three",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.552Z",
      "exists": true,
      "encoding": "utf8",
      "source": "// three.js - http://github.com/mrdoob/three.js\n'use strict';var THREE={REVISION:\"65\"};self.console=self.console||{info:function(){},log:function(){},debug:function(){},warn:function(){},error:function(){}};String.prototype.trim=String.prototype.trim||function(){return this.replace(/^\\s+|\\s+$/g,\"\")};THREE.extend=function(a,b){if(Object.keys)for(var c=Object.keys(b),d=0,e=c.length;d<e;d++){var f=c[d];Object.defineProperty(a,f,Object.getOwnPropertyDescriptor(b,f))}else for(f in c={}.hasOwnProperty,b)c.call(b,f)&&(a[f]=b[f]);return a};\n(function(){for(var a=0,b=[\"ms\",\"moz\",\"webkit\",\"o\"],c=0;c<b.length&&!self.requestAnimationFrame;++c)self.requestAnimationFrame=self[b[c]+\"RequestAnimationFrame\"],self.cancelAnimationFrame=self[b[c]+\"CancelAnimationFrame\"]||self[b[c]+\"CancelRequestAnimationFrame\"];void 0===self.requestAnimationFrame&&void 0!==self.setTimeout&&(self.requestAnimationFrame=function(b){var c=Date.now(),f=Math.max(0,16-(c-a)),g=self.setTimeout(function(){b(c+f)},f);a=c+f;return g});void 0===self.cancelAnimationFrame&&void 0!==\nself.clearTimeout&&(self.cancelAnimationFrame=function(a){self.clearTimeout(a)})})();THREE.CullFaceNone=0;THREE.CullFaceBack=1;THREE.CullFaceFront=2;THREE.CullFaceFrontBack=3;THREE.FrontFaceDirectionCW=0;THREE.FrontFaceDirectionCCW=1;THREE.BasicShadowMap=0;THREE.PCFShadowMap=1;THREE.PCFSoftShadowMap=2;THREE.FrontSide=0;THREE.BackSide=1;THREE.DoubleSide=2;THREE.NoShading=0;THREE.FlatShading=1;THREE.SmoothShading=2;THREE.NoColors=0;THREE.FaceColors=1;THREE.VertexColors=2;THREE.NoBlending=0;\nTHREE.NormalBlending=1;THREE.AdditiveBlending=2;THREE.SubtractiveBlending=3;THREE.MultiplyBlending=4;THREE.CustomBlending=5;THREE.AddEquation=100;THREE.SubtractEquation=101;THREE.ReverseSubtractEquation=102;THREE.ZeroFactor=200;THREE.OneFactor=201;THREE.SrcColorFactor=202;THREE.OneMinusSrcColorFactor=203;THREE.SrcAlphaFactor=204;THREE.OneMinusSrcAlphaFactor=205;THREE.DstAlphaFactor=206;THREE.OneMinusDstAlphaFactor=207;THREE.DstColorFactor=208;THREE.OneMinusDstColorFactor=209;\nTHREE.SrcAlphaSaturateFactor=210;THREE.MultiplyOperation=0;THREE.MixOperation=1;THREE.AddOperation=2;THREE.UVMapping=function(){};THREE.CubeReflectionMapping=function(){};THREE.CubeRefractionMapping=function(){};THREE.SphericalReflectionMapping=function(){};THREE.SphericalRefractionMapping=function(){};THREE.RepeatWrapping=1E3;THREE.ClampToEdgeWrapping=1001;THREE.MirroredRepeatWrapping=1002;THREE.NearestFilter=1003;THREE.NearestMipMapNearestFilter=1004;THREE.NearestMipMapLinearFilter=1005;\nTHREE.LinearFilter=1006;THREE.LinearMipMapNearestFilter=1007;THREE.LinearMipMapLinearFilter=1008;THREE.UnsignedByteType=1009;THREE.ByteType=1010;THREE.ShortType=1011;THREE.UnsignedShortType=1012;THREE.IntType=1013;THREE.UnsignedIntType=1014;THREE.FloatType=1015;THREE.UnsignedShort4444Type=1016;THREE.UnsignedShort5551Type=1017;THREE.UnsignedShort565Type=1018;THREE.AlphaFormat=1019;THREE.RGBFormat=1020;THREE.RGBAFormat=1021;THREE.LuminanceFormat=1022;THREE.LuminanceAlphaFormat=1023;\nTHREE.RGB_S3TC_DXT1_Format=2001;THREE.RGBA_S3TC_DXT1_Format=2002;THREE.RGBA_S3TC_DXT3_Format=2003;THREE.RGBA_S3TC_DXT5_Format=2004;THREE.Color=function(a){void 0!==a&&this.set(a);return this};\nTHREE.Color.prototype={constructor:THREE.Color,r:1,g:1,b:1,set:function(a){a instanceof THREE.Color?this.copy(a):\"number\"===typeof a?this.setHex(a):\"string\"===typeof a&&this.setStyle(a);return this},setHex:function(a){a=Math.floor(a);this.r=(a>>16&255)/255;this.g=(a>>8&255)/255;this.b=(a&255)/255;return this},setRGB:function(a,b,c){this.r=a;this.g=b;this.b=c;return this},setHSL:function(a,b,c){if(0===b)this.r=this.g=this.b=c;else{var d=function(a,b,c){0>c&&(c+=1);1<c&&(c-=1);return c<1/6?a+6*(b-a)*\nc:0.5>c?b:c<2/3?a+6*(b-a)*(2/3-c):a},b=0.5>=c?c*(1+b):c+b-c*b,c=2*c-b;this.r=d(c,b,a+1/3);this.g=d(c,b,a);this.b=d(c,b,a-1/3)}return this},setStyle:function(a){if(/^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.test(a))return a=/^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.exec(a),this.r=Math.min(255,parseInt(a[1],10))/255,this.g=Math.min(255,parseInt(a[2],10))/255,this.b=Math.min(255,parseInt(a[3],10))/255,this;if(/^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.test(a))return a=/^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.exec(a),this.r=\nMath.min(100,parseInt(a[1],10))/100,this.g=Math.min(100,parseInt(a[2],10))/100,this.b=Math.min(100,parseInt(a[3],10))/100,this;if(/^\\#([0-9a-f]{6})$/i.test(a))return a=/^\\#([0-9a-f]{6})$/i.exec(a),this.setHex(parseInt(a[1],16)),this;if(/^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a))return a=/^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a),this.setHex(parseInt(a[1]+a[1]+a[2]+a[2]+a[3]+a[3],16)),this;if(/^(\\w+)$/i.test(a))return this.setHex(THREE.ColorKeywords[a]),this},copy:function(a){this.r=a.r;this.g=\na.g;this.b=a.b;return this},copyGammaToLinear:function(a){this.r=a.r*a.r;this.g=a.g*a.g;this.b=a.b*a.b;return this},copyLinearToGamma:function(a){this.r=Math.sqrt(a.r);this.g=Math.sqrt(a.g);this.b=Math.sqrt(a.b);return this},convertGammaToLinear:function(){var a=this.r,b=this.g,c=this.b;this.r=a*a;this.g=b*b;this.b=c*c;return this},convertLinearToGamma:function(){this.r=Math.sqrt(this.r);this.g=Math.sqrt(this.g);this.b=Math.sqrt(this.b);return this},getHex:function(){return 255*this.r<<16^255*this.g<<\n8^255*this.b<<0},getHexString:function(){return(\"000000\"+this.getHex().toString(16)).slice(-6)},getHSL:function(a){var a=a||{h:0,s:0,l:0},b=this.r,c=this.g,d=this.b,e=Math.max(b,c,d),f=Math.min(b,c,d),g,h=(f+e)/2;if(f===e)f=g=0;else{var i=e-f,f=0.5>=h?i/(e+f):i/(2-e-f);switch(e){case b:g=(c-d)/i+(c<d?6:0);break;case c:g=(d-b)/i+2;break;case d:g=(b-c)/i+4}g/=6}a.h=g;a.s=f;a.l=h;return a},getStyle:function(){return\"rgb(\"+(255*this.r|0)+\",\"+(255*this.g|0)+\",\"+(255*this.b|0)+\")\"},offsetHSL:function(a,\nb,c){var d=this.getHSL();d.h+=a;d.s+=b;d.l+=c;this.setHSL(d.h,d.s,d.l);return this},add:function(a){this.r+=a.r;this.g+=a.g;this.b+=a.b;return this},addColors:function(a,b){this.r=a.r+b.r;this.g=a.g+b.g;this.b=a.b+b.b;return this},addScalar:function(a){this.r+=a;this.g+=a;this.b+=a;return this},multiply:function(a){this.r*=a.r;this.g*=a.g;this.b*=a.b;return this},multiplyScalar:function(a){this.r*=a;this.g*=a;this.b*=a;return this},lerp:function(a,b){this.r+=(a.r-this.r)*b;this.g+=(a.g-this.g)*b;\nthis.b+=(a.b-this.b)*b;return this},equals:function(a){return a.r===this.r&&a.g===this.g&&a.b===this.b},fromArray:function(a){this.r=a[0];this.g=a[1];this.b=a[2];return this},toArray:function(){return[this.r,this.g,this.b]},clone:function(){return(new THREE.Color).setRGB(this.r,this.g,this.b)}};\nTHREE.ColorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,\ndarkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,\ngrey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,\nlime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,\npalegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,\ntomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};THREE.Quaternion=function(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._w=void 0!==d?d:1};\nTHREE.Quaternion.prototype={constructor:THREE.Quaternion,_x:0,_y:0,_z:0,_w:0,_euler:void 0,_updateEuler:function(){void 0!==this._euler&&this._euler.setFromQuaternion(this,void 0,!1)},get x(){return this._x},set x(a){this._x=a;this._updateEuler()},get y(){return this._y},set y(a){this._y=a;this._updateEuler()},get z(){return this._z},set z(a){this._z=a;this._updateEuler()},get w(){return this._w},set w(a){this._w=a;this._updateEuler()},set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._w=d;\nthis._updateEuler();return this},copy:function(a){this._x=a._x;this._y=a._y;this._z=a._z;this._w=a._w;this._updateEuler();return this},setFromEuler:function(a,b){if(!1===a instanceof THREE.Euler)throw Error(\"ERROR: Quaternion's .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.\");var c=Math.cos(a._x/2),d=Math.cos(a._y/2),e=Math.cos(a._z/2),f=Math.sin(a._x/2),g=Math.sin(a._y/2),h=Math.sin(a._z/2);\"XYZ\"===a.order?(this._x=f*d*e+c*g*h,this._y=c*g*\ne-f*d*h,this._z=c*d*h+f*g*e,this._w=c*d*e-f*g*h):\"YXZ\"===a.order?(this._x=f*d*e+c*g*h,this._y=c*g*e-f*d*h,this._z=c*d*h-f*g*e,this._w=c*d*e+f*g*h):\"ZXY\"===a.order?(this._x=f*d*e-c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h+f*g*e,this._w=c*d*e-f*g*h):\"ZYX\"===a.order?(this._x=f*d*e-c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h-f*g*e,this._w=c*d*e+f*g*h):\"YZX\"===a.order?(this._x=f*d*e+c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h-f*g*e,this._w=c*d*e-f*g*h):\"XZY\"===a.order&&(this._x=f*d*e-c*g*h,this._y=c*g*e-f*d*h,this._z=\nc*d*h+f*g*e,this._w=c*d*e+f*g*h);!1!==b&&this._updateEuler();return this},setFromAxisAngle:function(a,b){var c=b/2,d=Math.sin(c);this._x=a.x*d;this._y=a.y*d;this._z=a.z*d;this._w=Math.cos(c);this._updateEuler();return this},setFromRotationMatrix:function(a){var b=a.elements,c=b[0],a=b[4],d=b[8],e=b[1],f=b[5],g=b[9],h=b[2],i=b[6],b=b[10],k=c+f+b;0<k?(c=0.5/Math.sqrt(k+1),this._w=0.25/c,this._x=(i-g)*c,this._y=(d-h)*c,this._z=(e-a)*c):c>f&&c>b?(c=2*Math.sqrt(1+c-f-b),this._w=(i-g)/c,this._x=0.25*c,\nthis._y=(a+e)/c,this._z=(d+h)/c):f>b?(c=2*Math.sqrt(1+f-c-b),this._w=(d-h)/c,this._x=(a+e)/c,this._y=0.25*c,this._z=(g+i)/c):(c=2*Math.sqrt(1+b-c-f),this._w=(e-a)/c,this._x=(d+h)/c,this._y=(g+i)/c,this._z=0.25*c);this._updateEuler();return this},inverse:function(){this.conjugate().normalize();return this},conjugate:function(){this._x*=-1;this._y*=-1;this._z*=-1;this._updateEuler();return this},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*\nthis._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var a=this.length();0===a?(this._z=this._y=this._x=0,this._w=1):(a=1/a,this._x*=a,this._y*=a,this._z*=a,this._w*=a);return this},multiply:function(a,b){return void 0!==b?(console.warn(\"DEPRECATED: Quaternion's .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.\"),this.multiplyQuaternions(a,b)):this.multiplyQuaternions(this,a)},multiplyQuaternions:function(a,b){var c=a._x,d=a._y,e=a._z,f=\na._w,g=b._x,h=b._y,i=b._z,k=b._w;this._x=c*k+f*g+d*i-e*h;this._y=d*k+f*h+e*g-c*i;this._z=e*k+f*i+c*h-d*g;this._w=f*k-c*g-d*h-e*i;this._updateEuler();return this},multiplyVector3:function(a){console.warn(\"DEPRECATED: Quaternion's .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.\");return a.applyQuaternion(this)},slerp:function(a,b){var c=this._x,d=this._y,e=this._z,f=this._w,g=f*a._w+c*a._x+d*a._y+e*a._z;0>g?(this._w=-a._w,this._x=-a._x,this._y=-a._y,this._z=\n-a._z,g=-g):this.copy(a);if(1<=g)return this._w=f,this._x=c,this._y=d,this._z=e,this;var h=Math.acos(g),i=Math.sqrt(1-g*g);if(0.001>Math.abs(i))return this._w=0.5*(f+this._w),this._x=0.5*(c+this._x),this._y=0.5*(d+this._y),this._z=0.5*(e+this._z),this;g=Math.sin((1-b)*h)/i;h=Math.sin(b*h)/i;this._w=f*g+this._w*h;this._x=c*g+this._x*h;this._y=d*g+this._y*h;this._z=e*g+this._z*h;this._updateEuler();return this},equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._w===this._w},\nfromArray:function(a){this._x=a[0];this._y=a[1];this._z=a[2];this._w=a[3];this._updateEuler();return this},toArray:function(){return[this._x,this._y,this._z,this._w]},clone:function(){return new THREE.Quaternion(this._x,this._y,this._z,this._w)}};THREE.Quaternion.slerp=function(a,b,c,d){return c.copy(a).slerp(b,d)};THREE.Vector2=function(a,b){this.x=a||0;this.y=b||0};\nTHREE.Vector2.prototype={constructor:THREE.Vector2,set:function(a,b){this.x=a;this.y=b;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;default:throw Error(\"index is out of range: \"+a);}},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;default:throw Error(\"index is out of range: \"+a);}},copy:function(a){this.x=a.x;this.y=a.y;return this},add:function(a,\nb){if(void 0!==b)return console.warn(\"DEPRECATED: Vector2's .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this},addScalar:function(a){this.x+=a;this.y+=a;return this},sub:function(a,b){if(void 0!==b)return console.warn(\"DEPRECATED: Vector2's .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"),this.subVectors(a,b);this.x-=a.x;this.y-=\na.y;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a):this.y=this.x=0;return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=a.y);return this},clamp:function(a,b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y);\nreturn this},negate:function(){return this.multiplyScalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},normalize:function(){return this.divideScalar(this.length())},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x,a=this.y-a.y;return b*b+a*a},setLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/\nb);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;return this},equals:function(a){return a.x===this.x&&a.y===this.y},fromArray:function(a){this.x=a[0];this.y=a[1];return this},toArray:function(){return[this.x,this.y]},clone:function(){return new THREE.Vector2(this.x,this.y)}};THREE.Vector3=function(a,b,c){this.x=a||0;this.y=b||0;this.z=c||0};\nTHREE.Vector3.prototype={constructor:THREE.Vector3,set:function(a,b,c){this.x=a;this.y=b;this.z=c;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;default:throw Error(\"index is out of range: \"+a);}},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw Error(\"index is out of range: \"+\na);}},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;return this},add:function(a,b){if(void 0!==b)return console.warn(\"DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this},sub:function(a,b){if(void 0!==b)return console.warn(\"DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"),\nthis.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this},multiply:function(a,b){if(void 0!==b)return console.warn(\"DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.\"),this.multiplyVectors(a,b);this.x*=a.x;this.y*=a.y;this.z*=a.z;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;return this},multiplyVectors:function(a,b){this.x=a.x*\nb.x;this.y=a.y*b.y;this.z=a.z*b.z;return this},applyMatrix3:function(a){var b=this.x,c=this.y,d=this.z,a=a.elements;this.x=a[0]*b+a[3]*c+a[6]*d;this.y=a[1]*b+a[4]*c+a[7]*d;this.z=a[2]*b+a[5]*c+a[8]*d;return this},applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z,a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12];this.y=a[1]*b+a[5]*c+a[9]*d+a[13];this.z=a[2]*b+a[6]*c+a[10]*d+a[14];return this},applyProjection:function(a){var b=this.x,c=this.y,d=this.z,a=a.elements,e=1/(a[3]*b+a[7]*c+a[11]*d+a[15]);\nthis.x=(a[0]*b+a[4]*c+a[8]*d+a[12])*e;this.y=(a[1]*b+a[5]*c+a[9]*d+a[13])*e;this.z=(a[2]*b+a[6]*c+a[10]*d+a[14])*e;return this},applyQuaternion:function(a){var b=this.x,c=this.y,d=this.z,e=a.x,f=a.y,g=a.z,a=a.w,h=a*b+f*d-g*c,i=a*c+g*b-e*d,k=a*d+e*c-f*b,b=-e*b-f*c-g*d;this.x=h*a+b*-e+i*-g-k*-f;this.y=i*a+b*-f+k*-e-h*-g;this.z=k*a+b*-g+h*-f-i*-e;return this},transformDirection:function(a){var b=this.x,c=this.y,d=this.z,a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d;this.y=a[1]*b+a[5]*c+a[9]*d;this.z=a[2]*\nb+a[6]*c+a[10]*d;this.normalize();return this},divide:function(a){this.x/=a.x;this.y/=a.y;this.z/=a.z;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a,this.z*=a):this.z=this.y=this.x=0;return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);this.z>a.z&&(this.z=a.z);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=a.y);this.z<a.z&&(this.z=a.z);return this},clamp:function(a,b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<\na.y?this.y=a.y:this.y>b.y&&(this.y=b.y);this.z<a.z?this.z=a.z:this.z>b.z&&(this.z=b.z);return this},negate:function(){return this.multiplyScalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length())},\nsetLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/b);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;return this},cross:function(a,b){if(void 0!==b)return console.warn(\"DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.\"),this.crossVectors(a,b);var c=this.x,d=this.y,e=this.z;this.x=d*a.z-e*a.y;this.y=e*a.x-c*a.z;this.z=c*a.y-d*a.x;return this},crossVectors:function(a,b){var c=\na.x,d=a.y,e=a.z,f=b.x,g=b.y,h=b.z;this.x=d*h-e*g;this.y=e*f-c*h;this.z=c*g-d*f;return this},angleTo:function(a){a=this.dot(a)/(this.length()*a.length());return Math.acos(THREE.Math.clamp(a,-1,1))},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x,c=this.y-a.y,a=this.z-a.z;return b*b+c*c+a*a},setEulerFromRotationMatrix:function(){console.error(\"REMOVED: Vector3's setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.\")},\nsetEulerFromQuaternion:function(){console.error(\"REMOVED: Vector3's setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.\")},getPositionFromMatrix:function(a){console.warn(\"DEPRECATED: Vector3's .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code.\");return this.setFromMatrixPosition(a)},getScaleFromMatrix:function(a){console.warn(\"DEPRECATED: Vector3's .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code.\");\nreturn this.setFromMatrixScale(a)},getColumnFromMatrix:function(a,b){console.warn(\"DEPRECATED: Vector3's .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code.\");return this.setFromMatrixColumn(a,b)},setFromMatrixPosition:function(a){this.x=a.elements[12];this.y=a.elements[13];this.z=a.elements[14];return this},setFromMatrixScale:function(a){var b=this.set(a.elements[0],a.elements[1],a.elements[2]).length(),c=this.set(a.elements[4],a.elements[5],a.elements[6]).length(),\na=this.set(a.elements[8],a.elements[9],a.elements[10]).length();this.x=b;this.y=c;this.z=a;return this},setFromMatrixColumn:function(a,b){var c=4*a,d=b.elements;this.x=d[c];this.y=d[c+1];this.z=d[c+2];return this},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z},fromArray:function(a){this.x=a[0];this.y=a[1];this.z=a[2];return this},toArray:function(){return[this.x,this.y,this.z]},clone:function(){return new THREE.Vector3(this.x,this.y,this.z)}};\nTHREE.extend(THREE.Vector3.prototype,{applyEuler:function(){var a=new THREE.Quaternion;return function(b){!1===b instanceof THREE.Euler&&console.error(\"ERROR: Vector3's .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.\");this.applyQuaternion(a.setFromEuler(b));return this}}(),applyAxisAngle:function(){var a=new THREE.Quaternion;return function(b,c){this.applyQuaternion(a.setFromAxisAngle(b,c));return this}}(),projectOnVector:function(){var a=new THREE.Vector3;\nreturn function(b){a.copy(b).normalize();b=this.dot(a);return this.copy(a).multiplyScalar(b)}}(),projectOnPlane:function(){var a=new THREE.Vector3;return function(b){a.copy(this).projectOnVector(b);return this.sub(a)}}(),reflect:function(){var a=new THREE.Vector3;return function(b){a.copy(this).projectOnVector(b).multiplyScalar(2);return this.subVectors(a,this)}}()});THREE.Vector4=function(a,b,c,d){this.x=a||0;this.y=b||0;this.z=c||0;this.w=void 0!==d?d:1};\nTHREE.Vector4.prototype={constructor:THREE.Vector4,set:function(a,b,c,d){this.x=a;this.y=b;this.z=c;this.w=d;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setW:function(a){this.w=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;case 3:this.w=b;break;default:throw Error(\"index is out of range: \"+a);}},getComponent:function(a){switch(a){case 0:return this.x;\ncase 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error(\"index is out of range: \"+a);}},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;this.w=void 0!==a.w?a.w:1;return this},add:function(a,b){if(void 0!==b)return console.warn(\"DEPRECATED: Vector4's .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;this.w+=a.w;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;this.w+=a;return this},\naddVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this},sub:function(a,b){if(void 0!==b)return console.warn(\"DEPRECATED: Vector4's .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;this.w-=a.w;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;this.w*=a;return this},\napplyMatrix4:function(a){var b=this.x,c=this.y,d=this.z,e=this.w,a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12]*e;this.y=a[1]*b+a[5]*c+a[9]*d+a[13]*e;this.z=a[2]*b+a[6]*c+a[10]*d+a[14]*e;this.w=a[3]*b+a[7]*c+a[11]*d+a[15]*e;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a,this.z*=a,this.w*=a):(this.z=this.y=this.x=0,this.w=1);return this},setAxisAngleFromQuaternion:function(a){this.w=2*Math.acos(a.w);var b=Math.sqrt(1-a.w*a.w);1E-4>b?(this.x=1,this.z=this.y=0):(this.x=a.x/b,\nthis.y=a.y/b,this.z=a.z/b);return this},setAxisAngleFromRotationMatrix:function(a){var b,c,d,a=a.elements,e=a[0];d=a[4];var f=a[8],g=a[1],h=a[5],i=a[9];c=a[2];b=a[6];var k=a[10];if(0.01>Math.abs(d-g)&&0.01>Math.abs(f-c)&&0.01>Math.abs(i-b)){if(0.1>Math.abs(d+g)&&0.1>Math.abs(f+c)&&0.1>Math.abs(i+b)&&0.1>Math.abs(e+h+k-3))return this.set(1,0,0,0),this;a=Math.PI;e=(e+1)/2;h=(h+1)/2;k=(k+1)/2;d=(d+g)/4;f=(f+c)/4;i=(i+b)/4;e>h&&e>k?0.01>e?(b=0,d=c=0.707106781):(b=Math.sqrt(e),c=d/b,d=f/b):h>k?0.01>h?\n(b=0.707106781,c=0,d=0.707106781):(c=Math.sqrt(h),b=d/c,d=i/c):0.01>k?(c=b=0.707106781,d=0):(d=Math.sqrt(k),b=f/d,c=i/d);this.set(b,c,d,a);return this}a=Math.sqrt((b-i)*(b-i)+(f-c)*(f-c)+(g-d)*(g-d));0.001>Math.abs(a)&&(a=1);this.x=(b-i)/a;this.y=(f-c)/a;this.z=(g-d)/a;this.w=Math.acos((e+h+k-1)/2);return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);this.z>a.z&&(this.z=a.z);this.w>a.w&&(this.w=a.w);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=\na.y);this.z<a.z&&(this.z=a.z);this.w<a.w&&(this.w=a.w);return this},clamp:function(a,b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y);this.z<a.z?this.z=a.z:this.z>b.z&&(this.z=b.z);this.w<a.w?this.w=a.w:this.w>b.w&&(this.w=b.w);return this},negate:function(){return this.multiplyScalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z+this.w*a.w},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},length:function(){return Math.sqrt(this.x*\nthis.x+this.y*this.y+this.z*this.z+this.w*this.w)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)},normalize:function(){return this.divideScalar(this.length())},setLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/b);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;this.w+=(a.w-this.w)*b;return this},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z&&\na.w===this.w},fromArray:function(a){this.x=a[0];this.y=a[1];this.z=a[2];this.w=a[3];return this},toArray:function(){return[this.x,this.y,this.z,this.w]},clone:function(){return new THREE.Vector4(this.x,this.y,this.z,this.w)}};THREE.Euler=function(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._order=d||THREE.Euler.DefaultOrder};THREE.Euler.RotationOrders=\"XYZ YZX ZXY XZY YXZ ZYX\".split(\" \");THREE.Euler.DefaultOrder=\"XYZ\";\nTHREE.Euler.prototype={constructor:THREE.Euler,_x:0,_y:0,_z:0,_order:THREE.Euler.DefaultOrder,_quaternion:void 0,_updateQuaternion:function(){void 0!==this._quaternion&&this._quaternion.setFromEuler(this,!1)},get x(){return this._x},set x(a){this._x=a;this._updateQuaternion()},get y(){return this._y},set y(a){this._y=a;this._updateQuaternion()},get z(){return this._z},set z(a){this._z=a;this._updateQuaternion()},get order(){return this._order},set order(a){this._order=a;this._updateQuaternion()},\nset:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._order=d||this._order;this._updateQuaternion();return this},copy:function(a){this._x=a._x;this._y=a._y;this._z=a._z;this._order=a._order;this._updateQuaternion();return this},setFromRotationMatrix:function(a,b){function c(a){return Math.min(Math.max(a,-1),1)}var d=a.elements,e=d[0],f=d[4],g=d[8],h=d[1],i=d[5],k=d[9],l=d[2],n=d[6],d=d[10],b=b||this._order;\"XYZ\"===b?(this._y=Math.asin(c(g)),0.99999>Math.abs(g)?(this._x=Math.atan2(-k,d),this._z=\nMath.atan2(-f,e)):(this._x=Math.atan2(n,i),this._z=0)):\"YXZ\"===b?(this._x=Math.asin(-c(k)),0.99999>Math.abs(k)?(this._y=Math.atan2(g,d),this._z=Math.atan2(h,i)):(this._y=Math.atan2(-l,e),this._z=0)):\"ZXY\"===b?(this._x=Math.asin(c(n)),0.99999>Math.abs(n)?(this._y=Math.atan2(-l,d),this._z=Math.atan2(-f,i)):(this._y=0,this._z=Math.atan2(h,e))):\"ZYX\"===b?(this._y=Math.asin(-c(l)),0.99999>Math.abs(l)?(this._x=Math.atan2(n,d),this._z=Math.atan2(h,e)):(this._x=0,this._z=Math.atan2(-f,i))):\"YZX\"===b?(this._z=\nMath.asin(c(h)),0.99999>Math.abs(h)?(this._x=Math.atan2(-k,i),this._y=Math.atan2(-l,e)):(this._x=0,this._y=Math.atan2(g,d))):\"XZY\"===b?(this._z=Math.asin(-c(f)),0.99999>Math.abs(f)?(this._x=Math.atan2(n,i),this._y=Math.atan2(g,e)):(this._x=Math.atan2(-k,d),this._y=0)):console.warn(\"WARNING: Euler.setFromRotationMatrix() given unsupported order: \"+b);this._order=b;this._updateQuaternion();return this},setFromQuaternion:function(a,b,c){function d(a){return Math.min(Math.max(a,-1),1)}var e=a.x*a.x,f=\na.y*a.y,g=a.z*a.z,h=a.w*a.w,b=b||this._order;\"XYZ\"===b?(this._x=Math.atan2(2*(a.x*a.w-a.y*a.z),h-e-f+g),this._y=Math.asin(d(2*(a.x*a.z+a.y*a.w))),this._z=Math.atan2(2*(a.z*a.w-a.x*a.y),h+e-f-g)):\"YXZ\"===b?(this._x=Math.asin(d(2*(a.x*a.w-a.y*a.z))),this._y=Math.atan2(2*(a.x*a.z+a.y*a.w),h-e-f+g),this._z=Math.atan2(2*(a.x*a.y+a.z*a.w),h-e+f-g)):\"ZXY\"===b?(this._x=Math.asin(d(2*(a.x*a.w+a.y*a.z))),this._y=Math.atan2(2*(a.y*a.w-a.z*a.x),h-e-f+g),this._z=Math.atan2(2*(a.z*a.w-a.x*a.y),h-e+f-g)):\"ZYX\"===\nb?(this._x=Math.atan2(2*(a.x*a.w+a.z*a.y),h-e-f+g),this._y=Math.asin(d(2*(a.y*a.w-a.x*a.z))),this._z=Math.atan2(2*(a.x*a.y+a.z*a.w),h+e-f-g)):\"YZX\"===b?(this._x=Math.atan2(2*(a.x*a.w-a.z*a.y),h-e+f-g),this._y=Math.atan2(2*(a.y*a.w-a.x*a.z),h+e-f-g),this._z=Math.asin(d(2*(a.x*a.y+a.z*a.w)))):\"XZY\"===b?(this._x=Math.atan2(2*(a.x*a.w+a.y*a.z),h-e+f-g),this._y=Math.atan2(2*(a.x*a.z+a.y*a.w),h+e-f-g),this._z=Math.asin(d(2*(a.z*a.w-a.x*a.y)))):console.warn(\"WARNING: Euler.setFromQuaternion() given unsupported order: \"+\nb);this._order=b;!1!==c&&this._updateQuaternion();return this},reorder:function(){var a=new THREE.Quaternion;return function(b){a.setFromEuler(this);this.setFromQuaternion(a,b)}}(),fromArray:function(a){this._x=a[0];this._y=a[1];this._z=a[2];void 0!==a[3]&&(this._order=a[3]);this._updateQuaternion();return this},toArray:function(){return[this._x,this._y,this._z,this._order]},equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._order===this._order},clone:function(){return new THREE.Euler(this._x,\nthis._y,this._z,this._order)}};THREE.Line3=function(a,b){this.start=void 0!==a?a:new THREE.Vector3;this.end=void 0!==b?b:new THREE.Vector3};\nTHREE.Line3.prototype={constructor:THREE.Line3,set:function(a,b){this.start.copy(a);this.end.copy(b);return this},copy:function(a){this.start.copy(a.start);this.end.copy(a.end);return this},center:function(a){return(a||new THREE.Vector3).addVectors(this.start,this.end).multiplyScalar(0.5)},delta:function(a){return(a||new THREE.Vector3).subVectors(this.end,this.start)},distanceSq:function(){return this.start.distanceToSquared(this.end)},distance:function(){return this.start.distanceTo(this.end)},at:function(a,\nb){var c=b||new THREE.Vector3;return this.delta(c).multiplyScalar(a).add(this.start)},closestPointToPointParameter:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d){a.subVectors(c,this.start);b.subVectors(this.end,this.start);var e=b.dot(b),e=b.dot(a)/e;d&&(e=THREE.Math.clamp(e,0,1));return e}}(),closestPointToPoint:function(a,b,c){a=this.closestPointToPointParameter(a,b);c=c||new THREE.Vector3;return this.delta(c).multiplyScalar(a).add(this.start)},applyMatrix4:function(a){this.start.applyMatrix4(a);\nthis.end.applyMatrix4(a);return this},equals:function(a){return a.start.equals(this.start)&&a.end.equals(this.end)},clone:function(){return(new THREE.Line3).copy(this)}};THREE.Box2=function(a,b){this.min=void 0!==a?a:new THREE.Vector2(Infinity,Infinity);this.max=void 0!==b?b:new THREE.Vector2(-Infinity,-Infinity)};\nTHREE.Box2.prototype={constructor:THREE.Box2,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},setFromPoints:function(a){if(0<a.length){var b=a[0];this.min.copy(b);this.max.copy(b);for(var c=1,d=a.length;c<d;c++)b=a[c],b.x<this.min.x?this.min.x=b.x:b.x>this.max.x&&(this.max.x=b.x),b.y<this.min.y?this.min.y=b.y:b.y>this.max.y&&(this.max.y=b.y)}else this.makeEmpty();return this},setFromCenterAndSize:function(){var a=new THREE.Vector2;return function(b,c){var d=a.copy(c).multiplyScalar(0.5);\nthis.min.copy(b).sub(d);this.max.copy(b).add(d);return this}}(),copy:function(a){this.min.copy(a.min);this.max.copy(a.max);return this},makeEmpty:function(){this.min.x=this.min.y=Infinity;this.max.x=this.max.y=-Infinity;return this},empty:function(){return this.max.x<this.min.x||this.max.y<this.min.y},center:function(a){return(a||new THREE.Vector2).addVectors(this.min,this.max).multiplyScalar(0.5)},size:function(a){return(a||new THREE.Vector2).subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);\nthis.max.max(a);return this},expandByVector:function(a){this.min.sub(a);this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y?!0:!1},getParameter:function(a,b){return(b||new THREE.Vector2).set((a.x-this.min.x)/(this.max.x-this.min.x),\n(a.y-this.min.y)/(this.max.y-this.min.y))},isIntersectionBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y?!1:!0},clampPoint:function(a,b){return(b||new THREE.Vector2).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new THREE.Vector2;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);return this},union:function(a){this.min.min(a.min);this.max.max(a.max);\nreturn this},translate:function(a){this.min.add(a);this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)},clone:function(){return(new THREE.Box2).copy(this)}};THREE.Box3=function(a,b){this.min=void 0!==a?a:new THREE.Vector3(Infinity,Infinity,Infinity);this.max=void 0!==b?b:new THREE.Vector3(-Infinity,-Infinity,-Infinity)};\nTHREE.Box3.prototype={constructor:THREE.Box3,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},addPoint:function(a){a.x<this.min.x?this.min.x=a.x:a.x>this.max.x&&(this.max.x=a.x);a.y<this.min.y?this.min.y=a.y:a.y>this.max.y&&(this.max.y=a.y);a.z<this.min.z?this.min.z=a.z:a.z>this.max.z&&(this.max.z=a.z)},setFromPoints:function(a){if(0<a.length){var b=a[0];this.min.copy(b);this.max.copy(b);for(var b=1,c=a.length;b<c;b++)this.addPoint(a[b])}else this.makeEmpty();return this},setFromCenterAndSize:function(){var a=\nnew THREE.Vector3;return function(b,c){var d=a.copy(c).multiplyScalar(0.5);this.min.copy(b).sub(d);this.max.copy(b).add(d);return this}}(),setFromObject:function(){var a=new THREE.Vector3;return function(b){var c=this;b.updateMatrixWorld(!0);this.makeEmpty();b.traverse(function(b){if(void 0!==b.geometry&&void 0!==b.geometry.vertices)for(var e=b.geometry.vertices,f=0,g=e.length;f<g;f++)a.copy(e[f]),a.applyMatrix4(b.matrixWorld),c.expandByPoint(a)});return this}}(),copy:function(a){this.min.copy(a.min);\nthis.max.copy(a.max);return this},makeEmpty:function(){this.min.x=this.min.y=this.min.z=Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this},empty:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z},center:function(a){return(a||new THREE.Vector3).addVectors(this.min,this.max).multiplyScalar(0.5)},size:function(a){return(a||new THREE.Vector3).subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);\nthis.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y||a.z<this.min.z||a.z>this.max.z?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y&&this.min.z<=a.min.z&&a.max.z<=this.max.z?!0:!1},getParameter:function(a,b){return(b||new THREE.Vector3).set((a.x-this.min.x)/(this.max.x-\nthis.min.x),(a.y-this.min.y)/(this.max.y-this.min.y),(a.z-this.min.z)/(this.max.z-this.min.z))},isIntersectionBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y||a.max.z<this.min.z||a.min.z>this.max.z?!1:!0},clampPoint:function(a,b){return(b||new THREE.Vector3).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new THREE.Vector3;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),getBoundingSphere:function(){var a=\nnew THREE.Vector3;return function(b){b=b||new THREE.Sphere;b.center=this.center();b.radius=0.5*this.size(a).length();return b}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);return this},union:function(a){this.min.min(a.min);this.max.max(a.max);return this},applyMatrix4:function(){var a=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];return function(b){a[0].set(this.min.x,this.min.y,\nthis.min.z).applyMatrix4(b);a[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(b);a[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(b);a[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(b);a[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(b);a[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(b);a[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(b);a[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(b);this.makeEmpty();this.setFromPoints(a);return this}}(),translate:function(a){this.min.add(a);\nthis.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)},clone:function(){return(new THREE.Box3).copy(this)}};THREE.Matrix3=function(a,b,c,d,e,f,g,h,i){this.elements=new Float32Array(9);this.set(void 0!==a?a:1,b||0,c||0,d||0,void 0!==e?e:1,f||0,g||0,h||0,void 0!==i?i:1)};\nTHREE.Matrix3.prototype={constructor:THREE.Matrix3,set:function(a,b,c,d,e,f,g,h,i){var k=this.elements;k[0]=a;k[3]=b;k[6]=c;k[1]=d;k[4]=e;k[7]=f;k[2]=g;k[5]=h;k[8]=i;return this},identity:function(){this.set(1,0,0,0,1,0,0,0,1);return this},copy:function(a){a=a.elements;this.set(a[0],a[3],a[6],a[1],a[4],a[7],a[2],a[5],a[8]);return this},multiplyVector3:function(a){console.warn(\"DEPRECATED: Matrix3's .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.\");return a.applyMatrix3(this)},\nmultiplyVector3Array:function(){var a=new THREE.Vector3;return function(b){for(var c=0,d=b.length;c<d;c+=3)a.x=b[c],a.y=b[c+1],a.z=b[c+2],a.applyMatrix3(this),b[c]=a.x,b[c+1]=a.y,b[c+2]=a.z;return b}}(),multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[3]*=a;b[6]*=a;b[1]*=a;b[4]*=a;b[7]*=a;b[2]*=a;b[5]*=a;b[8]*=a;return this},determinant:function(){var a=this.elements,b=a[0],c=a[1],d=a[2],e=a[3],f=a[4],g=a[5],h=a[6],i=a[7],a=a[8];return b*f*a-b*g*i-c*e*a+c*g*h+d*e*i-d*f*h},getInverse:function(a,\nb){var c=a.elements,d=this.elements;d[0]=c[10]*c[5]-c[6]*c[9];d[1]=-c[10]*c[1]+c[2]*c[9];d[2]=c[6]*c[1]-c[2]*c[5];d[3]=-c[10]*c[4]+c[6]*c[8];d[4]=c[10]*c[0]-c[2]*c[8];d[5]=-c[6]*c[0]+c[2]*c[4];d[6]=c[9]*c[4]-c[5]*c[8];d[7]=-c[9]*c[0]+c[1]*c[8];d[8]=c[5]*c[0]-c[1]*c[4];c=c[0]*d[0]+c[1]*d[3]+c[2]*d[6];if(0===c){if(b)throw Error(\"Matrix3.getInverse(): can't invert matrix, determinant is 0\");console.warn(\"Matrix3.getInverse(): can't invert matrix, determinant is 0\");this.identity();return this}this.multiplyScalar(1/\nc);return this},transpose:function(){var a,b=this.elements;a=b[1];b[1]=b[3];b[3]=a;a=b[2];b[2]=b[6];b[6]=a;a=b[5];b[5]=b[7];b[7]=a;return this},getNormalMatrix:function(a){this.getInverse(a).transpose();return this},transposeIntoArray:function(a){var b=this.elements;a[0]=b[0];a[1]=b[3];a[2]=b[6];a[3]=b[1];a[4]=b[4];a[5]=b[7];a[6]=b[2];a[7]=b[5];a[8]=b[8];return this},fromArray:function(a){this.elements.set(a);return this},toArray:function(){var a=this.elements;return[a[0],a[1],a[2],a[3],a[4],a[5],\na[6],a[7],a[8]]},clone:function(){var a=this.elements;return new THREE.Matrix3(a[0],a[3],a[6],a[1],a[4],a[7],a[2],a[5],a[8])}};THREE.Matrix4=function(a,b,c,d,e,f,g,h,i,k,l,n,p,t,r,m){var q=this.elements=new Float32Array(16);q[0]=void 0!==a?a:1;q[4]=b||0;q[8]=c||0;q[12]=d||0;q[1]=e||0;q[5]=void 0!==f?f:1;q[9]=g||0;q[13]=h||0;q[2]=i||0;q[6]=k||0;q[10]=void 0!==l?l:1;q[14]=n||0;q[3]=p||0;q[7]=t||0;q[11]=r||0;q[15]=void 0!==m?m:1};\nTHREE.Matrix4.prototype={constructor:THREE.Matrix4,set:function(a,b,c,d,e,f,g,h,i,k,l,n,p,t,r,m){var q=this.elements;q[0]=a;q[4]=b;q[8]=c;q[12]=d;q[1]=e;q[5]=f;q[9]=g;q[13]=h;q[2]=i;q[6]=k;q[10]=l;q[14]=n;q[3]=p;q[7]=t;q[11]=r;q[15]=m;return this},identity:function(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this},copy:function(a){this.elements.set(a.elements);return this},extractPosition:function(a){console.warn(\"DEPRECATED: Matrix4's .extractPosition() has been renamed to .copyPosition().\");\nreturn this.copyPosition(a)},copyPosition:function(a){var b=this.elements,a=a.elements;b[12]=a[12];b[13]=a[13];b[14]=a[14];return this},extractRotation:function(){var a=new THREE.Vector3;return function(b){var c=this.elements,b=b.elements,d=1/a.set(b[0],b[1],b[2]).length(),e=1/a.set(b[4],b[5],b[6]).length(),f=1/a.set(b[8],b[9],b[10]).length();c[0]=b[0]*d;c[1]=b[1]*d;c[2]=b[2]*d;c[4]=b[4]*e;c[5]=b[5]*e;c[6]=b[6]*e;c[8]=b[8]*f;c[9]=b[9]*f;c[10]=b[10]*f;return this}}(),makeRotationFromEuler:function(a){!1===\na instanceof THREE.Euler&&console.error(\"ERROR: Matrix's .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.\");var b=this.elements,c=a.x,d=a.y,e=a.z,f=Math.cos(c),c=Math.sin(c),g=Math.cos(d),d=Math.sin(d),h=Math.cos(e),e=Math.sin(e);if(\"XYZ\"===a.order){var a=f*h,i=f*e,k=c*h,l=c*e;b[0]=g*h;b[4]=-g*e;b[8]=d;b[1]=i+k*d;b[5]=a-l*d;b[9]=-c*g;b[2]=l-a*d;b[6]=k+i*d;b[10]=f*g}else\"YXZ\"===a.order?(a=g*h,i=g*e,k=d*h,l=d*e,b[0]=a+l*c,b[4]=k*c-i,b[8]=\nf*d,b[1]=f*e,b[5]=f*h,b[9]=-c,b[2]=i*c-k,b[6]=l+a*c,b[10]=f*g):\"ZXY\"===a.order?(a=g*h,i=g*e,k=d*h,l=d*e,b[0]=a-l*c,b[4]=-f*e,b[8]=k+i*c,b[1]=i+k*c,b[5]=f*h,b[9]=l-a*c,b[2]=-f*d,b[6]=c,b[10]=f*g):\"ZYX\"===a.order?(a=f*h,i=f*e,k=c*h,l=c*e,b[0]=g*h,b[4]=k*d-i,b[8]=a*d+l,b[1]=g*e,b[5]=l*d+a,b[9]=i*d-k,b[2]=-d,b[6]=c*g,b[10]=f*g):\"YZX\"===a.order?(a=f*g,i=f*d,k=c*g,l=c*d,b[0]=g*h,b[4]=l-a*e,b[8]=k*e+i,b[1]=e,b[5]=f*h,b[9]=-c*h,b[2]=-d*h,b[6]=i*e+k,b[10]=a-l*e):\"XZY\"===a.order&&(a=f*g,i=f*d,k=c*g,l=c*d,b[0]=\ng*h,b[4]=-e,b[8]=d*h,b[1]=a*e+l,b[5]=f*h,b[9]=i*e-k,b[2]=k*e-i,b[6]=c*h,b[10]=l*e+a);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},setRotationFromQuaternion:function(a){console.warn(\"DEPRECATED: Matrix4's .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.\");return this.makeRotationFromQuaternion(a)},makeRotationFromQuaternion:function(a){var b=this.elements,c=a.x,d=a.y,e=a.z,f=a.w,g=c+c,h=d+d,i=e+e,a=c*g,k=c*h,c=\nc*i,l=d*h,d=d*i,e=e*i,g=f*g,h=f*h,f=f*i;b[0]=1-(l+e);b[4]=k-f;b[8]=c+h;b[1]=k+f;b[5]=1-(a+e);b[9]=d-g;b[2]=c-h;b[6]=d+g;b[10]=1-(a+l);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},lookAt:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(d,e,f){var g=this.elements;c.subVectors(d,e).normalize();0===c.length()&&(c.z=1);a.crossVectors(f,c).normalize();0===a.length()&&(c.x+=1E-4,a.crossVectors(f,c).normalize());b.crossVectors(c,a);g[0]=a.x;\ng[4]=b.x;g[8]=c.x;g[1]=a.y;g[5]=b.y;g[9]=c.y;g[2]=a.z;g[6]=b.z;g[10]=c.z;return this}}(),multiply:function(a,b){return void 0!==b?(console.warn(\"DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.\"),this.multiplyMatrices(a,b)):this.multiplyMatrices(this,a)},multiplyMatrices:function(a,b){var c=a.elements,d=b.elements,e=this.elements,f=c[0],g=c[4],h=c[8],i=c[12],k=c[1],l=c[5],n=c[9],p=c[13],t=c[2],r=c[6],m=c[10],q=c[14],u=c[3],s=c[7],v=c[11],c=c[15],\nz=d[0],G=d[4],N=d[8],C=d[12],B=d[1],x=d[5],F=d[9],L=d[13],w=d[2],E=d[6],y=d[10],D=d[14],H=d[3],K=d[7],A=d[11],d=d[15];e[0]=f*z+g*B+h*w+i*H;e[4]=f*G+g*x+h*E+i*K;e[8]=f*N+g*F+h*y+i*A;e[12]=f*C+g*L+h*D+i*d;e[1]=k*z+l*B+n*w+p*H;e[5]=k*G+l*x+n*E+p*K;e[9]=k*N+l*F+n*y+p*A;e[13]=k*C+l*L+n*D+p*d;e[2]=t*z+r*B+m*w+q*H;e[6]=t*G+r*x+m*E+q*K;e[10]=t*N+r*F+m*y+q*A;e[14]=t*C+r*L+m*D+q*d;e[3]=u*z+s*B+v*w+c*H;e[7]=u*G+s*x+v*E+c*K;e[11]=u*N+s*F+v*y+c*A;e[15]=u*C+s*L+v*D+c*d;return this},multiplyToArray:function(a,b,\nc){var d=this.elements;this.multiplyMatrices(a,b);c[0]=d[0];c[1]=d[1];c[2]=d[2];c[3]=d[3];c[4]=d[4];c[5]=d[5];c[6]=d[6];c[7]=d[7];c[8]=d[8];c[9]=d[9];c[10]=d[10];c[11]=d[11];c[12]=d[12];c[13]=d[13];c[14]=d[14];c[15]=d[15];return this},multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[4]*=a;b[8]*=a;b[12]*=a;b[1]*=a;b[5]*=a;b[9]*=a;b[13]*=a;b[2]*=a;b[6]*=a;b[10]*=a;b[14]*=a;b[3]*=a;b[7]*=a;b[11]*=a;b[15]*=a;return this},multiplyVector3:function(a){console.warn(\"DEPRECATED: Matrix4's .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.\");\nreturn a.applyProjection(this)},multiplyVector4:function(a){console.warn(\"DEPRECATED: Matrix4's .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.\");return a.applyMatrix4(this)},multiplyVector3Array:function(){var a=new THREE.Vector3;return function(b){for(var c=0,d=b.length;c<d;c+=3)a.x=b[c],a.y=b[c+1],a.z=b[c+2],a.applyProjection(this),b[c]=a.x,b[c+1]=a.y,b[c+2]=a.z;return b}}(),rotateAxis:function(a){console.warn(\"DEPRECATED: Matrix4's .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.\");\na.transformDirection(this)},crossVector:function(a){console.warn(\"DEPRECATED: Matrix4's .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.\");return a.applyMatrix4(this)},determinant:function(){var a=this.elements,b=a[0],c=a[4],d=a[8],e=a[12],f=a[1],g=a[5],h=a[9],i=a[13],k=a[2],l=a[6],n=a[10],p=a[14];return a[3]*(+e*h*l-d*i*l-e*g*n+c*i*n+d*g*p-c*h*p)+a[7]*(+b*h*p-b*i*n+e*f*n-d*f*p+d*i*k-e*h*k)+a[11]*(+b*i*l-b*g*p-e*f*l+c*f*p+e*g*k-c*i*k)+a[15]*(-d*g*k-b*h*l+b*g*n+d*f*l-c*f*\nn+c*h*k)},transpose:function(){var a=this.elements,b;b=a[1];a[1]=a[4];a[4]=b;b=a[2];a[2]=a[8];a[8]=b;b=a[6];a[6]=a[9];a[9]=b;b=a[3];a[3]=a[12];a[12]=b;b=a[7];a[7]=a[13];a[13]=b;b=a[11];a[11]=a[14];a[14]=b;return this},flattenToArray:function(a){var b=this.elements;a[0]=b[0];a[1]=b[1];a[2]=b[2];a[3]=b[3];a[4]=b[4];a[5]=b[5];a[6]=b[6];a[7]=b[7];a[8]=b[8];a[9]=b[9];a[10]=b[10];a[11]=b[11];a[12]=b[12];a[13]=b[13];a[14]=b[14];a[15]=b[15];return a},flattenToArrayOffset:function(a,b){var c=this.elements;\na[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];a[b+9]=c[9];a[b+10]=c[10];a[b+11]=c[11];a[b+12]=c[12];a[b+13]=c[13];a[b+14]=c[14];a[b+15]=c[15];return a},getPosition:function(){var a=new THREE.Vector3;return function(){console.warn(\"DEPRECATED: Matrix4's .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.\");var b=this.elements;return a.set(b[12],b[13],b[14])}}(),setPosition:function(a){var b=this.elements;\nb[12]=a.x;b[13]=a.y;b[14]=a.z;return this},getInverse:function(a,b){var c=this.elements,d=a.elements,e=d[0],f=d[4],g=d[8],h=d[12],i=d[1],k=d[5],l=d[9],n=d[13],p=d[2],t=d[6],r=d[10],m=d[14],q=d[3],u=d[7],s=d[11],d=d[15];c[0]=l*m*u-n*r*u+n*t*s-k*m*s-l*t*d+k*r*d;c[4]=h*r*u-g*m*u-h*t*s+f*m*s+g*t*d-f*r*d;c[8]=g*n*u-h*l*u+h*k*s-f*n*s-g*k*d+f*l*d;c[12]=h*l*t-g*n*t-h*k*r+f*n*r+g*k*m-f*l*m;c[1]=n*r*q-l*m*q-n*p*s+i*m*s+l*p*d-i*r*d;c[5]=g*m*q-h*r*q+h*p*s-e*m*s-g*p*d+e*r*d;c[9]=h*l*q-g*n*q-h*i*s+e*n*s+g*i*d-\ne*l*d;c[13]=g*n*p-h*l*p+h*i*r-e*n*r-g*i*m+e*l*m;c[2]=k*m*q-n*t*q+n*p*u-i*m*u-k*p*d+i*t*d;c[6]=h*t*q-f*m*q-h*p*u+e*m*u+f*p*d-e*t*d;c[10]=f*n*q-h*k*q+h*i*u-e*n*u-f*i*d+e*k*d;c[14]=h*k*p-f*n*p-h*i*t+e*n*t+f*i*m-e*k*m;c[3]=l*t*q-k*r*q-l*p*u+i*r*u+k*p*s-i*t*s;c[7]=f*r*q-g*t*q+g*p*u-e*r*u-f*p*s+e*t*s;c[11]=g*k*q-f*l*q-g*i*u+e*l*u+f*i*s-e*k*s;c[15]=f*l*p-g*k*p+g*i*t-e*l*t-f*i*r+e*k*r;c=e*c[0]+i*c[4]+p*c[8]+q*c[12];if(0==c){if(b)throw Error(\"Matrix4.getInverse(): can't invert matrix, determinant is 0\");console.warn(\"Matrix4.getInverse(): can't invert matrix, determinant is 0\");\nthis.identity();return this}this.multiplyScalar(1/c);return this},translate:function(){console.warn(\"DEPRECATED: Matrix4's .translate() has been removed.\")},rotateX:function(){console.warn(\"DEPRECATED: Matrix4's .rotateX() has been removed.\")},rotateY:function(){console.warn(\"DEPRECATED: Matrix4's .rotateY() has been removed.\")},rotateZ:function(){console.warn(\"DEPRECATED: Matrix4's .rotateZ() has been removed.\")},rotateByAxis:function(){console.warn(\"DEPRECATED: Matrix4's .rotateByAxis() has been removed.\")},\nscale:function(a){var b=this.elements,c=a.x,d=a.y,a=a.z;b[0]*=c;b[4]*=d;b[8]*=a;b[1]*=c;b[5]*=d;b[9]*=a;b[2]*=c;b[6]*=d;b[10]*=a;b[3]*=c;b[7]*=d;b[11]*=a;return this},getMaxScaleOnAxis:function(){var a=this.elements;return Math.sqrt(Math.max(a[0]*a[0]+a[1]*a[1]+a[2]*a[2],Math.max(a[4]*a[4]+a[5]*a[5]+a[6]*a[6],a[8]*a[8]+a[9]*a[9]+a[10]*a[10])))},makeTranslation:function(a,b,c){this.set(1,0,0,a,0,1,0,b,0,0,1,c,0,0,0,1);return this},makeRotationX:function(a){var b=Math.cos(a),a=Math.sin(a);this.set(1,\n0,0,0,0,b,-a,0,0,a,b,0,0,0,0,1);return this},makeRotationY:function(a){var b=Math.cos(a),a=Math.sin(a);this.set(b,0,a,0,0,1,0,0,-a,0,b,0,0,0,0,1);return this},makeRotationZ:function(a){var b=Math.cos(a),a=Math.sin(a);this.set(b,-a,0,0,a,b,0,0,0,0,1,0,0,0,0,1);return this},makeRotationAxis:function(a,b){var c=Math.cos(b),d=Math.sin(b),e=1-c,f=a.x,g=a.y,h=a.z,i=e*f,k=e*g;this.set(i*f+c,i*g-d*h,i*h+d*g,0,i*g+d*h,k*g+c,k*h-d*f,0,i*h-d*g,k*h+d*f,e*h*h+c,0,0,0,0,1);return this},makeScale:function(a,b,c){this.set(a,\n0,0,0,0,b,0,0,0,0,c,0,0,0,0,1);return this},compose:function(a,b,c){this.makeRotationFromQuaternion(b);this.scale(c);this.setPosition(a);return this},decompose:function(){var a=new THREE.Vector3,b=new THREE.Matrix4;return function(c,d,e){var f=this.elements,g=a.set(f[0],f[1],f[2]).length(),h=a.set(f[4],f[5],f[6]).length(),i=a.set(f[8],f[9],f[10]).length();0>this.determinant()&&(g=-g);c.x=f[12];c.y=f[13];c.z=f[14];b.elements.set(this.elements);var c=1/g,f=1/h,k=1/i;b.elements[0]*=c;b.elements[1]*=\nc;b.elements[2]*=c;b.elements[4]*=f;b.elements[5]*=f;b.elements[6]*=f;b.elements[8]*=k;b.elements[9]*=k;b.elements[10]*=k;d.setFromRotationMatrix(b);e.x=g;e.y=h;e.z=i;return this}}(),makeFrustum:function(a,b,c,d,e,f){var g=this.elements;g[0]=2*e/(b-a);g[4]=0;g[8]=(b+a)/(b-a);g[12]=0;g[1]=0;g[5]=2*e/(d-c);g[9]=(d+c)/(d-c);g[13]=0;g[2]=0;g[6]=0;g[10]=-(f+e)/(f-e);g[14]=-2*f*e/(f-e);g[3]=0;g[7]=0;g[11]=-1;g[15]=0;return this},makePerspective:function(a,b,c,d){var a=c*Math.tan(THREE.Math.degToRad(0.5*\na)),e=-a;return this.makeFrustum(e*b,a*b,e,a,c,d)},makeOrthographic:function(a,b,c,d,e,f){var g=this.elements,h=b-a,i=c-d,k=f-e;g[0]=2/h;g[4]=0;g[8]=0;g[12]=-((b+a)/h);g[1]=0;g[5]=2/i;g[9]=0;g[13]=-((c+d)/i);g[2]=0;g[6]=0;g[10]=-2/k;g[14]=-((f+e)/k);g[3]=0;g[7]=0;g[11]=0;g[15]=1;return this},fromArray:function(a){this.elements.set(a);return this},toArray:function(){var a=this.elements;return[a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15]]},clone:function(){var a=\nthis.elements;return new THREE.Matrix4(a[0],a[4],a[8],a[12],a[1],a[5],a[9],a[13],a[2],a[6],a[10],a[14],a[3],a[7],a[11],a[15])}};THREE.Ray=function(a,b){this.origin=void 0!==a?a:new THREE.Vector3;this.direction=void 0!==b?b:new THREE.Vector3};\nTHREE.Ray.prototype={constructor:THREE.Ray,set:function(a,b){this.origin.copy(a);this.direction.copy(b);return this},copy:function(a){this.origin.copy(a.origin);this.direction.copy(a.direction);return this},at:function(a,b){return(b||new THREE.Vector3).copy(this.direction).multiplyScalar(a).add(this.origin)},recast:function(){var a=new THREE.Vector3;return function(b){this.origin.copy(this.at(b,a));return this}}(),closestPointToPoint:function(a,b){var c=b||new THREE.Vector3;c.subVectors(a,this.origin);\nvar d=c.dot(this.direction);return 0>d?c.copy(this.origin):c.copy(this.direction).multiplyScalar(d).add(this.origin)},distanceToPoint:function(){var a=new THREE.Vector3;return function(b){var c=a.subVectors(b,this.origin).dot(this.direction);if(0>c)return this.origin.distanceTo(b);a.copy(this.direction).multiplyScalar(c).add(this.origin);return a.distanceTo(b)}}(),distanceSqToSegment:function(a,b,c,d){var e=a.clone().add(b).multiplyScalar(0.5),f=b.clone().sub(a).normalize(),g=0.5*a.distanceTo(b),\nh=this.origin.clone().sub(e),a=-this.direction.dot(f),b=h.dot(this.direction),i=-h.dot(f),k=h.lengthSq(),l=Math.abs(1-a*a),n,p;0<=l?(h=a*i-b,n=a*b-i,p=g*l,0<=h?n>=-p?n<=p?(g=1/l,h*=g,n*=g,a=h*(h+a*n+2*b)+n*(a*h+n+2*i)+k):(n=g,h=Math.max(0,-(a*n+b)),a=-h*h+n*(n+2*i)+k):(n=-g,h=Math.max(0,-(a*n+b)),a=-h*h+n*(n+2*i)+k):n<=-p?(h=Math.max(0,-(-a*g+b)),n=0<h?-g:Math.min(Math.max(-g,-i),g),a=-h*h+n*(n+2*i)+k):n<=p?(h=0,n=Math.min(Math.max(-g,-i),g),a=n*(n+2*i)+k):(h=Math.max(0,-(a*g+b)),n=0<h?g:Math.min(Math.max(-g,\n-i),g),a=-h*h+n*(n+2*i)+k)):(n=0<a?-g:g,h=Math.max(0,-(a*n+b)),a=-h*h+n*(n+2*i)+k);c&&c.copy(this.direction.clone().multiplyScalar(h).add(this.origin));d&&d.copy(f.clone().multiplyScalar(n).add(e));return a},isIntersectionSphere:function(a){return this.distanceToPoint(a.center)<=a.radius},isIntersectionPlane:function(a){var b=a.distanceToPoint(this.origin);return 0===b||0>a.normal.dot(this.direction)*b?!0:!1},distanceToPlane:function(a){var b=a.normal.dot(this.direction);if(0==b)return 0==a.distanceToPoint(this.origin)?\n0:null;a=-(this.origin.dot(a.normal)+a.constant)/b;return 0<=a?a:null},intersectPlane:function(a,b){var c=this.distanceToPlane(a);return null===c?null:this.at(c,b)},isIntersectionBox:function(){var a=new THREE.Vector3;return function(b){return null!==this.intersectBox(b,a)}}(),intersectBox:function(a,b){var c,d,e,f,g;d=1/this.direction.x;f=1/this.direction.y;g=1/this.direction.z;var h=this.origin;0<=d?(c=(a.min.x-h.x)*d,d*=a.max.x-h.x):(c=(a.max.x-h.x)*d,d*=a.min.x-h.x);0<=f?(e=(a.min.y-h.y)*f,f*=\na.max.y-h.y):(e=(a.max.y-h.y)*f,f*=a.min.y-h.y);if(c>f||e>d)return null;if(e>c||c!==c)c=e;if(f<d||d!==d)d=f;0<=g?(e=(a.min.z-h.z)*g,g*=a.max.z-h.z):(e=(a.max.z-h.z)*g,g*=a.min.z-h.z);if(c>g||e>d)return null;if(e>c||c!==c)c=e;if(g<d||d!==d)d=g;return 0>d?null:this.at(0<=c?c:d,b)},intersectTriangle:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3,d=new THREE.Vector3;return function(e,f,g,h,i){b.subVectors(f,e);c.subVectors(g,e);d.crossVectors(b,c);f=this.direction.dot(d);if(0<\nf){if(h)return null;h=1}else if(0>f)h=-1,f=-f;else return null;a.subVectors(this.origin,e);e=h*this.direction.dot(c.crossVectors(a,c));if(0>e)return null;g=h*this.direction.dot(b.cross(a));if(0>g||e+g>f)return null;e=-h*a.dot(d);return 0>e?null:this.at(e/f,i)}}(),applyMatrix4:function(a){this.direction.add(this.origin).applyMatrix4(a);this.origin.applyMatrix4(a);this.direction.sub(this.origin);this.direction.normalize();return this},equals:function(a){return a.origin.equals(this.origin)&&a.direction.equals(this.direction)},\nclone:function(){return(new THREE.Ray).copy(this)}};THREE.Sphere=function(a,b){this.center=void 0!==a?a:new THREE.Vector3;this.radius=void 0!==b?b:0};\nTHREE.Sphere.prototype={constructor:THREE.Sphere,set:function(a,b){this.center.copy(a);this.radius=b;return this},setFromPoints:function(){var a=new THREE.Box3;return function(b,c){var d=this.center;void 0!==c?d.copy(c):a.setFromPoints(b).center(d);for(var e=0,f=0,g=b.length;f<g;f++)e=Math.max(e,d.distanceToSquared(b[f]));this.radius=Math.sqrt(e);return this}}(),copy:function(a){this.center.copy(a.center);this.radius=a.radius;return this},empty:function(){return 0>=this.radius},containsPoint:function(a){return a.distanceToSquared(this.center)<=\nthis.radius*this.radius},distanceToPoint:function(a){return a.distanceTo(this.center)-this.radius},intersectsSphere:function(a){var b=this.radius+a.radius;return a.center.distanceToSquared(this.center)<=b*b},clampPoint:function(a,b){var c=this.center.distanceToSquared(a),d=b||new THREE.Vector3;d.copy(a);c>this.radius*this.radius&&(d.sub(this.center).normalize(),d.multiplyScalar(this.radius).add(this.center));return d},getBoundingBox:function(a){a=a||new THREE.Box3;a.set(this.center,this.center);a.expandByScalar(this.radius);\nreturn a},applyMatrix4:function(a){this.center.applyMatrix4(a);this.radius*=a.getMaxScaleOnAxis();return this},translate:function(a){this.center.add(a);return this},equals:function(a){return a.center.equals(this.center)&&a.radius===this.radius},clone:function(){return(new THREE.Sphere).copy(this)}};THREE.Frustum=function(a,b,c,d,e,f){this.planes=[void 0!==a?a:new THREE.Plane,void 0!==b?b:new THREE.Plane,void 0!==c?c:new THREE.Plane,void 0!==d?d:new THREE.Plane,void 0!==e?e:new THREE.Plane,void 0!==f?f:new THREE.Plane]};\nTHREE.Frustum.prototype={constructor:THREE.Frustum,set:function(a,b,c,d,e,f){var g=this.planes;g[0].copy(a);g[1].copy(b);g[2].copy(c);g[3].copy(d);g[4].copy(e);g[5].copy(f);return this},copy:function(a){for(var b=this.planes,c=0;6>c;c++)b[c].copy(a.planes[c]);return this},setFromMatrix:function(a){var b=this.planes,c=a.elements,a=c[0],d=c[1],e=c[2],f=c[3],g=c[4],h=c[5],i=c[6],k=c[7],l=c[8],n=c[9],p=c[10],t=c[11],r=c[12],m=c[13],q=c[14],c=c[15];b[0].setComponents(f-a,k-g,t-l,c-r).normalize();b[1].setComponents(f+\na,k+g,t+l,c+r).normalize();b[2].setComponents(f+d,k+h,t+n,c+m).normalize();b[3].setComponents(f-d,k-h,t-n,c-m).normalize();b[4].setComponents(f-e,k-i,t-p,c-q).normalize();b[5].setComponents(f+e,k+i,t+p,c+q).normalize();return this},intersectsObject:function(){var a=new THREE.Sphere;return function(b){var c=b.geometry;null===c.boundingSphere&&c.computeBoundingSphere();a.copy(c.boundingSphere);a.applyMatrix4(b.matrixWorld);return this.intersectsSphere(a)}}(),intersectsSphere:function(a){for(var b=this.planes,\nc=a.center,a=-a.radius,d=0;6>d;d++)if(b[d].distanceToPoint(c)<a)return!1;return!0},intersectsBox:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c){for(var d=this.planes,e=0;6>e;e++){var f=d[e];a.x=0<f.normal.x?c.min.x:c.max.x;b.x=0<f.normal.x?c.max.x:c.min.x;a.y=0<f.normal.y?c.min.y:c.max.y;b.y=0<f.normal.y?c.max.y:c.min.y;a.z=0<f.normal.z?c.min.z:c.max.z;b.z=0<f.normal.z?c.max.z:c.min.z;var g=f.distanceToPoint(a),f=f.distanceToPoint(b);if(0>g&&0>f)return!1}return!0}}(),containsPoint:function(a){for(var b=\nthis.planes,c=0;6>c;c++)if(0>b[c].distanceToPoint(a))return!1;return!0},clone:function(){return(new THREE.Frustum).copy(this)}};THREE.Plane=function(a,b){this.normal=void 0!==a?a:new THREE.Vector3(1,0,0);this.constant=void 0!==b?b:0};\nTHREE.Plane.prototype={constructor:THREE.Plane,set:function(a,b){this.normal.copy(a);this.constant=b;return this},setComponents:function(a,b,c,d){this.normal.set(a,b,c);this.constant=d;return this},setFromNormalAndCoplanarPoint:function(a,b){this.normal.copy(a);this.constant=-b.dot(this.normal);return this},setFromCoplanarPoints:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d,e){d=a.subVectors(e,d).cross(b.subVectors(c,d)).normalize();this.setFromNormalAndCoplanarPoint(d,\nc);return this}}(),copy:function(a){this.normal.copy(a.normal);this.constant=a.constant;return this},normalize:function(){var a=1/this.normal.length();this.normal.multiplyScalar(a);this.constant*=a;return this},negate:function(){this.constant*=-1;this.normal.negate();return this},distanceToPoint:function(a){return this.normal.dot(a)+this.constant},distanceToSphere:function(a){return this.distanceToPoint(a.center)-a.radius},projectPoint:function(a,b){return this.orthoPoint(a,b).sub(a).negate()},orthoPoint:function(a,\nb){var c=this.distanceToPoint(a);return(b||new THREE.Vector3).copy(this.normal).multiplyScalar(c)},isIntersectionLine:function(a){var b=this.distanceToPoint(a.start),a=this.distanceToPoint(a.end);return 0>b&&0<a||0>a&&0<b},intersectLine:function(){var a=new THREE.Vector3;return function(b,c){var d=c||new THREE.Vector3,e=b.delta(a),f=this.normal.dot(e);if(0==f){if(0==this.distanceToPoint(b.start))return d.copy(b.start)}else return f=-(b.start.dot(this.normal)+this.constant)/f,0>f||1<f?void 0:d.copy(e).multiplyScalar(f).add(b.start)}}(),\ncoplanarPoint:function(a){return(a||new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)},applyMatrix4:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Matrix3;return function(d,e){var f=e||c.getNormalMatrix(d),f=a.copy(this.normal).applyMatrix3(f),g=this.coplanarPoint(b);g.applyMatrix4(d);this.setFromNormalAndCoplanarPoint(f,g);return this}}(),translate:function(a){this.constant-=a.dot(this.normal);return this},equals:function(a){return a.normal.equals(this.normal)&&\na.constant==this.constant},clone:function(){return(new THREE.Plane).copy(this)}};THREE.Math={PI2:2*Math.PI,generateUUID:function(){var a=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".split(\"\"),b=Array(36),c=0,d;return function(){for(var e=0;36>e;e++)8==e||13==e||18==e||23==e?b[e]=\"-\":14==e?b[e]=\"4\":(2>=c&&(c=33554432+16777216*Math.random()|0),d=c&15,c>>=4,b[e]=a[19==e?d&3|8:d]);return b.join(\"\")}}(),clamp:function(a,b,c){return a<b?b:a>c?c:a},clampBottom:function(a,b){return a<b?b:a},mapLinear:function(a,b,c,d,e){return d+(a-b)*(e-d)/(c-b)},smoothstep:function(a,\nb,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*(3-2*a)},smootherstep:function(a,b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*a*(a*(6*a-15)+10)},random16:function(){return(65280*Math.random()+255*Math.random())/65535},randInt:function(a,b){return a+Math.floor(Math.random()*(b-a+1))},randFloat:function(a,b){return a+Math.random()*(b-a)},randFloatSpread:function(a){return a*(0.5-Math.random())},sign:function(a){return 0>a?-1:0<a?1:0},degToRad:function(){var a=Math.PI/\n180;return function(b){return b*a}}(),radToDeg:function(){var a=180/Math.PI;return function(b){return b*a}}()};THREE.Spline=function(a){function b(a,b,c,d,e,f,g){a=0.5*(c-a);d=0.5*(d-b);return(2*(b-c)+a+d)*g+(-3*(b-c)-2*a-d)*f+a*e+b}this.points=a;var c=[],d={x:0,y:0,z:0},e,f,g,h,i,k,l,n,p;this.initFromArray=function(a){this.points=[];for(var b=0;b<a.length;b++)this.points[b]={x:a[b][0],y:a[b][1],z:a[b][2]}};this.getPoint=function(a){e=(this.points.length-1)*a;f=Math.floor(e);g=e-f;c[0]=0===f?f:f-1;c[1]=f;c[2]=f>this.points.length-2?this.points.length-1:f+1;c[3]=f>this.points.length-3?this.points.length-1:\nf+2;k=this.points[c[0]];l=this.points[c[1]];n=this.points[c[2]];p=this.points[c[3]];h=g*g;i=g*h;d.x=b(k.x,l.x,n.x,p.x,g,h,i);d.y=b(k.y,l.y,n.y,p.y,g,h,i);d.z=b(k.z,l.z,n.z,p.z,g,h,i);return d};this.getControlPointsArray=function(){var a,b,c=this.points.length,d=[];for(a=0;a<c;a++)b=this.points[a],d[a]=[b.x,b.y,b.z];return d};this.getLength=function(a){var b,c,d,e=b=b=0,f=new THREE.Vector3,g=new THREE.Vector3,h=[],i=0;h[0]=0;a||(a=100);c=this.points.length*a;f.copy(this.points[0]);for(a=1;a<c;a++)b=\na/c,d=this.getPoint(b),g.copy(d),i+=g.distanceTo(f),f.copy(d),b*=this.points.length-1,b=Math.floor(b),b!=e&&(h[b]=i,e=b);h[h.length]=i;return{chunks:h,total:i}};this.reparametrizeByArcLength=function(a){var b,c,d,e,f,g,h=[],i=new THREE.Vector3,k=this.getLength();h.push(i.copy(this.points[0]).clone());for(b=1;b<this.points.length;b++){c=k.chunks[b]-k.chunks[b-1];g=Math.ceil(a*c/k.total);e=(b-1)/(this.points.length-1);f=b/(this.points.length-1);for(c=1;c<g-1;c++)d=e+c*(1/g)*(f-e),d=this.getPoint(d),\nh.push(i.copy(d).clone());h.push(i.copy(this.points[b]).clone())}this.points=h}};THREE.Triangle=function(a,b,c){this.a=void 0!==a?a:new THREE.Vector3;this.b=void 0!==b?b:new THREE.Vector3;this.c=void 0!==c?c:new THREE.Vector3};THREE.Triangle.normal=function(){var a=new THREE.Vector3;return function(b,c,d,e){e=e||new THREE.Vector3;e.subVectors(d,c);a.subVectors(b,c);e.cross(a);b=e.lengthSq();return 0<b?e.multiplyScalar(1/Math.sqrt(b)):e.set(0,0,0)}}();\nTHREE.Triangle.barycoordFromPoint=function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(d,e,f,g,h){a.subVectors(g,e);b.subVectors(f,e);c.subVectors(d,e);var d=a.dot(a),e=a.dot(b),f=a.dot(c),i=b.dot(b),g=b.dot(c),k=d*i-e*e,h=h||new THREE.Vector3;if(0==k)return h.set(-2,-1,-1);k=1/k;i=(i*f-e*g)*k;d=(d*g-e*f)*k;return h.set(1-i-d,d,i)}}();\nTHREE.Triangle.containsPoint=function(){var a=new THREE.Vector3;return function(b,c,d,e){b=THREE.Triangle.barycoordFromPoint(b,c,d,e,a);return 0<=b.x&&0<=b.y&&1>=b.x+b.y}}();\nTHREE.Triangle.prototype={constructor:THREE.Triangle,set:function(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this},setFromPointsAndIndices:function(a,b,c,d){this.a.copy(a[b]);this.b.copy(a[c]);this.c.copy(a[d]);return this},copy:function(a){this.a.copy(a.a);this.b.copy(a.b);this.c.copy(a.c);return this},area:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(){a.subVectors(this.c,this.b);b.subVectors(this.a,this.b);return 0.5*a.cross(b).length()}}(),midpoint:function(a){return(a||\nnew THREE.Vector3).addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},normal:function(a){return THREE.Triangle.normal(this.a,this.b,this.c,a)},plane:function(a){return(a||new THREE.Plane).setFromCoplanarPoints(this.a,this.b,this.c)},barycoordFromPoint:function(a,b){return THREE.Triangle.barycoordFromPoint(a,this.a,this.b,this.c,b)},containsPoint:function(a){return THREE.Triangle.containsPoint(a,this.a,this.b,this.c)},equals:function(a){return a.a.equals(this.a)&&a.b.equals(this.b)&&a.c.equals(this.c)},\nclone:function(){return(new THREE.Triangle).copy(this)}};THREE.Vertex=function(a){console.warn(\"THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.\");return a};THREE.UV=function(a,b){console.warn(\"THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.\");return new THREE.Vector2(a,b)};THREE.Clock=function(a){this.autoStart=void 0!==a?a:!0;this.elapsedTime=this.oldTime=this.startTime=0;this.running=!1};\nTHREE.Clock.prototype={constructor:THREE.Clock,start:function(){this.oldTime=this.startTime=void 0!==self.performance&&void 0!==self.performance.now?self.performance.now():Date.now();this.running=!0},stop:function(){this.getElapsedTime();this.running=!1},getElapsedTime:function(){this.getDelta();return this.elapsedTime},getDelta:function(){var a=0;this.autoStart&&!this.running&&this.start();if(this.running){var b=void 0!==self.performance&&void 0!==self.performance.now?self.performance.now():Date.now(),\na=0.001*(b-this.oldTime);this.oldTime=b;this.elapsedTime+=a}return a}};THREE.EventDispatcher=function(){};\nTHREE.EventDispatcher.prototype={constructor:THREE.EventDispatcher,apply:function(a){a.addEventListener=THREE.EventDispatcher.prototype.addEventListener;a.hasEventListener=THREE.EventDispatcher.prototype.hasEventListener;a.removeEventListener=THREE.EventDispatcher.prototype.removeEventListener;a.dispatchEvent=THREE.EventDispatcher.prototype.dispatchEvent},addEventListener:function(a,b){void 0===this._listeners&&(this._listeners={});var c=this._listeners;void 0===c[a]&&(c[a]=[]);-1===c[a].indexOf(b)&&\nc[a].push(b)},hasEventListener:function(a,b){if(void 0===this._listeners)return!1;var c=this._listeners;return void 0!==c[a]&&-1!==c[a].indexOf(b)?!0:!1},removeEventListener:function(a,b){if(void 0!==this._listeners){var c=this._listeners[a];if(void 0!==c){var d=c.indexOf(b);-1!==d&&c.splice(d,1)}}},dispatchEvent:function(){var a=[];return function(b){if(void 0!==this._listeners){var c=this._listeners[b.type];if(void 0!==c){b.target=this;for(var d=c.length,e=0;e<d;e++)a[e]=c[e];for(e=0;e<d;e++)a[e].call(this,\nb)}}}}()};(function(a){a.Raycaster=function(b,c,d,e){this.ray=new a.Ray(b,c);this.near=d||0;this.far=e||Infinity};var b=new a.Sphere,c=new a.Ray;new a.Plane;new a.Vector3;var d=new a.Vector3,e=new a.Matrix4,f=function(a,b){return a.distance-b.distance},g=new a.Vector3,h=new a.Vector3,i=new a.Vector3,k=function(f,l,t){if(f instanceof a.Sprite){d.setFromMatrixPosition(f.matrixWorld);var r=l.ray.distanceToPoint(d);if(r>f.scale.x)return t;t.push({distance:r,point:f.position,face:null,object:f})}else if(f instanceof\na.LOD)d.setFromMatrixPosition(f.matrixWorld),r=l.ray.origin.distanceTo(d),k(f.getObjectForDistance(r),l,t);else if(f instanceof a.Mesh){var m=f.geometry;null===m.boundingSphere&&m.computeBoundingSphere();b.copy(m.boundingSphere);b.applyMatrix4(f.matrixWorld);if(!1===l.ray.isIntersectionSphere(b))return t;e.getInverse(f.matrixWorld);c.copy(l.ray).applyMatrix4(e);if(null!==m.boundingBox&&!1===c.isIntersectionBox(m.boundingBox))return t;if(m instanceof a.BufferGeometry){var q=f.material;if(void 0===\nq||!1===m.dynamic)return t;var u,s,v=l.precision;if(void 0!==m.attributes.index)for(var z=m.offsets,G=m.attributes.index.array,N=m.attributes.position.array,C=m.offsets.length,B=m.attributes.index.array.length/3,B=0;B<C;++B)for(var r=z[B].start,x=z[B].index,m=r,F=r+z[B].count;m<F;m+=3)r=x+G[m],u=x+G[m+1],s=x+G[m+2],g.set(N[3*r],N[3*r+1],N[3*r+2]),h.set(N[3*u],N[3*u+1],N[3*u+2]),i.set(N[3*s],N[3*s+1],N[3*s+2]),u=q.side===a.BackSide?c.intersectTriangle(i,h,g,!0):c.intersectTriangle(g,h,i,q.side!==a.DoubleSide),\nnull!==u&&(u.applyMatrix4(f.matrixWorld),r=l.ray.origin.distanceTo(u),r<v||(r<l.near||r>l.far)||t.push({distance:r,point:u,face:null,faceIndex:null,object:f}));else{N=m.attributes.position.array;B=m.attributes.position.array.length;for(m=0;m<B;m+=3)r=m,u=m+1,s=m+2,g.set(N[3*r],N[3*r+1],N[3*r+2]),h.set(N[3*u],N[3*u+1],N[3*u+2]),i.set(N[3*s],N[3*s+1],N[3*s+2]),u=q.side===a.BackSide?c.intersectTriangle(i,h,g,!0):c.intersectTriangle(g,h,i,q.side!==a.DoubleSide),null!==u&&(u.applyMatrix4(f.matrixWorld),\nr=l.ray.origin.distanceTo(u),r<v||(r<l.near||r>l.far)||t.push({distance:r,point:u,face:null,faceIndex:null,object:f}))}}else if(m instanceof a.Geometry){G=f.material instanceof a.MeshFaceMaterial;N=!0===G?f.material.materials:null;v=l.precision;z=m.vertices;C=0;for(B=m.faces.length;C<B;C++)if(x=m.faces[C],q=!0===G?N[x.materialIndex]:f.material,void 0!==q){r=z[x.a];u=z[x.b];s=z[x.c];if(!0===q.morphTargets){var F=m.morphTargets,L=f.morphTargetInfluences;g.set(0,0,0);h.set(0,0,0);i.set(0,0,0);for(var w=\n0,E=F.length;w<E;w++){var y=L[w];if(0!==y){var D=F[w].vertices;g.x+=(D[x.a].x-r.x)*y;g.y+=(D[x.a].y-r.y)*y;g.z+=(D[x.a].z-r.z)*y;h.x+=(D[x.b].x-u.x)*y;h.y+=(D[x.b].y-u.y)*y;h.z+=(D[x.b].z-u.z)*y;i.x+=(D[x.c].x-s.x)*y;i.y+=(D[x.c].y-s.y)*y;i.z+=(D[x.c].z-s.z)*y}}g.add(r);h.add(u);i.add(s);r=g;u=h;s=i}u=q.side===a.BackSide?c.intersectTriangle(s,u,r,!0):c.intersectTriangle(r,u,s,q.side!==a.DoubleSide);null!==u&&(u.applyMatrix4(f.matrixWorld),r=l.ray.origin.distanceTo(u),r<v||(r<l.near||r>l.far)||t.push({distance:r,\npoint:u,face:x,faceIndex:C,object:f}))}}}else if(f instanceof a.Line){v=l.linePrecision;q=v*v;m=f.geometry;null===m.boundingSphere&&m.computeBoundingSphere();b.copy(m.boundingSphere);b.applyMatrix4(f.matrixWorld);if(!1===l.ray.isIntersectionSphere(b))return t;e.getInverse(f.matrixWorld);c.copy(l.ray).applyMatrix4(e);if(m instanceof a.Geometry){z=m.vertices;v=z.length;u=new a.Vector3;s=new a.Vector3;B=f.type===a.LineStrip?1:2;for(m=0;m<v-1;m+=B)c.distanceSqToSegment(z[m],z[m+1],s,u)>q||(r=c.origin.distanceTo(s),\nr<l.near||r>l.far||t.push({distance:r,point:u.clone().applyMatrix4(f.matrixWorld),face:null,faceIndex:null,object:f}))}}},l=function(a,b,c){for(var a=a.getDescendants(),d=0,e=a.length;d<e;d++)k(a[d],b,c)};a.Raycaster.prototype.precision=1E-4;a.Raycaster.prototype.linePrecision=1;a.Raycaster.prototype.set=function(a,b){this.ray.set(a,b)};a.Raycaster.prototype.intersectObject=function(a,b){var c=[];!0===b&&l(a,this,c);k(a,this,c);c.sort(f);return c};a.Raycaster.prototype.intersectObjects=function(a,\nb){for(var c=[],d=0,e=a.length;d<e;d++)k(a[d],this,c),!0===b&&l(a[d],this,c);c.sort(f);return c}})(THREE);THREE.Object3D=function(){this.id=THREE.Object3DIdCount++;this.uuid=THREE.Math.generateUUID();this.name=\"\";this.parent=void 0;this.children=[];this.up=new THREE.Vector3(0,1,0);this.position=new THREE.Vector3;this._rotation=new THREE.Euler;this._quaternion=new THREE.Quaternion;this.scale=new THREE.Vector3(1,1,1);this._rotation._quaternion=this.quaternion;this._quaternion._euler=this.rotation;this.renderDepth=null;this.rotationAutoUpdate=!0;this.matrix=new THREE.Matrix4;this.matrixWorld=new THREE.Matrix4;\nthis.visible=this.matrixWorldNeedsUpdate=this.matrixAutoUpdate=!0;this.receiveShadow=this.castShadow=!1;this.frustumCulled=!0;this.userData={}};\nTHREE.Object3D.prototype={constructor:THREE.Object3D,get rotation(){return this._rotation},set rotation(a){this._rotation=a;this._rotation._quaternion=this._quaternion;this._quaternion._euler=this._rotation;this._rotation._updateQuaternion()},get quaternion(){return this._quaternion},set quaternion(a){this._quaternion=a;this._quaternion._euler=this._rotation;this._rotation._quaternion=this._quaternion;this._quaternion._updateEuler()},get eulerOrder(){console.warn(\"DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order.\");\nreturn this.rotation.order},set eulerOrder(a){console.warn(\"DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order.\");this.rotation.order=a},get useQuaternion(){console.warn(\"DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.\")},set useQuaternion(a){console.warn(\"DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.\")},applyMatrix:function(a){this.matrix.multiplyMatrices(a,this.matrix);\nthis.matrix.decompose(this.position,this.quaternion,this.scale)},setRotationFromAxisAngle:function(a,b){this.quaternion.setFromAxisAngle(a,b)},setRotationFromEuler:function(a){this.quaternion.setFromEuler(a,!0)},setRotationFromMatrix:function(a){this.quaternion.setFromRotationMatrix(a)},setRotationFromQuaternion:function(a){this.quaternion.copy(a)},rotateOnAxis:function(){var a=new THREE.Quaternion;return function(b,c){a.setFromAxisAngle(b,c);this.quaternion.multiply(a);return this}}(),rotateX:function(){var a=\nnew THREE.Vector3(1,0,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateY:function(){var a=new THREE.Vector3(0,1,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateZ:function(){var a=new THREE.Vector3(0,0,1);return function(b){return this.rotateOnAxis(a,b)}}(),translateOnAxis:function(){var a=new THREE.Vector3;return function(b,c){a.copy(b);a.applyQuaternion(this.quaternion);this.position.add(a.multiplyScalar(c));return this}}(),translate:function(a,b){console.warn(\"DEPRECATED: Object3D's .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.\");\nreturn this.translateOnAxis(b,a)},translateX:function(){var a=new THREE.Vector3(1,0,0);return function(b){return this.translateOnAxis(a,b)}}(),translateY:function(){var a=new THREE.Vector3(0,1,0);return function(b){return this.translateOnAxis(a,b)}}(),translateZ:function(){var a=new THREE.Vector3(0,0,1);return function(b){return this.translateOnAxis(a,b)}}(),localToWorld:function(a){return a.applyMatrix4(this.matrixWorld)},worldToLocal:function(){var a=new THREE.Matrix4;return function(b){return b.applyMatrix4(a.getInverse(this.matrixWorld))}}(),\nlookAt:function(){var a=new THREE.Matrix4;return function(b){a.lookAt(b,this.position,this.up);this.quaternion.setFromRotationMatrix(a)}}(),add:function(a){if(a===this)console.warn(\"THREE.Object3D.add: An object can't be added as a child of itself.\");else if(a instanceof THREE.Object3D){void 0!==a.parent&&a.parent.remove(a);a.parent=this;a.dispatchEvent({type:\"added\"});this.children.push(a);for(var b=this;void 0!==b.parent;)b=b.parent;void 0!==b&&b instanceof THREE.Scene&&b.__addObject(a)}},remove:function(a){var b=\nthis.children.indexOf(a);if(-1!==b){a.parent=void 0;a.dispatchEvent({type:\"removed\"});this.children.splice(b,1);for(b=this;void 0!==b.parent;)b=b.parent;void 0!==b&&b instanceof THREE.Scene&&b.__removeObject(a)}},traverse:function(a){a(this);for(var b=0,c=this.children.length;b<c;b++)this.children[b].traverse(a)},getObjectById:function(a,b){for(var c=0,d=this.children.length;c<d;c++){var e=this.children[c];if(e.id===a||!0===b&&(e=e.getObjectById(a,b),void 0!==e))return e}},getObjectByName:function(a,\nb){for(var c=0,d=this.children.length;c<d;c++){var e=this.children[c];if(e.name===a||!0===b&&(e=e.getObjectByName(a,b),void 0!==e))return e}},getChildByName:function(a,b){console.warn(\"DEPRECATED: Object3D's .getChildByName() has been renamed to .getObjectByName().\");return this.getObjectByName(a,b)},getDescendants:function(a){void 0===a&&(a=[]);Array.prototype.push.apply(a,this.children);for(var b=0,c=this.children.length;b<c;b++)this.children[b].getDescendants(a);return a},updateMatrix:function(){this.matrix.compose(this.position,\nthis.quaternion,this.scale);this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(a){!0===this.matrixAutoUpdate&&this.updateMatrix();if(!0===this.matrixWorldNeedsUpdate||!0===a)void 0===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,a=!0;for(var b=0,c=this.children.length;b<c;b++)this.children[b].updateMatrixWorld(a)},clone:function(a,b){void 0===a&&(a=new THREE.Object3D);void 0===b&&(b=!0);\na.name=this.name;a.up.copy(this.up);a.position.copy(this.position);a.quaternion.copy(this.quaternion);a.scale.copy(this.scale);a.renderDepth=this.renderDepth;a.rotationAutoUpdate=this.rotationAutoUpdate;a.matrix.copy(this.matrix);a.matrixWorld.copy(this.matrixWorld);a.matrixAutoUpdate=this.matrixAutoUpdate;a.matrixWorldNeedsUpdate=this.matrixWorldNeedsUpdate;a.visible=this.visible;a.castShadow=this.castShadow;a.receiveShadow=this.receiveShadow;a.frustumCulled=this.frustumCulled;a.userData=JSON.parse(JSON.stringify(this.userData));\nif(!0===b)for(var c=0;c<this.children.length;c++)a.add(this.children[c].clone());return a}};THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);THREE.Object3DIdCount=0;THREE.Projector=function(){function a(){if(i===l){var a=new THREE.RenderableVertex;k.push(a);l++;i++;return a}return k[i++]}function b(a,b){return a.z!==b.z?b.z-a.z:a.id!==b.id?a.id-b.id:0}function c(a,b){var c=0,d=1,e=a.z+a.w,f=b.z+b.w,g=-a.z+a.w,h=-b.z+b.w;if(0<=e&&0<=f&&0<=g&&0<=h)return!0;if(0>e&&0>f||0>g&&0>h)return!1;0>e?c=Math.max(c,e/(e-f)):0>f&&(d=Math.min(d,e/(e-f)));0>g?c=Math.max(c,g/(g-h)):0>h&&(d=Math.min(d,g/(g-h)));if(d<c)return!1;a.lerp(b,c);b.lerp(a,1-d);return!0}var d,e,f=[],g=\n0,h,i,k=[],l=0,n,p,t=[],r=0,m,q,u=[],s=0,v,z,G=[],N=0,C={objects:[],sprites:[],lights:[],elements:[]},B=new THREE.Vector3,x=new THREE.Vector3,F=new THREE.Vector3,L=new THREE.Vector3,w=new THREE.Vector4,E=new THREE.Box3(new THREE.Vector3(-1,-1,-1),new THREE.Vector3(1,1,1)),y=new THREE.Box3,D=Array(3),H=new THREE.Matrix4,K=new THREE.Matrix4,A,da=new THREE.Matrix4,ha=new THREE.Matrix3,ua=new THREE.Matrix3,O=new THREE.Vector3,T=new THREE.Frustum,ea=new THREE.Vector4,I=new THREE.Vector4;this.projectVector=\nfunction(a,b){b.matrixWorldInverse.getInverse(b.matrixWorld);K.multiplyMatrices(b.projectionMatrix,b.matrixWorldInverse);return a.applyProjection(K)};var P=new THREE.Matrix4;this.unprojectVector=function(a,b){P.getInverse(b.projectionMatrix);K.multiplyMatrices(b.matrixWorld,P);return a.applyProjection(K)};this.pickingRay=function(a,b){a.z=-1;var c=new THREE.Vector3(a.x,a.y,1);this.unprojectVector(a,b);this.unprojectVector(c,b);c.sub(a).normalize();return new THREE.Raycaster(a,c)};var Q=function(a){if(e===\ng){var b=new THREE.RenderableObject;f.push(b);g++;e++;d=b}else d=f[e++];d.id=a.id;d.object=a;null!==a.renderDepth?d.z=a.renderDepth:(L.setFromMatrixPosition(a.matrixWorld),L.applyProjection(K),d.z=L.z);return d},oa=function(a){var b=a.positionWorld,c=a.positionScreen;b.copy(a.position).applyMatrix4(A);c.copy(b).applyMatrix4(K);b=1/c.w;c.x*=b;c.y*=b;c.z*=b;a.visible=-1<=c.x&&1>=c.x&&-1<=c.y&&1>=c.y&&-1<=c.z&&1>=c.z},va=function(a){if(!1!==a.visible){a instanceof THREE.Light?C.lights.push(a):a instanceof\nTHREE.Mesh||a instanceof THREE.Line?(!1===a.frustumCulled||!0===T.intersectsObject(a))&&C.objects.push(Q(a)):a instanceof THREE.Sprite&&C.sprites.push(Q(a));for(var b=0,c=a.children.length;b<c;b++)va(a.children[b])}};this.projectScene=function(d,f,g,l){var P=!1,L,Q,ba,W,Ka,U,ca,wa,Ua;z=q=p=0;C.elements.length=0;!0===d.autoUpdate&&d.updateMatrixWorld();void 0===f.parent&&f.updateMatrixWorld();H.copy(f.matrixWorldInverse.getInverse(f.matrixWorld));K.multiplyMatrices(f.projectionMatrix,H);ua.getNormalMatrix(H);\nT.setFromMatrix(K);e=0;C.objects.length=0;C.sprites.length=0;C.lights.length=0;va(d);!0===g&&C.objects.sort(b);for(var g=0,Oa=C.objects.length;g<Oa;g++)if(d=C.objects[g].object,A=d.matrixWorld,i=0,d instanceof THREE.Mesh){L=d.geometry;Q=L.vertices;ba=L.faces;Ka=L.faceVertexUvs;ha.getNormalMatrix(A);wa=d.material instanceof THREE.MeshFaceMaterial;Ua=!0===wa?d.material:null;for(var la=0,ia=Q.length;la<ia;la++)h=a(),h.position.copy(Q[la]),oa(h);la=0;for(ia=ba.length;la<ia;la++){Q=ba[la];var Fa=!0===\nwa?Ua.materials[Q.materialIndex]:d.material;if(void 0!==Fa){var Ga=Fa.side;W=k[Q.a];U=k[Q.b];ca=k[Q.c];if(!0===Fa.morphTargets){var P=L.morphTargets,Ba=d.morphTargetInfluences,xa=W.position,Va=U.position,La=ca.position;B.set(0,0,0);x.set(0,0,0);F.set(0,0,0);for(var Ma=0,ya=P.length;Ma<ya;Ma++){var V=Ba[Ma];if(0!==V){var pa=P[Ma].vertices;B.x+=(pa[Q.a].x-xa.x)*V;B.y+=(pa[Q.a].y-xa.y)*V;B.z+=(pa[Q.a].z-xa.z)*V;x.x+=(pa[Q.b].x-Va.x)*V;x.y+=(pa[Q.b].y-Va.y)*V;x.z+=(pa[Q.b].z-Va.z)*V;F.x+=(pa[Q.c].x-La.x)*\nV;F.y+=(pa[Q.c].y-La.y)*V;F.z+=(pa[Q.c].z-La.z)*V}}W.position.add(B);U.position.add(x);ca.position.add(F);oa(W);oa(U);oa(ca)}D[0]=W.positionScreen;D[1]=U.positionScreen;D[2]=ca.positionScreen;if(!0===W.visible||!0===U.visible||!0===ca.visible||E.isIntersectionBox(y.setFromPoints(D)))if(P=0>(ca.positionScreen.x-W.positionScreen.x)*(U.positionScreen.y-W.positionScreen.y)-(ca.positionScreen.y-W.positionScreen.y)*(U.positionScreen.x-W.positionScreen.x),Ga===THREE.DoubleSide||P===(Ga===THREE.FrontSide)){p===\nr?(Ba=new THREE.RenderableFace3,t.push(Ba),r++,p++,n=Ba):n=t[p++];n.id=d.id;n.v1.copy(W);n.v2.copy(U);n.v3.copy(ca);n.normalModel.copy(Q.normal);!1===P&&(Ga===THREE.BackSide||Ga===THREE.DoubleSide)&&n.normalModel.negate();n.normalModel.applyMatrix3(ha).normalize();n.normalModelView.copy(n.normalModel).applyMatrix3(ua);n.centroidModel.copy(Q.centroid).applyMatrix4(A);W=Q.vertexNormals;U=0;for(ca=Math.min(W.length,3);U<ca;U++)Ba=n.vertexNormalsModel[U],Ba.copy(W[U]),!1===P&&(Ga===THREE.BackSide||Ga===\nTHREE.DoubleSide)&&Ba.negate(),Ba.applyMatrix3(ha).normalize(),n.vertexNormalsModelView[U].copy(Ba).applyMatrix3(ua);n.vertexNormalsLength=W.length;U=0;for(Ga=Math.min(Ka.length,3);U<Ga;U++)if(W=Ka[U][la],void 0!==W){ca=0;for(P=W.length;ca<P;ca++)n.uvs[U][ca]=W[ca]}n.color=Q.color;n.material=Fa;O.copy(n.centroidModel).applyProjection(K);n.z=O.z;C.elements.push(n)}}}}else if(d instanceof THREE.Line){da.multiplyMatrices(K,A);Q=d.geometry.vertices;W=a();W.positionScreen.copy(Q[0]).applyMatrix4(da);L=\nd.type===THREE.LinePieces?2:1;la=1;for(ia=Q.length;la<ia;la++)W=a(),W.positionScreen.copy(Q[la]).applyMatrix4(da),0<(la+1)%L||(U=k[i-2],ea.copy(W.positionScreen),I.copy(U.positionScreen),!0===c(ea,I)&&(ea.multiplyScalar(1/ea.w),I.multiplyScalar(1/I.w),q===s?(ba=new THREE.RenderableLine,u.push(ba),s++,q++,m=ba):m=u[q++],m.id=d.id,m.v1.positionScreen.copy(ea),m.v2.positionScreen.copy(I),m.z=Math.max(ea.z,I.z),m.material=d.material,d.material.vertexColors===THREE.VertexColors&&(m.vertexColors[0].copy(d.geometry.colors[la]),\nm.vertexColors[1].copy(d.geometry.colors[la-1])),C.elements.push(m)))}g=0;for(Oa=C.sprites.length;g<Oa;g++)d=C.sprites[g].object,A=d.matrixWorld,w.set(A.elements[12],A.elements[13],A.elements[14],1),w.applyMatrix4(K),L=1/w.w,w.z*=L,-1<=w.z&&1>=w.z&&(z===N?(ba=new THREE.RenderableSprite,G.push(ba),N++,z++,v=ba):v=G[z++],v.id=d.id,v.x=w.x*L,v.y=w.y*L,v.z=w.z,v.object=d,v.rotation=d.rotation,v.scale.x=d.scale.x*Math.abs(v.x-(w.x+f.projectionMatrix.elements[0])/(w.w+f.projectionMatrix.elements[12])),\nv.scale.y=d.scale.y*Math.abs(v.y-(w.y+f.projectionMatrix.elements[5])/(w.w+f.projectionMatrix.elements[13])),v.material=d.material,C.elements.push(v));!0===l&&C.elements.sort(b);return C}};THREE.Face3=function(a,b,c,d,e,f){this.a=a;this.b=b;this.c=c;this.normal=d instanceof THREE.Vector3?d:new THREE.Vector3;this.vertexNormals=d instanceof Array?d:[];this.color=e instanceof THREE.Color?e:new THREE.Color;this.vertexColors=e instanceof Array?e:[];this.vertexTangents=[];this.materialIndex=void 0!==f?f:0;this.centroid=new THREE.Vector3};\nTHREE.Face3.prototype={constructor:THREE.Face3,clone:function(){var a=new THREE.Face3(this.a,this.b,this.c);a.normal.copy(this.normal);a.color.copy(this.color);a.centroid.copy(this.centroid);a.materialIndex=this.materialIndex;var b,c;b=0;for(c=this.vertexNormals.length;b<c;b++)a.vertexNormals[b]=this.vertexNormals[b].clone();b=0;for(c=this.vertexColors.length;b<c;b++)a.vertexColors[b]=this.vertexColors[b].clone();b=0;for(c=this.vertexTangents.length;b<c;b++)a.vertexTangents[b]=this.vertexTangents[b].clone();\nreturn a}};THREE.Face4=function(a,b,c,d,e,f,g){console.warn(\"THREE.Face4 has been removed. A THREE.Face3 will be created instead.\");return new THREE.Face3(a,b,c,e,f,g)};THREE.Geometry=function(){this.id=THREE.GeometryIdCount++;this.uuid=THREE.Math.generateUUID();this.name=\"\";this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphColors=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingSphere=this.boundingBox=null;this.hasTangents=!1;this.dynamic=!0;this.buffersNeedUpdate=this.lineDistancesNeedUpdate=this.colorsNeedUpdate=this.tangentsNeedUpdate=this.normalsNeedUpdate=this.uvsNeedUpdate=\nthis.elementsNeedUpdate=this.verticesNeedUpdate=!1};\nTHREE.Geometry.prototype={constructor:THREE.Geometry,applyMatrix:function(a){for(var b=(new THREE.Matrix3).getNormalMatrix(a),c=0,d=this.vertices.length;c<d;c++)this.vertices[c].applyMatrix4(a);c=0;for(d=this.faces.length;c<d;c++){var e=this.faces[c];e.normal.applyMatrix3(b).normalize();for(var f=0,g=e.vertexNormals.length;f<g;f++)e.vertexNormals[f].applyMatrix3(b).normalize();e.centroid.applyMatrix4(a)}this.boundingBox instanceof THREE.Box3&&this.computeBoundingBox();this.boundingSphere instanceof\nTHREE.Sphere&&this.computeBoundingSphere()},computeCentroids:function(){var a,b,c;a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],c.centroid.set(0,0,0),c.centroid.add(this.vertices[c.a]),c.centroid.add(this.vertices[c.b]),c.centroid.add(this.vertices[c.c]),c.centroid.divideScalar(3)},computeFaceNormals:function(){for(var a=new THREE.Vector3,b=new THREE.Vector3,c=0,d=this.faces.length;c<d;c++){var e=this.faces[c],f=this.vertices[e.a],g=this.vertices[e.b];a.subVectors(this.vertices[e.c],g);b.subVectors(f,\ng);a.cross(b);a.normalize();e.normal.copy(a)}},computeVertexNormals:function(a){var b,c,d;d=Array(this.vertices.length);b=0;for(c=this.vertices.length;b<c;b++)d[b]=new THREE.Vector3;if(a){var e,f,g,h=new THREE.Vector3,i=new THREE.Vector3;new THREE.Vector3;new THREE.Vector3;new THREE.Vector3;a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],e=this.vertices[c.a],f=this.vertices[c.b],g=this.vertices[c.c],h.subVectors(g,f),i.subVectors(e,f),h.cross(i),d[c.a].add(h),d[c.b].add(h),d[c.c].add(h)}else{a=\n0;for(b=this.faces.length;a<b;a++)c=this.faces[a],d[c.a].add(c.normal),d[c.b].add(c.normal),d[c.c].add(c.normal)}b=0;for(c=this.vertices.length;b<c;b++)d[b].normalize();a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],c.vertexNormals[0]=d[c.a].clone(),c.vertexNormals[1]=d[c.b].clone(),c.vertexNormals[2]=d[c.c].clone()},computeMorphNormals:function(){var a,b,c,d,e;c=0;for(d=this.faces.length;c<d;c++){e=this.faces[c];e.__originalFaceNormal?e.__originalFaceNormal.copy(e.normal):e.__originalFaceNormal=\ne.normal.clone();e.__originalVertexNormals||(e.__originalVertexNormals=[]);a=0;for(b=e.vertexNormals.length;a<b;a++)e.__originalVertexNormals[a]?e.__originalVertexNormals[a].copy(e.vertexNormals[a]):e.__originalVertexNormals[a]=e.vertexNormals[a].clone()}var f=new THREE.Geometry;f.faces=this.faces;a=0;for(b=this.morphTargets.length;a<b;a++){if(!this.morphNormals[a]){this.morphNormals[a]={};this.morphNormals[a].faceNormals=[];this.morphNormals[a].vertexNormals=[];e=this.morphNormals[a].faceNormals;\nvar g=this.morphNormals[a].vertexNormals,h,i;c=0;for(d=this.faces.length;c<d;c++)h=new THREE.Vector3,i={a:new THREE.Vector3,b:new THREE.Vector3,c:new THREE.Vector3},e.push(h),g.push(i)}g=this.morphNormals[a];f.vertices=this.morphTargets[a].vertices;f.computeFaceNormals();f.computeVertexNormals();c=0;for(d=this.faces.length;c<d;c++)e=this.faces[c],h=g.faceNormals[c],i=g.vertexNormals[c],h.copy(e.normal),i.a.copy(e.vertexNormals[0]),i.b.copy(e.vertexNormals[1]),i.c.copy(e.vertexNormals[2])}c=0;for(d=\nthis.faces.length;c<d;c++)e=this.faces[c],e.normal=e.__originalFaceNormal,e.vertexNormals=e.__originalVertexNormals},computeTangents:function(){var a,b,c,d,e,f,g,h,i,k,l,n,p,t,r,m,q,u=[],s=[];c=new THREE.Vector3;var v=new THREE.Vector3,z=new THREE.Vector3,G=new THREE.Vector3,N=new THREE.Vector3;a=0;for(b=this.vertices.length;a<b;a++)u[a]=new THREE.Vector3,s[a]=new THREE.Vector3;a=0;for(b=this.faces.length;a<b;a++)e=this.faces[a],f=this.faceVertexUvs[0][a],d=e.a,q=e.b,e=e.c,g=this.vertices[d],h=this.vertices[q],\ni=this.vertices[e],k=f[0],l=f[1],n=f[2],f=h.x-g.x,p=i.x-g.x,t=h.y-g.y,r=i.y-g.y,h=h.z-g.z,g=i.z-g.z,i=l.x-k.x,m=n.x-k.x,l=l.y-k.y,k=n.y-k.y,n=1/(i*k-m*l),c.set((k*f-l*p)*n,(k*t-l*r)*n,(k*h-l*g)*n),v.set((i*p-m*f)*n,(i*r-m*t)*n,(i*g-m*h)*n),u[d].add(c),u[q].add(c),u[e].add(c),s[d].add(v),s[q].add(v),s[e].add(v);v=[\"a\",\"b\",\"c\",\"d\"];a=0;for(b=this.faces.length;a<b;a++){e=this.faces[a];for(c=0;c<Math.min(e.vertexNormals.length,3);c++)N.copy(e.vertexNormals[c]),d=e[v[c]],q=u[d],z.copy(q),z.sub(N.multiplyScalar(N.dot(q))).normalize(),\nG.crossVectors(e.vertexNormals[c],q),d=G.dot(s[d]),d=0>d?-1:1,e.vertexTangents[c]=new THREE.Vector4(z.x,z.y,z.z,d)}this.hasTangents=!0},computeLineDistances:function(){for(var a=0,b=this.vertices,c=0,d=b.length;c<d;c++)0<c&&(a+=b[c].distanceTo(b[c-1])),this.lineDistances[c]=a},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new THREE.Box3);this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere);\nthis.boundingSphere.setFromPoints(this.vertices)},mergeVertices:function(){var a={},b=[],c=[],d,e=Math.pow(10,4),f,g;f=0;for(g=this.vertices.length;f<g;f++)d=this.vertices[f],d=Math.round(d.x*e)+\"_\"+Math.round(d.y*e)+\"_\"+Math.round(d.z*e),void 0===a[d]?(a[d]=f,b.push(this.vertices[f]),c[f]=b.length-1):c[f]=c[a[d]];a=[];f=0;for(g=this.faces.length;f<g;f++){e=this.faces[f];e.a=c[e.a];e.b=c[e.b];e.c=c[e.c];e=[e.a,e.b,e.c];for(d=0;3>d;d++)if(e[d]==e[(d+1)%3]){a.push(f);break}}for(f=a.length-1;0<=f;f--){e=\na[f];this.faces.splice(e,1);c=0;for(g=this.faceVertexUvs.length;c<g;c++)this.faceVertexUvs[c].splice(e,1)}f=this.vertices.length-b.length;this.vertices=b;return f},clone:function(){for(var a=new THREE.Geometry,b=this.vertices,c=0,d=b.length;c<d;c++)a.vertices.push(b[c].clone());b=this.faces;c=0;for(d=b.length;c<d;c++)a.faces.push(b[c].clone());b=this.faceVertexUvs[0];c=0;for(d=b.length;c<d;c++){for(var e=b[c],f=[],g=0,h=e.length;g<h;g++)f.push(new THREE.Vector2(e[g].x,e[g].y));a.faceVertexUvs[0].push(f)}return a},\ndispose:function(){this.dispatchEvent({type:\"dispose\"})}};THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);THREE.GeometryIdCount=0;THREE.BufferGeometry=function(){this.id=THREE.GeometryIdCount++;this.uuid=THREE.Math.generateUUID();this.name=\"\";this.attributes={};this.dynamic=!0;this.offsets=[];this.boundingSphere=this.boundingBox=null;this.hasTangents=!1;this.morphTargets=[]};\nTHREE.BufferGeometry.prototype={constructor:THREE.BufferGeometry,addAttribute:function(a,b,c,d){this.attributes[a]={itemSize:d,array:new b(c*d)}},applyMatrix:function(a){var b,c;this.attributes.position&&(b=this.attributes.position.array);this.attributes.normal&&(c=this.attributes.normal.array);void 0!==b&&(a.multiplyVector3Array(b),this.verticesNeedUpdate=!0);void 0!==c&&((new THREE.Matrix3).getNormalMatrix(a).multiplyVector3Array(c),this.normalizeNormals(),this.normalsNeedUpdate=!0)},computeBoundingBox:function(){null===\nthis.boundingBox&&(this.boundingBox=new THREE.Box3);var a=this.attributes.position.array;if(a){var b=this.boundingBox,c,d,e;3<=a.length&&(b.min.x=b.max.x=a[0],b.min.y=b.max.y=a[1],b.min.z=b.max.z=a[2]);for(var f=3,g=a.length;f<g;f+=3)c=a[f],d=a[f+1],e=a[f+2],c<b.min.x?b.min.x=c:c>b.max.x&&(b.max.x=c),d<b.min.y?b.min.y=d:d>b.max.y&&(b.max.y=d),e<b.min.z?b.min.z=e:e>b.max.z&&(b.max.z=e)}if(void 0===a||0===a.length)this.boundingBox.min.set(0,0,0),this.boundingBox.max.set(0,0,0)},computeBoundingSphere:function(){var a=\nnew THREE.Box3,b=new THREE.Vector3;return function(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere);var c=this.attributes.position.array;if(c){a.makeEmpty();for(var d=this.boundingSphere.center,e=0,f=c.length;e<f;e+=3)b.set(c[e],c[e+1],c[e+2]),a.addPoint(b);a.center(d);for(var g=0,e=0,f=c.length;e<f;e+=3)b.set(c[e],c[e+1],c[e+2]),g=Math.max(g,d.distanceToSquared(b));this.boundingSphere.radius=Math.sqrt(g)}}}(),computeVertexNormals:function(){if(this.attributes.position){var a,\nb,c,d;a=this.attributes.position.array.length;if(void 0===this.attributes.normal)this.attributes.normal={itemSize:3,array:new Float32Array(a)};else{a=0;for(b=this.attributes.normal.array.length;a<b;a++)this.attributes.normal.array[a]=0}var e=this.attributes.position.array,f=this.attributes.normal.array,g,h,i,k,l,n,p=new THREE.Vector3,t=new THREE.Vector3,r=new THREE.Vector3,m=new THREE.Vector3,q=new THREE.Vector3;if(this.attributes.index){var u=this.attributes.index.array,s=this.offsets;c=0;for(d=\ns.length;c<d;++c){b=s[c].start;g=s[c].count;var v=s[c].index;a=b;for(b+=g;a<b;a+=3)g=v+u[a],h=v+u[a+1],i=v+u[a+2],k=e[3*g],l=e[3*g+1],n=e[3*g+2],p.set(k,l,n),k=e[3*h],l=e[3*h+1],n=e[3*h+2],t.set(k,l,n),k=e[3*i],l=e[3*i+1],n=e[3*i+2],r.set(k,l,n),m.subVectors(r,t),q.subVectors(p,t),m.cross(q),f[3*g]+=m.x,f[3*g+1]+=m.y,f[3*g+2]+=m.z,f[3*h]+=m.x,f[3*h+1]+=m.y,f[3*h+2]+=m.z,f[3*i]+=m.x,f[3*i+1]+=m.y,f[3*i+2]+=m.z}}else{a=0;for(b=e.length;a<b;a+=9)k=e[a],l=e[a+1],n=e[a+2],p.set(k,l,n),k=e[a+3],l=e[a+4],\nn=e[a+5],t.set(k,l,n),k=e[a+6],l=e[a+7],n=e[a+8],r.set(k,l,n),m.subVectors(r,t),q.subVectors(p,t),m.cross(q),f[a]=m.x,f[a+1]=m.y,f[a+2]=m.z,f[a+3]=m.x,f[a+4]=m.y,f[a+5]=m.z,f[a+6]=m.x,f[a+7]=m.y,f[a+8]=m.z}this.normalizeNormals();this.normalsNeedUpdate=!0}},normalizeNormals:function(){for(var a=this.attributes.normal.array,b,c,d,e=0,f=a.length;e<f;e+=3)b=a[e],c=a[e+1],d=a[e+2],b=1/Math.sqrt(b*b+c*c+d*d),a[e]*=b,a[e+1]*=b,a[e+2]*=b},computeTangents:function(){function a(a){ha.x=d[3*a];ha.y=d[3*a+1];\nha.z=d[3*a+2];ua.copy(ha);T=h[a];A.copy(T);A.sub(ha.multiplyScalar(ha.dot(T))).normalize();da.crossVectors(ua,T);ea=da.dot(i[a]);O=0>ea?-1:1;g[4*a]=A.x;g[4*a+1]=A.y;g[4*a+2]=A.z;g[4*a+3]=O}if(void 0===this.attributes.index||void 0===this.attributes.position||void 0===this.attributes.normal||void 0===this.attributes.uv)console.warn(\"Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()\");else{var b=this.attributes.index.array,c=this.attributes.position.array,\nd=this.attributes.normal.array,e=this.attributes.uv.array,f=c.length/3;void 0===this.attributes.tangent&&(this.attributes.tangent={itemSize:4,array:new Float32Array(4*f)});for(var g=this.attributes.tangent.array,h=[],i=[],k=0;k<f;k++)h[k]=new THREE.Vector3,i[k]=new THREE.Vector3;var l,n,p,t,r,m,q,u,s,v,z,G,N,C,B,f=new THREE.Vector3,k=new THREE.Vector3,x,F,L,w,E,y,D,H=this.offsets;L=0;for(w=H.length;L<w;++L){F=H[L].start;E=H[L].count;var K=H[L].index;x=F;for(F+=E;x<F;x+=3)E=K+b[x],y=K+b[x+1],D=K+b[x+\n2],l=c[3*E],n=c[3*E+1],p=c[3*E+2],t=c[3*y],r=c[3*y+1],m=c[3*y+2],q=c[3*D],u=c[3*D+1],s=c[3*D+2],v=e[2*E],z=e[2*E+1],G=e[2*y],N=e[2*y+1],C=e[2*D],B=e[2*D+1],t-=l,l=q-l,r-=n,n=u-n,m-=p,p=s-p,G-=v,v=C-v,N-=z,z=B-z,B=1/(G*z-v*N),f.set((z*t-N*l)*B,(z*r-N*n)*B,(z*m-N*p)*B),k.set((G*l-v*t)*B,(G*n-v*r)*B,(G*p-v*m)*B),h[E].add(f),h[y].add(f),h[D].add(f),i[E].add(k),i[y].add(k),i[D].add(k)}var A=new THREE.Vector3,da=new THREE.Vector3,ha=new THREE.Vector3,ua=new THREE.Vector3,O,T,ea;L=0;for(w=H.length;L<w;++L){F=\nH[L].start;E=H[L].count;K=H[L].index;x=F;for(F+=E;x<F;x+=3)E=K+b[x],y=K+b[x+1],D=K+b[x+2],a(E),a(y),a(D)}this.tangentsNeedUpdate=this.hasTangents=!0}},clone:function(){var a=new THREE.BufferGeometry,b=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],c;for(c in this.attributes){for(var d=this.attributes[c],e=d.array,f={itemSize:d.itemSize,numItems:d.numItems,array:null},d=0,g=b.length;d<g;d++){var h=b[d];if(e instanceof h){f.array=new h(e);\nbreak}}a.attributes[c]=f}d=0;for(g=this.offsets.length;d<g;d++)b=this.offsets[d],a.offsets.push({start:b.start,index:b.index,count:b.count});return a},dispose:function(){this.dispatchEvent({type:\"dispose\"})}};THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);THREE.Camera=function(){THREE.Object3D.call(this);this.matrixWorldInverse=new THREE.Matrix4;this.projectionMatrix=new THREE.Matrix4};THREE.Camera.prototype=Object.create(THREE.Object3D.prototype);THREE.Camera.prototype.lookAt=function(){var a=new THREE.Matrix4;return function(b){a.lookAt(this.position,b,this.up);this.quaternion.setFromRotationMatrix(a)}}();\nTHREE.Camera.prototype.clone=function(a){void 0===a&&(a=new THREE.Camera);THREE.Object3D.prototype.clone.call(this,a);a.matrixWorldInverse.copy(this.matrixWorldInverse);a.projectionMatrix.copy(this.projectionMatrix);return a};THREE.OrthographicCamera=function(a,b,c,d,e,f){THREE.Camera.call(this);this.left=a;this.right=b;this.top=c;this.bottom=d;this.near=void 0!==e?e:0.1;this.far=void 0!==f?f:2E3;this.updateProjectionMatrix()};THREE.OrthographicCamera.prototype=Object.create(THREE.Camera.prototype);THREE.OrthographicCamera.prototype.updateProjectionMatrix=function(){this.projectionMatrix.makeOrthographic(this.left,this.right,this.top,this.bottom,this.near,this.far)};\nTHREE.OrthographicCamera.prototype.clone=function(){var a=new THREE.OrthographicCamera;THREE.Camera.prototype.clone.call(this,a);a.left=this.left;a.right=this.right;a.top=this.top;a.bottom=this.bottom;a.near=this.near;a.far=this.far;return a};THREE.PerspectiveCamera=function(a,b,c,d){THREE.Camera.call(this);this.fov=void 0!==a?a:50;this.aspect=void 0!==b?b:1;this.near=void 0!==c?c:0.1;this.far=void 0!==d?d:2E3;this.updateProjectionMatrix()};THREE.PerspectiveCamera.prototype=Object.create(THREE.Camera.prototype);THREE.PerspectiveCamera.prototype.setLens=function(a,b){void 0===b&&(b=24);this.fov=2*THREE.Math.radToDeg(Math.atan(b/(2*a)));this.updateProjectionMatrix()};\nTHREE.PerspectiveCamera.prototype.setViewOffset=function(a,b,c,d,e,f){this.fullWidth=a;this.fullHeight=b;this.x=c;this.y=d;this.width=e;this.height=f;this.updateProjectionMatrix()};\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix=function(){if(this.fullWidth){var a=this.fullWidth/this.fullHeight,b=Math.tan(THREE.Math.degToRad(0.5*this.fov))*this.near,c=-b,d=a*c,a=Math.abs(a*b-d),c=Math.abs(b-c);this.projectionMatrix.makeFrustum(d+this.x*a/this.fullWidth,d+(this.x+this.width)*a/this.fullWidth,b-(this.y+this.height)*c/this.fullHeight,b-this.y*c/this.fullHeight,this.near,this.far)}else this.projectionMatrix.makePerspective(this.fov,this.aspect,this.near,this.far)};\nTHREE.PerspectiveCamera.prototype.clone=function(){var a=new THREE.PerspectiveCamera;THREE.Camera.prototype.clone.call(this,a);a.fov=this.fov;a.aspect=this.aspect;a.near=this.near;a.far=this.far;return a};THREE.Light=function(a){THREE.Object3D.call(this);this.color=new THREE.Color(a)};THREE.Light.prototype=Object.create(THREE.Object3D.prototype);THREE.Light.prototype.clone=function(a){void 0===a&&(a=new THREE.Light);THREE.Object3D.prototype.clone.call(this,a);a.color.copy(this.color);return a};THREE.AmbientLight=function(a){THREE.Light.call(this,a)};THREE.AmbientLight.prototype=Object.create(THREE.Light.prototype);THREE.AmbientLight.prototype.clone=function(){var a=new THREE.AmbientLight;THREE.Light.prototype.clone.call(this,a);return a};THREE.AreaLight=function(a,b){THREE.Light.call(this,a);this.normal=new THREE.Vector3(0,-1,0);this.right=new THREE.Vector3(1,0,0);this.intensity=void 0!==b?b:1;this.height=this.width=1;this.constantAttenuation=1.5;this.linearAttenuation=0.5;this.quadraticAttenuation=0.1};THREE.AreaLight.prototype=Object.create(THREE.Light.prototype);THREE.DirectionalLight=function(a,b){THREE.Light.call(this,a);this.position.set(0,1,0);this.target=new THREE.Object3D;this.intensity=void 0!==b?b:1;this.onlyShadow=this.castShadow=!1;this.shadowCameraNear=50;this.shadowCameraFar=5E3;this.shadowCameraLeft=-500;this.shadowCameraTop=this.shadowCameraRight=500;this.shadowCameraBottom=-500;this.shadowCameraVisible=!1;this.shadowBias=0;this.shadowDarkness=0.5;this.shadowMapHeight=this.shadowMapWidth=512;this.shadowCascade=!1;this.shadowCascadeOffset=new THREE.Vector3(0,\n0,-1E3);this.shadowCascadeCount=2;this.shadowCascadeBias=[0,0,0];this.shadowCascadeWidth=[512,512,512];this.shadowCascadeHeight=[512,512,512];this.shadowCascadeNearZ=[-1,0.99,0.998];this.shadowCascadeFarZ=[0.99,0.998,1];this.shadowCascadeArray=[];this.shadowMatrix=this.shadowCamera=this.shadowMapSize=this.shadowMap=null};THREE.DirectionalLight.prototype=Object.create(THREE.Light.prototype);\nTHREE.DirectionalLight.prototype.clone=function(){var a=new THREE.DirectionalLight;THREE.Light.prototype.clone.call(this,a);a.target=this.target.clone();a.intensity=this.intensity;a.castShadow=this.castShadow;a.onlyShadow=this.onlyShadow;return a};THREE.HemisphereLight=function(a,b,c){THREE.Light.call(this,a);this.position.set(0,100,0);this.groundColor=new THREE.Color(b);this.intensity=void 0!==c?c:1};THREE.HemisphereLight.prototype=Object.create(THREE.Light.prototype);THREE.HemisphereLight.prototype.clone=function(){var a=new THREE.HemisphereLight;THREE.Light.prototype.clone.call(this,a);a.groundColor.copy(this.groundColor);a.intensity=this.intensity;return a};THREE.PointLight=function(a,b,c){THREE.Light.call(this,a);this.intensity=void 0!==b?b:1;this.distance=void 0!==c?c:0};THREE.PointLight.prototype=Object.create(THREE.Light.prototype);THREE.PointLight.prototype.clone=function(){var a=new THREE.PointLight;THREE.Light.prototype.clone.call(this,a);a.intensity=this.intensity;a.distance=this.distance;return a};THREE.SpotLight=function(a,b,c,d,e){THREE.Light.call(this,a);this.position.set(0,1,0);this.target=new THREE.Object3D;this.intensity=void 0!==b?b:1;this.distance=void 0!==c?c:0;this.angle=void 0!==d?d:Math.PI/3;this.exponent=void 0!==e?e:10;this.onlyShadow=this.castShadow=!1;this.shadowCameraNear=50;this.shadowCameraFar=5E3;this.shadowCameraFov=50;this.shadowCameraVisible=!1;this.shadowBias=0;this.shadowDarkness=0.5;this.shadowMapHeight=this.shadowMapWidth=512;this.shadowMatrix=this.shadowCamera=this.shadowMapSize=\nthis.shadowMap=null};THREE.SpotLight.prototype=Object.create(THREE.Light.prototype);THREE.SpotLight.prototype.clone=function(){var a=new THREE.SpotLight;THREE.Light.prototype.clone.call(this,a);a.target=this.target.clone();a.intensity=this.intensity;a.distance=this.distance;a.angle=this.angle;a.exponent=this.exponent;a.castShadow=this.castShadow;a.onlyShadow=this.onlyShadow;return a};THREE.Loader=function(a){this.statusDomElement=(this.showStatus=a)?THREE.Loader.prototype.addStatusElement():null;this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){}};\nTHREE.Loader.prototype={constructor:THREE.Loader,crossOrigin:void 0,addStatusElement:function(){var a=document.createElement(\"div\");a.style.position=\"absolute\";a.style.right=\"0px\";a.style.top=\"0px\";a.style.fontSize=\"0.8em\";a.style.textAlign=\"left\";a.style.background=\"rgba(0,0,0,0.25)\";a.style.color=\"#fff\";a.style.width=\"120px\";a.style.padding=\"0.5em 0.5em 0.5em 0.5em\";a.style.zIndex=1E3;a.innerHTML=\"Loading ...\";return a},updateProgress:function(a){var b=\"Loaded \",b=a.total?b+((100*a.loaded/a.total).toFixed(0)+\n\"%\"):b+((a.loaded/1E3).toFixed(2)+\" KB\");this.statusDomElement.innerHTML=b},extractUrlBase:function(a){a=a.split(\"/\");a.pop();return(1>a.length?\".\":a.join(\"/\"))+\"/\"},initMaterials:function(a,b){for(var c=[],d=0;d<a.length;++d)c[d]=THREE.Loader.prototype.createMaterial(a[d],b);return c},needsTangents:function(a){for(var b=0,c=a.length;b<c;b++)if(a[b]instanceof THREE.ShaderMaterial)return!0;return!1},createMaterial:function(a,b){function c(a){a=Math.log(a)/Math.LN2;return Math.floor(a)==a}function d(a){a=\nMath.log(a)/Math.LN2;return Math.pow(2,Math.round(a))}function e(a,e,f,h,i,k,q){var u=/\\.dds$/i.test(f),s=b+\"/\"+f;if(u){var v=THREE.ImageUtils.loadCompressedTexture(s);a[e]=v}else v=document.createElement(\"canvas\"),a[e]=new THREE.Texture(v);a[e].sourceFile=f;h&&(a[e].repeat.set(h[0],h[1]),1!==h[0]&&(a[e].wrapS=THREE.RepeatWrapping),1!==h[1]&&(a[e].wrapT=THREE.RepeatWrapping));i&&a[e].offset.set(i[0],i[1]);k&&(f={repeat:THREE.RepeatWrapping,mirror:THREE.MirroredRepeatWrapping},void 0!==f[k[0]]&&(a[e].wrapS=\nf[k[0]]),void 0!==f[k[1]]&&(a[e].wrapT=f[k[1]]));q&&(a[e].anisotropy=q);if(!u){var z=a[e],a=new Image;a.onload=function(){if(!c(this.width)||!c(this.height)){var a=d(this.width),b=d(this.height);z.image.width=a;z.image.height=b;z.image.getContext(\"2d\").drawImage(this,0,0,a,b)}else z.image=this;z.needsUpdate=!0};void 0!==g.crossOrigin&&(a.crossOrigin=g.crossOrigin);a.src=s}}function f(a){return(255*a[0]<<16)+(255*a[1]<<8)+255*a[2]}var g=this,h=\"MeshLambertMaterial\",i={color:15658734,opacity:1,map:null,\nlightMap:null,normalMap:null,bumpMap:null,wireframe:!1};if(a.shading){var k=a.shading.toLowerCase();\"phong\"===k?h=\"MeshPhongMaterial\":\"basic\"===k&&(h=\"MeshBasicMaterial\")}void 0!==a.blending&&void 0!==THREE[a.blending]&&(i.blending=THREE[a.blending]);if(void 0!==a.transparent||1>a.opacity)i.transparent=a.transparent;void 0!==a.depthTest&&(i.depthTest=a.depthTest);void 0!==a.depthWrite&&(i.depthWrite=a.depthWrite);void 0!==a.visible&&(i.visible=a.visible);void 0!==a.flipSided&&(i.side=THREE.BackSide);\nvoid 0!==a.doubleSided&&(i.side=THREE.DoubleSide);void 0!==a.wireframe&&(i.wireframe=a.wireframe);void 0!==a.vertexColors&&(\"face\"===a.vertexColors?i.vertexColors=THREE.FaceColors:a.vertexColors&&(i.vertexColors=THREE.VertexColors));a.colorDiffuse?i.color=f(a.colorDiffuse):a.DbgColor&&(i.color=a.DbgColor);a.colorSpecular&&(i.specular=f(a.colorSpecular));a.colorAmbient&&(i.ambient=f(a.colorAmbient));a.transparency&&(i.opacity=a.transparency);a.specularCoef&&(i.shininess=a.specularCoef);a.mapDiffuse&&\nb&&e(i,\"map\",a.mapDiffuse,a.mapDiffuseRepeat,a.mapDiffuseOffset,a.mapDiffuseWrap,a.mapDiffuseAnisotropy);a.mapLight&&b&&e(i,\"lightMap\",a.mapLight,a.mapLightRepeat,a.mapLightOffset,a.mapLightWrap,a.mapLightAnisotropy);a.mapBump&&b&&e(i,\"bumpMap\",a.mapBump,a.mapBumpRepeat,a.mapBumpOffset,a.mapBumpWrap,a.mapBumpAnisotropy);a.mapNormal&&b&&e(i,\"normalMap\",a.mapNormal,a.mapNormalRepeat,a.mapNormalOffset,a.mapNormalWrap,a.mapNormalAnisotropy);a.mapSpecular&&b&&e(i,\"specularMap\",a.mapSpecular,a.mapSpecularRepeat,\na.mapSpecularOffset,a.mapSpecularWrap,a.mapSpecularAnisotropy);a.mapBumpScale&&(i.bumpScale=a.mapBumpScale);a.mapNormal?(h=THREE.ShaderLib.normalmap,k=THREE.UniformsUtils.clone(h.uniforms),k.tNormal.value=i.normalMap,a.mapNormalFactor&&k.uNormalScale.value.set(a.mapNormalFactor,a.mapNormalFactor),i.map&&(k.tDiffuse.value=i.map,k.enableDiffuse.value=!0),i.specularMap&&(k.tSpecular.value=i.specularMap,k.enableSpecular.value=!0),i.lightMap&&(k.tAO.value=i.lightMap,k.enableAO.value=!0),k.diffuse.value.setHex(i.color),\nk.specular.value.setHex(i.specular),k.ambient.value.setHex(i.ambient),k.shininess.value=i.shininess,void 0!==i.opacity&&(k.opacity.value=i.opacity),h=new THREE.ShaderMaterial({fragmentShader:h.fragmentShader,vertexShader:h.vertexShader,uniforms:k,lights:!0,fog:!0}),i.transparent&&(h.transparent=!0)):h=new THREE[h](i);void 0!==a.DbgName&&(h.name=a.DbgName);return h}};THREE.XHRLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};\nTHREE.XHRLoader.prototype={constructor:THREE.XHRLoader,load:function(a,b,c,d){var e=this,f=new XMLHttpRequest;void 0!==b&&f.addEventListener(\"load\",function(c){b(c.target.responseText);e.manager.itemEnd(a)},!1);void 0!==c&&f.addEventListener(\"progress\",function(a){c(a)},!1);void 0!==d&&f.addEventListener(\"error\",function(a){d(a)},!1);void 0!==this.crossOrigin&&(f.crossOrigin=this.crossOrigin);f.open(\"GET\",a,!0);f.send(null);e.manager.itemStart(a)},setCrossOrigin:function(a){this.crossOrigin=a}};THREE.ImageLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};\nTHREE.ImageLoader.prototype={constructor:THREE.ImageLoader,load:function(a,b,c,d){var e=this,f=document.createElement(\"img\");void 0!==b&&f.addEventListener(\"load\",function(){e.manager.itemEnd(a);b(this)},!1);void 0!==c&&f.addEventListener(\"progress\",function(a){c(a)},!1);void 0!==d&&f.addEventListener(\"error\",function(a){d(a)},!1);void 0!==this.crossOrigin&&(f.crossOrigin=this.crossOrigin);f.src=a;e.manager.itemStart(a);return f},setCrossOrigin:function(a){this.crossOrigin=a}};THREE.JSONLoader=function(a){THREE.Loader.call(this,a);this.withCredentials=!1};THREE.JSONLoader.prototype=Object.create(THREE.Loader.prototype);THREE.JSONLoader.prototype.load=function(a,b,c){c=c&&\"string\"===typeof c?c:this.extractUrlBase(a);this.onLoadStart();this.loadAjaxJSON(this,a,b,c)};\nTHREE.JSONLoader.prototype.loadAjaxJSON=function(a,b,c,d,e){var f=new XMLHttpRequest,g=0;f.onreadystatechange=function(){if(f.readyState===f.DONE)if(200===f.status||0===f.status){if(f.responseText){var h=JSON.parse(f.responseText),h=a.parse(h,d);c(h.geometry,h.materials)}else console.warn(\"THREE.JSONLoader: [\"+b+\"] seems to be unreachable or file there is empty\");a.onLoadComplete()}else console.error(\"THREE.JSONLoader: Couldn't load [\"+b+\"] [\"+f.status+\"]\");else f.readyState===f.LOADING?e&&(0===g&&\n(g=f.getResponseHeader(\"Content-Length\")),e({total:g,loaded:f.responseText.length})):f.readyState===f.HEADERS_RECEIVED&&void 0!==e&&(g=f.getResponseHeader(\"Content-Length\"))};f.open(\"GET\",b,!0);f.withCredentials=this.withCredentials;f.send(null)};\nTHREE.JSONLoader.prototype.parse=function(a,b){var c=new THREE.Geometry,d=void 0!==a.scale?1/a.scale:1,e,f,g,h,i,k,l,n,p,t,r,m,q,u,s=a.faces;p=a.vertices;var v=a.normals,z=a.colors,G=0;if(void 0!==a.uvs){for(e=0;e<a.uvs.length;e++)a.uvs[e].length&&G++;for(e=0;e<G;e++)c.faceVertexUvs[e]=[]}h=0;for(i=p.length;h<i;)k=new THREE.Vector3,k.x=p[h++]*d,k.y=p[h++]*d,k.z=p[h++]*d,c.vertices.push(k);h=0;for(i=s.length;h<i;)if(p=s[h++],t=p&1,g=p&2,e=p&8,l=p&16,r=p&32,k=p&64,p&=128,t){t=new THREE.Face3;t.a=s[h];\nt.b=s[h+1];t.c=s[h+3];m=new THREE.Face3;m.a=s[h+1];m.b=s[h+2];m.c=s[h+3];h+=4;g&&(g=s[h++],t.materialIndex=g,m.materialIndex=g);g=c.faces.length;if(e)for(e=0;e<G;e++){q=a.uvs[e];c.faceVertexUvs[e][g]=[];c.faceVertexUvs[e][g+1]=[];for(f=0;4>f;f++)n=s[h++],u=q[2*n],n=q[2*n+1],u=new THREE.Vector2(u,n),2!==f&&c.faceVertexUvs[e][g].push(u),0!==f&&c.faceVertexUvs[e][g+1].push(u)}l&&(l=3*s[h++],t.normal.set(v[l++],v[l++],v[l]),m.normal.copy(t.normal));if(r)for(e=0;4>e;e++)l=3*s[h++],r=new THREE.Vector3(v[l++],\nv[l++],v[l]),2!==e&&t.vertexNormals.push(r),0!==e&&m.vertexNormals.push(r);k&&(k=s[h++],k=z[k],t.color.setHex(k),m.color.setHex(k));if(p)for(e=0;4>e;e++)k=s[h++],k=z[k],2!==e&&t.vertexColors.push(new THREE.Color(k)),0!==e&&m.vertexColors.push(new THREE.Color(k));c.faces.push(t);c.faces.push(m)}else{t=new THREE.Face3;t.a=s[h++];t.b=s[h++];t.c=s[h++];g&&(g=s[h++],t.materialIndex=g);g=c.faces.length;if(e)for(e=0;e<G;e++){q=a.uvs[e];c.faceVertexUvs[e][g]=[];for(f=0;3>f;f++)n=s[h++],u=q[2*n],n=q[2*n+1],\nu=new THREE.Vector2(u,n),c.faceVertexUvs[e][g].push(u)}l&&(l=3*s[h++],t.normal.set(v[l++],v[l++],v[l]));if(r)for(e=0;3>e;e++)l=3*s[h++],r=new THREE.Vector3(v[l++],v[l++],v[l]),t.vertexNormals.push(r);k&&(k=s[h++],t.color.setHex(z[k]));if(p)for(e=0;3>e;e++)k=s[h++],t.vertexColors.push(new THREE.Color(z[k]));c.faces.push(t)}if(a.skinWeights){h=0;for(i=a.skinWeights.length;h<i;h+=2)s=a.skinWeights[h],v=a.skinWeights[h+1],c.skinWeights.push(new THREE.Vector4(s,v,0,0))}if(a.skinIndices){h=0;for(i=a.skinIndices.length;h<\ni;h+=2)s=a.skinIndices[h],v=a.skinIndices[h+1],c.skinIndices.push(new THREE.Vector4(s,v,0,0))}c.bones=a.bones;c.animation=a.animation;c.animations=a.animations;if(void 0!==a.morphTargets){h=0;for(i=a.morphTargets.length;h<i;h++){c.morphTargets[h]={};c.morphTargets[h].name=a.morphTargets[h].name;c.morphTargets[h].vertices=[];z=c.morphTargets[h].vertices;G=a.morphTargets[h].vertices;s=0;for(v=G.length;s<v;s+=3)p=new THREE.Vector3,p.x=G[s]*d,p.y=G[s+1]*d,p.z=G[s+2]*d,z.push(p)}}if(void 0!==a.morphColors){h=\n0;for(i=a.morphColors.length;h<i;h++){c.morphColors[h]={};c.morphColors[h].name=a.morphColors[h].name;c.morphColors[h].colors=[];v=c.morphColors[h].colors;z=a.morphColors[h].colors;d=0;for(s=z.length;d<s;d+=3)G=new THREE.Color(16755200),G.setRGB(z[d],z[d+1],z[d+2]),v.push(G)}}c.computeCentroids();c.computeFaceNormals();c.computeBoundingSphere();if(void 0===a.materials)return{geometry:c};d=this.initMaterials(a.materials,b);this.needsTangents(d)&&c.computeTangents();return{geometry:c,materials:d}};THREE.LoadingManager=function(a,b,c){var d=this,e=0,f=0;this.onLoad=a;this.onProgress=b;this.onError=c;this.itemStart=function(){f++};this.itemEnd=function(a){e++;if(void 0!==d.onProgress)d.onProgress(a,e,f);if(e===f&&void 0!==d.onLoad)d.onLoad()}};THREE.DefaultLoadingManager=new THREE.LoadingManager;THREE.BufferGeometryLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};\nTHREE.BufferGeometryLoader.prototype={constructor:THREE.BufferGeometryLoader,load:function(a,b){var c=this,d=new THREE.XHRLoader;d.setCrossOrigin(this.crossOrigin);d.load(a,function(a){b(c.parse(JSON.parse(a)))})},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a){var b=new THREE.BufferGeometry,c=a.attributes,d=a.offsets,a=a.boundingSphere,e;for(e in c){var f=c[e];b.attributes[e]={itemSize:f.itemSize,array:new self[f.type](f.array)}}void 0!==d&&(b.offsets=JSON.parse(JSON.stringify(d)));\nvoid 0!==a&&(b.boundingSphere=new THREE.Sphere((new THREE.Vector3).fromArray(void 0!==a.center?a.center:[0,0,0]),a.radius));return b}};THREE.GeometryLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};THREE.GeometryLoader.prototype={constructor:THREE.GeometryLoader,load:function(a,b){var c=this,d=new THREE.XHRLoader;d.setCrossOrigin(this.crossOrigin);d.load(a,function(a){b(c.parse(JSON.parse(a)))})},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(){}};THREE.MaterialLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};\nTHREE.MaterialLoader.prototype={constructor:THREE.MaterialLoader,load:function(a,b){var c=this,d=new THREE.XHRLoader;d.setCrossOrigin(this.crossOrigin);d.load(a,function(a){b(c.parse(JSON.parse(a)))})},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a){var b=new THREE[a.type];void 0!==a.color&&b.color.setHex(a.color);void 0!==a.ambient&&b.ambient.setHex(a.ambient);void 0!==a.emissive&&b.emissive.setHex(a.emissive);void 0!==a.specular&&b.specular.setHex(a.specular);void 0!==a.shininess&&\n(b.shininess=a.shininess);void 0!==a.vertexColors&&(b.vertexColors=a.vertexColors);void 0!==a.blending&&(b.blending=a.blending);void 0!==a.side&&(b.side=a.side);void 0!==a.opacity&&(b.opacity=a.opacity);void 0!==a.transparent&&(b.transparent=a.transparent);void 0!==a.wireframe&&(b.wireframe=a.wireframe);if(void 0!==a.materials)for(var c=0,d=a.materials.length;c<d;c++)b.materials.push(this.parse(a.materials[c]));return b}};THREE.ObjectLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};\nTHREE.ObjectLoader.prototype={constructor:THREE.ObjectLoader,load:function(a,b){var c=this,d=new THREE.XHRLoader(c.manager);d.setCrossOrigin(this.crossOrigin);d.load(a,function(a){b(c.parse(JSON.parse(a)))})},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a){var b=this.parseGeometries(a.geometries),c=this.parseMaterials(a.materials);return this.parseObject(a.object,b,c)},parseGeometries:function(a){var b={};if(void 0!==a)for(var c=new THREE.JSONLoader,d=new THREE.BufferGeometryLoader,\ne=0,f=a.length;e<f;e++){var g,h=a[e];switch(h.type){case \"PlaneGeometry\":g=new THREE.PlaneGeometry(h.width,h.height,h.widthSegments,h.heightSegments);break;case \"CircleGeometry\":g=new THREE.CircleGeometry(h.radius,h.segments);break;case \"CubeGeometry\":g=new THREE.CubeGeometry(h.width,h.height,h.depth,h.widthSegments,h.heightSegments,h.depthSegments);break;case \"CylinderGeometry\":g=new THREE.CylinderGeometry(h.radiusTop,h.radiusBottom,h.height,h.radialSegments,h.heightSegments,h.openEnded);break;case \"SphereGeometry\":g=\nnew THREE.SphereGeometry(h.radius,h.widthSegments,h.heightSegments,h.phiStart,h.phiLength,h.thetaStart,h.thetaLength);break;case \"IcosahedronGeometry\":g=new THREE.IcosahedronGeometry(h.radius,h.detail);break;case \"TorusGeometry\":g=new THREE.TorusGeometry(h.radius,h.tube,h.radialSegments,h.tubularSegments,h.arc);break;case \"TorusKnotGeometry\":g=new THREE.TorusKnotGeometry(h.radius,h.tube,h.radialSegments,h.tubularSegments,h.p,h.q,h.heightScale);break;case \"BufferGeometry\":g=d.parse(h.data);break;case \"Geometry\":g=\nc.parse(h.data).geometry}g.uuid=h.uuid;void 0!==h.name&&(g.name=h.name);b[h.uuid]=g}return b},parseMaterials:function(a){var b={};if(void 0!==a)for(var c=new THREE.MaterialLoader,d=0,e=a.length;d<e;d++){var f=a[d],g=c.parse(f);g.uuid=f.uuid;void 0!==f.name&&(g.name=f.name);b[f.uuid]=g}return b},parseObject:function(){var a=new THREE.Matrix4;return function(b,c,d){var e;switch(b.type){case \"Scene\":e=new THREE.Scene;break;case \"PerspectiveCamera\":e=new THREE.PerspectiveCamera(b.fov,b.aspect,b.near,\nb.far);break;case \"OrthographicCamera\":e=new THREE.OrthographicCamera(b.left,b.right,b.top,b.bottom,b.near,b.far);break;case \"AmbientLight\":e=new THREE.AmbientLight(b.color);break;case \"DirectionalLight\":e=new THREE.DirectionalLight(b.color,b.intensity);break;case \"PointLight\":e=new THREE.PointLight(b.color,b.intensity,b.distance);break;case \"SpotLight\":e=new THREE.SpotLight(b.color,b.intensity,b.distance,b.angle,b.exponent);break;case \"HemisphereLight\":e=new THREE.HemisphereLight(b.color,b.groundColor,\nb.intensity);break;case \"Mesh\":e=c[b.geometry];var f=d[b.material];void 0===e&&console.error(\"THREE.ObjectLoader: Undefined geometry \"+b.geometry);void 0===f&&console.error(\"THREE.ObjectLoader: Undefined material \"+b.material);e=new THREE.Mesh(e,f);break;case \"Sprite\":f=d[b.material];void 0===f&&console.error(\"THREE.ObjectLoader: Undefined material \"+b.material);e=new THREE.Sprite(f);break;default:e=new THREE.Object3D}e.uuid=b.uuid;void 0!==b.name&&(e.name=b.name);void 0!==b.matrix?(a.fromArray(b.matrix),\na.decompose(e.position,e.quaternion,e.scale)):(void 0!==b.position&&e.position.fromArray(b.position),void 0!==b.rotation&&e.rotation.fromArray(b.rotation),void 0!==b.scale&&e.scale.fromArray(b.scale));void 0!==b.visible&&(e.visible=b.visible);void 0!==b.userData&&(e.userData=b.userData);if(void 0!==b.children)for(var g in b.children)e.add(this.parseObject(b.children[g],c,d));return e}}()};THREE.SceneLoader=function(){this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){};this.callbackSync=function(){};this.callbackProgress=function(){};this.geometryHandlers={};this.hierarchyHandlers={};this.addGeometryHandler(\"ascii\",THREE.JSONLoader)};\nTHREE.SceneLoader.prototype={constructor:THREE.SceneLoader,load:function(a,b){var c=this,d=new THREE.XHRLoader(c.manager);d.setCrossOrigin(this.crossOrigin);d.load(a,function(d){c.parse(JSON.parse(d),b,a)})},setCrossOrigin:function(a){this.crossOrigin=a},addGeometryHandler:function(a,b){this.geometryHandlers[a]={loaderClass:b}},addHierarchyHandler:function(a,b){this.hierarchyHandlers[a]={loaderClass:b}},parse:function(a,b,c){function d(a,b){return\"relativeToHTML\"==b?a:p+\"/\"+a}function e(){f(C.scene,\nx.objects)}function f(a,b){var c,e,g,i,k,l;for(l in b){var p=C.objects[l],q=b[l];if(void 0===p){if(q.type&&q.type in n.hierarchyHandlers){if(void 0===q.loading){c={type:1,url:1,material:1,position:1,rotation:1,scale:1,visible:1,children:1,userData:1,skin:1,morph:1,mirroredLoop:1,duration:1};var u={},v;for(v in q)v in c||(u[v]=q[v]);r=C.materials[q.material];q.loading=!0;c=n.hierarchyHandlers[q.type].loaderObject;c.options?c.load(d(q.url,x.urlBaseType),h(l,a,r,q)):c.load(d(q.url,x.urlBaseType),h(l,\na,r,q),u)}}else if(void 0!==q.geometry){if(t=C.geometries[q.geometry]){p=!1;r=C.materials[q.material];p=r instanceof THREE.ShaderMaterial;e=q.position;g=q.rotation;i=q.scale;c=q.matrix;k=q.quaternion;q.material||(r=new THREE.MeshFaceMaterial(C.face_materials[q.geometry]));r instanceof THREE.MeshFaceMaterial&&0===r.materials.length&&(r=new THREE.MeshFaceMaterial(C.face_materials[q.geometry]));if(r instanceof THREE.MeshFaceMaterial)for(u=0;u<r.materials.length;u++)p=p||r.materials[u]instanceof THREE.ShaderMaterial;\np&&t.computeTangents();q.skin?p=new THREE.SkinnedMesh(t,r):q.morph?(p=new THREE.MorphAnimMesh(t,r),void 0!==q.duration&&(p.duration=q.duration),void 0!==q.time&&(p.time=q.time),void 0!==q.mirroredLoop&&(p.mirroredLoop=q.mirroredLoop),r.morphNormals&&t.computeMorphNormals()):p=new THREE.Mesh(t,r);p.name=l;c?(p.matrixAutoUpdate=!1,p.matrix.set(c[0],c[1],c[2],c[3],c[4],c[5],c[6],c[7],c[8],c[9],c[10],c[11],c[12],c[13],c[14],c[15])):(p.position.fromArray(e),k?p.quaternion.fromArray(k):p.rotation.fromArray(g),\np.scale.fromArray(i));p.visible=q.visible;p.castShadow=q.castShadow;p.receiveShadow=q.receiveShadow;a.add(p);C.objects[l]=p}}else if(\"AmbientLight\"===q.type||\"PointLight\"===q.type||\"DirectionalLight\"===q.type||\"SpotLight\"===q.type||\"HemisphereLight\"===q.type||\"AreaLight\"===q.type){u=q.color;c=q.intensity;e=q.distance;g=q.position;i=q.rotation;switch(q.type){case \"AmbientLight\":s=new THREE.AmbientLight(u);break;case \"PointLight\":s=new THREE.PointLight(u,c,e);s.position.fromArray(g);break;case \"DirectionalLight\":s=\nnew THREE.DirectionalLight(u,c);s.position.fromArray(q.direction);break;case \"SpotLight\":s=new THREE.SpotLight(u,c,e,1);s.angle=q.angle;s.position.fromArray(g);s.target.set(g[0],g[1]-e,g[2]);s.target.applyEuler(new THREE.Euler(i[0],i[1],i[2],\"XYZ\"));break;case \"HemisphereLight\":s=new THREE.DirectionalLight(u,c,e);s.target.set(g[0],g[1]-e,g[2]);s.target.applyEuler(new THREE.Euler(i[0],i[1],i[2],\"XYZ\"));break;case \"AreaLight\":s=new THREE.AreaLight(u,c),s.position.fromArray(g),s.width=q.size,s.height=\nq.size_y}a.add(s);s.name=l;C.lights[l]=s;C.objects[l]=s}else\"PerspectiveCamera\"===q.type||\"OrthographicCamera\"===q.type?(e=q.position,g=q.rotation,k=q.quaternion,\"PerspectiveCamera\"===q.type?m=new THREE.PerspectiveCamera(q.fov,q.aspect,q.near,q.far):\"OrthographicCamera\"===q.type&&(m=new THREE.OrthographicCamera(q.left,q.right,q.top,q.bottom,q.near,q.far)),m.name=l,m.position.fromArray(e),void 0!==k?m.quaternion.fromArray(k):void 0!==g&&m.rotation.fromArray(g),a.add(m),C.cameras[l]=m,C.objects[l]=\nm):(e=q.position,g=q.rotation,i=q.scale,k=q.quaternion,p=new THREE.Object3D,p.name=l,p.position.fromArray(e),k?p.quaternion.fromArray(k):p.rotation.fromArray(g),p.scale.fromArray(i),p.visible=void 0!==q.visible?q.visible:!1,a.add(p),C.objects[l]=p,C.empties[l]=p);if(p){if(void 0!==q.userData)for(var z in q.userData)p.userData[z]=q.userData[z];if(void 0!==q.groups)for(u=0;u<q.groups.length;u++)c=q.groups[u],void 0===C.groups[c]&&(C.groups[c]=[]),C.groups[c].push(l)}}void 0!==p&&void 0!==q.children&&\nf(p,q.children)}}function g(a){return function(b,c){b.name=a;C.geometries[a]=b;C.face_materials[a]=c;e();v-=1;n.onLoadComplete();k()}}function h(a,b,c,d){return function(f){var f=f.content?f.content:f.dae?f.scene:f,g=d.rotation,h=d.quaternion,i=d.scale;f.position.fromArray(d.position);h?f.quaternion.fromArray(h):f.rotation.fromArray(g);f.scale.fromArray(i);c&&f.traverse(function(a){a.material=c});var l=void 0!==d.visible?d.visible:!0;f.traverse(function(a){a.visible=l});b.add(f);f.name=a;C.objects[a]=\nf;e();v-=1;n.onLoadComplete();k()}}function i(a){return function(b,c){b.name=a;C.geometries[a]=b;C.face_materials[a]=c}}function k(){n.callbackProgress({totalModels:G,totalTextures:N,loadedModels:G-v,loadedTextures:N-z},C);n.onLoadProgress();if(0===v&&0===z){for(var a=0;a<B.length;a++){var c=B[a],d=C.objects[c.targetName];d?c.object.target=d:(c.object.target=new THREE.Object3D,C.scene.add(c.object.target));c.object.target.userData.targetInverse=c.object}b(C)}}function l(a,b){b(a);if(void 0!==a.children)for(var c in a.children)l(a.children[c],\nb)}var n=this,p=THREE.Loader.prototype.extractUrlBase(c),t,r,m,q,u,s,v,z,G,N,C,B=[],x=a,F;for(F in this.geometryHandlers)a=this.geometryHandlers[F].loaderClass,this.geometryHandlers[F].loaderObject=new a;for(F in this.hierarchyHandlers)a=this.hierarchyHandlers[F].loaderClass,this.hierarchyHandlers[F].loaderObject=new a;z=v=0;C={scene:new THREE.Scene,geometries:{},face_materials:{},materials:{},textures:{},objects:{},cameras:{},lights:{},fogs:{},empties:{},groups:{}};if(x.transform&&(F=x.transform.position,\na=x.transform.rotation,c=x.transform.scale,F&&C.scene.position.fromArray(F),a&&C.scene.rotation.fromArray(a),c&&C.scene.scale.fromArray(c),F||a||c))C.scene.updateMatrix(),C.scene.updateMatrixWorld();F=function(a){return function(){z-=a;k();n.onLoadComplete()}};for(var L in x.fogs)a=x.fogs[L],\"linear\"===a.type?q=new THREE.Fog(0,a.near,a.far):\"exp2\"===a.type&&(q=new THREE.FogExp2(0,a.density)),a=a.color,q.color.setRGB(a[0],a[1],a[2]),C.fogs[L]=q;for(var w in x.geometries)q=x.geometries[w],q.type in\nthis.geometryHandlers&&(v+=1,n.onLoadStart());for(var E in x.objects)l(x.objects[E],function(a){a.type&&a.type in n.hierarchyHandlers&&(v+=1,n.onLoadStart())});G=v;for(w in x.geometries)if(q=x.geometries[w],\"cube\"===q.type)t=new THREE.CubeGeometry(q.width,q.height,q.depth,q.widthSegments,q.heightSegments,q.depthSegments),t.name=w,C.geometries[w]=t;else if(\"plane\"===q.type)t=new THREE.PlaneGeometry(q.width,q.height,q.widthSegments,q.heightSegments),t.name=w,C.geometries[w]=t;else if(\"sphere\"===q.type)t=\nnew THREE.SphereGeometry(q.radius,q.widthSegments,q.heightSegments),t.name=w,C.geometries[w]=t;else if(\"cylinder\"===q.type)t=new THREE.CylinderGeometry(q.topRad,q.botRad,q.height,q.radSegs,q.heightSegs),t.name=w,C.geometries[w]=t;else if(\"torus\"===q.type)t=new THREE.TorusGeometry(q.radius,q.tube,q.segmentsR,q.segmentsT),t.name=w,C.geometries[w]=t;else if(\"icosahedron\"===q.type)t=new THREE.IcosahedronGeometry(q.radius,q.subdivisions),t.name=w,C.geometries[w]=t;else if(q.type in this.geometryHandlers){E=\n{};for(u in q)\"type\"!==u&&\"url\"!==u&&(E[u]=q[u]);this.geometryHandlers[q.type].loaderObject.load(d(q.url,x.urlBaseType),g(w),E)}else\"embedded\"===q.type&&(E=x.embeds[q.id],E.metadata=x.metadata,E&&(E=this.geometryHandlers.ascii.loaderObject.parse(E,\"\"),i(w)(E.geometry,E.materials)));for(var y in x.textures)if(w=x.textures[y],w.url instanceof Array){z+=w.url.length;for(u=0;u<w.url.length;u++)n.onLoadStart()}else z+=1,n.onLoadStart();N=z;for(y in x.textures){w=x.textures[y];void 0!==w.mapping&&void 0!==\nTHREE[w.mapping]&&(w.mapping=new THREE[w.mapping]);if(w.url instanceof Array){E=w.url.length;q=[];for(u=0;u<E;u++)q[u]=d(w.url[u],x.urlBaseType);u=(u=/\\.dds$/i.test(q[0]))?THREE.ImageUtils.loadCompressedTextureCube(q,w.mapping,F(E)):THREE.ImageUtils.loadTextureCube(q,w.mapping,F(E))}else u=/\\.dds$/i.test(w.url),E=d(w.url,x.urlBaseType),q=F(1),u=u?THREE.ImageUtils.loadCompressedTexture(E,w.mapping,q):THREE.ImageUtils.loadTexture(E,w.mapping,q),void 0!==THREE[w.minFilter]&&(u.minFilter=THREE[w.minFilter]),\nvoid 0!==THREE[w.magFilter]&&(u.magFilter=THREE[w.magFilter]),w.anisotropy&&(u.anisotropy=w.anisotropy),w.repeat&&(u.repeat.set(w.repeat[0],w.repeat[1]),1!==w.repeat[0]&&(u.wrapS=THREE.RepeatWrapping),1!==w.repeat[1]&&(u.wrapT=THREE.RepeatWrapping)),w.offset&&u.offset.set(w.offset[0],w.offset[1]),w.wrap&&(E={repeat:THREE.RepeatWrapping,mirror:THREE.MirroredRepeatWrapping},void 0!==E[w.wrap[0]]&&(u.wrapS=E[w.wrap[0]]),void 0!==E[w.wrap[1]]&&(u.wrapT=E[w.wrap[1]]));C.textures[y]=u}var D,H;for(D in x.materials){y=\nx.materials[D];for(H in y.parameters)\"envMap\"===H||\"map\"===H||\"lightMap\"===H||\"bumpMap\"===H?y.parameters[H]=C.textures[y.parameters[H]]:\"shading\"===H?y.parameters[H]=\"flat\"===y.parameters[H]?THREE.FlatShading:THREE.SmoothShading:\"side\"===H?y.parameters[H]=\"double\"==y.parameters[H]?THREE.DoubleSide:\"back\"==y.parameters[H]?THREE.BackSide:THREE.FrontSide:\"blending\"===H?y.parameters[H]=y.parameters[H]in THREE?THREE[y.parameters[H]]:THREE.NormalBlending:\"combine\"===H?y.parameters[H]=y.parameters[H]in THREE?\nTHREE[y.parameters[H]]:THREE.MultiplyOperation:\"vertexColors\"===H?\"face\"==y.parameters[H]?y.parameters[H]=THREE.FaceColors:y.parameters[H]&&(y.parameters[H]=THREE.VertexColors):\"wrapRGB\"===H&&(F=y.parameters[H],y.parameters[H]=new THREE.Vector3(F[0],F[1],F[2]));void 0!==y.parameters.opacity&&1>y.parameters.opacity&&(y.parameters.transparent=!0);y.parameters.normalMap?(F=THREE.ShaderLib.normalmap,w=THREE.UniformsUtils.clone(F.uniforms),u=y.parameters.color,E=y.parameters.specular,q=y.parameters.ambient,\nL=y.parameters.shininess,w.tNormal.value=C.textures[y.parameters.normalMap],y.parameters.normalScale&&w.uNormalScale.value.set(y.parameters.normalScale[0],y.parameters.normalScale[1]),y.parameters.map&&(w.tDiffuse.value=y.parameters.map,w.enableDiffuse.value=!0),y.parameters.envMap&&(w.tCube.value=y.parameters.envMap,w.enableReflection.value=!0,w.reflectivity.value=y.parameters.reflectivity),y.parameters.lightMap&&(w.tAO.value=y.parameters.lightMap,w.enableAO.value=!0),y.parameters.specularMap&&(w.tSpecular.value=\nC.textures[y.parameters.specularMap],w.enableSpecular.value=!0),y.parameters.displacementMap&&(w.tDisplacement.value=C.textures[y.parameters.displacementMap],w.enableDisplacement.value=!0,w.uDisplacementBias.value=y.parameters.displacementBias,w.uDisplacementScale.value=y.parameters.displacementScale),w.diffuse.value.setHex(u),w.specular.value.setHex(E),w.ambient.value.setHex(q),w.shininess.value=L,y.parameters.opacity&&(w.opacity.value=y.parameters.opacity),r=new THREE.ShaderMaterial({fragmentShader:F.fragmentShader,\nvertexShader:F.vertexShader,uniforms:w,lights:!0,fog:!0})):r=new THREE[y.type](y.parameters);r.name=D;C.materials[D]=r}for(D in x.materials)if(y=x.materials[D],y.parameters.materials){H=[];for(u=0;u<y.parameters.materials.length;u++)H.push(C.materials[y.parameters.materials[u]]);C.materials[D].materials=H}e();C.cameras&&x.defaults.camera&&(C.currentCamera=C.cameras[x.defaults.camera]);C.fogs&&x.defaults.fog&&(C.scene.fog=C.fogs[x.defaults.fog]);n.callbackSync(C);k()}};THREE.TextureLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};THREE.TextureLoader.prototype={constructor:THREE.TextureLoader,load:function(a,b){var c=new THREE.ImageLoader(this.manager);c.setCrossOrigin(this.crossOrigin);c.load(a,function(a){a=new THREE.Texture(a);a.needsUpdate=!0;void 0!==b&&b(a)})},setCrossOrigin:function(a){this.crossOrigin=a}};THREE.Material=function(){this.id=THREE.MaterialIdCount++;this.uuid=THREE.Math.generateUUID();this.name=\"\";this.side=THREE.FrontSide;this.opacity=1;this.transparent=!1;this.blending=THREE.NormalBlending;this.blendSrc=THREE.SrcAlphaFactor;this.blendDst=THREE.OneMinusSrcAlphaFactor;this.blendEquation=THREE.AddEquation;this.depthWrite=this.depthTest=!0;this.polygonOffset=!1;this.overdraw=this.alphaTest=this.polygonOffsetUnits=this.polygonOffsetFactor=0;this.needsUpdate=this.visible=!0};\nTHREE.Material.prototype={constructor:THREE.Material,setValues:function(a){if(void 0!==a)for(var b in a){var c=a[b];if(void 0===c)console.warn(\"THREE.Material: '\"+b+\"' parameter is undefined.\");else if(b in this){var d=this[b];d instanceof THREE.Color?d.set(c):d instanceof THREE.Vector3&&c instanceof THREE.Vector3?d.copy(c):this[b]=\"overdraw\"==b?Number(c):c}}},clone:function(a){void 0===a&&(a=new THREE.Material);a.name=this.name;a.side=this.side;a.opacity=this.opacity;a.transparent=this.transparent;\na.blending=this.blending;a.blendSrc=this.blendSrc;a.blendDst=this.blendDst;a.blendEquation=this.blendEquation;a.depthTest=this.depthTest;a.depthWrite=this.depthWrite;a.polygonOffset=this.polygonOffset;a.polygonOffsetFactor=this.polygonOffsetFactor;a.polygonOffsetUnits=this.polygonOffsetUnits;a.alphaTest=this.alphaTest;a.overdraw=this.overdraw;a.visible=this.visible;return a},dispose:function(){this.dispatchEvent({type:\"dispose\"})}};THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);\nTHREE.MaterialIdCount=0;THREE.LineBasicMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.linewidth=1;this.linejoin=this.linecap=\"round\";this.vertexColors=!1;this.fog=!0;this.setValues(a)};THREE.LineBasicMaterial.prototype=Object.create(THREE.Material.prototype);\nTHREE.LineBasicMaterial.prototype.clone=function(){var a=new THREE.LineBasicMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.linewidth=this.linewidth;a.linecap=this.linecap;a.linejoin=this.linejoin;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};THREE.LineDashedMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.scale=this.linewidth=1;this.dashSize=3;this.gapSize=1;this.vertexColors=!1;this.fog=!0;this.setValues(a)};THREE.LineDashedMaterial.prototype=Object.create(THREE.Material.prototype);\nTHREE.LineDashedMaterial.prototype.clone=function(){var a=new THREE.LineDashedMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.linewidth=this.linewidth;a.scale=this.scale;a.dashSize=this.dashSize;a.gapSize=this.gapSize;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};THREE.MeshBasicMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.envMap=this.specularMap=this.lightMap=this.map=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=\"round\";this.vertexColors=THREE.NoColors;this.morphTargets=this.skinning=!1;this.setValues(a)};\nTHREE.MeshBasicMaterial.prototype=Object.create(THREE.Material.prototype);\nTHREE.MeshBasicMaterial.prototype.clone=function(){var a=new THREE.MeshBasicMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.lightMap=this.lightMap;a.specularMap=this.specularMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=\nthis.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;return a};THREE.MeshLambertMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.ambient=new THREE.Color(16777215);this.emissive=new THREE.Color(0);this.wrapAround=!1;this.wrapRGB=new THREE.Vector3(1,1,1);this.envMap=this.specularMap=this.lightMap=this.map=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=\n\"round\";this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshLambertMaterial.prototype=Object.create(THREE.Material.prototype);\nTHREE.MeshLambertMaterial.prototype.clone=function(){var a=new THREE.MeshLambertMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.ambient.copy(this.ambient);a.emissive.copy(this.emissive);a.wrapAround=this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map=this.map;a.lightMap=this.lightMap;a.specularMap=this.specularMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;\na.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;a.morphNormals=this.morphNormals;return a};THREE.MeshPhongMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.ambient=new THREE.Color(16777215);this.emissive=new THREE.Color(0);this.specular=new THREE.Color(1118481);this.shininess=30;this.metal=!1;this.perPixel=!0;this.wrapAround=!1;this.wrapRGB=new THREE.Vector3(1,1,1);this.bumpMap=this.lightMap=this.map=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new THREE.Vector2(1,1);this.envMap=this.specularMap=null;this.combine=THREE.MultiplyOperation;\nthis.reflectivity=1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=\"round\";this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshPhongMaterial.prototype=Object.create(THREE.Material.prototype);\nTHREE.MeshPhongMaterial.prototype.clone=function(){var a=new THREE.MeshPhongMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.ambient.copy(this.ambient);a.emissive.copy(this.emissive);a.specular.copy(this.specular);a.shininess=this.shininess;a.metal=this.metal;a.perPixel=this.perPixel;a.wrapAround=this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map=this.map;a.lightMap=this.lightMap;a.bumpMap=this.bumpMap;a.bumpScale=this.bumpScale;a.normalMap=this.normalMap;a.normalScale.copy(this.normalScale);\na.specularMap=this.specularMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;a.morphNormals=this.morphNormals;return a};THREE.MeshDepthMaterial=function(a){THREE.Material.call(this);this.wireframe=!1;this.wireframeLinewidth=1;this.setValues(a)};THREE.MeshDepthMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshDepthMaterial.prototype.clone=function(){var a=new THREE.MeshDepthMaterial;THREE.Material.prototype.clone.call(this,a);a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;return a};THREE.MeshNormalMaterial=function(a){THREE.Material.call(this,a);this.shading=THREE.FlatShading;this.wireframe=!1;this.wireframeLinewidth=1;this.morphTargets=!1;this.setValues(a)};THREE.MeshNormalMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshNormalMaterial.prototype.clone=function(){var a=new THREE.MeshNormalMaterial;THREE.Material.prototype.clone.call(this,a);a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;return a};THREE.MeshFaceMaterial=function(a){this.materials=a instanceof Array?a:[]};THREE.MeshFaceMaterial.prototype.clone=function(){for(var a=new THREE.MeshFaceMaterial,b=0;b<this.materials.length;b++)a.materials.push(this.materials[b].clone());return a};THREE.ParticleSystemMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.map=null;this.size=1;this.sizeAttenuation=!0;this.vertexColors=!1;this.fog=!0;this.setValues(a)};THREE.ParticleSystemMaterial.prototype=Object.create(THREE.Material.prototype);\nTHREE.ParticleSystemMaterial.prototype.clone=function(){var a=new THREE.ParticleSystemMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.size=this.size;a.sizeAttenuation=this.sizeAttenuation;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};THREE.ParticleBasicMaterial=THREE.ParticleSystemMaterial;THREE.ShaderMaterial=function(a){THREE.Material.call(this);this.vertexShader=this.fragmentShader=\"void main() {}\";this.uniforms={};this.defines={};this.attributes=null;this.shading=THREE.SmoothShading;this.linewidth=1;this.wireframe=!1;this.wireframeLinewidth=1;this.lights=this.fog=!1;this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]};this.index0AttributeName=\"position\";this.setValues(a)};\nTHREE.ShaderMaterial.prototype=Object.create(THREE.Material.prototype);\nTHREE.ShaderMaterial.prototype.clone=function(){var a=new THREE.ShaderMaterial;THREE.Material.prototype.clone.call(this,a);a.fragmentShader=this.fragmentShader;a.vertexShader=this.vertexShader;a.uniforms=THREE.UniformsUtils.clone(this.uniforms);a.attributes=this.attributes;a.defines=this.defines;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.fog=this.fog;a.lights=this.lights;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=\nthis.morphTargets;a.morphNormals=this.morphNormals;return a};THREE.SpriteMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.map=null;this.rotation=0;this.fog=!1;this.setValues(a)};THREE.SpriteMaterial.prototype=Object.create(THREE.Material.prototype);THREE.SpriteMaterial.prototype.clone=function(){var a=new THREE.SpriteMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.rotation=this.rotation;a.fog=this.fog;return a};THREE.SpriteCanvasMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.program=function(){};this.setValues(a)};THREE.SpriteCanvasMaterial.prototype=Object.create(THREE.Material.prototype);THREE.SpriteCanvasMaterial.prototype.clone=function(){var a=new THREE.SpriteCanvasMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.program=this.program;return a};THREE.ParticleCanvasMaterial=THREE.SpriteCanvasMaterial;THREE.Texture=function(a,b,c,d,e,f,g,h,i){this.id=THREE.TextureIdCount++;this.uuid=THREE.Math.generateUUID();this.name=\"\";this.image=a;this.mipmaps=[];this.mapping=void 0!==b?b:new THREE.UVMapping;this.wrapS=void 0!==c?c:THREE.ClampToEdgeWrapping;this.wrapT=void 0!==d?d:THREE.ClampToEdgeWrapping;this.magFilter=void 0!==e?e:THREE.LinearFilter;this.minFilter=void 0!==f?f:THREE.LinearMipMapLinearFilter;this.anisotropy=void 0!==i?i:1;this.format=void 0!==g?g:THREE.RGBAFormat;this.type=void 0!==h?h:THREE.UnsignedByteType;\nthis.offset=new THREE.Vector2(0,0);this.repeat=new THREE.Vector2(1,1);this.generateMipmaps=!0;this.premultiplyAlpha=!1;this.flipY=!0;this.unpackAlignment=4;this._needsUpdate=!1;this.onUpdate=null};\nTHREE.Texture.prototype={constructor:THREE.Texture,get needsUpdate(){return this._needsUpdate},set needsUpdate(a){!0===a&&this.update();this._needsUpdate=a},clone:function(a){void 0===a&&(a=new THREE.Texture);a.image=this.image;a.mipmaps=this.mipmaps.slice(0);a.mapping=this.mapping;a.wrapS=this.wrapS;a.wrapT=this.wrapT;a.magFilter=this.magFilter;a.minFilter=this.minFilter;a.anisotropy=this.anisotropy;a.format=this.format;a.type=this.type;a.offset.copy(this.offset);a.repeat.copy(this.repeat);a.generateMipmaps=\nthis.generateMipmaps;a.premultiplyAlpha=this.premultiplyAlpha;a.flipY=this.flipY;a.unpackAlignment=this.unpackAlignment;return a},update:function(){this.dispatchEvent({type:\"update\"})},dispose:function(){this.dispatchEvent({type:\"dispose\"})}};THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);THREE.TextureIdCount=0;THREE.CompressedTexture=function(a,b,c,d,e,f,g,h,i,k,l){THREE.Texture.call(this,null,f,g,h,i,k,d,e,l);this.image={width:b,height:c};this.mipmaps=a;this.generateMipmaps=!1};THREE.CompressedTexture.prototype=Object.create(THREE.Texture.prototype);THREE.CompressedTexture.prototype.clone=function(){var a=new THREE.CompressedTexture;THREE.Texture.prototype.clone.call(this,a);return a};THREE.DataTexture=function(a,b,c,d,e,f,g,h,i,k,l){THREE.Texture.call(this,null,f,g,h,i,k,d,e,l);this.image={data:a,width:b,height:c}};THREE.DataTexture.prototype=Object.create(THREE.Texture.prototype);THREE.DataTexture.prototype.clone=function(){var a=new THREE.DataTexture;THREE.Texture.prototype.clone.call(this,a);return a};THREE.ParticleSystem=function(a,b){THREE.Object3D.call(this);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.ParticleSystemMaterial({color:16777215*Math.random()});this.frustumCulled=this.sortParticles=!1};THREE.ParticleSystem.prototype=Object.create(THREE.Object3D.prototype);\nTHREE.ParticleSystem.prototype.clone=function(a){void 0===a&&(a=new THREE.ParticleSystem(this.geometry,this.material));a.sortParticles=this.sortParticles;THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Line=function(a,b,c){THREE.Object3D.call(this);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.LineBasicMaterial({color:16777215*Math.random()});this.type=void 0!==c?c:THREE.LineStrip};THREE.LineStrip=0;THREE.LinePieces=1;THREE.Line.prototype=Object.create(THREE.Object3D.prototype);THREE.Line.prototype.clone=function(a){void 0===a&&(a=new THREE.Line(this.geometry,this.material,this.type));THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Mesh=function(a,b){THREE.Object3D.call(this);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.MeshBasicMaterial({color:16777215*Math.random()});this.updateMorphTargets()};THREE.Mesh.prototype=Object.create(THREE.Object3D.prototype);\nTHREE.Mesh.prototype.updateMorphTargets=function(){if(0<this.geometry.morphTargets.length){this.morphTargetBase=-1;this.morphTargetForcedOrder=[];this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var a=0,b=this.geometry.morphTargets.length;a<b;a++)this.morphTargetInfluences.push(0),this.morphTargetDictionary[this.geometry.morphTargets[a].name]=a}};\nTHREE.Mesh.prototype.getMorphTargetIndexByName=function(a){if(void 0!==this.morphTargetDictionary[a])return this.morphTargetDictionary[a];console.log(\"THREE.Mesh.getMorphTargetIndexByName: morph target \"+a+\" does not exist. Returning 0.\");return 0};THREE.Mesh.prototype.clone=function(a){void 0===a&&(a=new THREE.Mesh(this.geometry,this.material));THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Bone=function(a){THREE.Object3D.call(this);this.skin=a;this.skinMatrix=new THREE.Matrix4};THREE.Bone.prototype=Object.create(THREE.Object3D.prototype);THREE.Bone.prototype.update=function(a,b){this.matrixAutoUpdate&&(b|=this.updateMatrix());if(b||this.matrixWorldNeedsUpdate)a?this.skinMatrix.multiplyMatrices(a,this.matrix):this.skinMatrix.copy(this.matrix),this.matrixWorldNeedsUpdate=!1,b=!0;var c,d=this.children.length;for(c=0;c<d;c++)this.children[c].update(this.skinMatrix,b)};THREE.SkinnedMesh=function(a,b,c){THREE.Mesh.call(this,a,b);this.useVertexTexture=void 0!==c?c:!0;this.identityMatrix=new THREE.Matrix4;this.bones=[];this.boneMatrices=[];var d,e,f;if(this.geometry&&void 0!==this.geometry.bones){for(a=0;a<this.geometry.bones.length;a++)c=this.geometry.bones[a],d=c.pos,e=c.rotq,f=c.scl,b=this.addBone(),b.name=c.name,b.position.set(d[0],d[1],d[2]),b.quaternion.set(e[0],e[1],e[2],e[3]),void 0!==f?b.scale.set(f[0],f[1],f[2]):b.scale.set(1,1,1);for(a=0;a<this.bones.length;a++)c=\nthis.geometry.bones[a],b=this.bones[a],-1===c.parent?this.add(b):this.bones[c.parent].add(b);a=this.bones.length;this.useVertexTexture?(this.boneTextureHeight=this.boneTextureWidth=a=256<a?64:64<a?32:16<a?16:8,this.boneMatrices=new Float32Array(4*this.boneTextureWidth*this.boneTextureHeight),this.boneTexture=new THREE.DataTexture(this.boneMatrices,this.boneTextureWidth,this.boneTextureHeight,THREE.RGBAFormat,THREE.FloatType),this.boneTexture.minFilter=THREE.NearestFilter,this.boneTexture.magFilter=\nTHREE.NearestFilter,this.boneTexture.generateMipmaps=!1,this.boneTexture.flipY=!1):this.boneMatrices=new Float32Array(16*a);this.pose()}};THREE.SkinnedMesh.prototype=Object.create(THREE.Mesh.prototype);THREE.SkinnedMesh.prototype.addBone=function(a){void 0===a&&(a=new THREE.Bone(this));this.bones.push(a);return a};\nTHREE.SkinnedMesh.prototype.updateMatrixWorld=function(){var a=new THREE.Matrix4;return function(b){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||b)this.parent?this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix):this.matrixWorld.copy(this.matrix),this.matrixWorldNeedsUpdate=!1;for(var b=0,c=this.children.length;b<c;b++){var d=this.children[b];d instanceof THREE.Bone?d.update(this.identityMatrix,!1):d.updateMatrixWorld(!0)}if(void 0==this.boneInverses){this.boneInverses=\n[];b=0;for(c=this.bones.length;b<c;b++)d=new THREE.Matrix4,d.getInverse(this.bones[b].skinMatrix),this.boneInverses.push(d)}b=0;for(c=this.bones.length;b<c;b++)a.multiplyMatrices(this.bones[b].skinMatrix,this.boneInverses[b]),a.flattenToArrayOffset(this.boneMatrices,16*b);this.useVertexTexture&&(this.boneTexture.needsUpdate=!0)}}();THREE.SkinnedMesh.prototype.pose=function(){this.updateMatrixWorld(!0);this.normalizeSkinWeights()};\nTHREE.SkinnedMesh.prototype.normalizeSkinWeights=function(){if(this.geometry instanceof THREE.Geometry)for(var a=0;a<this.geometry.skinIndices.length;a++){var b=this.geometry.skinWeights[a],c=1/b.lengthManhattan();Infinity!==c?b.multiplyScalar(c):b.set(1)}};THREE.SkinnedMesh.prototype.clone=function(a){void 0===a&&(a=new THREE.SkinnedMesh(this.geometry,this.material,this.useVertexTexture));THREE.Mesh.prototype.clone.call(this,a);return a};THREE.MorphAnimMesh=function(a,b){THREE.Mesh.call(this,a,b);this.duration=1E3;this.mirroredLoop=!1;this.currentKeyframe=this.lastKeyframe=this.time=0;this.direction=1;this.directionBackwards=!1;this.setFrameRange(0,this.geometry.morphTargets.length-1)};THREE.MorphAnimMesh.prototype=Object.create(THREE.Mesh.prototype);THREE.MorphAnimMesh.prototype.setFrameRange=function(a,b){this.startKeyframe=a;this.endKeyframe=b;this.length=this.endKeyframe-this.startKeyframe+1};\nTHREE.MorphAnimMesh.prototype.setDirectionForward=function(){this.direction=1;this.directionBackwards=!1};THREE.MorphAnimMesh.prototype.setDirectionBackward=function(){this.direction=-1;this.directionBackwards=!0};\nTHREE.MorphAnimMesh.prototype.parseAnimations=function(){var a=this.geometry;a.animations||(a.animations={});for(var b,c=a.animations,d=/([a-z]+)(\\d+)/,e=0,f=a.morphTargets.length;e<f;e++){var g=a.morphTargets[e].name.match(d);if(g&&1<g.length){g=g[1];c[g]||(c[g]={start:Infinity,end:-Infinity});var h=c[g];e<h.start&&(h.start=e);e>h.end&&(h.end=e);b||(b=g)}}a.firstAnimation=b};\nTHREE.MorphAnimMesh.prototype.setAnimationLabel=function(a,b,c){this.geometry.animations||(this.geometry.animations={});this.geometry.animations[a]={start:b,end:c}};THREE.MorphAnimMesh.prototype.playAnimation=function(a,b){var c=this.geometry.animations[a];c?(this.setFrameRange(c.start,c.end),this.duration=1E3*((c.end-c.start)/b),this.time=0):console.warn(\"animation[\"+a+\"] undefined\")};\nTHREE.MorphAnimMesh.prototype.updateAnimation=function(a){var b=this.duration/this.length;this.time+=this.direction*a;if(this.mirroredLoop){if(this.time>this.duration||0>this.time)this.direction*=-1,this.time>this.duration&&(this.time=this.duration,this.directionBackwards=!0),0>this.time&&(this.time=0,this.directionBackwards=!1)}else this.time%=this.duration,0>this.time&&(this.time+=this.duration);a=this.startKeyframe+THREE.Math.clamp(Math.floor(this.time/b),0,this.length-1);a!==this.currentKeyframe&&\n(this.morphTargetInfluences[this.lastKeyframe]=0,this.morphTargetInfluences[this.currentKeyframe]=1,this.morphTargetInfluences[a]=0,this.lastKeyframe=this.currentKeyframe,this.currentKeyframe=a);b=this.time%b/b;this.directionBackwards&&(b=1-b);this.morphTargetInfluences[this.currentKeyframe]=b;this.morphTargetInfluences[this.lastKeyframe]=1-b};\nTHREE.MorphAnimMesh.prototype.clone=function(a){void 0===a&&(a=new THREE.MorphAnimMesh(this.geometry,this.material));a.duration=this.duration;a.mirroredLoop=this.mirroredLoop;a.time=this.time;a.lastKeyframe=this.lastKeyframe;a.currentKeyframe=this.currentKeyframe;a.direction=this.direction;a.directionBackwards=this.directionBackwards;THREE.Mesh.prototype.clone.call(this,a);return a};THREE.LOD=function(){THREE.Object3D.call(this);this.objects=[]};THREE.LOD.prototype=Object.create(THREE.Object3D.prototype);THREE.LOD.prototype.addLevel=function(a,b){void 0===b&&(b=0);for(var b=Math.abs(b),c=0;c<this.objects.length&&!(b<this.objects[c].distance);c++);this.objects.splice(c,0,{distance:b,object:a});this.add(a)};THREE.LOD.prototype.getObjectForDistance=function(a){for(var b=1,c=this.objects.length;b<c&&!(a<this.objects[b].distance);b++);return this.objects[b-1].object};\nTHREE.LOD.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c){if(1<this.objects.length){a.setFromMatrixPosition(c.matrixWorld);b.setFromMatrixPosition(this.matrixWorld);c=a.distanceTo(b);this.objects[0].object.visible=!0;for(var d=1,e=this.objects.length;d<e;d++)if(c>=this.objects[d].distance)this.objects[d-1].object.visible=!1,this.objects[d].object.visible=!0;else break;for(;d<e;d++)this.objects[d].object.visible=!1}}}();THREE.LOD.prototype.clone=function(){};THREE.Sprite=function(a){THREE.Object3D.call(this);this.material=void 0!==a?a:new THREE.SpriteMaterial};THREE.Sprite.prototype=Object.create(THREE.Object3D.prototype);THREE.Sprite.prototype.updateMatrix=function(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=!0};THREE.Sprite.prototype.clone=function(a){void 0===a&&(a=new THREE.Sprite(this.material));THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Particle=THREE.Sprite;THREE.Scene=function(){THREE.Object3D.call(this);this.overrideMaterial=this.fog=null;this.autoUpdate=!0;this.matrixAutoUpdate=!1;this.__lights=[];this.__objectsAdded=[];this.__objectsRemoved=[]};THREE.Scene.prototype=Object.create(THREE.Object3D.prototype);\nTHREE.Scene.prototype.__addObject=function(a){if(a instanceof THREE.Light)-1===this.__lights.indexOf(a)&&this.__lights.push(a),a.target&&void 0===a.target.parent&&this.add(a.target);else if(!(a instanceof THREE.Camera||a instanceof THREE.Bone)){this.__objectsAdded.push(a);var b=this.__objectsRemoved.indexOf(a);-1!==b&&this.__objectsRemoved.splice(b,1)}this.dispatchEvent({type:\"objectAdded\",object:a});a.dispatchEvent({type:\"addedToScene\",scene:this});for(b=0;b<a.children.length;b++)this.__addObject(a.children[b])};\nTHREE.Scene.prototype.__removeObject=function(a){if(a instanceof THREE.Light){var b=this.__lights.indexOf(a);-1!==b&&this.__lights.splice(b,1);if(a.shadowCascadeArray)for(b=0;b<a.shadowCascadeArray.length;b++)this.__removeObject(a.shadowCascadeArray[b])}else a instanceof THREE.Camera||(this.__objectsRemoved.push(a),b=this.__objectsAdded.indexOf(a),-1!==b&&this.__objectsAdded.splice(b,1));this.dispatchEvent({type:\"objectRemoved\",object:a});a.dispatchEvent({type:\"removedFromScene\",scene:this});for(b=\n0;b<a.children.length;b++)this.__removeObject(a.children[b])};THREE.Scene.prototype.clone=function(a){void 0===a&&(a=new THREE.Scene);THREE.Object3D.prototype.clone.call(this,a);null!==this.fog&&(a.fog=this.fog.clone());null!==this.overrideMaterial&&(a.overrideMaterial=this.overrideMaterial.clone());a.autoUpdate=this.autoUpdate;a.matrixAutoUpdate=this.matrixAutoUpdate;return a};THREE.Fog=function(a,b,c){this.name=\"\";this.color=new THREE.Color(a);this.near=void 0!==b?b:1;this.far=void 0!==c?c:1E3};THREE.Fog.prototype.clone=function(){return new THREE.Fog(this.color.getHex(),this.near,this.far)};THREE.FogExp2=function(a,b){this.name=\"\";this.color=new THREE.Color(a);this.density=void 0!==b?b:2.5E-4};THREE.FogExp2.prototype.clone=function(){return new THREE.FogExp2(this.color.getHex(),this.density)};THREE.CanvasRenderer=function(a){function b(a,b,c){for(var d=0,e=N.length;d<e;d++){var f=N[d];wa.copy(f.color);if(f instanceof THREE.DirectionalLight){var g=Na.setFromMatrixPosition(f.matrixWorld).normalize(),h=b.dot(g);0>=h||(h*=f.intensity,c.add(wa.multiplyScalar(h)))}else f instanceof THREE.PointLight&&(g=Na.setFromMatrixPosition(f.matrixWorld),h=b.dot(Na.subVectors(g,a).normalize()),0>=h||(h*=0==f.distance?1:1-Math.min(a.distanceTo(g)/f.distance,1),0!=h&&(h*=f.intensity,c.add(wa.multiplyScalar(h)))))}}\nfunction c(a,b,c,d){p(b);t(c);r(d);m(a.getStyle());E.stroke();pa.expandByScalar(2*b)}function d(a){q(a.getStyle());E.fill()}function e(a){f(a.target)}function f(a){var b=a.wrapS===THREE.RepeatWrapping,c=a.wrapT===THREE.RepeatWrapping,d=a.image,e=document.createElement(\"canvas\");e.width=d.width;e.height=d.height;var f=e.getContext(\"2d\");f.setTransform(1,0,0,-1,0,d.height);f.drawImage(d,0,0);Ua[a.id]=E.createPattern(e,!0===b&&!0===c?\"repeat\":!0===b&&!1===c?\"repeat-x\":!1===b&&!0===c?\"repeat-y\":\"no-repeat\")}\nfunction g(a,b,c,d,g,h,j,i,k,l,n,p,m){if(!(m instanceof THREE.DataTexture)){!1===m.hasEventListener(\"update\",e)&&(void 0!==m.image&&0<m.image.width&&f(m),m.addEventListener(\"update\",e));var t=Ua[m.id];if(void 0!==t){q(t);var t=m.offset.x/m.repeat.x,r=m.offset.y/m.repeat.y,s=m.image.width*m.repeat.x,m=m.image.height*m.repeat.y,j=(j+t)*s,i=(i+r)*m,c=c-a,d=d-b,g=g-a,h=h-b,k=(k+t)*s-j,l=(l+r)*m-i,n=(n+t)*s-j,p=(p+r)*m-i,m=k*p-n*l;0!==m&&(t=1/m,m=(p*c-l*g)*t,l=(p*d-l*h)*t,c=(k*g-n*c)*t,d=(k*h-n*d)*t,a=\na-m*j-c*i,b=b-l*j-d*i,E.save(),E.transform(m,l,c,d,a,b),E.fill(),E.restore())}else q(\"rgba(0,0,0,1)\"),E.fill()}}function h(a,b,c,d,e,f,g,h,j,i,k,l,n){var m,p;m=n.width-1;p=n.height-1;g*=m;h*=p;c-=a;d-=b;e-=a;f-=b;j=j*m-g;i=i*p-h;k=k*m-g;l=l*p-h;p=1/(j*l-k*i);m=(l*c-i*e)*p;i=(l*d-i*f)*p;c=(j*e-k*c)*p;d=(j*f-k*d)*p;a=a-m*g-c*h;b=b-i*g-d*h;E.save();E.transform(m,i,c,d,a,b);E.clip();E.drawImage(n,0,0);E.restore()}function i(a,b,c,d){qa[0]=255*a.r|0;qa[1]=255*a.g|0;qa[2]=255*a.b|0;qa[4]=255*b.r|0;qa[5]=\n255*b.g|0;qa[6]=255*b.b|0;qa[8]=255*c.r|0;qa[9]=255*c.g|0;qa[10]=255*c.b|0;qa[12]=255*d.r|0;qa[13]=255*d.g|0;qa[14]=255*d.b|0;Pa.putImageData(Wa,0,0);hb.drawImage(j,0,0);return ta}function k(a,b,c){var d=b.x-a.x,e=b.y-a.y,f=d*d+e*e;0!==f&&(c/=Math.sqrt(f),d*=c,e*=c,b.x+=d,b.y+=e,a.x-=d,a.y-=e)}function l(a){H!==a&&(H=E.globalAlpha=a)}function n(a){K!==a&&(a===THREE.NormalBlending?E.globalCompositeOperation=\"source-over\":a===THREE.AdditiveBlending?E.globalCompositeOperation=\"lighter\":a===THREE.SubtractiveBlending&&\n(E.globalCompositeOperation=\"darker\"),K=a)}function p(a){ha!==a&&(ha=E.lineWidth=a)}function t(a){ua!==a&&(ua=E.lineCap=a)}function r(a){O!==a&&(O=E.lineJoin=a)}function m(a){A!==a&&(A=E.strokeStyle=a)}function q(a){da!==a&&(da=E.fillStyle=a)}function u(a,b){if(T!==a||ea!==b)E.setLineDash([a,b]),T=a,ea=b}console.log(\"THREE.CanvasRenderer\",THREE.REVISION);var s=THREE.Math.smoothstep,a=a||{},v=this,z,G,N,C=new THREE.Projector,B=void 0!==a.canvas?a.canvas:document.createElement(\"canvas\"),x=B.width,F=\nB.height,L=Math.floor(x/2),w=Math.floor(F/2),E=B.getContext(\"2d\"),y=new THREE.Color(0),D=0,H=1,K=0,A=null,da=null,ha=null,ua=null,O=null,T=null,ea=0,I,P,Q,oa;new THREE.RenderableVertex;new THREE.RenderableVertex;var va,Ea,za,Ha,Ta,Ja,sa=new THREE.Color,Aa=new THREE.Color,ba=new THREE.Color,W=new THREE.Color,Ka=new THREE.Color,U=new THREE.Color,ca=new THREE.Color,wa=new THREE.Color,Ua={},Oa,la,ia,Fa,Ga,Ba,xa,Va,La,Ma,ya=new THREE.Box2,V=new THREE.Box2,pa=new THREE.Box2,ja=new THREE.Color,fa=new THREE.Color,\nZa=new THREE.Color,Na=new THREE.Vector3,j,Pa,Wa,qa,ta,hb,db=16;j=document.createElement(\"canvas\");j.width=j.height=2;Pa=j.getContext(\"2d\");Pa.fillStyle=\"rgba(0,0,0,1)\";Pa.fillRect(0,0,2,2);Wa=Pa.getImageData(0,0,2,2);qa=Wa.data;ta=document.createElement(\"canvas\");ta.width=ta.height=db;hb=ta.getContext(\"2d\");hb.translate(-db/2,-db/2);hb.scale(db,db);db--;void 0===E.setLineDash&&(E.setLineDash=void 0!==E.mozDash?function(a){E.mozDash=null!==a[0]?a:null}:function(){});this.domElement=B;this.devicePixelRatio=\nvoid 0!==a.devicePixelRatio?a.devicePixelRatio:void 0!==self.devicePixelRatio?self.devicePixelRatio:1;this.sortElements=this.sortObjects=this.autoClear=!0;this.info={render:{vertices:0,faces:0}};this.supportsVertexTextures=function(){};this.setFaceCulling=function(){};this.setSize=function(a,b,c){x=a*this.devicePixelRatio;F=b*this.devicePixelRatio;L=Math.floor(x/2);w=Math.floor(F/2);B.width=x;B.height=F;1!==this.devicePixelRatio&&!1!==c&&(B.style.width=a+\"px\",B.style.height=b+\"px\");ya.set(new THREE.Vector2(-L,\n-w),new THREE.Vector2(L,w));V.set(new THREE.Vector2(-L,-w),new THREE.Vector2(L,w));H=1;K=0;O=ua=ha=da=A=null};this.setClearColor=function(a,b){y.set(a);D=void 0!==b?b:1;V.set(new THREE.Vector2(-L,-w),new THREE.Vector2(L,w))};this.setClearColorHex=function(a,b){console.warn(\"DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.\");this.setClearColor(a,b)};this.getMaxAnisotropy=function(){return 0};this.clear=function(){E.setTransform(1,0,0,-1,L,w);!1===V.empty()&&(V.intersect(ya),\nV.expandByScalar(2),1>D&&E.clearRect(V.min.x|0,V.min.y|0,V.max.x-V.min.x|0,V.max.y-V.min.y|0),0<D&&(n(THREE.NormalBlending),l(1),q(\"rgba(\"+Math.floor(255*y.r)+\",\"+Math.floor(255*y.g)+\",\"+Math.floor(255*y.b)+\",\"+D+\")\"),E.fillRect(V.min.x|0,V.min.y|0,V.max.x-V.min.x|0,V.max.y-V.min.y|0)),V.makeEmpty())};this.clearColor=function(){};this.clearDepth=function(){};this.clearStencil=function(){};this.render=function(a,j){if(!1===j instanceof THREE.Camera)console.error(\"THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.\");\nelse{!0===this.autoClear&&this.clear();E.setTransform(1,0,0,-1,L,w);v.info.render.vertices=0;v.info.render.faces=0;z=C.projectScene(a,j,this.sortObjects,this.sortElements);G=z.elements;N=z.lights;I=j;ja.setRGB(0,0,0);fa.setRGB(0,0,0);Za.setRGB(0,0,0);for(var x=0,H=N.length;x<H;x++){var B=N[x],F=B.color;B instanceof THREE.AmbientLight?ja.add(F):B instanceof THREE.DirectionalLight?fa.add(F):B instanceof THREE.PointLight&&Za.add(F)}x=0;for(H=G.length;x<H;x++){var y=G[x],D=y.material;if(!(void 0===D||\n!1===D.visible)){pa.makeEmpty();if(y instanceof THREE.RenderableSprite){P=y;P.x*=L;P.y*=w;B=P;F=D;l(F.opacity);n(F.blending);var A=y.scale.x*L,y=y.scale.y*w,D=0.5*Math.sqrt(A*A+y*y);pa.min.set(B.x-D,B.y-D);pa.max.set(B.x+D,B.y+D);if(!1===ya.isIntersectionBox(pa))pa.makeEmpty();else if(F instanceof THREE.SpriteMaterial||F instanceof THREE.ParticleSystemMaterial){var O=F.map;if(null!==O){!1===O.hasEventListener(\"update\",e)&&(void 0!==O.image&&0<O.image.width&&f(O),O.addEventListener(\"update\",e));D=\nUa[O.id];void 0!==D?q(D):q(\"rgba( 0, 0, 0, 1 )\");var K=O.image,D=K.width*O.offset.x,T=K.height*O.offset.y,da=K.width*O.repeat.x,O=K.height*O.repeat.y,K=A/da,ha=y/O;E.save();E.translate(B.x,B.y);0!==F.rotation&&E.rotate(F.rotation);E.translate(-A/2,-y/2);E.scale(K,ha);E.translate(-D,-T);E.fillRect(D,T,da,O)}else q(F.color.getStyle()),E.save(),E.translate(B.x,B.y),0!==F.rotation&&E.rotate(F.rotation),E.scale(A,-y),E.fillRect(-0.5,-0.5,1,1);E.restore()}else F instanceof THREE.SpriteCanvasMaterial&&(m(F.color.getStyle()),\nq(F.color.getStyle()),E.save(),E.translate(B.x,B.y),0!==F.rotation&&E.rotate(F.rotation),E.scale(A,y),F.program(E),E.restore())}else if(y instanceof THREE.RenderableLine){if(P=y.v1,Q=y.v2,P.positionScreen.x*=L,P.positionScreen.y*=w,Q.positionScreen.x*=L,Q.positionScreen.y*=w,pa.setFromPoints([P.positionScreen,Q.positionScreen]),!0===ya.isIntersectionBox(pa))if(B=P,F=Q,A=y,y=D,l(y.opacity),n(y.blending),E.beginPath(),E.moveTo(B.positionScreen.x,B.positionScreen.y),E.lineTo(F.positionScreen.x,F.positionScreen.y),\ny instanceof THREE.LineBasicMaterial){p(y.linewidth);t(y.linecap);r(y.linejoin);if(y.vertexColors!==THREE.VertexColors)m(y.color.getStyle());else if(D=A.vertexColors[0].getStyle(),A=A.vertexColors[1].getStyle(),D===A)m(D);else{try{var ea=E.createLinearGradient(B.positionScreen.x,B.positionScreen.y,F.positionScreen.x,F.positionScreen.y);ea.addColorStop(0,D);ea.addColorStop(1,A)}catch(qa){ea=D}m(ea)}E.stroke();pa.expandByScalar(2*y.linewidth)}else y instanceof THREE.LineDashedMaterial&&(p(y.linewidth),\nt(y.linecap),r(y.linejoin),m(y.color.getStyle()),u(y.dashSize,y.gapSize),E.stroke(),pa.expandByScalar(2*y.linewidth),u(null,null))}else if(y instanceof THREE.RenderableFace3){P=y.v1;Q=y.v2;oa=y.v3;if(-1>P.positionScreen.z||1<P.positionScreen.z)continue;if(-1>Q.positionScreen.z||1<Q.positionScreen.z)continue;if(-1>oa.positionScreen.z||1<oa.positionScreen.z)continue;P.positionScreen.x*=L;P.positionScreen.y*=w;Q.positionScreen.x*=L;Q.positionScreen.y*=w;oa.positionScreen.x*=L;oa.positionScreen.y*=w;\n0<D.overdraw&&(k(P.positionScreen,Q.positionScreen,D.overdraw),k(Q.positionScreen,oa.positionScreen,D.overdraw),k(oa.positionScreen,P.positionScreen,D.overdraw));pa.setFromPoints([P.positionScreen,Q.positionScreen,oa.positionScreen]);if(!0===ya.isIntersectionBox(pa)){B=P;F=Q;A=oa;v.info.render.vertices+=3;v.info.render.faces++;l(D.opacity);n(D.blending);va=B.positionScreen.x;Ea=B.positionScreen.y;za=F.positionScreen.x;Ha=F.positionScreen.y;Ta=A.positionScreen.x;Ja=A.positionScreen.y;var T=va,da=Ea,\nO=za,K=Ha,ha=Ta,ua=Ja;E.beginPath();E.moveTo(T,da);E.lineTo(O,K);E.lineTo(ha,ua);E.closePath();(D instanceof THREE.MeshLambertMaterial||D instanceof THREE.MeshPhongMaterial)&&null===D.map?(U.copy(D.color),ca.copy(D.emissive),D.vertexColors===THREE.FaceColors&&U.multiply(y.color),!1===D.wireframe&&D.shading===THREE.SmoothShading&&3===y.vertexNormalsLength?(Aa.copy(ja),ba.copy(ja),W.copy(ja),b(y.v1.positionWorld,y.vertexNormalsModel[0],Aa),b(y.v2.positionWorld,y.vertexNormalsModel[1],ba),b(y.v3.positionWorld,\ny.vertexNormalsModel[2],W),Aa.multiply(U).add(ca),ba.multiply(U).add(ca),W.multiply(U).add(ca),Ka.addColors(ba,W).multiplyScalar(0.5),ia=i(Aa,ba,W,Ka),h(va,Ea,za,Ha,Ta,Ja,0,0,1,0,0,1,ia)):(sa.copy(ja),b(y.centroidModel,y.normalModel,sa),sa.multiply(U).add(ca),!0===D.wireframe?c(sa,D.wireframeLinewidth,D.wireframeLinecap,D.wireframeLinejoin):d(sa))):D instanceof THREE.MeshBasicMaterial||D instanceof THREE.MeshLambertMaterial||D instanceof THREE.MeshPhongMaterial?null!==D.map?D.map.mapping instanceof\nTHREE.UVMapping&&(Fa=y.uvs[0],g(va,Ea,za,Ha,Ta,Ja,Fa[0].x,Fa[0].y,Fa[1].x,Fa[1].y,Fa[2].x,Fa[2].y,D.map)):null!==D.envMap?D.envMap.mapping instanceof THREE.SphericalReflectionMapping&&(Na.copy(y.vertexNormalsModelView[0]),Ga=0.5*Na.x+0.5,Ba=0.5*Na.y+0.5,Na.copy(y.vertexNormalsModelView[1]),xa=0.5*Na.x+0.5,Va=0.5*Na.y+0.5,Na.copy(y.vertexNormalsModelView[2]),La=0.5*Na.x+0.5,Ma=0.5*Na.y+0.5,g(va,Ea,za,Ha,Ta,Ja,Ga,Ba,xa,Va,La,Ma,D.envMap)):(sa.copy(D.color),D.vertexColors===THREE.FaceColors&&sa.multiply(y.color),\n!0===D.wireframe?c(sa,D.wireframeLinewidth,D.wireframeLinecap,D.wireframeLinejoin):d(sa)):D instanceof THREE.MeshDepthMaterial?(Oa=I.near,la=I.far,Aa.r=Aa.g=Aa.b=1-s(B.positionScreen.z*B.positionScreen.w,Oa,la),ba.r=ba.g=ba.b=1-s(F.positionScreen.z*F.positionScreen.w,Oa,la),W.r=W.g=W.b=1-s(A.positionScreen.z*A.positionScreen.w,Oa,la),Ka.addColors(ba,W).multiplyScalar(0.5),ia=i(Aa,ba,W,Ka),h(va,Ea,za,Ha,Ta,Ja,0,0,1,0,0,1,ia)):D instanceof THREE.MeshNormalMaterial&&(B=void 0,D.shading===THREE.FlatShading?\n(B=y.normalModelView,sa.setRGB(B.x,B.y,B.z).multiplyScalar(0.5).addScalar(0.5),!0===D.wireframe?c(sa,D.wireframeLinewidth,D.wireframeLinecap,D.wireframeLinejoin):d(sa)):D.shading===THREE.SmoothShading&&(B=y.vertexNormalsModelView[0],Aa.setRGB(B.x,B.y,B.z).multiplyScalar(0.5).addScalar(0.5),B=y.vertexNormalsModelView[1],ba.setRGB(B.x,B.y,B.z).multiplyScalar(0.5).addScalar(0.5),B=y.vertexNormalsModelView[2],W.setRGB(B.x,B.y,B.z).multiplyScalar(0.5).addScalar(0.5),Ka.addColors(ba,W).multiplyScalar(0.5),\nia=i(Aa,ba,W,Ka),h(va,Ea,za,Ha,Ta,Ja,0,0,1,0,0,1,ia)))}}V.union(pa)}}E.setTransform(1,0,0,1,0,0)}}};THREE.ShaderChunk={fog_pars_fragment:\"#ifdef USE_FOG\\nuniform vec3 fogColor;\\n#ifdef FOG_EXP2\\nuniform float fogDensity;\\n#else\\nuniform float fogNear;\\nuniform float fogFar;\\n#endif\\n#endif\",fog_fragment:\"#ifdef USE_FOG\\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n#ifdef FOG_EXP2\\nconst float LOG2 = 1.442695;\\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\\n#else\\nfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n#endif\\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n#endif\",\nenvmap_pars_fragment:\"#ifdef USE_ENVMAP\\nuniform float reflectivity;\\nuniform samplerCube envMap;\\nuniform float flipEnvMap;\\nuniform int combine;\\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\nuniform bool useRefract;\\nuniform float refractionRatio;\\n#else\\nvarying vec3 vReflect;\\n#endif\\n#endif\",envmap_fragment:\"#ifdef USE_ENVMAP\\nvec3 reflectVec;\\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\nif ( useRefract ) {\\nreflectVec = refract( cameraToVertex, normal, refractionRatio );\\n} else { \\nreflectVec = reflect( cameraToVertex, normal );\\n}\\n#else\\nreflectVec = vReflect;\\n#endif\\n#ifdef DOUBLE_SIDED\\nfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\nvec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n#else\\nvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n#endif\\n#ifdef GAMMA_INPUT\\ncubeColor.xyz *= cubeColor.xyz;\\n#endif\\nif ( combine == 1 ) {\\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\\n} else if ( combine == 2 ) {\\ngl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\\n} else {\\ngl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\\n}\\n#endif\",\nenvmap_pars_vertex:\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\\nvarying vec3 vReflect;\\nuniform float refractionRatio;\\nuniform bool useRefract;\\n#endif\",worldpos_vertex:\"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n#ifdef USE_SKINNING\\nvec4 worldPosition = modelMatrix * skinned;\\n#endif\\n#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\\nvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\\n#endif\\n#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n#endif\\n#endif\",\nenvmap_vertex:\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\\nvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\\nworldNormal = normalize( worldNormal );\\nvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\nif ( useRefract ) {\\nvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n} else {\\nvReflect = reflect( cameraToVertex, worldNormal );\\n}\\n#endif\",map_particle_pars_fragment:\"#ifdef USE_MAP\\nuniform sampler2D map;\\n#endif\",\nmap_particle_fragment:\"#ifdef USE_MAP\\ngl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\\n#endif\",map_pars_vertex:\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\\nvarying vec2 vUv;\\nuniform vec4 offsetRepeat;\\n#endif\",map_pars_fragment:\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\\nvarying vec2 vUv;\\n#endif\\n#ifdef USE_MAP\\nuniform sampler2D map;\\n#endif\",\nmap_vertex:\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\\nvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\",map_fragment:\"#ifdef USE_MAP\\nvec4 texelColor = texture2D( map, vUv );\\n#ifdef GAMMA_INPUT\\ntexelColor.xyz *= texelColor.xyz;\\n#endif\\ngl_FragColor = gl_FragColor * texelColor;\\n#endif\",lightmap_pars_fragment:\"#ifdef USE_LIGHTMAP\\nvarying vec2 vUv2;\\nuniform sampler2D lightMap;\\n#endif\",lightmap_pars_vertex:\"#ifdef USE_LIGHTMAP\\nvarying vec2 vUv2;\\n#endif\",\nlightmap_fragment:\"#ifdef USE_LIGHTMAP\\ngl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\\n#endif\",lightmap_vertex:\"#ifdef USE_LIGHTMAP\\nvUv2 = uv2;\\n#endif\",bumpmap_pars_fragment:\"#ifdef USE_BUMPMAP\\nuniform sampler2D bumpMap;\\nuniform float bumpScale;\\nvec2 dHdxy_fwd() {\\nvec2 dSTdx = dFdx( vUv );\\nvec2 dSTdy = dFdy( vUv );\\nfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\nfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\nfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\nreturn vec2( dBx, dBy );\\n}\\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\nvec3 vSigmaX = dFdx( surf_pos );\\nvec3 vSigmaY = dFdy( surf_pos );\\nvec3 vN = surf_norm;\\nvec3 R1 = cross( vSigmaY, vN );\\nvec3 R2 = cross( vN, vSigmaX );\\nfloat fDet = dot( vSigmaX, R1 );\\nvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\nreturn normalize( abs( fDet ) * surf_norm - vGrad );\\n}\\n#endif\",\nnormalmap_pars_fragment:\"#ifdef USE_NORMALMAP\\nuniform sampler2D normalMap;\\nuniform vec2 normalScale;\\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\nvec3 q0 = dFdx( eye_pos.xyz );\\nvec3 q1 = dFdy( eye_pos.xyz );\\nvec2 st0 = dFdx( vUv.st );\\nvec2 st1 = dFdy( vUv.st );\\nvec3 S = normalize(  q0 * st1.t - q1 * st0.t );\\nvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\nvec3 N = normalize( surf_norm );\\nvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\nmapN.xy = normalScale * mapN.xy;\\nmat3 tsn = mat3( S, T, N );\\nreturn normalize( tsn * mapN );\\n}\\n#endif\",\nspecularmap_pars_fragment:\"#ifdef USE_SPECULARMAP\\nuniform sampler2D specularMap;\\n#endif\",specularmap_fragment:\"float specularStrength;\\n#ifdef USE_SPECULARMAP\\nvec4 texelSpecular = texture2D( specularMap, vUv );\\nspecularStrength = texelSpecular.r;\\n#else\\nspecularStrength = 1.0;\\n#endif\",lights_lambert_pars_vertex:\"uniform vec3 ambient;\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 ambientLightColor;\\n#if MAX_DIR_LIGHTS > 0\\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n#endif\\n#ifdef WRAP_AROUND\\nuniform vec3 wrapRGB;\\n#endif\",\nlights_lambert_vertex:\"vLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\nvLightBack = vec3( 0.0 );\\n#endif\\ntransformedNormal = normalize( transformedNormal );\\n#if MAX_DIR_LIGHTS > 0\\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\nvec3 dirVector = normalize( lDirection.xyz );\\nfloat dotProduct = dot( transformedNormal, dirVector );\\nvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n#ifdef DOUBLE_SIDED\\nvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n#ifdef WRAP_AROUND\\nvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n#endif\\n#endif\\n#ifdef WRAP_AROUND\\nvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\ndirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\\n#ifdef DOUBLE_SIDED\\ndirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\\n#endif\\n#endif\\nvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\\n#ifdef DOUBLE_SIDED\\nvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\\n#endif\\n}\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\\nfloat lDistance = 1.0;\\nif ( pointLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\nlVector = normalize( lVector );\\nfloat dotProduct = dot( transformedNormal, lVector );\\nvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n#ifdef DOUBLE_SIDED\\nvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n#ifdef WRAP_AROUND\\nvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n#endif\\n#endif\\n#ifdef WRAP_AROUND\\nvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\npointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\\n#ifdef DOUBLE_SIDED\\npointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\\n#endif\\n#endif\\nvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\\n#ifdef DOUBLE_SIDED\\nvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\\n#endif\\n}\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\\nif ( spotEffect > spotLightAngleCos[ i ] ) {\\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\\nfloat lDistance = 1.0;\\nif ( spotLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\\nlVector = normalize( lVector );\\nfloat dotProduct = dot( transformedNormal, lVector );\\nvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n#ifdef DOUBLE_SIDED\\nvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n#ifdef WRAP_AROUND\\nvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n#endif\\n#endif\\n#ifdef WRAP_AROUND\\nvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\nspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\\n#ifdef DOUBLE_SIDED\\nspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\\n#endif\\n#endif\\nvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\\n#ifdef DOUBLE_SIDED\\nvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\\n#endif\\n}\\n}\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\\nvec3 lVector = normalize( lDirection.xyz );\\nfloat dotProduct = dot( transformedNormal, lVector );\\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\nfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\\nvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n#ifdef DOUBLE_SIDED\\nvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\\n#endif\\n}\\n#endif\\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\\n#ifdef DOUBLE_SIDED\\nvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\\n#endif\",\nlights_phong_pars_vertex:\"#ifndef PHONG_PER_PIXEL\\n#if MAX_POINT_LIGHTS > 0\\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\nvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\nvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\\n#endif\\n#endif\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\\nvarying vec3 vWorldPosition;\\n#endif\",\nlights_phong_vertex:\"#ifndef PHONG_PER_PIXEL\\n#if MAX_POINT_LIGHTS > 0\\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\\nfloat lDistance = 1.0;\\nif ( pointLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\nvPointLight[ i ] = vec4( lVector, lDistance );\\n}\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\\nfloat lDistance = 1.0;\\nif ( spotLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\\nvSpotLight[ i ] = vec4( lVector, lDistance );\\n}\\n#endif\\n#endif\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\\nvWorldPosition = worldPosition.xyz;\\n#endif\",\nlights_phong_pars_fragment:\"uniform vec3 ambientLightColor;\\n#if MAX_DIR_LIGHTS > 0\\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n#ifdef PHONG_PER_PIXEL\\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n#else\\nvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\\n#endif\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n#ifdef PHONG_PER_PIXEL\\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n#else\\nvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\\n#endif\\n#endif\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\\nvarying vec3 vWorldPosition;\\n#endif\\n#ifdef WRAP_AROUND\\nuniform vec3 wrapRGB;\\n#endif\\nvarying vec3 vViewPosition;\\nvarying vec3 vNormal;\",\nlights_phong_fragment:\"vec3 normal = normalize( vNormal );\\nvec3 viewPosition = normalize( vViewPosition );\\n#ifdef DOUBLE_SIDED\\nnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n#endif\\n#ifdef USE_NORMALMAP\\nnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\nnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\nvec3 pointDiffuse  = vec3( 0.0 );\\nvec3 pointSpecular = vec3( 0.0 );\\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n#ifdef PHONG_PER_PIXEL\\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\nfloat lDistance = 1.0;\\nif ( pointLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\nlVector = normalize( lVector );\\n#else\\nvec3 lVector = normalize( vPointLight[ i ].xyz );\\nfloat lDistance = vPointLight[ i ].w;\\n#endif\\nfloat dotProduct = dot( normal, lVector );\\n#ifdef WRAP_AROUND\\nfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\\nfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n#else\\nfloat pointDiffuseWeight = max( dotProduct, 0.0 );\\n#endif\\npointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\\nvec3 pointHalfVector = normalize( lVector + viewPosition );\\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\nfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\\n}\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nvec3 spotDiffuse  = vec3( 0.0 );\\nvec3 spotSpecular = vec3( 0.0 );\\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n#ifdef PHONG_PER_PIXEL\\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\nfloat lDistance = 1.0;\\nif ( spotLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\\nlVector = normalize( lVector );\\n#else\\nvec3 lVector = normalize( vSpotLight[ i ].xyz );\\nfloat lDistance = vSpotLight[ i ].w;\\n#endif\\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\\nif ( spotEffect > spotLightAngleCos[ i ] ) {\\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\\nfloat dotProduct = dot( normal, lVector );\\n#ifdef WRAP_AROUND\\nfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\\nfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\\n#else\\nfloat spotDiffuseWeight = max( dotProduct, 0.0 );\\n#endif\\nspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\\nvec3 spotHalfVector = normalize( lVector + viewPosition );\\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\\nfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\\n}\\n}\\n#endif\\n#if MAX_DIR_LIGHTS > 0\\nvec3 dirDiffuse  = vec3( 0.0 );\\nvec3 dirSpecular = vec3( 0.0 );\\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\nvec3 dirVector = normalize( lDirection.xyz );\\nfloat dotProduct = dot( normal, dirVector );\\n#ifdef WRAP_AROUND\\nfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\\nfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\nvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\\n#else\\nfloat dirDiffuseWeight = max( dotProduct, 0.0 );\\n#endif\\ndirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\nfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n}\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nvec3 hemiDiffuse  = vec3( 0.0 );\\nvec3 hemiSpecular = vec3( 0.0 );\\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\\nvec3 lVector = normalize( lDirection.xyz );\\nfloat dotProduct = dot( normal, lVector );\\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\nhemiDiffuse += diffuse * hemiColor;\\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\\nfloat hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\\nvec3 lVectorGround = -lVector;\\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\\nfloat hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\\nfloat dotProductGround = dot( normal, lVectorGround );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\\n}\\n#endif\\nvec3 totalDiffuse = vec3( 0.0 );\\nvec3 totalSpecular = vec3( 0.0 );\\n#if MAX_DIR_LIGHTS > 0\\ntotalDiffuse += dirDiffuse;\\ntotalSpecular += dirSpecular;\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\ntotalDiffuse += hemiDiffuse;\\ntotalSpecular += hemiSpecular;\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\ntotalDiffuse += pointDiffuse;\\ntotalSpecular += pointSpecular;\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\ntotalDiffuse += spotDiffuse;\\ntotalSpecular += spotSpecular;\\n#endif\\n#ifdef METAL\\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\\n#else\\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\\n#endif\",\ncolor_pars_fragment:\"#ifdef USE_COLOR\\nvarying vec3 vColor;\\n#endif\",color_fragment:\"#ifdef USE_COLOR\\ngl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\\n#endif\",color_pars_vertex:\"#ifdef USE_COLOR\\nvarying vec3 vColor;\\n#endif\",color_vertex:\"#ifdef USE_COLOR\\n#ifdef GAMMA_INPUT\\nvColor = color * color;\\n#else\\nvColor = color;\\n#endif\\n#endif\",skinning_pars_vertex:\"#ifdef USE_SKINNING\\n#ifdef BONE_TEXTURE\\nuniform sampler2D boneTexture;\\nuniform int boneTextureWidth;\\nuniform int boneTextureHeight;\\nmat4 getBoneMatrix( const in float i ) {\\nfloat j = i * 4.0;\\nfloat x = mod( j, float( boneTextureWidth ) );\\nfloat y = floor( j / float( boneTextureWidth ) );\\nfloat dx = 1.0 / float( boneTextureWidth );\\nfloat dy = 1.0 / float( boneTextureHeight );\\ny = dy * ( y + 0.5 );\\nvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\nvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\nvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\nvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\nmat4 bone = mat4( v1, v2, v3, v4 );\\nreturn bone;\\n}\\n#else\\nuniform mat4 boneGlobalMatrices[ MAX_BONES ];\\nmat4 getBoneMatrix( const in float i ) {\\nmat4 bone = boneGlobalMatrices[ int(i) ];\\nreturn bone;\\n}\\n#endif\\n#endif\",\nskinbase_vertex:\"#ifdef USE_SKINNING\\nmat4 boneMatX = getBoneMatrix( skinIndex.x );\\nmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n#endif\",skinning_vertex:\"#ifdef USE_SKINNING\\n#ifdef USE_MORPHTARGETS\\nvec4 skinVertex = vec4( morphed, 1.0 );\\n#else\\nvec4 skinVertex = vec4( position, 1.0 );\\n#endif\\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\\nskinned \\t  += boneMatY * skinVertex * skinWeight.y;\\n#endif\",morphtarget_pars_vertex:\"#ifdef USE_MORPHTARGETS\\n#ifndef USE_MORPHNORMALS\\nuniform float morphTargetInfluences[ 8 ];\\n#else\\nuniform float morphTargetInfluences[ 4 ];\\n#endif\\n#endif\",\nmorphtarget_vertex:\"#ifdef USE_MORPHTARGETS\\nvec3 morphed = vec3( 0.0 );\\nmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\nmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\nmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\nmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n#ifndef USE_MORPHNORMALS\\nmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\nmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\nmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\nmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n#endif\\nmorphed += position;\\n#endif\",\ndefault_vertex:\"vec4 mvPosition;\\n#ifdef USE_SKINNING\\nmvPosition = modelViewMatrix * skinned;\\n#endif\\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\\nmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\\n#endif\\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\\nmvPosition = modelViewMatrix * vec4( position, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\",morphnormal_vertex:\"#ifdef USE_MORPHNORMALS\\nvec3 morphedNormal = vec3( 0.0 );\\nmorphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\nmorphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\nmorphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\nmorphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\nmorphedNormal += normal;\\n#endif\",\nskinnormal_vertex:\"#ifdef USE_SKINNING\\nmat4 skinMatrix = skinWeight.x * boneMatX;\\nskinMatrix \\t+= skinWeight.y * boneMatY;\\n#ifdef USE_MORPHNORMALS\\nvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\\n#else\\nvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\\n#endif\\n#endif\",defaultnormal_vertex:\"vec3 objectNormal;\\n#ifdef USE_SKINNING\\nobjectNormal = skinnedNormal.xyz;\\n#endif\\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\\nobjectNormal = morphedNormal;\\n#endif\\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\\nobjectNormal = normal;\\n#endif\\n#ifdef FLIP_SIDED\\nobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\",\nshadowmap_pars_fragment:\"#ifdef USE_SHADOWMAP\\nuniform sampler2D shadowMap[ MAX_SHADOWS ];\\nuniform vec2 shadowMapSize[ MAX_SHADOWS ];\\nuniform float shadowDarkness[ MAX_SHADOWS ];\\nuniform float shadowBias[ MAX_SHADOWS ];\\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\nfloat unpackDepth( const in vec4 rgba_depth ) {\\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\nfloat depth = dot( rgba_depth, bit_shift );\\nreturn depth;\\n}\\n#endif\",shadowmap_fragment:\"#ifdef USE_SHADOWMAP\\n#ifdef SHADOWMAP_DEBUG\\nvec3 frustumColors[3];\\nfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\\nfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\\nfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\\n#endif\\n#ifdef SHADOWMAP_CASCADE\\nint inFrustumCount = 0;\\n#endif\\nfloat fDepth;\\nvec3 shadowColor = vec3( 1.0 );\\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\nvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\\nbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\nbool inFrustum = all( inFrustumVec );\\n#ifdef SHADOWMAP_CASCADE\\ninFrustumCount += int( inFrustum );\\nbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\\n#else\\nbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n#endif\\nbool frustumTest = all( frustumTestVec );\\nif ( frustumTest ) {\\nshadowCoord.z += shadowBias[ i ];\\n#if defined( SHADOWMAP_TYPE_PCF )\\nfloat shadow = 0.0;\\nconst float shadowDelta = 1.0 / 9.0;\\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\nfloat dx0 = -1.25 * xPixelOffset;\\nfloat dy0 = -1.25 * yPixelOffset;\\nfloat dx1 = 1.25 * xPixelOffset;\\nfloat dy1 = 1.25 * yPixelOffset;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\nfloat shadow = 0.0;\\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\nfloat dx0 = -1.0 * xPixelOffset;\\nfloat dy0 = -1.0 * yPixelOffset;\\nfloat dx1 = 1.0 * xPixelOffset;\\nfloat dy1 = 1.0 * yPixelOffset;\\nmat3 shadowKernel;\\nmat3 depthKernel;\\ndepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\ndepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\ndepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\ndepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\ndepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\ndepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\ndepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\ndepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\ndepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\nvec3 shadowZ = vec3( shadowCoord.z );\\nshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\\nshadowKernel[0] *= vec3(0.25);\\nshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\\nshadowKernel[1] *= vec3(0.25);\\nshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\\nshadowKernel[2] *= vec3(0.25);\\nvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\\nshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\\nshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\\nvec4 shadowValues;\\nshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\\nshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\\nshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\\nshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\\nshadow = dot( shadowValues, vec4( 1.0 ) );\\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n#else\\nvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\\nfloat fDepth = unpackDepth( rgbaDepth );\\nif ( fDepth < shadowCoord.z )\\nshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\\n#endif\\n}\\n#ifdef SHADOWMAP_DEBUG\\n#ifdef SHADOWMAP_CASCADE\\nif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\\n#else\\nif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\\n#endif\\n#endif\\n}\\n#ifdef GAMMA_OUTPUT\\nshadowColor *= shadowColor;\\n#endif\\ngl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\\n#endif\",\nshadowmap_pars_vertex:\"#ifdef USE_SHADOWMAP\\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\nuniform mat4 shadowMatrix[ MAX_SHADOWS ];\\n#endif\",shadowmap_vertex:\"#ifdef USE_SHADOWMAP\\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\\n}\\n#endif\",alphatest_fragment:\"#ifdef ALPHATEST\\nif ( gl_FragColor.a < ALPHATEST ) discard;\\n#endif\",linear_to_gamma_fragment:\"#ifdef GAMMA_OUTPUT\\ngl_FragColor.xyz = sqrt( gl_FragColor.xyz );\\n#endif\"};THREE.UniformsUtils={merge:function(a){var b,c,d,e={};for(b=0;b<a.length;b++)for(c in d=this.clone(a[b]),d)e[c]=d[c];return e},clone:function(a){var b,c,d,e={};for(b in a)for(c in e[b]={},a[b])d=a[b][c],e[b][c]=d instanceof THREE.Color||d instanceof THREE.Vector2||d instanceof THREE.Vector3||d instanceof THREE.Vector4||d instanceof THREE.Matrix4||d instanceof THREE.Texture?d.clone():d instanceof Array?d.slice():d;return e}};THREE.UniformsLib={common:{diffuse:{type:\"c\",value:new THREE.Color(15658734)},opacity:{type:\"f\",value:1},map:{type:\"t\",value:null},offsetRepeat:{type:\"v4\",value:new THREE.Vector4(0,0,1,1)},lightMap:{type:\"t\",value:null},specularMap:{type:\"t\",value:null},envMap:{type:\"t\",value:null},flipEnvMap:{type:\"f\",value:-1},useRefract:{type:\"i\",value:0},reflectivity:{type:\"f\",value:1},refractionRatio:{type:\"f\",value:0.98},combine:{type:\"i\",value:0},morphTargetInfluences:{type:\"f\",value:0}},bump:{bumpMap:{type:\"t\",\nvalue:null},bumpScale:{type:\"f\",value:1}},normalmap:{normalMap:{type:\"t\",value:null},normalScale:{type:\"v2\",value:new THREE.Vector2(1,1)}},fog:{fogDensity:{type:\"f\",value:2.5E-4},fogNear:{type:\"f\",value:1},fogFar:{type:\"f\",value:2E3},fogColor:{type:\"c\",value:new THREE.Color(16777215)}},lights:{ambientLightColor:{type:\"fv\",value:[]},directionalLightDirection:{type:\"fv\",value:[]},directionalLightColor:{type:\"fv\",value:[]},hemisphereLightDirection:{type:\"fv\",value:[]},hemisphereLightSkyColor:{type:\"fv\",\nvalue:[]},hemisphereLightGroundColor:{type:\"fv\",value:[]},pointLightColor:{type:\"fv\",value:[]},pointLightPosition:{type:\"fv\",value:[]},pointLightDistance:{type:\"fv1\",value:[]},spotLightColor:{type:\"fv\",value:[]},spotLightPosition:{type:\"fv\",value:[]},spotLightDirection:{type:\"fv\",value:[]},spotLightDistance:{type:\"fv1\",value:[]},spotLightAngleCos:{type:\"fv1\",value:[]},spotLightExponent:{type:\"fv1\",value:[]}},particle:{psColor:{type:\"c\",value:new THREE.Color(15658734)},opacity:{type:\"f\",value:1},size:{type:\"f\",\nvalue:1},scale:{type:\"f\",value:1},map:{type:\"t\",value:null},fogDensity:{type:\"f\",value:2.5E-4},fogNear:{type:\"f\",value:1},fogFar:{type:\"f\",value:2E3},fogColor:{type:\"c\",value:new THREE.Color(16777215)}},shadowmap:{shadowMap:{type:\"tv\",value:[]},shadowMapSize:{type:\"v2v\",value:[]},shadowBias:{type:\"fv1\",value:[]},shadowDarkness:{type:\"fv1\",value:[]},shadowMatrix:{type:\"m4v\",value:[]}}};THREE.ShaderLib={basic:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,THREE.UniformsLib.shadowmap]),vertexShader:[THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,\"void main() {\",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,\nTHREE.ShaderChunk.skinbase_vertex,\"#ifdef USE_ENVMAP\",THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,\"#endif\",THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.shadowmap_vertex,\"}\"].join(\"\\n\"),fragmentShader:[\"uniform vec3 diffuse;\\nuniform float opacity;\",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,\nTHREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,\"void main() {\\ngl_FragColor = vec4( diffuse, opacity );\",THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,THREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,\nTHREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,\"}\"].join(\"\\n\")},lambert:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{ambient:{type:\"c\",value:new THREE.Color(16777215)},emissive:{type:\"c\",value:new THREE.Color(0)},wrapRGB:{type:\"v3\",value:new THREE.Vector3(1,1,1)}}]),vertexShader:[\"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\nvarying vec3 vLightBack;\\n#endif\",\nTHREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.lights_lambert_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,\"void main() {\",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,\nTHREE.ShaderChunk.defaultnormal_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.lights_lambert_vertex,THREE.ShaderChunk.shadowmap_vertex,\"}\"].join(\"\\n\"),fragmentShader:[\"uniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\nvarying vec3 vLightBack;\\n#endif\",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,\nTHREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,\"void main() {\\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,\"#ifdef DOUBLE_SIDED\\nif ( gl_FrontFacing )\\ngl_FragColor.xyz *= vLightFront;\\nelse\\ngl_FragColor.xyz *= vLightBack;\\n#else\\ngl_FragColor.xyz *= vLightFront;\\n#endif\",THREE.ShaderChunk.lightmap_fragment,\nTHREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,\"}\"].join(\"\\n\")},phong:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.bump,THREE.UniformsLib.normalmap,THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{ambient:{type:\"c\",value:new THREE.Color(16777215)},emissive:{type:\"c\",value:new THREE.Color(0)},specular:{type:\"c\",\nvalue:new THREE.Color(1118481)},shininess:{type:\"f\",value:30},wrapRGB:{type:\"v3\",value:new THREE.Vector3(1,1,1)}}]),vertexShader:[\"#define PHONG\\nvarying vec3 vViewPosition;\\nvarying vec3 vNormal;\",THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.lights_phong_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,\n\"void main() {\",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,\"vNormal = normalize( transformedNormal );\",THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,\"vViewPosition = -mvPosition.xyz;\",THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,\nTHREE.ShaderChunk.lights_phong_vertex,THREE.ShaderChunk.shadowmap_vertex,\"}\"].join(\"\\n\"),fragmentShader:[\"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform vec3 ambient;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.lights_phong_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,\nTHREE.ShaderChunk.bumpmap_pars_fragment,THREE.ShaderChunk.normalmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,\"void main() {\\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,THREE.ShaderChunk.lights_phong_fragment,THREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,\nTHREE.ShaderChunk.fog_fragment,\"}\"].join(\"\\n\")},particle_basic:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.particle,THREE.UniformsLib.shadowmap]),vertexShader:[\"uniform float size;\\nuniform float scale;\",THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,\"void main() {\",THREE.ShaderChunk.color_vertex,\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n#ifdef USE_SIZEATTENUATION\\ngl_PointSize = size * ( scale / length( mvPosition.xyz ) );\\n#else\\ngl_PointSize = size;\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\",\nTHREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.shadowmap_vertex,\"}\"].join(\"\\n\"),fragmentShader:[\"uniform vec3 psColor;\\nuniform float opacity;\",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_particle_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,\"void main() {\\ngl_FragColor = vec4( psColor, opacity );\",THREE.ShaderChunk.map_particle_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.shadowmap_fragment,\nTHREE.ShaderChunk.fog_fragment,\"}\"].join(\"\\n\")},dashed:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,{scale:{type:\"f\",value:1},dashSize:{type:\"f\",value:1},totalSize:{type:\"f\",value:2}}]),vertexShader:[\"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\",THREE.ShaderChunk.color_pars_vertex,\"void main() {\",THREE.ShaderChunk.color_vertex,\"vLineDistance = scale * lineDistance;\\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\\n}\"].join(\"\\n\"),\nfragmentShader:[\"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,\"void main() {\\nif ( mod( vLineDistance, totalSize ) > dashSize ) {\\ndiscard;\\n}\\ngl_FragColor = vec4( diffuse, opacity );\",THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.fog_fragment,\"}\"].join(\"\\n\")},depth:{uniforms:{mNear:{type:\"f\",value:1},mFar:{type:\"f\",value:2E3},opacity:{type:\"f\",\nvalue:1}},vertexShader:\"void main() {\\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"uniform float mNear;\\nuniform float mFar;\\nuniform float opacity;\\nvoid main() {\\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\nfloat color = 1.0 - smoothstep( mNear, mFar, depth );\\ngl_FragColor = vec4( vec3( color ), opacity );\\n}\"},normal:{uniforms:{opacity:{type:\"f\",value:1}},vertexShader:[\"varying vec3 vNormal;\",THREE.ShaderChunk.morphtarget_pars_vertex,\"void main() {\\nvNormal = normalize( normalMatrix * normal );\",\nTHREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.default_vertex,\"}\"].join(\"\\n\"),fragmentShader:\"uniform float opacity;\\nvarying vec3 vNormal;\\nvoid main() {\\ngl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\\n}\"},normalmap:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{enableAO:{type:\"i\",value:0},enableDiffuse:{type:\"i\",value:0},enableSpecular:{type:\"i\",value:0},enableReflection:{type:\"i\",value:0},enableDisplacement:{type:\"i\",\nvalue:0},tDisplacement:{type:\"t\",value:null},tDiffuse:{type:\"t\",value:null},tCube:{type:\"t\",value:null},tNormal:{type:\"t\",value:null},tSpecular:{type:\"t\",value:null},tAO:{type:\"t\",value:null},uNormalScale:{type:\"v2\",value:new THREE.Vector2(1,1)},uDisplacementBias:{type:\"f\",value:0},uDisplacementScale:{type:\"f\",value:1},diffuse:{type:\"c\",value:new THREE.Color(16777215)},specular:{type:\"c\",value:new THREE.Color(1118481)},ambient:{type:\"c\",value:new THREE.Color(16777215)},shininess:{type:\"f\",value:30},\nopacity:{type:\"f\",value:1},useRefract:{type:\"i\",value:0},refractionRatio:{type:\"f\",value:0.98},reflectivity:{type:\"f\",value:0.5},uOffset:{type:\"v2\",value:new THREE.Vector2(0,0)},uRepeat:{type:\"v2\",value:new THREE.Vector2(1,1)},wrapRGB:{type:\"v3\",value:new THREE.Vector3(1,1,1)}}]),fragmentShader:[\"uniform vec3 ambient;\\nuniform vec3 diffuse;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\nuniform bool enableDiffuse;\\nuniform bool enableSpecular;\\nuniform bool enableAO;\\nuniform bool enableReflection;\\nuniform sampler2D tDiffuse;\\nuniform sampler2D tNormal;\\nuniform sampler2D tSpecular;\\nuniform sampler2D tAO;\\nuniform samplerCube tCube;\\nuniform vec2 uNormalScale;\\nuniform bool useRefract;\\nuniform float refractionRatio;\\nuniform float reflectivity;\\nvarying vec3 vTangent;\\nvarying vec3 vBinormal;\\nvarying vec3 vNormal;\\nvarying vec2 vUv;\\nuniform vec3 ambientLightColor;\\n#if MAX_DIR_LIGHTS > 0\\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n#endif\\n#ifdef WRAP_AROUND\\nuniform vec3 wrapRGB;\\n#endif\\nvarying vec3 vWorldPosition;\\nvarying vec3 vViewPosition;\",\nTHREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,\"void main() {\\ngl_FragColor = vec4( vec3( 1.0 ), opacity );\\nvec3 specularTex = vec3( 1.0 );\\nvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\\nnormalTex.xy *= uNormalScale;\\nnormalTex = normalize( normalTex );\\nif( enableDiffuse ) {\\n#ifdef GAMMA_INPUT\\nvec4 texelColor = texture2D( tDiffuse, vUv );\\ntexelColor.xyz *= texelColor.xyz;\\ngl_FragColor = gl_FragColor * texelColor;\\n#else\\ngl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\\n#endif\\n}\\nif( enableAO ) {\\n#ifdef GAMMA_INPUT\\nvec4 aoColor = texture2D( tAO, vUv );\\naoColor.xyz *= aoColor.xyz;\\ngl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\\n#else\\ngl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\\n#endif\\n}\\nif( enableSpecular )\\nspecularTex = texture2D( tSpecular, vUv ).xyz;\\nmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\\nvec3 finalNormal = tsb * normalTex;\\n#ifdef FLIP_SIDED\\nfinalNormal = -finalNormal;\\n#endif\\nvec3 normal = normalize( finalNormal );\\nvec3 viewPosition = normalize( vViewPosition );\\n#if MAX_POINT_LIGHTS > 0\\nvec3 pointDiffuse = vec3( 0.0 );\\nvec3 pointSpecular = vec3( 0.0 );\\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\nvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\\nfloat pointDistance = 1.0;\\nif ( pointLightDistance[ i ] > 0.0 )\\npointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\\npointVector = normalize( pointVector );\\n#ifdef WRAP_AROUND\\nfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\\nfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n#else\\nfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\\n#endif\\npointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\\nvec3 pointHalfVector = normalize( pointVector + viewPosition );\\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\nfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\\n}\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nvec3 spotDiffuse = vec3( 0.0 );\\nvec3 spotSpecular = vec3( 0.0 );\\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\nvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\\nfloat spotDistance = 1.0;\\nif ( spotLightDistance[ i ] > 0.0 )\\nspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\\nspotVector = normalize( spotVector );\\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\\nif ( spotEffect > spotLightAngleCos[ i ] ) {\\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\\n#ifdef WRAP_AROUND\\nfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\\nfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\\n#else\\nfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\\n#endif\\nspotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\\nvec3 spotHalfVector = normalize( spotVector + viewPosition );\\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\\nfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\\n}\\n}\\n#endif\\n#if MAX_DIR_LIGHTS > 0\\nvec3 dirDiffuse = vec3( 0.0 );\\nvec3 dirSpecular = vec3( 0.0 );\\nfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\nvec3 dirVector = normalize( lDirection.xyz );\\n#ifdef WRAP_AROUND\\nfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\\nfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\\nvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\\n#else\\nfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\\n#endif\\ndirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\nfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n}\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nvec3 hemiDiffuse  = vec3( 0.0 );\\nvec3 hemiSpecular = vec3( 0.0 );\\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\\nvec3 lVector = normalize( lDirection.xyz );\\nfloat dotProduct = dot( normal, lVector );\\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\nhemiDiffuse += diffuse * hemiColor;\\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\\nfloat hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\\nvec3 lVectorGround = -lVector;\\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\\nfloat hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\\nfloat dotProductGround = dot( normal, lVectorGround );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\\n}\\n#endif\\nvec3 totalDiffuse = vec3( 0.0 );\\nvec3 totalSpecular = vec3( 0.0 );\\n#if MAX_DIR_LIGHTS > 0\\ntotalDiffuse += dirDiffuse;\\ntotalSpecular += dirSpecular;\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\ntotalDiffuse += hemiDiffuse;\\ntotalSpecular += hemiSpecular;\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\ntotalDiffuse += pointDiffuse;\\ntotalSpecular += pointSpecular;\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\ntotalDiffuse += spotDiffuse;\\ntotalSpecular += spotSpecular;\\n#endif\\n#ifdef METAL\\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\\n#else\\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\\n#endif\\nif ( enableReflection ) {\\nvec3 vReflect;\\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\nif ( useRefract ) {\\nvReflect = refract( cameraToVertex, normal, refractionRatio );\\n} else {\\nvReflect = reflect( cameraToVertex, normal );\\n}\\nvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\\n#ifdef GAMMA_INPUT\\ncubeColor.xyz *= cubeColor.xyz;\\n#endif\\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\\n}\",\nTHREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,\"}\"].join(\"\\n\"),vertexShader:[\"attribute vec4 tangent;\\nuniform vec2 uOffset;\\nuniform vec2 uRepeat;\\nuniform bool enableDisplacement;\\n#ifdef VERTEX_TEXTURES\\nuniform sampler2D tDisplacement;\\nuniform float uDisplacementScale;\\nuniform float uDisplacementBias;\\n#endif\\nvarying vec3 vTangent;\\nvarying vec3 vBinormal;\\nvarying vec3 vNormal;\\nvarying vec2 vUv;\\nvarying vec3 vWorldPosition;\\nvarying vec3 vViewPosition;\",\nTHREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,\"void main() {\",THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,\"#ifdef USE_SKINNING\\nvNormal = normalize( normalMatrix * skinnedNormal.xyz );\\nvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\\nvTangent = normalize( normalMatrix * skinnedTangent.xyz );\\n#else\\nvNormal = normalize( normalMatrix * normal );\\nvTangent = normalize( normalMatrix * tangent.xyz );\\n#endif\\nvBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\\nvUv = uv * uRepeat + uOffset;\\nvec3 displacedPosition;\\n#ifdef VERTEX_TEXTURES\\nif ( enableDisplacement ) {\\nvec3 dv = texture2D( tDisplacement, uv ).xyz;\\nfloat df = uDisplacementScale * dv.x + uDisplacementBias;\\ndisplacedPosition = position + normalize( normal ) * df;\\n} else {\\n#ifdef USE_SKINNING\\nvec4 skinVertex = vec4( position, 1.0 );\\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\\nskinned \\t  += boneMatY * skinVertex * skinWeight.y;\\ndisplacedPosition  = skinned.xyz;\\n#else\\ndisplacedPosition = position;\\n#endif\\n}\\n#else\\n#ifdef USE_SKINNING\\nvec4 skinVertex = vec4( position, 1.0 );\\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\\nskinned \\t  += boneMatY * skinVertex * skinWeight.y;\\ndisplacedPosition  = skinned.xyz;\\n#else\\ndisplacedPosition = position;\\n#endif\\n#endif\\nvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\\nvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\\nvWorldPosition = worldPosition.xyz;\\nvViewPosition = -mvPosition.xyz;\\n#ifdef USE_SHADOWMAP\\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\\n}\\n#endif\\n}\"].join(\"\\n\")},\ncube:{uniforms:{tCube:{type:\"t\",value:null},tFlip:{type:\"f\",value:-1}},vertexShader:\"varying vec3 vWorldPosition;\\nvoid main() {\\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\nvWorldPosition = worldPosition.xyz;\\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"uniform samplerCube tCube;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\nvoid main() {\\ngl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n}\"},\ndepthRGBA:{uniforms:{},vertexShader:[THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,\"void main() {\",THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,\"}\"].join(\"\\n\"),fragmentShader:\"vec4 pack_depth( const in float depth ) {\\nconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\\nconst vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\\nvec4 res = fract( depth * bit_shift );\\nres -= res.xxyz * bit_mask;\\nreturn res;\\n}\\nvoid main() {\\ngl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\\n}\"}};THREE.WebGLRenderer=function(a){function b(a,b){var c=a.vertices.length,d=b.material;if(d.attributes){void 0===a.__webglCustomAttributesList&&(a.__webglCustomAttributesList=[]);for(var e in d.attributes){var f=d.attributes[e];if(!f.__webglInitialized||f.createUniqueBuffers){f.__webglInitialized=!0;var g=1;\"v2\"===f.type?g=2:\"v3\"===f.type?g=3:\"v4\"===f.type?g=4:\"c\"===f.type&&(g=3);f.size=g;f.array=new Float32Array(c*g);f.buffer=j.createBuffer();f.buffer.belongsToAttribute=e;f.needsUpdate=!0}a.__webglCustomAttributesList.push(f)}}}\nfunction c(a,b){var c=b.geometry,g=a.faces3,h=3*g.length,i=1*g.length,k=3*g.length,g=d(b,a),l=f(g),m=e(g),n=g.vertexColors?g.vertexColors:!1;a.__vertexArray=new Float32Array(3*h);m&&(a.__normalArray=new Float32Array(3*h));c.hasTangents&&(a.__tangentArray=new Float32Array(4*h));n&&(a.__colorArray=new Float32Array(3*h));l&&(0<c.faceVertexUvs.length&&(a.__uvArray=new Float32Array(2*h)),1<c.faceVertexUvs.length&&(a.__uv2Array=new Float32Array(2*h)));b.geometry.skinWeights.length&&b.geometry.skinIndices.length&&\n(a.__skinIndexArray=new Float32Array(4*h),a.__skinWeightArray=new Float32Array(4*h));a.__faceArray=new Uint16Array(3*i);a.__lineArray=new Uint16Array(2*k);if(a.numMorphTargets){a.__morphTargetsArrays=[];c=0;for(l=a.numMorphTargets;c<l;c++)a.__morphTargetsArrays.push(new Float32Array(3*h))}if(a.numMorphNormals){a.__morphNormalsArrays=[];c=0;for(l=a.numMorphNormals;c<l;c++)a.__morphNormalsArrays.push(new Float32Array(3*h))}a.__webglFaceCount=3*i;a.__webglLineCount=2*k;if(g.attributes){void 0===a.__webglCustomAttributesList&&\n(a.__webglCustomAttributesList=[]);for(var p in g.attributes){var i=g.attributes[p],k={},q;for(q in i)k[q]=i[q];if(!k.__webglInitialized||k.createUniqueBuffers)k.__webglInitialized=!0,c=1,\"v2\"===k.type?c=2:\"v3\"===k.type?c=3:\"v4\"===k.type?c=4:\"c\"===k.type&&(c=3),k.size=c,k.array=new Float32Array(h*c),k.buffer=j.createBuffer(),k.buffer.belongsToAttribute=p,i.needsUpdate=!0,k.__original=i;a.__webglCustomAttributesList.push(k)}}a.__inittedArrays=!0}function d(a,b){return a.material instanceof THREE.MeshFaceMaterial?\na.material.materials[b.materialIndex]:a.material}function e(a){return a instanceof THREE.MeshBasicMaterial&&!a.envMap||a instanceof THREE.MeshDepthMaterial?!1:a&&void 0!==a.shading&&a.shading===THREE.SmoothShading?THREE.SmoothShading:THREE.FlatShading}function f(a){return a.map||a.lightMap||a.bumpMap||a.normalMap||a.specularMap||a instanceof THREE.ShaderMaterial?!0:!1}function g(a){Ma[a]||(j.enableVertexAttribArray(a),Ma[a]=!0)}function h(){for(var a in Ma)Ma[a]&&(j.disableVertexAttribArray(a),Ma[a]=\n!1)}function i(a,b){return a.z!==b.z?b.z-a.z:a.id-b.id}function k(a,b){return b[0]-a[0]}function l(a,b,c){if(a.length)for(var d=0,e=a.length;d<e;d++)Ha=oa=null,Ea=za=Aa=sa=wa=ca=ba=-1,Za=!0,a[d].render(b,c,Va,La),Ha=oa=null,Ea=za=Aa=sa=wa=ca=ba=-1,Za=!0}function n(a,b,c,d,e,f,g,h){var j,i,k,l;b?(i=a.length-1,l=b=-1):(i=0,b=a.length,l=1);for(var m=i;m!==b;m+=l)if(j=a[m],j.render){i=j.object;k=j.buffer;if(h)j=h;else{j=j[c];if(!j)continue;g&&I.setBlending(j.blending,j.blendEquation,j.blendSrc,j.blendDst);\nI.setDepthTest(j.depthTest);I.setDepthWrite(j.depthWrite);x(j.polygonOffset,j.polygonOffsetFactor,j.polygonOffsetUnits)}I.setMaterialFaces(j);k instanceof THREE.BufferGeometry?I.renderBufferDirect(d,e,f,j,k,i):I.renderBuffer(d,e,f,j,k,i)}}function p(a,b,c,d,e,f,g){for(var h,j,i=0,k=a.length;i<k;i++)if(h=a[i],j=h.object,j.visible){if(g)h=g;else{h=h[b];if(!h)continue;f&&I.setBlending(h.blending,h.blendEquation,h.blendSrc,h.blendDst);I.setDepthTest(h.depthTest);I.setDepthWrite(h.depthWrite);x(h.polygonOffset,\nh.polygonOffsetFactor,h.polygonOffsetUnits)}I.renderImmediateObject(c,d,e,h,j)}}function t(a,d){var e,f,g,h;if(void 0===a.__webglInit&&(a.__webglInit=!0,a._modelViewMatrix=new THREE.Matrix4,a._normalMatrix=new THREE.Matrix3,void 0!==a.geometry&&void 0===a.geometry.__webglInit&&(a.geometry.__webglInit=!0,a.geometry.addEventListener(\"dispose\",Lb)),f=a.geometry,void 0!==f))if(f instanceof THREE.BufferGeometry){var i,k;for(i in f.attributes)k=\"index\"===i?j.ELEMENT_ARRAY_BUFFER:j.ARRAY_BUFFER,h=f.attributes[i],\nvoid 0===h.numItems&&(h.numItems=h.array.length),h.buffer=j.createBuffer(),j.bindBuffer(k,h.buffer),j.bufferData(k,h.array,j.STATIC_DRAW)}else if(a instanceof THREE.Mesh){g=a.material;if(void 0===f.geometryGroups){i=f;var l,m,n;k={};var p=i.morphTargets.length,q=i.morphNormals.length,t=g instanceof THREE.MeshFaceMaterial;i.geometryGroups={};g=0;for(l=i.faces.length;g<l;g++)m=i.faces[g],m=t?m.materialIndex:0,void 0===k[m]&&(k[m]={hash:m,counter:0}),n=k[m].hash+\"_\"+k[m].counter,void 0===i.geometryGroups[n]&&\n(i.geometryGroups[n]={faces3:[],materialIndex:m,vertices:0,numMorphTargets:p,numMorphNormals:q}),65535<i.geometryGroups[n].vertices+3&&(k[m].counter+=1,n=k[m].hash+\"_\"+k[m].counter,void 0===i.geometryGroups[n]&&(i.geometryGroups[n]={faces3:[],materialIndex:m,vertices:0,numMorphTargets:p,numMorphNormals:q})),i.geometryGroups[n].faces3.push(g),i.geometryGroups[n].vertices+=3;i.geometryGroupsList=[];for(h in i.geometryGroups)i.geometryGroups[h].id=Ta++,i.geometryGroupsList.push(i.geometryGroups[h])}for(e in f.geometryGroups)if(h=\nf.geometryGroups[e],!h.__webglVertexBuffer){i=h;i.__webglVertexBuffer=j.createBuffer();i.__webglNormalBuffer=j.createBuffer();i.__webglTangentBuffer=j.createBuffer();i.__webglColorBuffer=j.createBuffer();i.__webglUVBuffer=j.createBuffer();i.__webglUV2Buffer=j.createBuffer();i.__webglSkinIndicesBuffer=j.createBuffer();i.__webglSkinWeightsBuffer=j.createBuffer();i.__webglFaceBuffer=j.createBuffer();i.__webglLineBuffer=j.createBuffer();p=k=void 0;if(i.numMorphTargets){i.__webglMorphTargetsBuffers=[];\nk=0;for(p=i.numMorphTargets;k<p;k++)i.__webglMorphTargetsBuffers.push(j.createBuffer())}if(i.numMorphNormals){i.__webglMorphNormalsBuffers=[];k=0;for(p=i.numMorphNormals;k<p;k++)i.__webglMorphNormalsBuffers.push(j.createBuffer())}I.info.memory.geometries++;c(h,a);f.verticesNeedUpdate=!0;f.morphTargetsNeedUpdate=!0;f.elementsNeedUpdate=!0;f.uvsNeedUpdate=!0;f.normalsNeedUpdate=!0;f.tangentsNeedUpdate=!0;f.colorsNeedUpdate=!0}}else a instanceof THREE.Line?f.__webglVertexBuffer||(h=f,h.__webglVertexBuffer=\nj.createBuffer(),h.__webglColorBuffer=j.createBuffer(),h.__webglLineDistanceBuffer=j.createBuffer(),I.info.memory.geometries++,h=f,i=h.vertices.length,h.__vertexArray=new Float32Array(3*i),h.__colorArray=new Float32Array(3*i),h.__lineDistanceArray=new Float32Array(1*i),h.__webglLineCount=i,b(h,a),f.verticesNeedUpdate=!0,f.colorsNeedUpdate=!0,f.lineDistancesNeedUpdate=!0):a instanceof THREE.ParticleSystem&&!f.__webglVertexBuffer&&(h=f,h.__webglVertexBuffer=j.createBuffer(),h.__webglColorBuffer=j.createBuffer(),\nI.info.memory.geometries++,h=f,i=h.vertices.length,h.__vertexArray=new Float32Array(3*i),h.__colorArray=new Float32Array(3*i),h.__sortArray=[],h.__webglParticleCount=i,b(h,a),f.verticesNeedUpdate=!0,f.colorsNeedUpdate=!0);if(void 0===a.__webglActive){if(a instanceof THREE.Mesh)if(f=a.geometry,f instanceof THREE.BufferGeometry)r(d.__webglObjects,f,a);else{if(f instanceof THREE.Geometry)for(e in f.geometryGroups)h=f.geometryGroups[e],r(d.__webglObjects,h,a)}else a instanceof THREE.Line||a instanceof\nTHREE.ParticleSystem?(f=a.geometry,r(d.__webglObjects,f,a)):a instanceof THREE.ImmediateRenderObject||a.immediateRenderCallback?d.__webglObjectsImmediate.push({id:null,object:a,opaque:null,transparent:null,z:0}):a instanceof THREE.Sprite?d.__webglSprites.push(a):a instanceof THREE.LensFlare&&d.__webglFlares.push(a);a.__webglActive=!0}}function r(a,b,c){a.push({id:null,buffer:b,object:c,opaque:null,transparent:null,z:0})}function m(a){for(var b in a.attributes)if(a.attributes[b].needsUpdate)return!0;\nreturn!1}function q(a){for(var b in a.attributes)a.attributes[b].needsUpdate=!1}function u(a,b){a instanceof THREE.Mesh||a instanceof THREE.ParticleSystem||a instanceof THREE.Line?s(b.__webglObjects,a):a instanceof THREE.Sprite?v(b.__webglSprites,a):a instanceof THREE.LensFlare?v(b.__webglFlares,a):(a instanceof THREE.ImmediateRenderObject||a.immediateRenderCallback)&&s(b.__webglObjectsImmediate,a);delete a.__webglActive}function s(a,b){for(var c=a.length-1;0<=c;c--)a[c].object===b&&a.splice(c,1)}\nfunction v(a,b){for(var c=a.length-1;0<=c;c--)a[c]===b&&a.splice(c,1)}function z(a,b,c,d,e){Ja=0;d.needsUpdate&&(d.program&&Eb(d),I.initMaterial(d,b,c,e),d.needsUpdate=!1);d.morphTargets&&!e.__webglMorphTargetInfluences&&(e.__webglMorphTargetInfluences=new Float32Array(I.maxMorphTargets));var f=!1,g=d.program,h=g.uniforms,i=d.uniforms;g!==oa&&(j.useProgram(g),oa=g,f=!0);d.id!==Ea&&(Ea=d.id,f=!0);if(f||a!==Ha)j.uniformMatrix4fv(h.projectionMatrix,!1,a.projectionMatrix.elements),a!==Ha&&(Ha=a);if(d.skinning)if(tb&&\ne.useVertexTexture){if(null!==h.boneTexture){var k=G();j.uniform1i(h.boneTexture,k);I.setTexture(e.boneTexture,k)}null!==h.boneTextureWidth&&j.uniform1i(h.boneTextureWidth,e.boneTextureWidth);null!==h.boneTextureHeight&&j.uniform1i(h.boneTextureHeight,e.boneTextureHeight)}else null!==h.boneGlobalMatrices&&j.uniformMatrix4fv(h.boneGlobalMatrices,!1,e.boneMatrices);if(f){c&&d.fog&&(i.fogColor.value=c.color,c instanceof THREE.Fog?(i.fogNear.value=c.near,i.fogFar.value=c.far):c instanceof THREE.FogExp2&&\n(i.fogDensity.value=c.density));if(d instanceof THREE.MeshPhongMaterial||d instanceof THREE.MeshLambertMaterial||d.lights){if(Za){for(var l,m=k=0,n=0,p,q,t,r=Na,s=r.directional.colors,u=r.directional.positions,v=r.point.colors,z=r.point.positions,y=r.point.distances,x=r.spot.colors,B=r.spot.positions,F=r.spot.distances,E=r.spot.directions,L=r.spot.anglesCos,A=r.spot.exponents,O=r.hemi.skyColors,Q=r.hemi.groundColors,K=r.hemi.positions,P=0,W=0,T=0,va=0,sa=0,Y=0,Z=0,X=0,U=l=0,c=t=U=0,f=b.length;c<f;c++)l=\nb[c],l.onlyShadow||(p=l.color,q=l.intensity,t=l.distance,l instanceof THREE.AmbientLight?l.visible&&(I.gammaInput?(k+=p.r*p.r,m+=p.g*p.g,n+=p.b*p.b):(k+=p.r,m+=p.g,n+=p.b)):l instanceof THREE.DirectionalLight?(sa+=1,l.visible&&(fa.setFromMatrixPosition(l.matrixWorld),ja.setFromMatrixPosition(l.target.matrixWorld),fa.sub(ja),fa.normalize(),0===fa.x&&0===fa.y&&0===fa.z||(l=3*P,u[l]=fa.x,u[l+1]=fa.y,u[l+2]=fa.z,I.gammaInput?N(s,l,p,q*q):C(s,l,p,q),P+=1))):l instanceof THREE.PointLight?(Y+=1,l.visible&&\n(U=3*W,I.gammaInput?N(v,U,p,q*q):C(v,U,p,q),ja.setFromMatrixPosition(l.matrixWorld),z[U]=ja.x,z[U+1]=ja.y,z[U+2]=ja.z,y[W]=t,W+=1)):l instanceof THREE.SpotLight?(Z+=1,l.visible&&(U=3*T,I.gammaInput?N(x,U,p,q*q):C(x,U,p,q),ja.setFromMatrixPosition(l.matrixWorld),B[U]=ja.x,B[U+1]=ja.y,B[U+2]=ja.z,F[T]=t,fa.copy(ja),ja.setFromMatrixPosition(l.target.matrixWorld),fa.sub(ja),fa.normalize(),E[U]=fa.x,E[U+1]=fa.y,E[U+2]=fa.z,L[T]=Math.cos(l.angle),A[T]=l.exponent,T+=1)):l instanceof THREE.HemisphereLight&&\n(X+=1,l.visible&&(fa.setFromMatrixPosition(l.matrixWorld),fa.normalize(),0===fa.x&&0===fa.y&&0===fa.z||(t=3*va,K[t]=fa.x,K[t+1]=fa.y,K[t+2]=fa.z,p=l.color,l=l.groundColor,I.gammaInput?(q*=q,N(O,t,p,q),N(Q,t,l,q)):(C(O,t,p,q),C(Q,t,l,q)),va+=1))));c=3*P;for(f=Math.max(s.length,3*sa);c<f;c++)s[c]=0;c=3*W;for(f=Math.max(v.length,3*Y);c<f;c++)v[c]=0;c=3*T;for(f=Math.max(x.length,3*Z);c<f;c++)x[c]=0;c=3*va;for(f=Math.max(O.length,3*X);c<f;c++)O[c]=0;c=3*va;for(f=Math.max(Q.length,3*X);c<f;c++)Q[c]=0;r.directional.length=\nP;r.point.length=W;r.spot.length=T;r.hemi.length=va;r.ambient[0]=k;r.ambient[1]=m;r.ambient[2]=n;Za=!1}c=Na;i.ambientLightColor.value=c.ambient;i.directionalLightColor.value=c.directional.colors;i.directionalLightDirection.value=c.directional.positions;i.pointLightColor.value=c.point.colors;i.pointLightPosition.value=c.point.positions;i.pointLightDistance.value=c.point.distances;i.spotLightColor.value=c.spot.colors;i.spotLightPosition.value=c.spot.positions;i.spotLightDistance.value=c.spot.distances;\ni.spotLightDirection.value=c.spot.directions;i.spotLightAngleCos.value=c.spot.anglesCos;i.spotLightExponent.value=c.spot.exponents;i.hemisphereLightSkyColor.value=c.hemi.skyColors;i.hemisphereLightGroundColor.value=c.hemi.groundColors;i.hemisphereLightDirection.value=c.hemi.positions}if(d instanceof THREE.MeshBasicMaterial||d instanceof THREE.MeshLambertMaterial||d instanceof THREE.MeshPhongMaterial){i.opacity.value=d.opacity;I.gammaInput?i.diffuse.value.copyGammaToLinear(d.color):i.diffuse.value=\nd.color;i.map.value=d.map;i.lightMap.value=d.lightMap;i.specularMap.value=d.specularMap;d.bumpMap&&(i.bumpMap.value=d.bumpMap,i.bumpScale.value=d.bumpScale);d.normalMap&&(i.normalMap.value=d.normalMap,i.normalScale.value.copy(d.normalScale));var V;d.map?V=d.map:d.specularMap?V=d.specularMap:d.normalMap?V=d.normalMap:d.bumpMap&&(V=d.bumpMap);void 0!==V&&(c=V.offset,V=V.repeat,i.offsetRepeat.value.set(c.x,c.y,V.x,V.y));i.envMap.value=d.envMap;i.flipEnvMap.value=d.envMap instanceof THREE.WebGLRenderTargetCube?\n1:-1;i.reflectivity.value=d.reflectivity;i.refractionRatio.value=d.refractionRatio;i.combine.value=d.combine;i.useRefract.value=d.envMap&&d.envMap.mapping instanceof THREE.CubeRefractionMapping}d instanceof THREE.LineBasicMaterial?(i.diffuse.value=d.color,i.opacity.value=d.opacity):d instanceof THREE.LineDashedMaterial?(i.diffuse.value=d.color,i.opacity.value=d.opacity,i.dashSize.value=d.dashSize,i.totalSize.value=d.dashSize+d.gapSize,i.scale.value=d.scale):d instanceof THREE.ParticleSystemMaterial?\n(i.psColor.value=d.color,i.opacity.value=d.opacity,i.size.value=d.size,i.scale.value=H.height/2,i.map.value=d.map):d instanceof THREE.MeshPhongMaterial?(i.shininess.value=d.shininess,I.gammaInput?(i.ambient.value.copyGammaToLinear(d.ambient),i.emissive.value.copyGammaToLinear(d.emissive),i.specular.value.copyGammaToLinear(d.specular)):(i.ambient.value=d.ambient,i.emissive.value=d.emissive,i.specular.value=d.specular),d.wrapAround&&i.wrapRGB.value.copy(d.wrapRGB)):d instanceof THREE.MeshLambertMaterial?\n(I.gammaInput?(i.ambient.value.copyGammaToLinear(d.ambient),i.emissive.value.copyGammaToLinear(d.emissive)):(i.ambient.value=d.ambient,i.emissive.value=d.emissive),d.wrapAround&&i.wrapRGB.value.copy(d.wrapRGB)):d instanceof THREE.MeshDepthMaterial?(i.mNear.value=a.near,i.mFar.value=a.far,i.opacity.value=d.opacity):d instanceof THREE.MeshNormalMaterial&&(i.opacity.value=d.opacity);if(e.receiveShadow&&!d._shadowPass&&i.shadowMatrix){c=V=0;for(f=b.length;c<f;c++)if(k=b[c],k.castShadow&&(k instanceof\nTHREE.SpotLight||k instanceof THREE.DirectionalLight&&!k.shadowCascade))i.shadowMap.value[V]=k.shadowMap,i.shadowMapSize.value[V]=k.shadowMapSize,i.shadowMatrix.value[V]=k.shadowMatrix,i.shadowDarkness.value[V]=k.shadowDarkness,i.shadowBias.value[V]=k.shadowBias,V++}b=d.uniformsList;i=0;for(V=b.length;i<V;i++)if(f=g.uniforms[b[i][1]])if(c=b[i][0],m=c.type,k=c.value,\"i\"===m)j.uniform1i(f,k);else if(\"f\"===m)j.uniform1f(f,k);else if(\"v2\"===m)j.uniform2f(f,k.x,k.y);else if(\"v3\"===m)j.uniform3f(f,k.x,\nk.y,k.z);else if(\"v4\"===m)j.uniform4f(f,k.x,k.y,k.z,k.w);else if(\"c\"===m)j.uniform3f(f,k.r,k.g,k.b);else if(\"iv1\"===m)j.uniform1iv(f,k);else if(\"iv\"===m)j.uniform3iv(f,k);else if(\"fv1\"===m)j.uniform1fv(f,k);else if(\"fv\"===m)j.uniform3fv(f,k);else if(\"v2v\"===m){void 0===c._array&&(c._array=new Float32Array(2*k.length));m=0;for(n=k.length;m<n;m++)r=2*m,c._array[r]=k[m].x,c._array[r+1]=k[m].y;j.uniform2fv(f,c._array)}else if(\"v3v\"===m){void 0===c._array&&(c._array=new Float32Array(3*k.length));m=0;for(n=\nk.length;m<n;m++)r=3*m,c._array[r]=k[m].x,c._array[r+1]=k[m].y,c._array[r+2]=k[m].z;j.uniform3fv(f,c._array)}else if(\"v4v\"===m){void 0===c._array&&(c._array=new Float32Array(4*k.length));m=0;for(n=k.length;m<n;m++)r=4*m,c._array[r]=k[m].x,c._array[r+1]=k[m].y,c._array[r+2]=k[m].z,c._array[r+3]=k[m].w;j.uniform4fv(f,c._array)}else if(\"m4\"===m)void 0===c._array&&(c._array=new Float32Array(16)),k.flattenToArray(c._array),j.uniformMatrix4fv(f,!1,c._array);else if(\"m4v\"===m){void 0===c._array&&(c._array=\nnew Float32Array(16*k.length));m=0;for(n=k.length;m<n;m++)k[m].flattenToArrayOffset(c._array,16*m);j.uniformMatrix4fv(f,!1,c._array)}else if(\"t\"===m){if(r=k,k=G(),j.uniform1i(f,k),r)if(r.image instanceof Array&&6===r.image.length){if(c=r,f=k,6===c.image.length)if(c.needsUpdate){c.image.__webglTextureCube||(c.addEventListener(\"dispose\",Bb),c.image.__webglTextureCube=j.createTexture(),I.info.memory.textures++);j.activeTexture(j.TEXTURE0+f);j.bindTexture(j.TEXTURE_CUBE_MAP,c.image.__webglTextureCube);\nj.pixelStorei(j.UNPACK_FLIP_Y_WEBGL,c.flipY);f=c instanceof THREE.CompressedTexture;k=[];for(m=0;6>m;m++)I.autoScaleCubemaps&&!f?(n=k,r=m,s=c.image[m],v=Yb,s.width<=v&&s.height<=v||(z=Math.max(s.width,s.height),u=Math.floor(s.width*v/z),v=Math.floor(s.height*v/z),z=document.createElement(\"canvas\"),z.width=u,z.height=v,z.getContext(\"2d\").drawImage(s,0,0,s.width,s.height,0,0,u,v),s=z),n[r]=s):k[m]=c.image[m];m=k[0];n=0===(m.width&m.width-1)&&0===(m.height&m.height-1);r=D(c.format);s=D(c.type);w(j.TEXTURE_CUBE_MAP,\nc,n);for(m=0;6>m;m++)if(f){v=k[m].mipmaps;z=0;for(y=v.length;z<y;z++)u=v[z],c.format!==THREE.RGBAFormat?j.compressedTexImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X+m,z,r,u.width,u.height,0,u.data):j.texImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X+m,z,r,u.width,u.height,0,r,s,u.data)}else j.texImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X+m,0,r,r,s,k[m]);c.generateMipmaps&&n&&j.generateMipmap(j.TEXTURE_CUBE_MAP);c.needsUpdate=!1;if(c.onUpdate)c.onUpdate()}else j.activeTexture(j.TEXTURE0+f),j.bindTexture(j.TEXTURE_CUBE_MAP,\nc.image.__webglTextureCube)}else r instanceof THREE.WebGLRenderTargetCube?(c=r,j.activeTexture(j.TEXTURE0+k),j.bindTexture(j.TEXTURE_CUBE_MAP,c.__webglTexture)):I.setTexture(r,k)}else if(\"tv\"===m){void 0===c._array&&(c._array=[]);m=0;for(n=c.value.length;m<n;m++)c._array[m]=G();j.uniform1iv(f,c._array);m=0;for(n=c.value.length;m<n;m++)r=c.value[m],k=c._array[m],r&&I.setTexture(r,k)}else console.warn(\"THREE.WebGLRenderer: Unknown uniform type: \"+m);if((d instanceof THREE.ShaderMaterial||d instanceof\nTHREE.MeshPhongMaterial||d.envMap)&&null!==h.cameraPosition)ja.setFromMatrixPosition(a.matrixWorld),j.uniform3f(h.cameraPosition,ja.x,ja.y,ja.z);(d instanceof THREE.MeshPhongMaterial||d instanceof THREE.MeshLambertMaterial||d instanceof THREE.ShaderMaterial||d.skinning)&&null!==h.viewMatrix&&j.uniformMatrix4fv(h.viewMatrix,!1,a.matrixWorldInverse.elements)}j.uniformMatrix4fv(h.modelViewMatrix,!1,e._modelViewMatrix.elements);h.normalMatrix&&j.uniformMatrix3fv(h.normalMatrix,!1,e._normalMatrix.elements);\nnull!==h.modelMatrix&&j.uniformMatrix4fv(h.modelMatrix,!1,e.matrixWorld.elements);return g}function G(){var a=Ja;a>=Ab&&console.warn(\"WebGLRenderer: trying to use \"+a+\" texture units while this GPU supports only \"+Ab);Ja+=1;return a}function N(a,b,c,d){a[b]=c.r*c.r*d;a[b+1]=c.g*c.g*d;a[b+2]=c.b*c.b*d}function C(a,b,c,d){a[b]=c.r*d;a[b+1]=c.g*d;a[b+2]=c.b*d}function B(a){a!==ia&&(j.lineWidth(a),ia=a)}function x(a,b,c){Ua!==a&&(a?j.enable(j.POLYGON_OFFSET_FILL):j.disable(j.POLYGON_OFFSET_FILL),Ua=a);\nif(a&&(Oa!==b||la!==c))j.polygonOffset(b,c),Oa=b,la=c}function F(a){for(var a=a.split(\"\\n\"),b=0,c=a.length;b<c;b++)a[b]=b+1+\": \"+a[b];return a.join(\"\\n\")}function L(a,b){var c;\"fragment\"===a?c=j.createShader(j.FRAGMENT_SHADER):\"vertex\"===a&&(c=j.createShader(j.VERTEX_SHADER));j.shaderSource(c,b);j.compileShader(c);return!j.getShaderParameter(c,j.COMPILE_STATUS)?(console.error(j.getShaderInfoLog(c)),console.error(F(b)),null):c}function w(a,b,c){c?(j.texParameteri(a,j.TEXTURE_WRAP_S,D(b.wrapS)),j.texParameteri(a,\nj.TEXTURE_WRAP_T,D(b.wrapT)),j.texParameteri(a,j.TEXTURE_MAG_FILTER,D(b.magFilter)),j.texParameteri(a,j.TEXTURE_MIN_FILTER,D(b.minFilter))):(j.texParameteri(a,j.TEXTURE_WRAP_S,j.CLAMP_TO_EDGE),j.texParameteri(a,j.TEXTURE_WRAP_T,j.CLAMP_TO_EDGE),j.texParameteri(a,j.TEXTURE_MAG_FILTER,y(b.magFilter)),j.texParameteri(a,j.TEXTURE_MIN_FILTER,y(b.minFilter)));if(qa&&b.type!==THREE.FloatType&&(1<b.anisotropy||b.__oldAnisotropy))j.texParameterf(a,qa.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(b.anisotropy,Jb)),b.__oldAnisotropy=\nb.anisotropy}function E(a,b){j.bindRenderbuffer(j.RENDERBUFFER,a);b.depthBuffer&&!b.stencilBuffer?(j.renderbufferStorage(j.RENDERBUFFER,j.DEPTH_COMPONENT16,b.width,b.height),j.framebufferRenderbuffer(j.FRAMEBUFFER,j.DEPTH_ATTACHMENT,j.RENDERBUFFER,a)):b.depthBuffer&&b.stencilBuffer?(j.renderbufferStorage(j.RENDERBUFFER,j.DEPTH_STENCIL,b.width,b.height),j.framebufferRenderbuffer(j.FRAMEBUFFER,j.DEPTH_STENCIL_ATTACHMENT,j.RENDERBUFFER,a)):j.renderbufferStorage(j.RENDERBUFFER,j.RGBA4,b.width,b.height)}\nfunction y(a){return a===THREE.NearestFilter||a===THREE.NearestMipMapNearestFilter||a===THREE.NearestMipMapLinearFilter?j.NEAREST:j.LINEAR}function D(a){if(a===THREE.RepeatWrapping)return j.REPEAT;if(a===THREE.ClampToEdgeWrapping)return j.CLAMP_TO_EDGE;if(a===THREE.MirroredRepeatWrapping)return j.MIRRORED_REPEAT;if(a===THREE.NearestFilter)return j.NEAREST;if(a===THREE.NearestMipMapNearestFilter)return j.NEAREST_MIPMAP_NEAREST;if(a===THREE.NearestMipMapLinearFilter)return j.NEAREST_MIPMAP_LINEAR;if(a===\nTHREE.LinearFilter)return j.LINEAR;if(a===THREE.LinearMipMapNearestFilter)return j.LINEAR_MIPMAP_NEAREST;if(a===THREE.LinearMipMapLinearFilter)return j.LINEAR_MIPMAP_LINEAR;if(a===THREE.UnsignedByteType)return j.UNSIGNED_BYTE;if(a===THREE.UnsignedShort4444Type)return j.UNSIGNED_SHORT_4_4_4_4;if(a===THREE.UnsignedShort5551Type)return j.UNSIGNED_SHORT_5_5_5_1;if(a===THREE.UnsignedShort565Type)return j.UNSIGNED_SHORT_5_6_5;if(a===THREE.ByteType)return j.BYTE;if(a===THREE.ShortType)return j.SHORT;if(a===\nTHREE.UnsignedShortType)return j.UNSIGNED_SHORT;if(a===THREE.IntType)return j.INT;if(a===THREE.UnsignedIntType)return j.UNSIGNED_INT;if(a===THREE.FloatType)return j.FLOAT;if(a===THREE.AlphaFormat)return j.ALPHA;if(a===THREE.RGBFormat)return j.RGB;if(a===THREE.RGBAFormat)return j.RGBA;if(a===THREE.LuminanceFormat)return j.LUMINANCE;if(a===THREE.LuminanceAlphaFormat)return j.LUMINANCE_ALPHA;if(a===THREE.AddEquation)return j.FUNC_ADD;if(a===THREE.SubtractEquation)return j.FUNC_SUBTRACT;if(a===THREE.ReverseSubtractEquation)return j.FUNC_REVERSE_SUBTRACT;\nif(a===THREE.ZeroFactor)return j.ZERO;if(a===THREE.OneFactor)return j.ONE;if(a===THREE.SrcColorFactor)return j.SRC_COLOR;if(a===THREE.OneMinusSrcColorFactor)return j.ONE_MINUS_SRC_COLOR;if(a===THREE.SrcAlphaFactor)return j.SRC_ALPHA;if(a===THREE.OneMinusSrcAlphaFactor)return j.ONE_MINUS_SRC_ALPHA;if(a===THREE.DstAlphaFactor)return j.DST_ALPHA;if(a===THREE.OneMinusDstAlphaFactor)return j.ONE_MINUS_DST_ALPHA;if(a===THREE.DstColorFactor)return j.DST_COLOR;if(a===THREE.OneMinusDstColorFactor)return j.ONE_MINUS_DST_COLOR;\nif(a===THREE.SrcAlphaSaturateFactor)return j.SRC_ALPHA_SATURATE;if(void 0!==ta){if(a===THREE.RGB_S3TC_DXT1_Format)return ta.COMPRESSED_RGB_S3TC_DXT1_EXT;if(a===THREE.RGBA_S3TC_DXT1_Format)return ta.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(a===THREE.RGBA_S3TC_DXT3_Format)return ta.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(a===THREE.RGBA_S3TC_DXT5_Format)return ta.COMPRESSED_RGBA_S3TC_DXT5_EXT}return 0}console.log(\"THREE.WebGLRenderer\",THREE.REVISION);var a=a||{},H=void 0!==a.canvas?a.canvas:document.createElement(\"canvas\"),\nK=void 0!==a.precision?a.precision:\"highp\",A=void 0!==a.alpha?a.alpha:!1,da=void 0!==a.premultipliedAlpha?a.premultipliedAlpha:!0,ha=void 0!==a.antialias?a.antialias:!1,ua=void 0!==a.stencil?a.stencil:!0,O=void 0!==a.preserveDrawingBuffer?a.preserveDrawingBuffer:!1,T=new THREE.Color(0),ea=0;this.domElement=H;this.context=null;this.devicePixelRatio=void 0!==a.devicePixelRatio?a.devicePixelRatio:void 0!==self.devicePixelRatio?self.devicePixelRatio:1;this.autoUpdateObjects=this.sortObjects=this.autoClearStencil=\nthis.autoClearDepth=this.autoClearColor=this.autoClear=!0;this.shadowMapEnabled=this.gammaOutput=this.gammaInput=!1;this.shadowMapAutoUpdate=!0;this.shadowMapType=THREE.PCFShadowMap;this.shadowMapCullFace=THREE.CullFaceFront;this.shadowMapCascade=this.shadowMapDebug=!1;this.maxMorphTargets=8;this.maxMorphNormals=4;this.autoScaleCubemaps=!0;this.renderPluginsPre=[];this.renderPluginsPost=[];this.info={memory:{programs:0,geometries:0,textures:0},render:{calls:0,vertices:0,faces:0,points:0}};var I=this,\nP=[],Q=0,oa=null,va=null,Ea=-1,za=null,Ha=null,Ta=0,Ja=0,sa=-1,Aa=-1,ba=-1,W=-1,Ka=-1,U=-1,ca=-1,wa=-1,Ua=null,Oa=null,la=null,ia=null,Fa=0,Ga=0,Ba=H.width,xa=H.height,Va=0,La=0,Ma={},ya=new THREE.Frustum,V=new THREE.Matrix4,pa=new THREE.Matrix4,ja=new THREE.Vector3,fa=new THREE.Vector3,Za=!0,Na={ambient:[0,0,0],directional:{length:0,colors:[],positions:[]},point:{length:0,colors:[],positions:[],distances:[]},spot:{length:0,colors:[],positions:[],distances:[],directions:[],anglesCos:[],exponents:[]},\nhemi:{length:0,skyColors:[],groundColors:[],positions:[]}},j,Pa,Wa,qa,ta;try{var hb={alpha:A,premultipliedAlpha:da,antialias:ha,stencil:ua,preserveDrawingBuffer:O};j=H.getContext(\"webgl\",hb)||H.getContext(\"experimental-webgl\",hb);if(null===j)throw\"Error creating WebGL context.\";}catch(db){console.error(db)}Pa=j.getExtension(\"OES_texture_float\");j.getExtension(\"OES_texture_float_linear\");Wa=j.getExtension(\"OES_standard_derivatives\");qa=j.getExtension(\"EXT_texture_filter_anisotropic\")||j.getExtension(\"MOZ_EXT_texture_filter_anisotropic\")||\nj.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\");ta=j.getExtension(\"WEBGL_compressed_texture_s3tc\")||j.getExtension(\"MOZ_WEBGL_compressed_texture_s3tc\")||j.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\");Pa||console.log(\"THREE.WebGLRenderer: Float textures not supported.\");Wa||console.log(\"THREE.WebGLRenderer: Standard derivatives not supported.\");qa||console.log(\"THREE.WebGLRenderer: Anisotropic texture filtering not supported.\");ta||console.log(\"THREE.WebGLRenderer: S3TC compressed textures not supported.\");\nvoid 0===j.getShaderPrecisionFormat&&(j.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}});j.clearColor(0,0,0,1);j.clearDepth(1);j.clearStencil(0);j.enable(j.DEPTH_TEST);j.depthFunc(j.LEQUAL);j.frontFace(j.CCW);j.cullFace(j.BACK);j.enable(j.CULL_FACE);j.enable(j.BLEND);j.blendEquation(j.FUNC_ADD);j.blendFunc(j.SRC_ALPHA,j.ONE_MINUS_SRC_ALPHA);j.viewport(Fa,Ga,Ba,xa);j.clearColor(T.r,T.g,T.b,ea);this.context=j;var Ab=j.getParameter(j.MAX_TEXTURE_IMAGE_UNITS),Xb=j.getParameter(j.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\nj.getParameter(j.MAX_TEXTURE_SIZE);var Yb=j.getParameter(j.MAX_CUBE_MAP_TEXTURE_SIZE),Jb=qa?j.getParameter(qa.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,xb=0<Xb,tb=xb&&Pa;ta&&j.getParameter(j.COMPRESSED_TEXTURE_FORMATS);var Zb=j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.HIGH_FLOAT),$b=j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.MEDIUM_FLOAT);j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.LOW_FLOAT);var ac=j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,j.HIGH_FLOAT),pc=j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,\nj.MEDIUM_FLOAT);j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,j.LOW_FLOAT);j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.HIGH_INT);j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.MEDIUM_INT);j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.LOW_INT);j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,j.HIGH_INT);j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,j.MEDIUM_INT);j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,j.LOW_INT);var qc=0<Zb.precision&&0<ac.precision,Kb=0<$b.precision&&0<pc.precision;\"highp\"===K&&!qc&&\n(Kb?(K=\"mediump\",console.warn(\"WebGLRenderer: highp not supported, using mediump\")):(K=\"lowp\",console.warn(\"WebGLRenderer: highp and mediump not supported, using lowp\")));\"mediump\"===K&&!Kb&&(K=\"lowp\",console.warn(\"WebGLRenderer: mediump not supported, using lowp\"));this.getContext=function(){return j};this.supportsVertexTextures=function(){return xb};this.supportsFloatTextures=function(){return Pa};this.supportsStandardDerivatives=function(){return Wa};this.supportsCompressedTextureS3TC=function(){return ta};\nthis.getMaxAnisotropy=function(){return Jb};this.getPrecision=function(){return K};this.setSize=function(a,b,c){H.width=a*this.devicePixelRatio;H.height=b*this.devicePixelRatio;1!==this.devicePixelRatio&&!1!==c&&(H.style.width=a+\"px\",H.style.height=b+\"px\");this.setViewport(0,0,H.width,H.height)};this.setViewport=function(a,b,c,d){Fa=void 0!==a?a:0;Ga=void 0!==b?b:0;Ba=void 0!==c?c:H.width;xa=void 0!==d?d:H.height;j.viewport(Fa,Ga,Ba,xa)};this.setScissor=function(a,b,c,d){j.scissor(a,b,c,d)};this.enableScissorTest=\nfunction(a){a?j.enable(j.SCISSOR_TEST):j.disable(j.SCISSOR_TEST)};this.setClearColor=function(a,b){T.set(a);ea=void 0!==b?b:1;j.clearColor(T.r,T.g,T.b,ea)};this.setClearColorHex=function(a,b){console.warn(\"DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.\");this.setClearColor(a,b)};this.getClearColor=function(){return T};this.getClearAlpha=function(){return ea};this.clear=function(a,b,c){var d=0;if(void 0===a||a)d|=j.COLOR_BUFFER_BIT;if(void 0===b||b)d|=j.DEPTH_BUFFER_BIT;\nif(void 0===c||c)d|=j.STENCIL_BUFFER_BIT;j.clear(d)};this.clearColor=function(){j.clear(j.COLOR_BUFFER_BIT)};this.clearDepth=function(){j.clear(j.DEPTH_BUFFER_BIT)};this.clearStencil=function(){j.clear(j.STENCIL_BUFFER_BIT)};this.clearTarget=function(a,b,c,d){this.setRenderTarget(a);this.clear(b,c,d)};this.addPostPlugin=function(a){a.init(this);this.renderPluginsPost.push(a)};this.addPrePlugin=function(a){a.init(this);this.renderPluginsPre.push(a)};this.updateShadowMap=function(a,b){oa=null;Ea=za=\nwa=ca=ba=-1;Za=!0;Aa=sa=-1;this.shadowMapPlugin.update(a,b)};var Lb=function(a){a=a.target;a.removeEventListener(\"dispose\",Lb);a.__webglInit=void 0;if(a instanceof THREE.BufferGeometry){var b=a.attributes,c;for(c in b)void 0!==b[c].buffer&&j.deleteBuffer(b[c].buffer);I.info.memory.geometries--}else if(void 0!==a.geometryGroups)for(b in a.geometryGroups){c=a.geometryGroups[b];if(void 0!==c.numMorphTargets)for(var d=0,e=c.numMorphTargets;d<e;d++)j.deleteBuffer(c.__webglMorphTargetsBuffers[d]);if(void 0!==\nc.numMorphNormals){d=0;for(e=c.numMorphNormals;d<e;d++)j.deleteBuffer(c.__webglMorphNormalsBuffers[d])}Db(c)}else Db(a)},Bb=function(a){a=a.target;a.removeEventListener(\"dispose\",Bb);a.image&&a.image.__webglTextureCube?j.deleteTexture(a.image.__webglTextureCube):a.__webglInit&&(a.__webglInit=!1,j.deleteTexture(a.__webglTexture));I.info.memory.textures--},Mb=function(a){a=a.target;a.removeEventListener(\"dispose\",Mb);if(a&&a.__webglTexture)if(j.deleteTexture(a.__webglTexture),a instanceof THREE.WebGLRenderTargetCube)for(var b=\n0;6>b;b++)j.deleteFramebuffer(a.__webglFramebuffer[b]),j.deleteRenderbuffer(a.__webglRenderbuffer[b]);else j.deleteFramebuffer(a.__webglFramebuffer),j.deleteRenderbuffer(a.__webglRenderbuffer);I.info.memory.textures--},Cb=function(a){a=a.target;a.removeEventListener(\"dispose\",Cb);Eb(a)},Db=function(a){void 0!==a.__webglVertexBuffer&&j.deleteBuffer(a.__webglVertexBuffer);void 0!==a.__webglNormalBuffer&&j.deleteBuffer(a.__webglNormalBuffer);void 0!==a.__webglTangentBuffer&&j.deleteBuffer(a.__webglTangentBuffer);\nvoid 0!==a.__webglColorBuffer&&j.deleteBuffer(a.__webglColorBuffer);void 0!==a.__webglUVBuffer&&j.deleteBuffer(a.__webglUVBuffer);void 0!==a.__webglUV2Buffer&&j.deleteBuffer(a.__webglUV2Buffer);void 0!==a.__webglSkinIndicesBuffer&&j.deleteBuffer(a.__webglSkinIndicesBuffer);void 0!==a.__webglSkinWeightsBuffer&&j.deleteBuffer(a.__webglSkinWeightsBuffer);void 0!==a.__webglFaceBuffer&&j.deleteBuffer(a.__webglFaceBuffer);void 0!==a.__webglLineBuffer&&j.deleteBuffer(a.__webglLineBuffer);void 0!==a.__webglLineDistanceBuffer&&\nj.deleteBuffer(a.__webglLineDistanceBuffer);if(void 0!==a.__webglCustomAttributesList)for(var b in a.__webglCustomAttributesList)j.deleteBuffer(a.__webglCustomAttributesList[b].buffer);I.info.memory.geometries--},Eb=function(a){var b=a.program;if(void 0!==b){a.program=void 0;var c,d,e=!1,a=0;for(c=P.length;a<c;a++)if(d=P[a],d.program===b){d.usedTimes--;0===d.usedTimes&&(e=!0);break}if(!0===e){e=[];a=0;for(c=P.length;a<c;a++)d=P[a],d.program!==b&&e.push(d);P=e;j.deleteProgram(b);I.info.memory.programs--}}};\nthis.renderBufferImmediate=function(a,b,c){a.hasPositions&&!a.__webglVertexBuffer&&(a.__webglVertexBuffer=j.createBuffer());a.hasNormals&&!a.__webglNormalBuffer&&(a.__webglNormalBuffer=j.createBuffer());a.hasUvs&&!a.__webglUvBuffer&&(a.__webglUvBuffer=j.createBuffer());a.hasColors&&!a.__webglColorBuffer&&(a.__webglColorBuffer=j.createBuffer());a.hasPositions&&(j.bindBuffer(j.ARRAY_BUFFER,a.__webglVertexBuffer),j.bufferData(j.ARRAY_BUFFER,a.positionArray,j.DYNAMIC_DRAW),j.enableVertexAttribArray(b.attributes.position),\nj.vertexAttribPointer(b.attributes.position,3,j.FLOAT,!1,0,0));if(a.hasNormals){j.bindBuffer(j.ARRAY_BUFFER,a.__webglNormalBuffer);if(c.shading===THREE.FlatShading){var d,e,f,g,h,i,k,l,m,n,p,q=3*a.count;for(p=0;p<q;p+=9)n=a.normalArray,d=n[p],e=n[p+1],f=n[p+2],g=n[p+3],i=n[p+4],l=n[p+5],h=n[p+6],k=n[p+7],m=n[p+8],d=(d+g+h)/3,e=(e+i+k)/3,f=(f+l+m)/3,n[p]=d,n[p+1]=e,n[p+2]=f,n[p+3]=d,n[p+4]=e,n[p+5]=f,n[p+6]=d,n[p+7]=e,n[p+8]=f}j.bufferData(j.ARRAY_BUFFER,a.normalArray,j.DYNAMIC_DRAW);j.enableVertexAttribArray(b.attributes.normal);\nj.vertexAttribPointer(b.attributes.normal,3,j.FLOAT,!1,0,0)}a.hasUvs&&c.map&&(j.bindBuffer(j.ARRAY_BUFFER,a.__webglUvBuffer),j.bufferData(j.ARRAY_BUFFER,a.uvArray,j.DYNAMIC_DRAW),j.enableVertexAttribArray(b.attributes.uv),j.vertexAttribPointer(b.attributes.uv,2,j.FLOAT,!1,0,0));a.hasColors&&c.vertexColors!==THREE.NoColors&&(j.bindBuffer(j.ARRAY_BUFFER,a.__webglColorBuffer),j.bufferData(j.ARRAY_BUFFER,a.colorArray,j.DYNAMIC_DRAW),j.enableVertexAttribArray(b.attributes.color),j.vertexAttribPointer(b.attributes.color,\n3,j.FLOAT,!1,0,0));j.drawArrays(j.TRIANGLES,0,a.count);a.count=0};this.renderBufferDirect=function(a,b,c,d,e,f){if(!1!==d.visible){var i,k,l,m;i=z(a,b,c,d,f);b=i.attributes;a=e.attributes;c=!1;i=16777215*e.id+2*i.id+(d.wireframe?1:0);i!==za&&(za=i,c=!0);c&&h();if(f instanceof THREE.Mesh)if(f=a.index){e=e.offsets;1<e.length&&(c=!0);for(var n=0,p=e.length;n<p;n++){var q=e[n].index;if(c){for(k in b)l=b[k],i=a[k],0<=l&&(i?(m=i.itemSize,j.bindBuffer(j.ARRAY_BUFFER,i.buffer),g(l),j.vertexAttribPointer(l,\nm,j.FLOAT,!1,0,4*q*m)):d.defaultAttributeValues&&(2===d.defaultAttributeValues[k].length?j.vertexAttrib2fv(l,d.defaultAttributeValues[k]):3===d.defaultAttributeValues[k].length&&j.vertexAttrib3fv(l,d.defaultAttributeValues[k])));j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,f.buffer)}j.drawElements(j.TRIANGLES,e[n].count,j.UNSIGNED_SHORT,2*e[n].start);I.info.render.calls++;I.info.render.vertices+=e[n].count;I.info.render.faces+=e[n].count/3}}else{if(c)for(k in b)\"index\"!==k&&(l=b[k],i=a[k],0<=l&&(i?(m=i.itemSize,\nj.bindBuffer(j.ARRAY_BUFFER,i.buffer),g(l),j.vertexAttribPointer(l,m,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&d.defaultAttributeValues[k]&&(2===d.defaultAttributeValues[k].length?j.vertexAttrib2fv(l,d.defaultAttributeValues[k]):3===d.defaultAttributeValues[k].length&&j.vertexAttrib3fv(l,d.defaultAttributeValues[k]))));d=e.attributes.position;j.drawArrays(j.TRIANGLES,0,d.numItems/3);I.info.render.calls++;I.info.render.vertices+=d.numItems/3;I.info.render.faces+=d.numItems/3/3}else if(f instanceof\nTHREE.ParticleSystem){if(c)for(k in b)l=b[k],i=a[k],0<=l&&(i?(m=i.itemSize,j.bindBuffer(j.ARRAY_BUFFER,i.buffer),g(l),j.vertexAttribPointer(l,m,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&d.defaultAttributeValues[k]&&(2===d.defaultAttributeValues[k].length?j.vertexAttrib2fv(l,d.defaultAttributeValues[k]):3===d.defaultAttributeValues[k].length&&j.vertexAttrib3fv(l,d.defaultAttributeValues[k])));d=a.position;j.drawArrays(j.POINTS,0,d.numItems/3);I.info.render.calls++;I.info.render.points+=d.numItems/\n3}else if(f instanceof THREE.Line){if(c)for(k in b)l=b[k],i=a[k],0<=l&&(i?(m=i.itemSize,j.bindBuffer(j.ARRAY_BUFFER,i.buffer),g(l),j.vertexAttribPointer(l,m,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&d.defaultAttributeValues[k]&&(2===d.defaultAttributeValues[k].length?j.vertexAttrib2fv(l,d.defaultAttributeValues[k]):3===d.defaultAttributeValues[k].length&&j.vertexAttrib3fv(l,d.defaultAttributeValues[k])));k=f.type===THREE.LineStrip?j.LINE_STRIP:j.LINES;B(d.linewidth);d=a.position;j.drawArrays(k,0,\nd.numItems/3);I.info.render.calls++;I.info.render.points+=d.numItems}}};this.renderBuffer=function(a,b,c,d,e,f){if(!1!==d.visible){var i,l,c=z(a,b,c,d,f),a=c.attributes,b=!1,c=16777215*e.id+2*c.id+(d.wireframe?1:0);c!==za&&(za=c,b=!0);b&&h();if(!d.morphTargets&&0<=a.position)b&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglVertexBuffer),g(a.position),j.vertexAttribPointer(a.position,3,j.FLOAT,!1,0,0));else if(f.morphTargetBase){c=d.program.attributes;-1!==f.morphTargetBase&&0<=c.position?(j.bindBuffer(j.ARRAY_BUFFER,\ne.__webglMorphTargetsBuffers[f.morphTargetBase]),g(c.position),j.vertexAttribPointer(c.position,3,j.FLOAT,!1,0,0)):0<=c.position&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglVertexBuffer),g(c.position),j.vertexAttribPointer(c.position,3,j.FLOAT,!1,0,0));if(f.morphTargetForcedOrder.length){var m=0;l=f.morphTargetForcedOrder;for(i=f.morphTargetInfluences;m<d.numSupportedMorphTargets&&m<l.length;)0<=c[\"morphTarget\"+m]&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglMorphTargetsBuffers[l[m]]),g(c[\"morphTarget\"+m]),\nj.vertexAttribPointer(c[\"morphTarget\"+m],3,j.FLOAT,!1,0,0)),0<=c[\"morphNormal\"+m]&&d.morphNormals&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglMorphNormalsBuffers[l[m]]),g(c[\"morphNormal\"+m]),j.vertexAttribPointer(c[\"morphNormal\"+m],3,j.FLOAT,!1,0,0)),f.__webglMorphTargetInfluences[m]=i[l[m]],m++}else{l=[];i=f.morphTargetInfluences;var n,p=i.length;for(n=0;n<p;n++)m=i[n],0<m&&l.push([m,n]);l.length>d.numSupportedMorphTargets?(l.sort(k),l.length=d.numSupportedMorphTargets):l.length>d.numSupportedMorphNormals?\nl.sort(k):0===l.length&&l.push([0,0]);for(m=0;m<d.numSupportedMorphTargets;)l[m]?(n=l[m][1],0<=c[\"morphTarget\"+m]&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglMorphTargetsBuffers[n]),g(c[\"morphTarget\"+m]),j.vertexAttribPointer(c[\"morphTarget\"+m],3,j.FLOAT,!1,0,0)),0<=c[\"morphNormal\"+m]&&d.morphNormals&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglMorphNormalsBuffers[n]),g(c[\"morphNormal\"+m]),j.vertexAttribPointer(c[\"morphNormal\"+m],3,j.FLOAT,!1,0,0)),f.__webglMorphTargetInfluences[m]=i[n]):f.__webglMorphTargetInfluences[m]=\n0,m++}null!==d.program.uniforms.morphTargetInfluences&&j.uniform1fv(d.program.uniforms.morphTargetInfluences,f.__webglMorphTargetInfluences)}if(b){if(e.__webglCustomAttributesList){i=0;for(l=e.__webglCustomAttributesList.length;i<l;i++)c=e.__webglCustomAttributesList[i],0<=a[c.buffer.belongsToAttribute]&&(j.bindBuffer(j.ARRAY_BUFFER,c.buffer),g(a[c.buffer.belongsToAttribute]),j.vertexAttribPointer(a[c.buffer.belongsToAttribute],c.size,j.FLOAT,!1,0,0))}0<=a.color&&(0<f.geometry.colors.length||0<f.geometry.faces.length?\n(j.bindBuffer(j.ARRAY_BUFFER,e.__webglColorBuffer),g(a.color),j.vertexAttribPointer(a.color,3,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&j.vertexAttrib3fv(a.color,d.defaultAttributeValues.color));0<=a.normal&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglNormalBuffer),g(a.normal),j.vertexAttribPointer(a.normal,3,j.FLOAT,!1,0,0));0<=a.tangent&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglTangentBuffer),g(a.tangent),j.vertexAttribPointer(a.tangent,4,j.FLOAT,!1,0,0));0<=a.uv&&(f.geometry.faceVertexUvs[0]?(j.bindBuffer(j.ARRAY_BUFFER,\ne.__webglUVBuffer),g(a.uv),j.vertexAttribPointer(a.uv,2,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&j.vertexAttrib2fv(a.uv,d.defaultAttributeValues.uv));0<=a.uv2&&(f.geometry.faceVertexUvs[1]?(j.bindBuffer(j.ARRAY_BUFFER,e.__webglUV2Buffer),g(a.uv2),j.vertexAttribPointer(a.uv2,2,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&j.vertexAttrib2fv(a.uv2,d.defaultAttributeValues.uv2));d.skinning&&(0<=a.skinIndex&&0<=a.skinWeight)&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglSkinIndicesBuffer),g(a.skinIndex),j.vertexAttribPointer(a.skinIndex,\n4,j.FLOAT,!1,0,0),j.bindBuffer(j.ARRAY_BUFFER,e.__webglSkinWeightsBuffer),g(a.skinWeight),j.vertexAttribPointer(a.skinWeight,4,j.FLOAT,!1,0,0));0<=a.lineDistance&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglLineDistanceBuffer),g(a.lineDistance),j.vertexAttribPointer(a.lineDistance,1,j.FLOAT,!1,0,0))}f instanceof THREE.Mesh?(d.wireframe?(B(d.wireframeLinewidth),b&&j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,e.__webglLineBuffer),j.drawElements(j.LINES,e.__webglLineCount,j.UNSIGNED_SHORT,0)):(b&&j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,\ne.__webglFaceBuffer),j.drawElements(j.TRIANGLES,e.__webglFaceCount,j.UNSIGNED_SHORT,0)),I.info.render.calls++,I.info.render.vertices+=e.__webglFaceCount,I.info.render.faces+=e.__webglFaceCount/3):f instanceof THREE.Line?(f=f.type===THREE.LineStrip?j.LINE_STRIP:j.LINES,B(d.linewidth),j.drawArrays(f,0,e.__webglLineCount),I.info.render.calls++):f instanceof THREE.ParticleSystem&&(j.drawArrays(j.POINTS,0,e.__webglParticleCount),I.info.render.calls++,I.info.render.points+=e.__webglParticleCount)}};this.render=\nfunction(a,b,c,d){if(!1===b instanceof THREE.Camera)console.error(\"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.\");else{var e,f,g,h,k=a.__lights,m=a.fog;Ea=-1;Za=!0;!0===a.autoUpdate&&a.updateMatrixWorld();void 0===b.parent&&b.updateMatrixWorld();b.matrixWorldInverse.getInverse(b.matrixWorld);V.multiplyMatrices(b.projectionMatrix,b.matrixWorldInverse);ya.setFromMatrix(V);this.autoUpdateObjects&&this.initWebGLObjects(a);l(this.renderPluginsPre,a,b);I.info.render.calls=0;I.info.render.vertices=\n0;I.info.render.faces=0;I.info.render.points=0;this.setRenderTarget(c);(this.autoClear||d)&&this.clear(this.autoClearColor,this.autoClearDepth,this.autoClearStencil);h=a.__webglObjects;d=0;for(e=h.length;d<e;d++)if(f=h[d],g=f.object,f.id=d,f.render=!1,g.visible&&(!(g instanceof THREE.Mesh||g instanceof THREE.ParticleSystem)||!g.frustumCulled||ya.intersectsObject(g))){var q=g;q._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse,q.matrixWorld);q._normalMatrix.getNormalMatrix(q._modelViewMatrix);\nvar q=f,r=q.buffer,t=void 0,s=t=void 0,s=q.object.material;if(s instanceof THREE.MeshFaceMaterial)t=r.materialIndex,t=s.materials[t],t.transparent?(q.transparent=t,q.opaque=null):(q.opaque=t,q.transparent=null);else if(t=s)t.transparent?(q.transparent=t,q.opaque=null):(q.opaque=t,q.transparent=null);f.render=!0;!0===this.sortObjects&&(null!==g.renderDepth?f.z=g.renderDepth:(ja.setFromMatrixPosition(g.matrixWorld),ja.applyProjection(V),f.z=ja.z))}this.sortObjects&&h.sort(i);h=a.__webglObjectsImmediate;\nd=0;for(e=h.length;d<e;d++)f=h[d],g=f.object,g.visible&&(g._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse,g.matrixWorld),g._normalMatrix.getNormalMatrix(g._modelViewMatrix),g=f.object.material,g.transparent?(f.transparent=g,f.opaque=null):(f.opaque=g,f.transparent=null));a.overrideMaterial?(d=a.overrideMaterial,this.setBlending(d.blending,d.blendEquation,d.blendSrc,d.blendDst),this.setDepthTest(d.depthTest),this.setDepthWrite(d.depthWrite),x(d.polygonOffset,d.polygonOffsetFactor,d.polygonOffsetUnits),\nn(a.__webglObjects,!1,\"\",b,k,m,!0,d),p(a.__webglObjectsImmediate,\"\",b,k,m,!1,d)):(d=null,this.setBlending(THREE.NoBlending),n(a.__webglObjects,!0,\"opaque\",b,k,m,!1,d),p(a.__webglObjectsImmediate,\"opaque\",b,k,m,!1,d),n(a.__webglObjects,!1,\"transparent\",b,k,m,!0,d),p(a.__webglObjectsImmediate,\"transparent\",b,k,m,!0,d));l(this.renderPluginsPost,a,b);c&&(c.generateMipmaps&&c.minFilter!==THREE.NearestFilter&&c.minFilter!==THREE.LinearFilter)&&(c instanceof THREE.WebGLRenderTargetCube?(j.bindTexture(j.TEXTURE_CUBE_MAP,\nc.__webglTexture),j.generateMipmap(j.TEXTURE_CUBE_MAP),j.bindTexture(j.TEXTURE_CUBE_MAP,null)):(j.bindTexture(j.TEXTURE_2D,c.__webglTexture),j.generateMipmap(j.TEXTURE_2D),j.bindTexture(j.TEXTURE_2D,null)));this.setDepthTest(!0);this.setDepthWrite(!0)}};this.renderImmediateObject=function(a,b,c,d,e){var f=z(a,b,c,d,e);za=-1;I.setMaterialFaces(d);e.immediateRenderCallback?e.immediateRenderCallback(f,j,ya):e.render(function(a){I.renderBufferImmediate(a,f,d)})};this.initWebGLObjects=function(a){a.__webglObjects||\n(a.__webglObjects=[],a.__webglObjectsImmediate=[],a.__webglSprites=[],a.__webglFlares=[]);for(;a.__objectsAdded.length;)t(a.__objectsAdded[0],a),a.__objectsAdded.splice(0,1);for(;a.__objectsRemoved.length;)u(a.__objectsRemoved[0],a),a.__objectsRemoved.splice(0,1);for(var b=0,g=a.__webglObjects.length;b<g;b++){var h=a.__webglObjects[b].object;void 0===h.__webglInit&&(void 0!==h.__webglActive&&u(h,a),t(h,a));var i=h,l=i.geometry,n=void 0,p=void 0,r=void 0;if(l instanceof THREE.BufferGeometry){var s=\nj.DYNAMIC_DRAW,v=!l.dynamic,z=l.attributes,y=void 0,x=void 0;for(y in z)x=z[y],x.needsUpdate&&(\"index\"===y?(j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,x.buffer),j.bufferData(j.ELEMENT_ARRAY_BUFFER,x.array,s)):(j.bindBuffer(j.ARRAY_BUFFER,x.buffer),j.bufferData(j.ARRAY_BUFFER,x.array,s)),x.needsUpdate=!1),v&&!x.dynamic&&(x.array=null)}else if(i instanceof THREE.Mesh){for(var B=0,C=l.geometryGroupsList.length;B<C;B++)if(n=l.geometryGroupsList[B],r=d(i,n),l.buffersNeedUpdate&&c(n,i),p=r.attributes&&m(r),l.verticesNeedUpdate||\nl.morphTargetsNeedUpdate||l.elementsNeedUpdate||l.uvsNeedUpdate||l.normalsNeedUpdate||l.colorsNeedUpdate||l.tangentsNeedUpdate||p){var w=n,D=i,F=j.DYNAMIC_DRAW,E=!l.dynamic,G=r;if(w.__inittedArrays){var H=e(G),L=G.vertexColors?G.vertexColors:!1,N=f(G),O=H===THREE.SmoothShading,A=void 0,I=void 0,Q=void 0,K=void 0,P=void 0,U=void 0,T=void 0,W=void 0,oa=void 0,va=void 0,sa=void 0,Y=void 0,Z=void 0,X=void 0,Ea=void 0,Ta=void 0,ba=void 0,da=void 0,ca=void 0,za=void 0,Ja=void 0,ea=void 0,fa=void 0,ha=void 0,\nHa=void 0,la=void 0,Aa=void 0,qa=void 0,ua=void 0,Ia=void 0,Fa=void 0,Ba=void 0,Ka=void 0,Ga=void 0,ia=void 0,Na=void 0,ta=void 0,wa=void 0,Ma=void 0,Oa=void 0,xa=0,ya=0,Pa=0,Ua=0,Va=0,ib=0,Ya=0,La=0,eb=0,ra=0,Ca=0,M=0,Xa=void 0,jb=w.__vertexArray,Za=w.__uvArray,db=w.__uv2Array,Wa=w.__normalArray,$a=w.__tangentArray,kb=w.__colorArray,ab=w.__skinIndexArray,bb=w.__skinWeightArray,hb=w.__morphTargetsArrays,xb=w.__morphNormalsArrays,tb=w.__webglCustomAttributesList,J=void 0,Nb=w.__faceArray,ub=w.__lineArray,\nQa=D.geometry,Bb=Qa.elementsNeedUpdate,Ab=Qa.uvsNeedUpdate,Jb=Qa.normalsNeedUpdate,Kb=Qa.tangentsNeedUpdate,Lb=Qa.colorsNeedUpdate,Mb=Qa.morphTargetsNeedUpdate,bc=Qa.vertices,aa=w.faces3,lb=Qa.faces,Cb=Qa.faceVertexUvs[0],Db=Qa.faceVertexUvs[1],cc=Qa.skinIndices,Ob=Qa.skinWeights,Pb=Qa.morphTargets,Eb=Qa.morphNormals;if(Qa.verticesNeedUpdate){A=0;for(I=aa.length;A<I;A++)K=lb[aa[A]],Y=bc[K.a],Z=bc[K.b],X=bc[K.c],jb[ya]=Y.x,jb[ya+1]=Y.y,jb[ya+2]=Y.z,jb[ya+3]=Z.x,jb[ya+4]=Z.y,jb[ya+5]=Z.z,jb[ya+6]=X.x,\njb[ya+7]=X.y,jb[ya+8]=X.z,ya+=9;j.bindBuffer(j.ARRAY_BUFFER,w.__webglVertexBuffer);j.bufferData(j.ARRAY_BUFFER,jb,F)}if(Mb){ia=0;for(Na=Pb.length;ia<Na;ia++){A=Ca=0;for(I=aa.length;A<I;A++)Ma=aa[A],K=lb[Ma],Y=Pb[ia].vertices[K.a],Z=Pb[ia].vertices[K.b],X=Pb[ia].vertices[K.c],ta=hb[ia],ta[Ca]=Y.x,ta[Ca+1]=Y.y,ta[Ca+2]=Y.z,ta[Ca+3]=Z.x,ta[Ca+4]=Z.y,ta[Ca+5]=Z.z,ta[Ca+6]=X.x,ta[Ca+7]=X.y,ta[Ca+8]=X.z,G.morphNormals&&(O?(Oa=Eb[ia].vertexNormals[Ma],da=Oa.a,ca=Oa.b,za=Oa.c):za=ca=da=Eb[ia].faceNormals[Ma],\nwa=xb[ia],wa[Ca]=da.x,wa[Ca+1]=da.y,wa[Ca+2]=da.z,wa[Ca+3]=ca.x,wa[Ca+4]=ca.y,wa[Ca+5]=ca.z,wa[Ca+6]=za.x,wa[Ca+7]=za.y,wa[Ca+8]=za.z),Ca+=9;j.bindBuffer(j.ARRAY_BUFFER,w.__webglMorphTargetsBuffers[ia]);j.bufferData(j.ARRAY_BUFFER,hb[ia],F);G.morphNormals&&(j.bindBuffer(j.ARRAY_BUFFER,w.__webglMorphNormalsBuffers[ia]),j.bufferData(j.ARRAY_BUFFER,xb[ia],F))}}if(Ob.length){A=0;for(I=aa.length;A<I;A++)K=lb[aa[A]],ha=Ob[K.a],Ha=Ob[K.b],la=Ob[K.c],bb[ra]=ha.x,bb[ra+1]=ha.y,bb[ra+2]=ha.z,bb[ra+3]=ha.w,\nbb[ra+4]=Ha.x,bb[ra+5]=Ha.y,bb[ra+6]=Ha.z,bb[ra+7]=Ha.w,bb[ra+8]=la.x,bb[ra+9]=la.y,bb[ra+10]=la.z,bb[ra+11]=la.w,Aa=cc[K.a],qa=cc[K.b],ua=cc[K.c],ab[ra]=Aa.x,ab[ra+1]=Aa.y,ab[ra+2]=Aa.z,ab[ra+3]=Aa.w,ab[ra+4]=qa.x,ab[ra+5]=qa.y,ab[ra+6]=qa.z,ab[ra+7]=qa.w,ab[ra+8]=ua.x,ab[ra+9]=ua.y,ab[ra+10]=ua.z,ab[ra+11]=ua.w,ra+=12;0<ra&&(j.bindBuffer(j.ARRAY_BUFFER,w.__webglSkinIndicesBuffer),j.bufferData(j.ARRAY_BUFFER,ab,F),j.bindBuffer(j.ARRAY_BUFFER,w.__webglSkinWeightsBuffer),j.bufferData(j.ARRAY_BUFFER,\nbb,F))}if(Lb&&L){A=0;for(I=aa.length;A<I;A++)K=lb[aa[A]],T=K.vertexColors,W=K.color,3===T.length&&L===THREE.VertexColors?(Ja=T[0],ea=T[1],fa=T[2]):fa=ea=Ja=W,kb[eb]=Ja.r,kb[eb+1]=Ja.g,kb[eb+2]=Ja.b,kb[eb+3]=ea.r,kb[eb+4]=ea.g,kb[eb+5]=ea.b,kb[eb+6]=fa.r,kb[eb+7]=fa.g,kb[eb+8]=fa.b,eb+=9;0<eb&&(j.bindBuffer(j.ARRAY_BUFFER,w.__webglColorBuffer),j.bufferData(j.ARRAY_BUFFER,kb,F))}if(Kb&&Qa.hasTangents){A=0;for(I=aa.length;A<I;A++)K=lb[aa[A]],oa=K.vertexTangents,Ea=oa[0],Ta=oa[1],ba=oa[2],$a[Ya]=Ea.x,\n$a[Ya+1]=Ea.y,$a[Ya+2]=Ea.z,$a[Ya+3]=Ea.w,$a[Ya+4]=Ta.x,$a[Ya+5]=Ta.y,$a[Ya+6]=Ta.z,$a[Ya+7]=Ta.w,$a[Ya+8]=ba.x,$a[Ya+9]=ba.y,$a[Ya+10]=ba.z,$a[Ya+11]=ba.w,Ya+=12;j.bindBuffer(j.ARRAY_BUFFER,w.__webglTangentBuffer);j.bufferData(j.ARRAY_BUFFER,$a,F)}if(Jb&&H){A=0;for(I=aa.length;A<I;A++)if(K=lb[aa[A]],P=K.vertexNormals,U=K.normal,3===P.length&&O)for(Ia=0;3>Ia;Ia++)Ba=P[Ia],Wa[ib]=Ba.x,Wa[ib+1]=Ba.y,Wa[ib+2]=Ba.z,ib+=3;else for(Ia=0;3>Ia;Ia++)Wa[ib]=U.x,Wa[ib+1]=U.y,Wa[ib+2]=U.z,ib+=3;j.bindBuffer(j.ARRAY_BUFFER,\nw.__webglNormalBuffer);j.bufferData(j.ARRAY_BUFFER,Wa,F)}if(Ab&&Cb&&N){A=0;for(I=aa.length;A<I;A++)if(Q=aa[A],va=Cb[Q],void 0!==va)for(Ia=0;3>Ia;Ia++)Ka=va[Ia],Za[Pa]=Ka.x,Za[Pa+1]=Ka.y,Pa+=2;0<Pa&&(j.bindBuffer(j.ARRAY_BUFFER,w.__webglUVBuffer),j.bufferData(j.ARRAY_BUFFER,Za,F))}if(Ab&&Db&&N){A=0;for(I=aa.length;A<I;A++)if(Q=aa[A],sa=Db[Q],void 0!==sa)for(Ia=0;3>Ia;Ia++)Ga=sa[Ia],db[Ua]=Ga.x,db[Ua+1]=Ga.y,Ua+=2;0<Ua&&(j.bindBuffer(j.ARRAY_BUFFER,w.__webglUV2Buffer),j.bufferData(j.ARRAY_BUFFER,db,\nF))}if(Bb){A=0;for(I=aa.length;A<I;A++)Nb[Va]=xa,Nb[Va+1]=xa+1,Nb[Va+2]=xa+2,Va+=3,ub[La]=xa,ub[La+1]=xa+1,ub[La+2]=xa,ub[La+3]=xa+2,ub[La+4]=xa+1,ub[La+5]=xa+2,La+=6,xa+=3;j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,w.__webglFaceBuffer);j.bufferData(j.ELEMENT_ARRAY_BUFFER,Nb,F);j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,w.__webglLineBuffer);j.bufferData(j.ELEMENT_ARRAY_BUFFER,ub,F)}if(tb){Ia=0;for(Fa=tb.length;Ia<Fa;Ia++)if(J=tb[Ia],J.__original.needsUpdate){M=0;if(1===J.size)if(void 0===J.boundTo||\"vertices\"===\nJ.boundTo){A=0;for(I=aa.length;A<I;A++)K=lb[aa[A]],J.array[M]=J.value[K.a],J.array[M+1]=J.value[K.b],J.array[M+2]=J.value[K.c],M+=3}else{if(\"faces\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)Xa=J.value[aa[A]],J.array[M]=Xa,J.array[M+1]=Xa,J.array[M+2]=Xa,M+=3}}else if(2===J.size)if(void 0===J.boundTo||\"vertices\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)K=lb[aa[A]],Y=J.value[K.a],Z=J.value[K.b],X=J.value[K.c],J.array[M]=Y.x,J.array[M+1]=Y.y,J.array[M+2]=Z.x,J.array[M+3]=Z.y,J.array[M+4]=X.x,J.array[M+\n5]=X.y,M+=6}else{if(\"faces\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)X=Z=Y=Xa=J.value[aa[A]],J.array[M]=Y.x,J.array[M+1]=Y.y,J.array[M+2]=Z.x,J.array[M+3]=Z.y,J.array[M+4]=X.x,J.array[M+5]=X.y,M+=6}}else if(3===J.size){var na;na=\"c\"===J.type?[\"r\",\"g\",\"b\"]:[\"x\",\"y\",\"z\"];if(void 0===J.boundTo||\"vertices\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)K=lb[aa[A]],Y=J.value[K.a],Z=J.value[K.b],X=J.value[K.c],J.array[M]=Y[na[0]],J.array[M+1]=Y[na[1]],J.array[M+2]=Y[na[2]],J.array[M+3]=Z[na[0]],J.array[M+4]=\nZ[na[1]],J.array[M+5]=Z[na[2]],J.array[M+6]=X[na[0]],J.array[M+7]=X[na[1]],J.array[M+8]=X[na[2]],M+=9}else if(\"faces\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)X=Z=Y=Xa=J.value[aa[A]],J.array[M]=Y[na[0]],J.array[M+1]=Y[na[1]],J.array[M+2]=Y[na[2]],J.array[M+3]=Z[na[0]],J.array[M+4]=Z[na[1]],J.array[M+5]=Z[na[2]],J.array[M+6]=X[na[0]],J.array[M+7]=X[na[1]],J.array[M+8]=X[na[2]],M+=9}else if(\"faceVertices\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)Xa=J.value[aa[A]],Y=Xa[0],Z=Xa[1],X=Xa[2],J.array[M]=\nY[na[0]],J.array[M+1]=Y[na[1]],J.array[M+2]=Y[na[2]],J.array[M+3]=Z[na[0]],J.array[M+4]=Z[na[1]],J.array[M+5]=Z[na[2]],J.array[M+6]=X[na[0]],J.array[M+7]=X[na[1]],J.array[M+8]=X[na[2]],M+=9}}else if(4===J.size)if(void 0===J.boundTo||\"vertices\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)K=lb[aa[A]],Y=J.value[K.a],Z=J.value[K.b],X=J.value[K.c],J.array[M]=Y.x,J.array[M+1]=Y.y,J.array[M+2]=Y.z,J.array[M+3]=Y.w,J.array[M+4]=Z.x,J.array[M+5]=Z.y,J.array[M+6]=Z.z,J.array[M+7]=Z.w,J.array[M+8]=X.x,J.array[M+\n9]=X.y,J.array[M+10]=X.z,J.array[M+11]=X.w,M+=12}else if(\"faces\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)X=Z=Y=Xa=J.value[aa[A]],J.array[M]=Y.x,J.array[M+1]=Y.y,J.array[M+2]=Y.z,J.array[M+3]=Y.w,J.array[M+4]=Z.x,J.array[M+5]=Z.y,J.array[M+6]=Z.z,J.array[M+7]=Z.w,J.array[M+8]=X.x,J.array[M+9]=X.y,J.array[M+10]=X.z,J.array[M+11]=X.w,M+=12}else if(\"faceVertices\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)Xa=J.value[aa[A]],Y=Xa[0],Z=Xa[1],X=Xa[2],J.array[M]=Y.x,J.array[M+1]=Y.y,J.array[M+2]=Y.z,J.array[M+\n3]=Y.w,J.array[M+4]=Z.x,J.array[M+5]=Z.y,J.array[M+6]=Z.z,J.array[M+7]=Z.w,J.array[M+8]=X.x,J.array[M+9]=X.y,J.array[M+10]=X.z,J.array[M+11]=X.w,M+=12}j.bindBuffer(j.ARRAY_BUFFER,J.buffer);j.bufferData(j.ARRAY_BUFFER,J.array,F)}}E&&(delete w.__inittedArrays,delete w.__colorArray,delete w.__normalArray,delete w.__tangentArray,delete w.__uvArray,delete w.__uv2Array,delete w.__faceArray,delete w.__vertexArray,delete w.__lineArray,delete w.__skinIndexArray,delete w.__skinWeightArray)}}l.verticesNeedUpdate=\n!1;l.morphTargetsNeedUpdate=!1;l.elementsNeedUpdate=!1;l.uvsNeedUpdate=!1;l.normalsNeedUpdate=!1;l.colorsNeedUpdate=!1;l.tangentsNeedUpdate=!1;l.buffersNeedUpdate=!1;r.attributes&&q(r)}else if(i instanceof THREE.Line){r=d(i,l);p=r.attributes&&m(r);if(l.verticesNeedUpdate||l.colorsNeedUpdate||l.lineDistancesNeedUpdate||p){var cb=l,Qb=j.DYNAMIC_DRAW,Fb=void 0,Gb=void 0,Hb=void 0,Rb=void 0,ma=void 0,Sb=void 0,hc=cb.vertices,ic=cb.colors,jc=cb.lineDistances,Xb=hc.length,Yb=ic.length,Zb=jc.length,Tb=cb.__vertexArray,\nUb=cb.__colorArray,kc=cb.__lineDistanceArray,$b=cb.colorsNeedUpdate,ac=cb.lineDistancesNeedUpdate,dc=cb.__webglCustomAttributesList,Vb=void 0,lc=void 0,Da=void 0,yb=void 0,Ra=void 0,ka=void 0;if(cb.verticesNeedUpdate){for(Fb=0;Fb<Xb;Fb++)Rb=hc[Fb],ma=3*Fb,Tb[ma]=Rb.x,Tb[ma+1]=Rb.y,Tb[ma+2]=Rb.z;j.bindBuffer(j.ARRAY_BUFFER,cb.__webglVertexBuffer);j.bufferData(j.ARRAY_BUFFER,Tb,Qb)}if($b){for(Gb=0;Gb<Yb;Gb++)Sb=ic[Gb],ma=3*Gb,Ub[ma]=Sb.r,Ub[ma+1]=Sb.g,Ub[ma+2]=Sb.b;j.bindBuffer(j.ARRAY_BUFFER,cb.__webglColorBuffer);\nj.bufferData(j.ARRAY_BUFFER,Ub,Qb)}if(ac){for(Hb=0;Hb<Zb;Hb++)kc[Hb]=jc[Hb];j.bindBuffer(j.ARRAY_BUFFER,cb.__webglLineDistanceBuffer);j.bufferData(j.ARRAY_BUFFER,kc,Qb)}if(dc){Vb=0;for(lc=dc.length;Vb<lc;Vb++)if(ka=dc[Vb],ka.needsUpdate&&(void 0===ka.boundTo||\"vertices\"===ka.boundTo)){ma=0;yb=ka.value.length;if(1===ka.size)for(Da=0;Da<yb;Da++)ka.array[Da]=ka.value[Da];else if(2===ka.size)for(Da=0;Da<yb;Da++)Ra=ka.value[Da],ka.array[ma]=Ra.x,ka.array[ma+1]=Ra.y,ma+=2;else if(3===ka.size)if(\"c\"===ka.type)for(Da=\n0;Da<yb;Da++)Ra=ka.value[Da],ka.array[ma]=Ra.r,ka.array[ma+1]=Ra.g,ka.array[ma+2]=Ra.b,ma+=3;else for(Da=0;Da<yb;Da++)Ra=ka.value[Da],ka.array[ma]=Ra.x,ka.array[ma+1]=Ra.y,ka.array[ma+2]=Ra.z,ma+=3;else if(4===ka.size)for(Da=0;Da<yb;Da++)Ra=ka.value[Da],ka.array[ma]=Ra.x,ka.array[ma+1]=Ra.y,ka.array[ma+2]=Ra.z,ka.array[ma+3]=Ra.w,ma+=4;j.bindBuffer(j.ARRAY_BUFFER,ka.buffer);j.bufferData(j.ARRAY_BUFFER,ka.array,Qb)}}}l.verticesNeedUpdate=!1;l.colorsNeedUpdate=!1;l.lineDistancesNeedUpdate=!1;r.attributes&&\nq(r)}else if(i instanceof THREE.ParticleSystem){r=d(i,l);p=r.attributes&&m(r);if(l.verticesNeedUpdate||l.colorsNeedUpdate||i.sortParticles||p){var mb=l,ec=j.DYNAMIC_DRAW,Ib=i,Sa=void 0,nb=void 0,ob=void 0,S=void 0,pb=void 0,sb=void 0,Wb=mb.vertices,fc=Wb.length,gc=mb.colors,mc=gc.length,vb=mb.__vertexArray,wb=mb.__colorArray,qb=mb.__sortArray,nc=mb.verticesNeedUpdate,oc=mb.colorsNeedUpdate,rb=mb.__webglCustomAttributesList,fb=void 0,zb=void 0,$=void 0,gb=void 0,ga=void 0,R=void 0;if(Ib.sortParticles){pa.copy(V);\npa.multiply(Ib.matrixWorld);for(Sa=0;Sa<fc;Sa++)ob=Wb[Sa],ja.copy(ob),ja.applyProjection(pa),qb[Sa]=[ja.z,Sa];qb.sort(k);for(Sa=0;Sa<fc;Sa++)ob=Wb[qb[Sa][1]],S=3*Sa,vb[S]=ob.x,vb[S+1]=ob.y,vb[S+2]=ob.z;for(nb=0;nb<mc;nb++)S=3*nb,sb=gc[qb[nb][1]],wb[S]=sb.r,wb[S+1]=sb.g,wb[S+2]=sb.b;if(rb){fb=0;for(zb=rb.length;fb<zb;fb++)if(R=rb[fb],void 0===R.boundTo||\"vertices\"===R.boundTo)if(S=0,gb=R.value.length,1===R.size)for($=0;$<gb;$++)pb=qb[$][1],R.array[$]=R.value[pb];else if(2===R.size)for($=0;$<gb;$++)pb=\nqb[$][1],ga=R.value[pb],R.array[S]=ga.x,R.array[S+1]=ga.y,S+=2;else if(3===R.size)if(\"c\"===R.type)for($=0;$<gb;$++)pb=qb[$][1],ga=R.value[pb],R.array[S]=ga.r,R.array[S+1]=ga.g,R.array[S+2]=ga.b,S+=3;else for($=0;$<gb;$++)pb=qb[$][1],ga=R.value[pb],R.array[S]=ga.x,R.array[S+1]=ga.y,R.array[S+2]=ga.z,S+=3;else if(4===R.size)for($=0;$<gb;$++)pb=qb[$][1],ga=R.value[pb],R.array[S]=ga.x,R.array[S+1]=ga.y,R.array[S+2]=ga.z,R.array[S+3]=ga.w,S+=4}}else{if(nc)for(Sa=0;Sa<fc;Sa++)ob=Wb[Sa],S=3*Sa,vb[S]=ob.x,\nvb[S+1]=ob.y,vb[S+2]=ob.z;if(oc)for(nb=0;nb<mc;nb++)sb=gc[nb],S=3*nb,wb[S]=sb.r,wb[S+1]=sb.g,wb[S+2]=sb.b;if(rb){fb=0;for(zb=rb.length;fb<zb;fb++)if(R=rb[fb],R.needsUpdate&&(void 0===R.boundTo||\"vertices\"===R.boundTo))if(gb=R.value.length,S=0,1===R.size)for($=0;$<gb;$++)R.array[$]=R.value[$];else if(2===R.size)for($=0;$<gb;$++)ga=R.value[$],R.array[S]=ga.x,R.array[S+1]=ga.y,S+=2;else if(3===R.size)if(\"c\"===R.type)for($=0;$<gb;$++)ga=R.value[$],R.array[S]=ga.r,R.array[S+1]=ga.g,R.array[S+2]=ga.b,S+=\n3;else for($=0;$<gb;$++)ga=R.value[$],R.array[S]=ga.x,R.array[S+1]=ga.y,R.array[S+2]=ga.z,S+=3;else if(4===R.size)for($=0;$<gb;$++)ga=R.value[$],R.array[S]=ga.x,R.array[S+1]=ga.y,R.array[S+2]=ga.z,R.array[S+3]=ga.w,S+=4}}if(nc||Ib.sortParticles)j.bindBuffer(j.ARRAY_BUFFER,mb.__webglVertexBuffer),j.bufferData(j.ARRAY_BUFFER,vb,ec);if(oc||Ib.sortParticles)j.bindBuffer(j.ARRAY_BUFFER,mb.__webglColorBuffer),j.bufferData(j.ARRAY_BUFFER,wb,ec);if(rb){fb=0;for(zb=rb.length;fb<zb;fb++)if(R=rb[fb],R.needsUpdate||\nIb.sortParticles)j.bindBuffer(j.ARRAY_BUFFER,R.buffer),j.bufferData(j.ARRAY_BUFFER,R.array,ec)}}l.verticesNeedUpdate=!1;l.colorsNeedUpdate=!1;r.attributes&&q(r)}}};this.initMaterial=function(a,b,c,d){var e,f,g,h;a.addEventListener(\"dispose\",Cb);var i,k,l,m,n;a instanceof THREE.MeshDepthMaterial?n=\"depth\":a instanceof THREE.MeshNormalMaterial?n=\"normal\":a instanceof THREE.MeshBasicMaterial?n=\"basic\":a instanceof THREE.MeshLambertMaterial?n=\"lambert\":a instanceof THREE.MeshPhongMaterial?n=\"phong\":a instanceof\nTHREE.LineBasicMaterial?n=\"basic\":a instanceof THREE.LineDashedMaterial?n=\"dashed\":a instanceof THREE.ParticleSystemMaterial&&(n=\"particle_basic\");if(n){var p=THREE.ShaderLib[n];a.uniforms=THREE.UniformsUtils.clone(p.uniforms);a.vertexShader=p.vertexShader;a.fragmentShader=p.fragmentShader}var q=e=0,r=0,t=p=0;for(f=b.length;t<f;t++)g=b[t],g.onlyShadow||(g instanceof THREE.DirectionalLight&&e++,g instanceof THREE.PointLight&&q++,g instanceof THREE.SpotLight&&r++,g instanceof THREE.HemisphereLight&&\np++);f=q;g=r;h=p;r=p=0;for(q=b.length;r<q;r++)t=b[r],t.castShadow&&(t instanceof THREE.SpotLight&&p++,t instanceof THREE.DirectionalLight&&!t.shadowCascade&&p++);m=p;tb&&d&&d.useVertexTexture?l=1024:(b=j.getParameter(j.MAX_VERTEX_UNIFORM_VECTORS),b=Math.floor((b-20)/4),void 0!==d&&d instanceof THREE.SkinnedMesh&&(b=Math.min(d.bones.length,b),b<d.bones.length&&console.warn(\"WebGLRenderer: too many bones - \"+d.bones.length+\", this GPU supports just \"+b+\" (try OpenGL instead of ANGLE)\")),l=b);a:{var r=\na.fragmentShader,q=a.vertexShader,p=a.uniforms,b=a.attributes,t=a.defines,c={map:!!a.map,envMap:!!a.envMap,lightMap:!!a.lightMap,bumpMap:!!a.bumpMap,normalMap:!!a.normalMap,specularMap:!!a.specularMap,vertexColors:a.vertexColors,fog:c,useFog:a.fog,fogExp:c instanceof THREE.FogExp2,sizeAttenuation:a.sizeAttenuation,skinning:a.skinning,maxBones:l,useVertexTexture:tb&&d&&d.useVertexTexture,morphTargets:a.morphTargets,morphNormals:a.morphNormals,maxMorphTargets:this.maxMorphTargets,maxMorphNormals:this.maxMorphNormals,\nmaxDirLights:e,maxPointLights:f,maxSpotLights:g,maxHemiLights:h,maxShadows:m,shadowMapEnabled:this.shadowMapEnabled&&d.receiveShadow,shadowMapType:this.shadowMapType,shadowMapDebug:this.shadowMapDebug,shadowMapCascade:this.shadowMapCascade,alphaTest:a.alphaTest,metal:a.metal,perPixel:a.perPixel,wrapAround:a.wrapAround,doubleSided:a.side===THREE.DoubleSide,flipSided:a.side===THREE.BackSide},d=a.index0AttributeName,s,u,v;e=[];n?e.push(n):(e.push(r),e.push(q));for(u in t)e.push(u),e.push(t[u]);for(s in c)e.push(s),\ne.push(c[s]);n=e.join();s=0;for(u=P.length;s<u;s++)if(e=P[s],e.code===n){e.usedTimes++;k=e.program;break a}s=\"SHADOWMAP_TYPE_BASIC\";c.shadowMapType===THREE.PCFShadowMap?s=\"SHADOWMAP_TYPE_PCF\":c.shadowMapType===THREE.PCFSoftShadowMap&&(s=\"SHADOWMAP_TYPE_PCF_SOFT\");u=[];for(v in t)e=t[v],!1!==e&&(e=\"#define \"+v+\" \"+e,u.push(e));e=u.join(\"\\n\");v=j.createProgram();u=[\"precision \"+K+\" float;\",\"precision \"+K+\" int;\",e,xb?\"#define VERTEX_TEXTURES\":\"\",I.gammaInput?\"#define GAMMA_INPUT\":\"\",I.gammaOutput?\"#define GAMMA_OUTPUT\":\n\"\",\"#define MAX_DIR_LIGHTS \"+c.maxDirLights,\"#define MAX_POINT_LIGHTS \"+c.maxPointLights,\"#define MAX_SPOT_LIGHTS \"+c.maxSpotLights,\"#define MAX_HEMI_LIGHTS \"+c.maxHemiLights,\"#define MAX_SHADOWS \"+c.maxShadows,\"#define MAX_BONES \"+c.maxBones,c.map?\"#define USE_MAP\":\"\",c.envMap?\"#define USE_ENVMAP\":\"\",c.lightMap?\"#define USE_LIGHTMAP\":\"\",c.bumpMap?\"#define USE_BUMPMAP\":\"\",c.normalMap?\"#define USE_NORMALMAP\":\"\",c.specularMap?\"#define USE_SPECULARMAP\":\"\",c.vertexColors?\"#define USE_COLOR\":\"\",c.skinning?\n\"#define USE_SKINNING\":\"\",c.useVertexTexture?\"#define BONE_TEXTURE\":\"\",c.morphTargets?\"#define USE_MORPHTARGETS\":\"\",c.morphNormals?\"#define USE_MORPHNORMALS\":\"\",c.perPixel?\"#define PHONG_PER_PIXEL\":\"\",c.wrapAround?\"#define WRAP_AROUND\":\"\",c.doubleSided?\"#define DOUBLE_SIDED\":\"\",c.flipSided?\"#define FLIP_SIDED\":\"\",c.shadowMapEnabled?\"#define USE_SHADOWMAP\":\"\",c.shadowMapEnabled?\"#define \"+s:\"\",c.shadowMapDebug?\"#define SHADOWMAP_DEBUG\":\"\",c.shadowMapCascade?\"#define SHADOWMAP_CASCADE\":\"\",c.sizeAttenuation?\n\"#define USE_SIZEATTENUATION\":\"\",\"uniform mat4 modelMatrix;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\nuniform vec3 cameraPosition;\\nattribute vec3 position;\\nattribute vec3 normal;\\nattribute vec2 uv;\\nattribute vec2 uv2;\\n#ifdef USE_COLOR\\nattribute vec3 color;\\n#endif\\n#ifdef USE_MORPHTARGETS\\nattribute vec3 morphTarget0;\\nattribute vec3 morphTarget1;\\nattribute vec3 morphTarget2;\\nattribute vec3 morphTarget3;\\n#ifdef USE_MORPHNORMALS\\nattribute vec3 morphNormal0;\\nattribute vec3 morphNormal1;\\nattribute vec3 morphNormal2;\\nattribute vec3 morphNormal3;\\n#else\\nattribute vec3 morphTarget4;\\nattribute vec3 morphTarget5;\\nattribute vec3 morphTarget6;\\nattribute vec3 morphTarget7;\\n#endif\\n#endif\\n#ifdef USE_SKINNING\\nattribute vec4 skinIndex;\\nattribute vec4 skinWeight;\\n#endif\\n\"].join(\"\\n\");\ns=[\"precision \"+K+\" float;\",\"precision \"+K+\" int;\",c.bumpMap||c.normalMap?\"#extension GL_OES_standard_derivatives : enable\":\"\",e,\"#define MAX_DIR_LIGHTS \"+c.maxDirLights,\"#define MAX_POINT_LIGHTS \"+c.maxPointLights,\"#define MAX_SPOT_LIGHTS \"+c.maxSpotLights,\"#define MAX_HEMI_LIGHTS \"+c.maxHemiLights,\"#define MAX_SHADOWS \"+c.maxShadows,c.alphaTest?\"#define ALPHATEST \"+c.alphaTest:\"\",I.gammaInput?\"#define GAMMA_INPUT\":\"\",I.gammaOutput?\"#define GAMMA_OUTPUT\":\"\",c.useFog&&c.fog?\"#define USE_FOG\":\"\",c.useFog&&\nc.fogExp?\"#define FOG_EXP2\":\"\",c.map?\"#define USE_MAP\":\"\",c.envMap?\"#define USE_ENVMAP\":\"\",c.lightMap?\"#define USE_LIGHTMAP\":\"\",c.bumpMap?\"#define USE_BUMPMAP\":\"\",c.normalMap?\"#define USE_NORMALMAP\":\"\",c.specularMap?\"#define USE_SPECULARMAP\":\"\",c.vertexColors?\"#define USE_COLOR\":\"\",c.metal?\"#define METAL\":\"\",c.perPixel?\"#define PHONG_PER_PIXEL\":\"\",c.wrapAround?\"#define WRAP_AROUND\":\"\",c.doubleSided?\"#define DOUBLE_SIDED\":\"\",c.flipSided?\"#define FLIP_SIDED\":\"\",c.shadowMapEnabled?\"#define USE_SHADOWMAP\":\n\"\",c.shadowMapEnabled?\"#define \"+s:\"\",c.shadowMapDebug?\"#define SHADOWMAP_DEBUG\":\"\",c.shadowMapCascade?\"#define SHADOWMAP_CASCADE\":\"\",\"uniform mat4 viewMatrix;\\nuniform vec3 cameraPosition;\\n\"].join(\"\\n\");u=L(\"vertex\",u+q);s=L(\"fragment\",s+r);j.attachShader(v,u);j.attachShader(v,s);d&&j.bindAttribLocation(v,0,d);j.linkProgram(v);j.getProgramParameter(v,j.LINK_STATUS)||(console.error(\"Could not initialise shader\\nVALIDATE_STATUS: \"+j.getProgramParameter(v,j.VALIDATE_STATUS)+\", gl error [\"+j.getError()+\n\"]\"),console.error(\"Program Info Log: \"+j.getProgramInfoLog(v)));j.deleteShader(s);j.deleteShader(u);v.uniforms={};v.attributes={};var w;s=\"viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences\".split(\" \");c.useVertexTexture?(s.push(\"boneTexture\"),s.push(\"boneTextureWidth\"),s.push(\"boneTextureHeight\")):s.push(\"boneGlobalMatrices\");for(w in p)s.push(w);w=s;s=0;for(u=w.length;s<u;s++)p=w[s],v.uniforms[p]=j.getUniformLocation(v,p);s=\"position normal uv uv2 tangent color skinIndex skinWeight lineDistance\".split(\" \");\nfor(w=0;w<c.maxMorphTargets;w++)s.push(\"morphTarget\"+w);for(w=0;w<c.maxMorphNormals;w++)s.push(\"morphNormal\"+w);for(k in b)s.push(k);k=s;w=0;for(b=k.length;w<b;w++)s=k[w],v.attributes[s]=j.getAttribLocation(v,s);v.id=Q++;P.push({program:v,code:n,usedTimes:1});I.info.memory.programs=P.length;k=v}a.program=k;w=a.program.attributes;if(a.morphTargets){a.numSupportedMorphTargets=0;b=\"morphTarget\";for(k=0;k<this.maxMorphTargets;k++)v=b+k,0<=w[v]&&a.numSupportedMorphTargets++}if(a.morphNormals){a.numSupportedMorphNormals=\n0;b=\"morphNormal\";for(k=0;k<this.maxMorphNormals;k++)v=b+k,0<=w[v]&&a.numSupportedMorphNormals++}a.uniformsList=[];for(i in a.uniforms)a.uniformsList.push([a.uniforms[i],i])};this.setFaceCulling=function(a,b){a===THREE.CullFaceNone?j.disable(j.CULL_FACE):(b===THREE.FrontFaceDirectionCW?j.frontFace(j.CW):j.frontFace(j.CCW),a===THREE.CullFaceBack?j.cullFace(j.BACK):a===THREE.CullFaceFront?j.cullFace(j.FRONT):j.cullFace(j.FRONT_AND_BACK),j.enable(j.CULL_FACE))};this.setMaterialFaces=function(a){var b=\na.side===THREE.DoubleSide,a=a.side===THREE.BackSide;sa!==b&&(b?j.disable(j.CULL_FACE):j.enable(j.CULL_FACE),sa=b);Aa!==a&&(a?j.frontFace(j.CW):j.frontFace(j.CCW),Aa=a)};this.setDepthTest=function(a){ca!==a&&(a?j.enable(j.DEPTH_TEST):j.disable(j.DEPTH_TEST),ca=a)};this.setDepthWrite=function(a){wa!==a&&(j.depthMask(a),wa=a)};this.setBlending=function(a,b,c,d){a!==ba&&(a===THREE.NoBlending?j.disable(j.BLEND):a===THREE.AdditiveBlending?(j.enable(j.BLEND),j.blendEquation(j.FUNC_ADD),j.blendFunc(j.SRC_ALPHA,\nj.ONE)):a===THREE.SubtractiveBlending?(j.enable(j.BLEND),j.blendEquation(j.FUNC_ADD),j.blendFunc(j.ZERO,j.ONE_MINUS_SRC_COLOR)):a===THREE.MultiplyBlending?(j.enable(j.BLEND),j.blendEquation(j.FUNC_ADD),j.blendFunc(j.ZERO,j.SRC_COLOR)):a===THREE.CustomBlending?j.enable(j.BLEND):(j.enable(j.BLEND),j.blendEquationSeparate(j.FUNC_ADD,j.FUNC_ADD),j.blendFuncSeparate(j.SRC_ALPHA,j.ONE_MINUS_SRC_ALPHA,j.ONE,j.ONE_MINUS_SRC_ALPHA)),ba=a);if(a===THREE.CustomBlending){if(b!==W&&(j.blendEquation(D(b)),W=b),\nc!==Ka||d!==U)j.blendFunc(D(c),D(d)),Ka=c,U=d}else U=Ka=W=null};this.setTexture=function(a,b){if(a.needsUpdate){a.__webglInit||(a.__webglInit=!0,a.addEventListener(\"dispose\",Bb),a.__webglTexture=j.createTexture(),I.info.memory.textures++);j.activeTexture(j.TEXTURE0+b);j.bindTexture(j.TEXTURE_2D,a.__webglTexture);j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL,a.flipY);j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL,a.premultiplyAlpha);j.pixelStorei(j.UNPACK_ALIGNMENT,a.unpackAlignment);var c=a.image,d=0===(c.width&\nc.width-1)&&0===(c.height&c.height-1),e=D(a.format),f=D(a.type);w(j.TEXTURE_2D,a,d);var g=a.mipmaps;if(a instanceof THREE.DataTexture)if(0<g.length&&d){for(var h=0,i=g.length;h<i;h++)c=g[h],j.texImage2D(j.TEXTURE_2D,h,e,c.width,c.height,0,e,f,c.data);a.generateMipmaps=!1}else j.texImage2D(j.TEXTURE_2D,0,e,c.width,c.height,0,e,f,c.data);else if(a instanceof THREE.CompressedTexture){h=0;for(i=g.length;h<i;h++)c=g[h],a.format!==THREE.RGBAFormat?j.compressedTexImage2D(j.TEXTURE_2D,h,e,c.width,c.height,\n0,c.data):j.texImage2D(j.TEXTURE_2D,h,e,c.width,c.height,0,e,f,c.data)}else if(0<g.length&&d){h=0;for(i=g.length;h<i;h++)c=g[h],j.texImage2D(j.TEXTURE_2D,h,e,e,f,c);a.generateMipmaps=!1}else j.texImage2D(j.TEXTURE_2D,0,e,e,f,a.image);a.generateMipmaps&&d&&j.generateMipmap(j.TEXTURE_2D);a.needsUpdate=!1;if(a.onUpdate)a.onUpdate()}else j.activeTexture(j.TEXTURE0+b),j.bindTexture(j.TEXTURE_2D,a.__webglTexture)};this.setRenderTarget=function(a){var b=a instanceof THREE.WebGLRenderTargetCube;if(a&&!a.__webglFramebuffer){void 0===\na.depthBuffer&&(a.depthBuffer=!0);void 0===a.stencilBuffer&&(a.stencilBuffer=!0);a.addEventListener(\"dispose\",Mb);a.__webglTexture=j.createTexture();I.info.memory.textures++;var c=0===(a.width&a.width-1)&&0===(a.height&a.height-1),d=D(a.format),e=D(a.type);if(b){a.__webglFramebuffer=[];a.__webglRenderbuffer=[];j.bindTexture(j.TEXTURE_CUBE_MAP,a.__webglTexture);w(j.TEXTURE_CUBE_MAP,a,c);for(var f=0;6>f;f++){a.__webglFramebuffer[f]=j.createFramebuffer();a.__webglRenderbuffer[f]=j.createRenderbuffer();\nj.texImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X+f,0,d,a.width,a.height,0,d,e,null);var g=a,h=j.TEXTURE_CUBE_MAP_POSITIVE_X+f;j.bindFramebuffer(j.FRAMEBUFFER,a.__webglFramebuffer[f]);j.framebufferTexture2D(j.FRAMEBUFFER,j.COLOR_ATTACHMENT0,h,g.__webglTexture,0);E(a.__webglRenderbuffer[f],a)}c&&j.generateMipmap(j.TEXTURE_CUBE_MAP)}else a.__webglFramebuffer=j.createFramebuffer(),a.__webglRenderbuffer=a.shareDepthFrom?a.shareDepthFrom.__webglRenderbuffer:j.createRenderbuffer(),j.bindTexture(j.TEXTURE_2D,a.__webglTexture),\nw(j.TEXTURE_2D,a,c),j.texImage2D(j.TEXTURE_2D,0,d,a.width,a.height,0,d,e,null),d=j.TEXTURE_2D,j.bindFramebuffer(j.FRAMEBUFFER,a.__webglFramebuffer),j.framebufferTexture2D(j.FRAMEBUFFER,j.COLOR_ATTACHMENT0,d,a.__webglTexture,0),a.shareDepthFrom?a.depthBuffer&&!a.stencilBuffer?j.framebufferRenderbuffer(j.FRAMEBUFFER,j.DEPTH_ATTACHMENT,j.RENDERBUFFER,a.__webglRenderbuffer):a.depthBuffer&&a.stencilBuffer&&j.framebufferRenderbuffer(j.FRAMEBUFFER,j.DEPTH_STENCIL_ATTACHMENT,j.RENDERBUFFER,a.__webglRenderbuffer):\nE(a.__webglRenderbuffer,a),c&&j.generateMipmap(j.TEXTURE_2D);b?j.bindTexture(j.TEXTURE_CUBE_MAP,null):j.bindTexture(j.TEXTURE_2D,null);j.bindRenderbuffer(j.RENDERBUFFER,null);j.bindFramebuffer(j.FRAMEBUFFER,null)}a?(b=b?a.__webglFramebuffer[a.activeCubeFace]:a.__webglFramebuffer,c=a.width,a=a.height,e=d=0):(b=null,c=Ba,a=xa,d=Fa,e=Ga);b!==va&&(j.bindFramebuffer(j.FRAMEBUFFER,b),j.viewport(d,e,c,a),va=b);Va=c;La=a};this.shadowMapPlugin=new THREE.ShadowMapPlugin;this.addPrePlugin(this.shadowMapPlugin);\nthis.addPostPlugin(new THREE.SpritePlugin);this.addPostPlugin(new THREE.LensFlarePlugin)};THREE.WebGLRenderTarget=function(a,b,c){this.width=a;this.height=b;c=c||{};this.wrapS=void 0!==c.wrapS?c.wrapS:THREE.ClampToEdgeWrapping;this.wrapT=void 0!==c.wrapT?c.wrapT:THREE.ClampToEdgeWrapping;this.magFilter=void 0!==c.magFilter?c.magFilter:THREE.LinearFilter;this.minFilter=void 0!==c.minFilter?c.minFilter:THREE.LinearMipMapLinearFilter;this.anisotropy=void 0!==c.anisotropy?c.anisotropy:1;this.offset=new THREE.Vector2(0,0);this.repeat=new THREE.Vector2(1,1);this.format=void 0!==c.format?c.format:\nTHREE.RGBAFormat;this.type=void 0!==c.type?c.type:THREE.UnsignedByteType;this.depthBuffer=void 0!==c.depthBuffer?c.depthBuffer:!0;this.stencilBuffer=void 0!==c.stencilBuffer?c.stencilBuffer:!0;this.generateMipmaps=!0;this.shareDepthFrom=null};\nTHREE.WebGLRenderTarget.prototype={constructor:THREE.WebGLRenderTarget,clone:function(){var a=new THREE.WebGLRenderTarget(this.width,this.height);a.wrapS=this.wrapS;a.wrapT=this.wrapT;a.magFilter=this.magFilter;a.minFilter=this.minFilter;a.anisotropy=this.anisotropy;a.offset.copy(this.offset);a.repeat.copy(this.repeat);a.format=this.format;a.type=this.type;a.depthBuffer=this.depthBuffer;a.stencilBuffer=this.stencilBuffer;a.generateMipmaps=this.generateMipmaps;a.shareDepthFrom=this.shareDepthFrom;\nreturn a},dispose:function(){this.dispatchEvent({type:\"dispose\"})}};THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);THREE.WebGLRenderTargetCube=function(a,b,c){THREE.WebGLRenderTarget.call(this,a,b,c);this.activeCubeFace=0};THREE.WebGLRenderTargetCube.prototype=Object.create(THREE.WebGLRenderTarget.prototype);THREE.RenderableVertex=function(){this.position=new THREE.Vector3;this.positionWorld=new THREE.Vector3;this.positionScreen=new THREE.Vector4;this.visible=!0};THREE.RenderableVertex.prototype.copy=function(a){this.positionWorld.copy(a.positionWorld);this.positionScreen.copy(a.positionScreen)};THREE.RenderableFace3=function(){this.id=0;this.v1=new THREE.RenderableVertex;this.v2=new THREE.RenderableVertex;this.v3=new THREE.RenderableVertex;this.centroidModel=new THREE.Vector3;this.normalModel=new THREE.Vector3;this.normalModelView=new THREE.Vector3;this.vertexNormalsLength=0;this.vertexNormalsModel=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];this.vertexNormalsModelView=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];this.material=this.color=null;this.uvs=[[]];this.z=\n0};THREE.RenderableObject=function(){this.id=0;this.object=null;this.z=0};THREE.RenderableSprite=function(){this.id=0;this.object=null;this.rotation=this.z=this.y=this.x=0;this.scale=new THREE.Vector2;this.material=null};THREE.RenderableLine=function(){this.id=0;this.v1=new THREE.RenderableVertex;this.v2=new THREE.RenderableVertex;this.vertexColors=[new THREE.Color,new THREE.Color];this.material=null;this.z=0};THREE.GeometryUtils={merge:function(a,b,c){var d,e,f=a.vertices.length,g=b instanceof THREE.Mesh?b.geometry:b,h=a.vertices,i=g.vertices,k=a.faces,l=g.faces,a=a.faceVertexUvs[0],g=g.faceVertexUvs[0];void 0===c&&(c=0);b instanceof THREE.Mesh&&(b.matrixAutoUpdate&&b.updateMatrix(),d=b.matrix,e=(new THREE.Matrix3).getNormalMatrix(d));for(var b=0,n=i.length;b<n;b++){var p=i[b].clone();d&&p.applyMatrix4(d);h.push(p)}b=0;for(n=l.length;b<n;b++){var p=l[b],t,r,m=p.vertexNormals,q=p.vertexColors;t=new THREE.Face3(p.a+\nf,p.b+f,p.c+f);t.normal.copy(p.normal);e&&t.normal.applyMatrix3(e).normalize();h=0;for(i=m.length;h<i;h++)r=m[h].clone(),e&&r.applyMatrix3(e).normalize(),t.vertexNormals.push(r);t.color.copy(p.color);h=0;for(i=q.length;h<i;h++)r=q[h],t.vertexColors.push(r.clone());t.materialIndex=p.materialIndex+c;t.centroid.copy(p.centroid);d&&t.centroid.applyMatrix4(d);k.push(t)}b=0;for(n=g.length;b<n;b++){c=g[b];d=[];h=0;for(i=c.length;h<i;h++)d.push(new THREE.Vector2(c[h].x,c[h].y));a.push(d)}},randomPointInTriangle:function(){var a=\nnew THREE.Vector3;return function(b,c,d){var e=new THREE.Vector3,f=THREE.Math.random16(),g=THREE.Math.random16();1<f+g&&(f=1-f,g=1-g);var h=1-f-g;e.copy(b);e.multiplyScalar(f);a.copy(c);a.multiplyScalar(g);e.add(a);a.copy(d);a.multiplyScalar(h);e.add(a);return e}}(),randomPointInFace:function(a,b){return THREE.GeometryUtils.randomPointInTriangle(b.vertices[a.a],b.vertices[a.b],b.vertices[a.c])},randomPointsInGeometry:function(a,b){function c(a){function b(c,d){if(d<c)return c;var e=c+Math.floor((d-\nc)/2);return k[e]>a?b(c,e-1):k[e]<a?b(e+1,d):e}return b(0,k.length-1)}var d,e,f=a.faces,g=a.vertices,h=f.length,i=0,k=[],l,n,p;for(e=0;e<h;e++)d=f[e],l=g[d.a],n=g[d.b],p=g[d.c],d._area=THREE.GeometryUtils.triangleArea(l,n,p),i+=d._area,k[e]=i;d=[];for(e=0;e<b;e++)g=THREE.Math.random16()*i,g=c(g),d[e]=THREE.GeometryUtils.randomPointInFace(f[g],a,!0);return d},triangleArea:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d,e){a.subVectors(d,c);b.subVectors(e,c);a.cross(b);return 0.5*\na.length()}}(),center:function(a){a.computeBoundingBox();var b=a.boundingBox,c=new THREE.Vector3;c.addVectors(b.min,b.max);c.multiplyScalar(-0.5);a.applyMatrix((new THREE.Matrix4).makeTranslation(c.x,c.y,c.z));a.computeBoundingBox();return c},triangulateQuads:function(a){var b,c,d,e,f=[],g=[];b=0;for(c=a.faceVertexUvs.length;b<c;b++)g[b]=[];b=0;for(c=a.faces.length;b<c;b++){f.push(a.faces[b]);d=0;for(e=a.faceVertexUvs.length;d<e;d++)g[d].push(a.faceVertexUvs[d][b])}a.faces=f;a.faceVertexUvs=g;a.computeCentroids();\na.computeFaceNormals();a.computeVertexNormals();a.hasTangents&&a.computeTangents()}};THREE.ImageUtils={crossOrigin:void 0,loadTexture:function(a,b,c){var d=new THREE.ImageLoader;d.crossOrigin=this.crossOrigin;var e=new THREE.Texture(void 0,b),b=d.load(a,function(){e.needsUpdate=!0;c&&c(e)});e.image=b;e.sourceFile=a;return e},loadCompressedTexture:function(a,b,c,d){var e=new THREE.CompressedTexture;e.mapping=b;var f=new XMLHttpRequest;f.onload=function(){var a=THREE.ImageUtils.parseDDS(f.response,!0);e.format=a.format;e.mipmaps=a.mipmaps;e.image.width=a.width;e.image.height=a.height;\ne.generateMipmaps=!1;e.needsUpdate=!0;c&&c(e)};f.onerror=d;f.open(\"GET\",a,!0);f.responseType=\"arraybuffer\";f.send(null);return e},loadTextureCube:function(a,b,c,d){var e=[];e.loadCount=0;var f=new THREE.Texture;f.image=e;void 0!==b&&(f.mapping=b);f.flipY=!1;for(var b=0,g=a.length;b<g;++b){var h=new Image;e[b]=h;h.onload=function(){e.loadCount+=1;6===e.loadCount&&(f.needsUpdate=!0,c&&c(f))};h.onerror=d;h.crossOrigin=this.crossOrigin;h.src=a[b]}return f},loadCompressedTextureCube:function(a,b,c,d){var e=\n[];e.loadCount=0;var f=new THREE.CompressedTexture;f.image=e;void 0!==b&&(f.mapping=b);f.flipY=!1;f.generateMipmaps=!1;b=function(a,b){return function(){var d=THREE.ImageUtils.parseDDS(a.response,!0);b.format=d.format;b.mipmaps=d.mipmaps;b.width=d.width;b.height=d.height;e.loadCount+=1;6===e.loadCount&&(f.format=d.format,f.needsUpdate=!0,c&&c(f))}};if(a instanceof Array)for(var g=0,h=a.length;g<h;++g){var i={};e[g]=i;var k=new XMLHttpRequest;k.onload=b(k,i);k.onerror=d;i=a[g];k.open(\"GET\",i,!0);k.responseType=\n\"arraybuffer\";k.send(null)}else k=new XMLHttpRequest,k.onload=function(){var a=THREE.ImageUtils.parseDDS(k.response,!0);if(a.isCubemap){for(var b=a.mipmaps.length/a.mipmapCount,d=0;d<b;d++){e[d]={mipmaps:[]};for(var g=0;g<a.mipmapCount;g++)e[d].mipmaps.push(a.mipmaps[d*a.mipmapCount+g]),e[d].format=a.format,e[d].width=a.width,e[d].height=a.height}f.format=a.format;f.needsUpdate=!0;c&&c(f)}},k.onerror=d,k.open(\"GET\",a,!0),k.responseType=\"arraybuffer\",k.send(null);return f},loadDDSTexture:function(a,\nb,c,d){var e=[];e.loadCount=0;var f=new THREE.CompressedTexture;f.image=e;void 0!==b&&(f.mapping=b);f.flipY=!1;f.generateMipmaps=!1;var g=new XMLHttpRequest;g.onload=function(){var a=THREE.ImageUtils.parseDDS(g.response,!0);if(a.isCubemap)for(var b=a.mipmaps.length/a.mipmapCount,d=0;d<b;d++){e[d]={mipmaps:[]};for(var l=0;l<a.mipmapCount;l++)e[d].mipmaps.push(a.mipmaps[d*a.mipmapCount+l]),e[d].format=a.format,e[d].width=a.width,e[d].height=a.height}else f.image.width=a.width,f.image.height=a.height,\nf.mipmaps=a.mipmaps;f.format=a.format;f.needsUpdate=!0;c&&c(f)};g.onerror=d;g.open(\"GET\",a,!0);g.responseType=\"arraybuffer\";g.send(null);return f},parseDDS:function(a,b){function c(a){return a.charCodeAt(0)+(a.charCodeAt(1)<<8)+(a.charCodeAt(2)<<16)+(a.charCodeAt(3)<<24)}var d={mipmaps:[],width:0,height:0,format:null,mipmapCount:1},e=c(\"DXT1\"),f=c(\"DXT3\"),g=c(\"DXT5\"),h=new Int32Array(a,0,31);if(542327876!==h[0])return console.error(\"ImageUtils.parseDDS(): Invalid magic number in DDS header\"),d;if(!h[20]&\n4)return console.error(\"ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code\"),d;var i=h[21],k=!1;switch(i){case e:e=8;d.format=THREE.RGB_S3TC_DXT1_Format;break;case f:e=16;d.format=THREE.RGBA_S3TC_DXT3_Format;break;case g:e=16;d.format=THREE.RGBA_S3TC_DXT5_Format;break;default:if(32==h[22]&&h[23]&16711680&&h[24]&65280&&h[25]&255&&h[26]&4278190080)k=!0,e=64,d.format=THREE.RGBAFormat;else return console.error(\"ImageUtils.parseDDS(): Unsupported FourCC code: \",String.fromCharCode(i&\n255,i>>8&255,i>>16&255,i>>24&255)),d}d.mipmapCount=1;h[2]&131072&&!1!==b&&(d.mipmapCount=Math.max(1,h[7]));d.isCubemap=h[28]&512?!0:!1;d.width=h[4];d.height=h[3];for(var h=h[1]+4,f=d.width,g=d.height,i=d.isCubemap?6:1,l=0;l<i;l++){for(var n=0;n<d.mipmapCount;n++){if(k){var p;p=f;for(var t=g,r=4*p*t,m=new Uint8Array(a,h,r),r=new Uint8Array(r),q=0,u=0,s=0;s<t;s++)for(var v=0;v<p;v++){var z=m[u];u++;var G=m[u];u++;var N=m[u];u++;var C=m[u];u++;r[q]=N;q++;r[q]=G;q++;r[q]=z;q++;r[q]=C;q++}p=r;t=p.length}else t=\nMath.max(4,f)/4*Math.max(4,g)/4*e,p=new Uint8Array(a,h,t);d.mipmaps.push({data:p,width:f,height:g});h+=t;f=Math.max(0.5*f,1);g=Math.max(0.5*g,1)}f=d.width;g=d.height}return d},getNormalMap:function(a,b){var c=function(a){var b=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);return[a[0]/b,a[1]/b,a[2]/b]},b=b|1,d=a.width,e=a.height,f=document.createElement(\"canvas\");f.width=d;f.height=e;var g=f.getContext(\"2d\");g.drawImage(a,0,0);for(var h=g.getImageData(0,0,d,e).data,i=g.createImageData(d,e),k=i.data,l=0;l<\nd;l++)for(var n=0;n<e;n++){var p=0>n-1?0:n-1,t=n+1>e-1?e-1:n+1,r=0>l-1?0:l-1,m=l+1>d-1?d-1:l+1,q=[],u=[0,0,h[4*(n*d+l)]/255*b];q.push([-1,0,h[4*(n*d+r)]/255*b]);q.push([-1,-1,h[4*(p*d+r)]/255*b]);q.push([0,-1,h[4*(p*d+l)]/255*b]);q.push([1,-1,h[4*(p*d+m)]/255*b]);q.push([1,0,h[4*(n*d+m)]/255*b]);q.push([1,1,h[4*(t*d+m)]/255*b]);q.push([0,1,h[4*(t*d+l)]/255*b]);q.push([-1,1,h[4*(t*d+r)]/255*b]);p=[];r=q.length;for(t=0;t<r;t++){var m=q[t],s=q[(t+1)%r],m=[m[0]-u[0],m[1]-u[1],m[2]-u[2]],s=[s[0]-u[0],\ns[1]-u[1],s[2]-u[2]];p.push(c([m[1]*s[2]-m[2]*s[1],m[2]*s[0]-m[0]*s[2],m[0]*s[1]-m[1]*s[0]]))}q=[0,0,0];for(t=0;t<p.length;t++)q[0]+=p[t][0],q[1]+=p[t][1],q[2]+=p[t][2];q[0]/=p.length;q[1]/=p.length;q[2]/=p.length;u=4*(n*d+l);k[u]=255*((q[0]+1)/2)|0;k[u+1]=255*((q[1]+1)/2)|0;k[u+2]=255*q[2]|0;k[u+3]=255}g.putImageData(i,0,0);return f},generateDataTexture:function(a,b,c){for(var d=a*b,e=new Uint8Array(3*d),f=Math.floor(255*c.r),g=Math.floor(255*c.g),c=Math.floor(255*c.b),h=0;h<d;h++)e[3*h]=f,e[3*h+\n1]=g,e[3*h+2]=c;a=new THREE.DataTexture(e,a,b,THREE.RGBFormat);a.needsUpdate=!0;return a}};THREE.SceneUtils={createMultiMaterialObject:function(a,b){for(var c=new THREE.Object3D,d=0,e=b.length;d<e;d++)c.add(new THREE.Mesh(a,b[d]));return c},detach:function(a,b,c){a.applyMatrix(b.matrixWorld);b.remove(a);c.add(a)},attach:function(a,b,c){var d=new THREE.Matrix4;d.getInverse(c.matrixWorld);a.applyMatrix(d);b.remove(a);c.add(a)}};THREE.FontUtils={faces:{},face:\"helvetiker\",weight:\"normal\",style:\"normal\",size:150,divisions:10,getFace:function(){return this.faces[this.face][this.weight][this.style]},loadFace:function(a){var b=a.familyName.toLowerCase();this.faces[b]=this.faces[b]||{};this.faces[b][a.cssFontWeight]=this.faces[b][a.cssFontWeight]||{};this.faces[b][a.cssFontWeight][a.cssFontStyle]=a;return this.faces[b][a.cssFontWeight][a.cssFontStyle]=a},drawText:function(a){for(var b=this.getFace(),c=this.size/b.resolution,d=\n0,e=String(a).split(\"\"),f=e.length,g=[],a=0;a<f;a++){var h=new THREE.Path,h=this.extractGlyphPoints(e[a],b,c,d,h),d=d+h.offset;g.push(h.path)}return{paths:g,offset:d/2}},extractGlyphPoints:function(a,b,c,d,e){var f=[],g,h,i,k,l,n,p,t,r,m,q,u=b.glyphs[a]||b.glyphs[\"?\"];if(u){if(u.o){b=u._cachedOutline||(u._cachedOutline=u.o.split(\" \"));k=b.length;for(a=0;a<k;)switch(i=b[a++],i){case \"m\":i=b[a++]*c+d;l=b[a++]*c;e.moveTo(i,l);break;case \"l\":i=b[a++]*c+d;l=b[a++]*c;e.lineTo(i,l);break;case \"q\":i=b[a++]*\nc+d;l=b[a++]*c;t=b[a++]*c+d;r=b[a++]*c;e.quadraticCurveTo(t,r,i,l);if(g=f[f.length-1]){n=g.x;p=g.y;g=1;for(h=this.divisions;g<=h;g++){var s=g/h;THREE.Shape.Utils.b2(s,n,t,i);THREE.Shape.Utils.b2(s,p,r,l)}}break;case \"b\":if(i=b[a++]*c+d,l=b[a++]*c,t=b[a++]*c+d,r=b[a++]*-c,m=b[a++]*c+d,q=b[a++]*-c,e.bezierCurveTo(i,l,t,r,m,q),g=f[f.length-1]){n=g.x;p=g.y;g=1;for(h=this.divisions;g<=h;g++)s=g/h,THREE.Shape.Utils.b3(s,n,t,m,i),THREE.Shape.Utils.b3(s,p,r,q,l)}}}return{offset:u.ha*c,path:e}}}};\nTHREE.FontUtils.generateShapes=function(a,b){var b=b||{},c=void 0!==b.curveSegments?b.curveSegments:4,d=void 0!==b.font?b.font:\"helvetiker\",e=void 0!==b.weight?b.weight:\"normal\",f=void 0!==b.style?b.style:\"normal\";THREE.FontUtils.size=void 0!==b.size?b.size:100;THREE.FontUtils.divisions=c;THREE.FontUtils.face=d;THREE.FontUtils.weight=e;THREE.FontUtils.style=f;c=THREE.FontUtils.drawText(a).paths;d=[];e=0;for(f=c.length;e<f;e++)Array.prototype.push.apply(d,c[e].toShapes());return d};\n(function(a){var b=function(a){for(var b=a.length,e=0,f=b-1,g=0;g<b;f=g++)e+=a[f].x*a[g].y-a[g].x*a[f].y;return 0.5*e};a.Triangulate=function(a,d){var e=a.length;if(3>e)return null;var f=[],g=[],h=[],i,k,l;if(0<b(a))for(k=0;k<e;k++)g[k]=k;else for(k=0;k<e;k++)g[k]=e-1-k;var n=2*e;for(k=e-1;2<e;){if(0>=n--){console.log(\"Warning, unable to triangulate polygon!\");break}i=k;e<=i&&(i=0);k=i+1;e<=k&&(k=0);l=k+1;e<=l&&(l=0);var p;a:{var t=p=void 0,r=void 0,m=void 0,q=void 0,u=void 0,s=void 0,v=void 0,z=\nvoid 0,t=a[g[i]].x,r=a[g[i]].y,m=a[g[k]].x,q=a[g[k]].y,u=a[g[l]].x,s=a[g[l]].y;if(1E-10>(m-t)*(s-r)-(q-r)*(u-t))p=!1;else{var G=void 0,N=void 0,C=void 0,B=void 0,x=void 0,F=void 0,L=void 0,w=void 0,E=void 0,y=void 0,E=w=L=z=v=void 0,G=u-m,N=s-q,C=t-u,B=r-s,x=m-t,F=q-r;for(p=0;p<e;p++)if(!(p===i||p===k||p===l))if(v=a[g[p]].x,z=a[g[p]].y,L=v-t,w=z-r,E=v-m,y=z-q,v-=u,z-=s,E=G*y-N*E,L=x*w-F*L,w=C*z-B*v,-1E-10<=E&&-1E-10<=w&&-1E-10<=L){p=!1;break a}p=!0}}if(p){f.push([a[g[i]],a[g[k]],a[g[l]]]);h.push([g[i],\ng[k],g[l]]);i=k;for(l=k+1;l<e;i++,l++)g[i]=g[l];e--;n=2*e}}return d?h:f};a.Triangulate.area=b;return a})(THREE.FontUtils);self._typeface_js={faces:THREE.FontUtils.faces,loadFace:THREE.FontUtils.loadFace};THREE.typeface_js=self._typeface_js;THREE.Curve=function(){};THREE.Curve.prototype.getPoint=function(){console.log(\"Warning, getPoint() not implemented!\");return null};THREE.Curve.prototype.getPointAt=function(a){a=this.getUtoTmapping(a);return this.getPoint(a)};THREE.Curve.prototype.getPoints=function(a){a||(a=5);var b,c=[];for(b=0;b<=a;b++)c.push(this.getPoint(b/a));return c};THREE.Curve.prototype.getSpacedPoints=function(a){a||(a=5);var b,c=[];for(b=0;b<=a;b++)c.push(this.getPointAt(b/a));return c};\nTHREE.Curve.prototype.getLength=function(){var a=this.getLengths();return a[a.length-1]};THREE.Curve.prototype.getLengths=function(a){a||(a=this.__arcLengthDivisions?this.__arcLengthDivisions:200);if(this.cacheArcLengths&&this.cacheArcLengths.length==a+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;var b=[],c,d=this.getPoint(0),e,f=0;b.push(0);for(e=1;e<=a;e++)c=this.getPoint(e/a),f+=c.distanceTo(d),b.push(f),d=c;return this.cacheArcLengths=b};\nTHREE.Curve.prototype.updateArcLengths=function(){this.needsUpdate=!0;this.getLengths()};THREE.Curve.prototype.getUtoTmapping=function(a,b){var c=this.getLengths(),d=0,e=c.length,f;f=b?b:a*c[e-1];for(var g=0,h=e-1,i;g<=h;)if(d=Math.floor(g+(h-g)/2),i=c[d]-f,0>i)g=d+1;else if(0<i)h=d-1;else{h=d;break}d=h;if(c[d]==f)return d/(e-1);g=c[d];return c=(d+(f-g)/(c[d+1]-g))/(e-1)};THREE.Curve.prototype.getTangent=function(a){var b=a-1E-4,a=a+1E-4;0>b&&(b=0);1<a&&(a=1);b=this.getPoint(b);return this.getPoint(a).clone().sub(b).normalize()};\nTHREE.Curve.prototype.getTangentAt=function(a){a=this.getUtoTmapping(a);return this.getTangent(a)};\nTHREE.Curve.Utils={tangentQuadraticBezier:function(a,b,c,d){return 2*(1-a)*(c-b)+2*a*(d-c)},tangentCubicBezier:function(a,b,c,d,e){return-3*b*(1-a)*(1-a)+3*c*(1-a)*(1-a)-6*a*c*(1-a)+6*a*d*(1-a)-3*a*a*d+3*a*a*e},tangentSpline:function(a){return 6*a*a-6*a+(3*a*a-4*a+1)+(-6*a*a+6*a)+(3*a*a-2*a)},interpolate:function(a,b,c,d,e){var a=0.5*(c-a),d=0.5*(d-b),f=e*e;return(2*b-2*c+a+d)*e*f+(-3*b+3*c-2*a-d)*f+a*e+b}};\nTHREE.Curve.create=function(a,b){a.prototype=Object.create(THREE.Curve.prototype);a.prototype.getPoint=b;return a};THREE.CurvePath=function(){this.curves=[];this.bends=[];this.autoClose=!1};THREE.CurvePath.prototype=Object.create(THREE.Curve.prototype);THREE.CurvePath.prototype.add=function(a){this.curves.push(a)};THREE.CurvePath.prototype.checkConnection=function(){};THREE.CurvePath.prototype.closePath=function(){var a=this.curves[0].getPoint(0),b=this.curves[this.curves.length-1].getPoint(1);a.equals(b)||this.curves.push(new THREE.LineCurve(b,a))};\nTHREE.CurvePath.prototype.getPoint=function(a){for(var b=a*this.getLength(),c=this.getCurveLengths(),a=0;a<c.length;){if(c[a]>=b)return b=c[a]-b,a=this.curves[a],b=1-b/a.getLength(),a.getPointAt(b);a++}return null};THREE.CurvePath.prototype.getLength=function(){var a=this.getCurveLengths();return a[a.length-1]};\nTHREE.CurvePath.prototype.getCurveLengths=function(){if(this.cacheLengths&&this.cacheLengths.length==this.curves.length)return this.cacheLengths;var a=[],b=0,c,d=this.curves.length;for(c=0;c<d;c++)b+=this.curves[c].getLength(),a.push(b);return this.cacheLengths=a};\nTHREE.CurvePath.prototype.getBoundingBox=function(){var a=this.getPoints(),b,c,d,e,f,g;b=c=Number.NEGATIVE_INFINITY;e=f=Number.POSITIVE_INFINITY;var h,i,k,l,n=a[0]instanceof THREE.Vector3;l=n?new THREE.Vector3:new THREE.Vector2;i=0;for(k=a.length;i<k;i++)h=a[i],h.x>b?b=h.x:h.x<e&&(e=h.x),h.y>c?c=h.y:h.y<f&&(f=h.y),n&&(h.z>d?d=h.z:h.z<g&&(g=h.z)),l.add(h);a={minX:e,minY:f,maxX:b,maxY:c,centroid:l.divideScalar(k)};n&&(a.maxZ=d,a.minZ=g);return a};\nTHREE.CurvePath.prototype.createPointsGeometry=function(a){a=this.getPoints(a,!0);return this.createGeometry(a)};THREE.CurvePath.prototype.createSpacedPointsGeometry=function(a){a=this.getSpacedPoints(a,!0);return this.createGeometry(a)};THREE.CurvePath.prototype.createGeometry=function(a){for(var b=new THREE.Geometry,c=0;c<a.length;c++)b.vertices.push(new THREE.Vector3(a[c].x,a[c].y,a[c].z||0));return b};THREE.CurvePath.prototype.addWrapPath=function(a){this.bends.push(a)};\nTHREE.CurvePath.prototype.getTransformedPoints=function(a,b){var c=this.getPoints(a),d,e;b||(b=this.bends);d=0;for(e=b.length;d<e;d++)c=this.getWrapPoints(c,b[d]);return c};THREE.CurvePath.prototype.getTransformedSpacedPoints=function(a,b){var c=this.getSpacedPoints(a),d,e;b||(b=this.bends);d=0;for(e=b.length;d<e;d++)c=this.getWrapPoints(c,b[d]);return c};\nTHREE.CurvePath.prototype.getWrapPoints=function(a,b){var c=this.getBoundingBox(),d,e,f,g,h,i;d=0;for(e=a.length;d<e;d++)f=a[d],g=f.x,h=f.y,i=g/c.maxX,i=b.getUtoTmapping(i,g),g=b.getPoint(i),i=b.getTangent(i),i.set(-i.y,i.x).multiplyScalar(h),f.x=g.x+i.x,f.y=g.y+i.y;return a};THREE.Gyroscope=function(){THREE.Object3D.call(this)};THREE.Gyroscope.prototype=Object.create(THREE.Object3D.prototype);\nTHREE.Gyroscope.prototype.updateMatrixWorld=function(a){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||a)this.parent?(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorld.decompose(this.translationWorld,this.quaternionWorld,this.scaleWorld),this.matrix.decompose(this.translationObject,this.quaternionObject,this.scaleObject),this.matrixWorld.compose(this.translationWorld,this.quaternionObject,this.scaleWorld)):this.matrixWorld.copy(this.matrix),\nthis.matrixWorldNeedsUpdate=!1,a=!0;for(var b=0,c=this.children.length;b<c;b++)this.children[b].updateMatrixWorld(a)};THREE.Gyroscope.prototype.translationWorld=new THREE.Vector3;THREE.Gyroscope.prototype.translationObject=new THREE.Vector3;THREE.Gyroscope.prototype.quaternionWorld=new THREE.Quaternion;THREE.Gyroscope.prototype.quaternionObject=new THREE.Quaternion;THREE.Gyroscope.prototype.scaleWorld=new THREE.Vector3;THREE.Gyroscope.prototype.scaleObject=new THREE.Vector3;THREE.Path=function(a){THREE.CurvePath.call(this);this.actions=[];a&&this.fromPoints(a)};THREE.Path.prototype=Object.create(THREE.CurvePath.prototype);THREE.PathActions={MOVE_TO:\"moveTo\",LINE_TO:\"lineTo\",QUADRATIC_CURVE_TO:\"quadraticCurveTo\",BEZIER_CURVE_TO:\"bezierCurveTo\",CSPLINE_THRU:\"splineThru\",ARC:\"arc\",ELLIPSE:\"ellipse\"};THREE.Path.prototype.fromPoints=function(a){this.moveTo(a[0].x,a[0].y);for(var b=1,c=a.length;b<c;b++)this.lineTo(a[b].x,a[b].y)};\nTHREE.Path.prototype.moveTo=function(a,b){var c=Array.prototype.slice.call(arguments);this.actions.push({action:THREE.PathActions.MOVE_TO,args:c})};THREE.Path.prototype.lineTo=function(a,b){var c=Array.prototype.slice.call(arguments),d=this.actions[this.actions.length-1].args,d=new THREE.LineCurve(new THREE.Vector2(d[d.length-2],d[d.length-1]),new THREE.Vector2(a,b));this.curves.push(d);this.actions.push({action:THREE.PathActions.LINE_TO,args:c})};\nTHREE.Path.prototype.quadraticCurveTo=function(a,b,c,d){var e=Array.prototype.slice.call(arguments),f=this.actions[this.actions.length-1].args,f=new THREE.QuadraticBezierCurve(new THREE.Vector2(f[f.length-2],f[f.length-1]),new THREE.Vector2(a,b),new THREE.Vector2(c,d));this.curves.push(f);this.actions.push({action:THREE.PathActions.QUADRATIC_CURVE_TO,args:e})};\nTHREE.Path.prototype.bezierCurveTo=function(a,b,c,d,e,f){var g=Array.prototype.slice.call(arguments),h=this.actions[this.actions.length-1].args,h=new THREE.CubicBezierCurve(new THREE.Vector2(h[h.length-2],h[h.length-1]),new THREE.Vector2(a,b),new THREE.Vector2(c,d),new THREE.Vector2(e,f));this.curves.push(h);this.actions.push({action:THREE.PathActions.BEZIER_CURVE_TO,args:g})};\nTHREE.Path.prototype.splineThru=function(a){var b=Array.prototype.slice.call(arguments),c=this.actions[this.actions.length-1].args,c=[new THREE.Vector2(c[c.length-2],c[c.length-1])];Array.prototype.push.apply(c,a);c=new THREE.SplineCurve(c);this.curves.push(c);this.actions.push({action:THREE.PathActions.CSPLINE_THRU,args:b})};THREE.Path.prototype.arc=function(a,b,c,d,e,f){var g=this.actions[this.actions.length-1].args;this.absarc(a+g[g.length-2],b+g[g.length-1],c,d,e,f)};\nTHREE.Path.prototype.absarc=function(a,b,c,d,e,f){this.absellipse(a,b,c,c,d,e,f)};THREE.Path.prototype.ellipse=function(a,b,c,d,e,f,g){var h=this.actions[this.actions.length-1].args;this.absellipse(a+h[h.length-2],b+h[h.length-1],c,d,e,f,g)};THREE.Path.prototype.absellipse=function(a,b,c,d,e,f,g){var h=Array.prototype.slice.call(arguments),i=new THREE.EllipseCurve(a,b,c,d,e,f,g);this.curves.push(i);i=i.getPoint(1);h.push(i.x);h.push(i.y);this.actions.push({action:THREE.PathActions.ELLIPSE,args:h})};\nTHREE.Path.prototype.getSpacedPoints=function(a){a||(a=40);for(var b=[],c=0;c<a;c++)b.push(this.getPoint(c/a));return b};\nTHREE.Path.prototype.getPoints=function(a,b){if(this.useSpacedPoints)return console.log(\"tata\"),this.getSpacedPoints(a,b);var a=a||12,c=[],d,e,f,g,h,i,k,l,n,p,t,r,m;d=0;for(e=this.actions.length;d<e;d++)switch(f=this.actions[d],g=f.action,f=f.args,g){case THREE.PathActions.MOVE_TO:c.push(new THREE.Vector2(f[0],f[1]));break;case THREE.PathActions.LINE_TO:c.push(new THREE.Vector2(f[0],f[1]));break;case THREE.PathActions.QUADRATIC_CURVE_TO:h=f[2];i=f[3];n=f[0];p=f[1];0<c.length?(g=c[c.length-1],t=g.x,\nr=g.y):(g=this.actions[d-1].args,t=g[g.length-2],r=g[g.length-1]);for(f=1;f<=a;f++)m=f/a,g=THREE.Shape.Utils.b2(m,t,n,h),m=THREE.Shape.Utils.b2(m,r,p,i),c.push(new THREE.Vector2(g,m));break;case THREE.PathActions.BEZIER_CURVE_TO:h=f[4];i=f[5];n=f[0];p=f[1];k=f[2];l=f[3];0<c.length?(g=c[c.length-1],t=g.x,r=g.y):(g=this.actions[d-1].args,t=g[g.length-2],r=g[g.length-1]);for(f=1;f<=a;f++)m=f/a,g=THREE.Shape.Utils.b3(m,t,n,k,h),m=THREE.Shape.Utils.b3(m,r,p,l,i),c.push(new THREE.Vector2(g,m));break;case THREE.PathActions.CSPLINE_THRU:g=\nthis.actions[d-1].args;m=[new THREE.Vector2(g[g.length-2],g[g.length-1])];g=a*f[0].length;m=m.concat(f[0]);m=new THREE.SplineCurve(m);for(f=1;f<=g;f++)c.push(m.getPointAt(f/g));break;case THREE.PathActions.ARC:h=f[0];i=f[1];p=f[2];k=f[3];g=f[4];n=!!f[5];t=g-k;r=2*a;for(f=1;f<=r;f++)m=f/r,n||(m=1-m),m=k+m*t,g=h+p*Math.cos(m),m=i+p*Math.sin(m),c.push(new THREE.Vector2(g,m));break;case THREE.PathActions.ELLIPSE:h=f[0];i=f[1];p=f[2];l=f[3];k=f[4];g=f[5];n=!!f[6];t=g-k;r=2*a;for(f=1;f<=r;f++)m=f/r,n||\n(m=1-m),m=k+m*t,g=h+p*Math.cos(m),m=i+l*Math.sin(m),c.push(new THREE.Vector2(g,m))}d=c[c.length-1];1E-10>Math.abs(d.x-c[0].x)&&1E-10>Math.abs(d.y-c[0].y)&&c.splice(c.length-1,1);b&&c.push(c[0]);return c};\nTHREE.Path.prototype.toShapes=function(a){var b,c,d,e,f=[],g=new THREE.Path;b=0;for(c=this.actions.length;b<c;b++)d=this.actions[b],e=d.args,d=d.action,d==THREE.PathActions.MOVE_TO&&0!=g.actions.length&&(f.push(g),g=new THREE.Path),g[d].apply(g,e);0!=g.actions.length&&f.push(g);if(0==f.length)return[];var h;e=[];if(1==f.length)return d=f[0],h=new THREE.Shape,h.actions=d.actions,h.curves=d.curves,e.push(h),e;b=!THREE.Shape.Utils.isClockWise(f[0].getPoints());if(a?!b:b){h=new THREE.Shape;b=0;for(c=\nf.length;b<c;b++)d=f[b],g=THREE.Shape.Utils.isClockWise(d.getPoints()),(g=a?!g:g)?(h.actions=d.actions,h.curves=d.curves,e.push(h),h=new THREE.Shape):h.holes.push(d)}else{h=void 0;b=0;for(c=f.length;b<c;b++)d=f[b],g=THREE.Shape.Utils.isClockWise(d.getPoints()),(g=a?!g:g)?(h&&e.push(h),h=new THREE.Shape,h.actions=d.actions,h.curves=d.curves):h.holes.push(d);e.push(h)}return e};THREE.Shape=function(){THREE.Path.apply(this,arguments);this.holes=[]};THREE.Shape.prototype=Object.create(THREE.Path.prototype);THREE.Shape.prototype.extrude=function(a){return new THREE.ExtrudeGeometry(this,a)};THREE.Shape.prototype.makeGeometry=function(a){return new THREE.ShapeGeometry(this,a)};THREE.Shape.prototype.getPointsHoles=function(a){var b,c=this.holes.length,d=[];for(b=0;b<c;b++)d[b]=this.holes[b].getTransformedPoints(a,this.bends);return d};\nTHREE.Shape.prototype.getSpacedPointsHoles=function(a){var b,c=this.holes.length,d=[];for(b=0;b<c;b++)d[b]=this.holes[b].getTransformedSpacedPoints(a,this.bends);return d};THREE.Shape.prototype.extractAllPoints=function(a){return{shape:this.getTransformedPoints(a),holes:this.getPointsHoles(a)}};THREE.Shape.prototype.extractPoints=function(a){return this.useSpacedPoints?this.extractAllSpacedPoints(a):this.extractAllPoints(a)};\nTHREE.Shape.prototype.extractAllSpacedPoints=function(a){return{shape:this.getTransformedSpacedPoints(a),holes:this.getSpacedPointsHoles(a)}};\nTHREE.Shape.Utils={removeHoles:function(a,b){var c=a.concat(),d=c.concat(),e,f,g,h,i,k,l,n,p,t,r=[];for(i=0;i<b.length;i++){k=b[i];Array.prototype.push.apply(d,k);f=Number.POSITIVE_INFINITY;for(e=0;e<k.length;e++){p=k[e];t=[];for(n=0;n<c.length;n++)l=c[n],l=p.distanceToSquared(l),t.push(l),l<f&&(f=l,g=e,h=n)}e=0<=h-1?h-1:c.length-1;f=0<=g-1?g-1:k.length-1;var m=[k[g],c[h],c[e]];n=THREE.FontUtils.Triangulate.area(m);var q=[k[g],k[f],c[h]];p=THREE.FontUtils.Triangulate.area(q);t=h;l=g;h+=1;g+=-1;0>\nh&&(h+=c.length);h%=c.length;0>g&&(g+=k.length);g%=k.length;e=0<=h-1?h-1:c.length-1;f=0<=g-1?g-1:k.length-1;m=[k[g],c[h],c[e]];m=THREE.FontUtils.Triangulate.area(m);q=[k[g],k[f],c[h]];q=THREE.FontUtils.Triangulate.area(q);n+p>m+q&&(h=t,g=l,0>h&&(h+=c.length),h%=c.length,0>g&&(g+=k.length),g%=k.length,e=0<=h-1?h-1:c.length-1,f=0<=g-1?g-1:k.length-1);n=c.slice(0,h);p=c.slice(h);t=k.slice(g);l=k.slice(0,g);f=[k[g],k[f],c[h]];r.push([k[g],c[h],c[e]]);r.push(f);c=n.concat(t).concat(l).concat(p)}return{shape:c,\nisolatedPts:r,allpoints:d}},triangulateShape:function(a,b){var c=THREE.Shape.Utils.removeHoles(a,b),d=c.allpoints,e=c.isolatedPts,c=THREE.FontUtils.Triangulate(c.shape,!1),f,g,h,i,k={};f=0;for(g=d.length;f<g;f++)i=d[f].x+\":\"+d[f].y,void 0!==k[i]&&console.log(\"Duplicate point\",i),k[i]=f;f=0;for(g=c.length;f<g;f++){h=c[f];for(d=0;3>d;d++)i=h[d].x+\":\"+h[d].y,i=k[i],void 0!==i&&(h[d]=i)}f=0;for(g=e.length;f<g;f++){h=e[f];for(d=0;3>d;d++)i=h[d].x+\":\"+h[d].y,i=k[i],void 0!==i&&(h[d]=i)}return c.concat(e)},\nisClockWise:function(a){return 0>THREE.FontUtils.Triangulate.area(a)},b2p0:function(a,b){var c=1-a;return c*c*b},b2p1:function(a,b){return 2*(1-a)*a*b},b2p2:function(a,b){return a*a*b},b2:function(a,b,c,d){return this.b2p0(a,b)+this.b2p1(a,c)+this.b2p2(a,d)},b3p0:function(a,b){var c=1-a;return c*c*c*b},b3p1:function(a,b){var c=1-a;return 3*c*c*a*b},b3p2:function(a,b){return 3*(1-a)*a*a*b},b3p3:function(a,b){return a*a*a*b},b3:function(a,b,c,d,e){return this.b3p0(a,b)+this.b3p1(a,c)+this.b3p2(a,d)+\nthis.b3p3(a,e)}};THREE.LineCurve=function(a,b){this.v1=a;this.v2=b};THREE.LineCurve.prototype=Object.create(THREE.Curve.prototype);THREE.LineCurve.prototype.getPoint=function(a){var b=this.v2.clone().sub(this.v1);b.multiplyScalar(a).add(this.v1);return b};THREE.LineCurve.prototype.getPointAt=function(a){return this.getPoint(a)};THREE.LineCurve.prototype.getTangent=function(){return this.v2.clone().sub(this.v1).normalize()};THREE.QuadraticBezierCurve=function(a,b,c){this.v0=a;this.v1=b;this.v2=c};THREE.QuadraticBezierCurve.prototype=Object.create(THREE.Curve.prototype);THREE.QuadraticBezierCurve.prototype.getPoint=function(a){var b;b=THREE.Shape.Utils.b2(a,this.v0.x,this.v1.x,this.v2.x);a=THREE.Shape.Utils.b2(a,this.v0.y,this.v1.y,this.v2.y);return new THREE.Vector2(b,a)};\nTHREE.QuadraticBezierCurve.prototype.getTangent=function(a){var b;b=THREE.Curve.Utils.tangentQuadraticBezier(a,this.v0.x,this.v1.x,this.v2.x);a=THREE.Curve.Utils.tangentQuadraticBezier(a,this.v0.y,this.v1.y,this.v2.y);b=new THREE.Vector2(b,a);b.normalize();return b};THREE.CubicBezierCurve=function(a,b,c,d){this.v0=a;this.v1=b;this.v2=c;this.v3=d};THREE.CubicBezierCurve.prototype=Object.create(THREE.Curve.prototype);THREE.CubicBezierCurve.prototype.getPoint=function(a){var b;b=THREE.Shape.Utils.b3(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);a=THREE.Shape.Utils.b3(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);return new THREE.Vector2(b,a)};\nTHREE.CubicBezierCurve.prototype.getTangent=function(a){var b;b=THREE.Curve.Utils.tangentCubicBezier(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);a=THREE.Curve.Utils.tangentCubicBezier(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);b=new THREE.Vector2(b,a);b.normalize();return b};THREE.SplineCurve=function(a){this.points=void 0==a?[]:a};THREE.SplineCurve.prototype=Object.create(THREE.Curve.prototype);THREE.SplineCurve.prototype.getPoint=function(a){var b=new THREE.Vector2,c=[],d=this.points,e;e=(d.length-1)*a;a=Math.floor(e);e-=a;c[0]=0==a?a:a-1;c[1]=a;c[2]=a>d.length-2?d.length-1:a+1;c[3]=a>d.length-3?d.length-1:a+2;b.x=THREE.Curve.Utils.interpolate(d[c[0]].x,d[c[1]].x,d[c[2]].x,d[c[3]].x,e);b.y=THREE.Curve.Utils.interpolate(d[c[0]].y,d[c[1]].y,d[c[2]].y,d[c[3]].y,e);return b};THREE.EllipseCurve=function(a,b,c,d,e,f,g){this.aX=a;this.aY=b;this.xRadius=c;this.yRadius=d;this.aStartAngle=e;this.aEndAngle=f;this.aClockwise=g};THREE.EllipseCurve.prototype=Object.create(THREE.Curve.prototype);\nTHREE.EllipseCurve.prototype.getPoint=function(a){var b;b=this.aEndAngle-this.aStartAngle;0>b&&(b+=2*Math.PI);b>2*Math.PI&&(b-=2*Math.PI);b=!0===this.aClockwise?this.aEndAngle+(1-a)*(2*Math.PI-b):this.aStartAngle+a*b;a=this.aX+this.xRadius*Math.cos(b);b=this.aY+this.yRadius*Math.sin(b);return new THREE.Vector2(a,b)};THREE.ArcCurve=function(a,b,c,d,e,f){THREE.EllipseCurve.call(this,a,b,c,c,d,e,f)};THREE.ArcCurve.prototype=Object.create(THREE.EllipseCurve.prototype);THREE.LineCurve3=THREE.Curve.create(function(a,b){this.v1=a;this.v2=b},function(a){var b=new THREE.Vector3;b.subVectors(this.v2,this.v1);b.multiplyScalar(a);b.add(this.v1);return b});THREE.QuadraticBezierCurve3=THREE.Curve.create(function(a,b,c){this.v0=a;this.v1=b;this.v2=c},function(a){var b,c;b=THREE.Shape.Utils.b2(a,this.v0.x,this.v1.x,this.v2.x);c=THREE.Shape.Utils.b2(a,this.v0.y,this.v1.y,this.v2.y);a=THREE.Shape.Utils.b2(a,this.v0.z,this.v1.z,this.v2.z);return new THREE.Vector3(b,c,a)});THREE.CubicBezierCurve3=THREE.Curve.create(function(a,b,c,d){this.v0=a;this.v1=b;this.v2=c;this.v3=d},function(a){var b,c;b=THREE.Shape.Utils.b3(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);c=THREE.Shape.Utils.b3(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);a=THREE.Shape.Utils.b3(a,this.v0.z,this.v1.z,this.v2.z,this.v3.z);return new THREE.Vector3(b,c,a)});THREE.SplineCurve3=THREE.Curve.create(function(a){this.points=void 0==a?[]:a},function(a){var b=new THREE.Vector3,c=[],d=this.points,e,a=(d.length-1)*a;e=Math.floor(a);a-=e;c[0]=0==e?e:e-1;c[1]=e;c[2]=e>d.length-2?d.length-1:e+1;c[3]=e>d.length-3?d.length-1:e+2;e=d[c[0]];var f=d[c[1]],g=d[c[2]],c=d[c[3]];b.x=THREE.Curve.Utils.interpolate(e.x,f.x,g.x,c.x,a);b.y=THREE.Curve.Utils.interpolate(e.y,f.y,g.y,c.y,a);b.z=THREE.Curve.Utils.interpolate(e.z,f.z,g.z,c.z,a);return b});THREE.ClosedSplineCurve3=THREE.Curve.create(function(a){this.points=void 0==a?[]:a},function(a){var b=new THREE.Vector3,c=[],d=this.points,e;e=(d.length-0)*a;a=Math.floor(e);e-=a;a+=0<a?0:(Math.floor(Math.abs(a)/d.length)+1)*d.length;c[0]=(a-1)%d.length;c[1]=a%d.length;c[2]=(a+1)%d.length;c[3]=(a+2)%d.length;b.x=THREE.Curve.Utils.interpolate(d[c[0]].x,d[c[1]].x,d[c[2]].x,d[c[3]].x,e);b.y=THREE.Curve.Utils.interpolate(d[c[0]].y,d[c[1]].y,d[c[2]].y,d[c[3]].y,e);b.z=THREE.Curve.Utils.interpolate(d[c[0]].z,\nd[c[1]].z,d[c[2]].z,d[c[3]].z,e);return b});THREE.AnimationHandler=function(){var a=[],b={},c={update:function(b){for(var c=0;c<a.length;c++)a[c].update(b)},addToUpdate:function(b){-1===a.indexOf(b)&&a.push(b)},removeFromUpdate:function(b){b=a.indexOf(b);-1!==b&&a.splice(b,1)},add:function(a){void 0!==b[a.name]&&console.log(\"THREE.AnimationHandler.add: Warning! \"+a.name+\" already exists in library. Overwriting.\");b[a.name]=a;if(!0!==a.initialized){for(var c=0;c<a.hierarchy.length;c++){for(var d=0;d<a.hierarchy[c].keys.length;d++)if(0>a.hierarchy[c].keys[d].time&&\n(a.hierarchy[c].keys[d].time=0),void 0!==a.hierarchy[c].keys[d].rot&&!(a.hierarchy[c].keys[d].rot instanceof THREE.Quaternion)){var h=a.hierarchy[c].keys[d].rot;a.hierarchy[c].keys[d].rot=new THREE.Quaternion(h[0],h[1],h[2],h[3])}if(a.hierarchy[c].keys.length&&void 0!==a.hierarchy[c].keys[0].morphTargets){h={};for(d=0;d<a.hierarchy[c].keys.length;d++)for(var i=0;i<a.hierarchy[c].keys[d].morphTargets.length;i++){var k=a.hierarchy[c].keys[d].morphTargets[i];h[k]=-1}a.hierarchy[c].usedMorphTargets=h;\nfor(d=0;d<a.hierarchy[c].keys.length;d++){var l={};for(k in h){for(i=0;i<a.hierarchy[c].keys[d].morphTargets.length;i++)if(a.hierarchy[c].keys[d].morphTargets[i]===k){l[k]=a.hierarchy[c].keys[d].morphTargetsInfluences[i];break}i===a.hierarchy[c].keys[d].morphTargets.length&&(l[k]=0)}a.hierarchy[c].keys[d].morphTargetsInfluences=l}}for(d=1;d<a.hierarchy[c].keys.length;d++)a.hierarchy[c].keys[d].time===a.hierarchy[c].keys[d-1].time&&(a.hierarchy[c].keys.splice(d,1),d--);for(d=0;d<a.hierarchy[c].keys.length;d++)a.hierarchy[c].keys[d].index=\nd}d=parseInt(a.length*a.fps,10);a.JIT={};a.JIT.hierarchy=[];for(c=0;c<a.hierarchy.length;c++)a.JIT.hierarchy.push(Array(d));a.initialized=!0}},get:function(a){if(\"string\"===typeof a){if(b[a])return b[a];console.log(\"THREE.AnimationHandler.get: Couldn't find animation \"+a);return null}},parse:function(a){var b=[];if(a instanceof THREE.SkinnedMesh)for(var c=0;c<a.bones.length;c++)b.push(a.bones[c]);else d(a,b);return b}},d=function(a,b){b.push(a);for(var c=0;c<a.children.length;c++)d(a.children[c],\nb)};c.LINEAR=0;c.CATMULLROM=1;c.CATMULLROM_FORWARD=2;return c}();THREE.Animation=function(a,b,c){this.root=a;this.data=THREE.AnimationHandler.get(b);this.hierarchy=THREE.AnimationHandler.parse(a);this.currentTime=0;this.timeScale=1;this.isPlaying=!1;this.loop=this.isPaused=!0;this.interpolationType=void 0!==c?c:THREE.AnimationHandler.LINEAR;this.points=[];this.target=new THREE.Vector3};\nTHREE.Animation.prototype.play=function(a,b){if(!1===this.isPlaying){this.isPlaying=!0;this.loop=void 0!==a?a:!0;this.currentTime=void 0!==b?b:0;var c,d=this.hierarchy.length,e;for(c=0;c<d;c++){e=this.hierarchy[c];e.matrixAutoUpdate=!0;void 0===e.animationCache&&(e.animationCache={},e.animationCache.prevKey={pos:0,rot:0,scl:0},e.animationCache.nextKey={pos:0,rot:0,scl:0},e.animationCache.originalMatrix=e instanceof THREE.Bone?e.skinMatrix:e.matrix);var f=e.animationCache.prevKey;e=e.animationCache.nextKey;\nf.pos=this.data.hierarchy[c].keys[0];f.rot=this.data.hierarchy[c].keys[0];f.scl=this.data.hierarchy[c].keys[0];e.pos=this.getNextKeyWith(\"pos\",c,1);e.rot=this.getNextKeyWith(\"rot\",c,1);e.scl=this.getNextKeyWith(\"scl\",c,1)}this.update(0)}this.isPaused=!1;THREE.AnimationHandler.addToUpdate(this)};THREE.Animation.prototype.pause=function(){!0===this.isPaused?THREE.AnimationHandler.addToUpdate(this):THREE.AnimationHandler.removeFromUpdate(this);this.isPaused=!this.isPaused};\nTHREE.Animation.prototype.stop=function(){this.isPaused=this.isPlaying=!1;THREE.AnimationHandler.removeFromUpdate(this)};\nTHREE.Animation.prototype.update=function(a){if(!1!==this.isPlaying){var b=[\"pos\",\"rot\",\"scl\"],c,d,e,f,g,h,i,k,l;for(l=this.currentTime+=a*this.timeScale;this.currentTime>this.data.length;)this.currentTime-=this.data.length;k=this.currentTime%=this.data.length;parseInt(Math.min(k*this.data.fps,this.data.length*this.data.fps),10);for(var n=0,p=this.hierarchy.length;n<p;n++){a=this.hierarchy[n];i=a.animationCache;for(var t=0;3>t;t++){c=b[t];g=i.prevKey[c];h=i.nextKey[c];if(h.time<=l){if(k<=l)if(this.loop){g=\nthis.data.hierarchy[n].keys[0];for(h=this.getNextKeyWith(c,n,1);null!==h&&h.time<k&&h.index>g.index;)g=h,h=this.getNextKeyWith(c,n,h.index+1)}else{this.stop();return}else{do g=h,h=this.getNextKeyWith(c,n,h.index+1);while(null!==h&&h.time<k&&h.index>g.index)}i.prevKey[c]=g;i.nextKey[c]=h}a.matrixAutoUpdate=!0;a.matrixWorldNeedsUpdate=!0;d=(k-g.time)/(h.time-g.time);e=g[c];f=h[c];if(0>d||1<d)console.log(\"THREE.Animation.update: Warning! Scale out of bounds:\"+d+\" on bone \"+n),d=0>d?0:1;if(\"pos\"===c)if(c=\na.position,this.interpolationType===THREE.AnimationHandler.LINEAR)c.x=e[0]+(f[0]-e[0])*d,c.y=e[1]+(f[1]-e[1])*d,c.z=e[2]+(f[2]-e[2])*d;else{if(this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD)this.points[0]=this.getPrevKeyWith(\"pos\",n,g.index-1).pos,this.points[1]=e,this.points[2]=f,this.points[3]=this.getNextKeyWith(\"pos\",n,h.index+1).pos,d=0.33*d+0.33,e=this.interpolateCatmullRom(this.points,d),c.x=e[0],c.y=e[1],c.z=e[2],\nthis.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD&&(d=this.interpolateCatmullRom(this.points,1.01*d),this.target.set(d[0],d[1],d[2]),this.target.sub(c),this.target.y=0,this.target.normalize(),d=Math.atan2(this.target.x,this.target.z),a.rotation.set(0,d,0))}else\"rot\"===c?THREE.Quaternion.slerp(e,f,a.quaternion,d):\"scl\"===c&&(c=a.scale,c.x=e[0]+(f[0]-e[0])*d,c.y=e[1]+(f[1]-e[1])*d,c.z=e[2]+(f[2]-e[2])*d)}}}};\nTHREE.Animation.prototype.interpolateCatmullRom=function(a,b){var c=[],d=[],e,f,g,h,i,k;e=(a.length-1)*b;f=Math.floor(e);e-=f;c[0]=0===f?f:f-1;c[1]=f;c[2]=f>a.length-2?f:f+1;c[3]=f>a.length-3?f:f+2;f=a[c[0]];h=a[c[1]];i=a[c[2]];k=a[c[3]];c=e*e;g=e*c;d[0]=this.interpolate(f[0],h[0],i[0],k[0],e,c,g);d[1]=this.interpolate(f[1],h[1],i[1],k[1],e,c,g);d[2]=this.interpolate(f[2],h[2],i[2],k[2],e,c,g);return d};\nTHREE.Animation.prototype.interpolate=function(a,b,c,d,e,f,g){a=0.5*(c-a);d=0.5*(d-b);return(2*(b-c)+a+d)*g+(-3*(b-c)-2*a-d)*f+a*e+b};THREE.Animation.prototype.getNextKeyWith=function(a,b,c){for(var d=this.data.hierarchy[b].keys,c=this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD?c<d.length-1?c:d.length-1:c%d.length;c<d.length;c++)if(void 0!==d[c][a])return d[c];return this.data.hierarchy[b].keys[0]};\nTHREE.Animation.prototype.getPrevKeyWith=function(a,b,c){for(var d=this.data.hierarchy[b].keys,c=this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD?0<c?c:0:0<=c?c:c+d.length;0<=c;c--)if(void 0!==d[c][a])return d[c];return this.data.hierarchy[b].keys[d.length-1]};THREE.KeyFrameAnimation=function(a,b,c){this.root=a;this.data=THREE.AnimationHandler.get(b);this.hierarchy=THREE.AnimationHandler.parse(a);this.currentTime=0;this.timeScale=0.001;this.isPlaying=!1;this.loop=this.isPaused=!0;this.JITCompile=void 0!==c?c:!0;a=0;for(b=this.hierarchy.length;a<b;a++){var c=this.data.hierarchy[a].sids,d=this.hierarchy[a];if(this.data.hierarchy[a].keys.length&&c){for(var e=0;e<c.length;e++){var f=c[e],g=this.getNextKeyWith(f,a,0);g&&g.apply(f)}d.matrixAutoUpdate=!1;this.data.hierarchy[a].node.updateMatrix();\nd.matrixWorldNeedsUpdate=!0}}};\nTHREE.KeyFrameAnimation.prototype.play=function(a,b){if(!this.isPlaying){this.isPlaying=!0;this.loop=void 0!==a?a:!0;this.currentTime=void 0!==b?b:0;this.startTimeMs=b;this.startTime=1E7;this.endTime=-this.startTime;var c,d=this.hierarchy.length,e,f;for(c=0;c<d;c++)e=this.hierarchy[c],f=this.data.hierarchy[c],void 0===f.animationCache&&(f.animationCache={},f.animationCache.prevKey=null,f.animationCache.nextKey=null,f.animationCache.originalMatrix=e instanceof THREE.Bone?e.skinMatrix:e.matrix),e=this.data.hierarchy[c].keys,\ne.length&&(f.animationCache.prevKey=e[0],f.animationCache.nextKey=e[1],this.startTime=Math.min(e[0].time,this.startTime),this.endTime=Math.max(e[e.length-1].time,this.endTime));this.update(0)}this.isPaused=!1;THREE.AnimationHandler.addToUpdate(this)};THREE.KeyFrameAnimation.prototype.pause=function(){this.isPaused?THREE.AnimationHandler.addToUpdate(this):THREE.AnimationHandler.removeFromUpdate(this);this.isPaused=!this.isPaused};\nTHREE.KeyFrameAnimation.prototype.stop=function(){this.isPaused=this.isPlaying=!1;THREE.AnimationHandler.removeFromUpdate(this);for(var a=0;a<this.data.hierarchy.length;a++){var b=this.hierarchy[a],c=this.data.hierarchy[a];if(void 0!==c.animationCache){var d=c.animationCache.originalMatrix;b instanceof THREE.Bone?(d.copy(b.skinMatrix),b.skinMatrix=d):(d.copy(b.matrix),b.matrix=d);delete c.animationCache}}};\nTHREE.KeyFrameAnimation.prototype.update=function(a){if(this.isPlaying){var b,c,d,e,f=this.data.JIT.hierarchy,g,h,i;h=this.currentTime+=a*this.timeScale;g=this.currentTime%=this.data.length;g<this.startTimeMs&&(g=this.currentTime=this.startTimeMs+g);e=parseInt(Math.min(g*this.data.fps,this.data.length*this.data.fps),10);if((i=g<h)&&!this.loop){for(var a=0,k=this.hierarchy.length;a<k;a++){var l=this.data.hierarchy[a].keys,f=this.data.hierarchy[a].sids;d=l.length-1;e=this.hierarchy[a];if(l.length){for(l=\n0;l<f.length;l++)g=f[l],(h=this.getPrevKeyWith(g,a,d))&&h.apply(g);this.data.hierarchy[a].node.updateMatrix();e.matrixWorldNeedsUpdate=!0}}this.stop()}else if(!(g<this.startTime)){a=0;for(k=this.hierarchy.length;a<k;a++){d=this.hierarchy[a];b=this.data.hierarchy[a];var l=b.keys,n=b.animationCache;if(this.JITCompile&&void 0!==f[a][e])d instanceof THREE.Bone?(d.skinMatrix=f[a][e],d.matrixWorldNeedsUpdate=!1):(d.matrix=f[a][e],d.matrixWorldNeedsUpdate=!0);else if(l.length){this.JITCompile&&n&&(d instanceof\nTHREE.Bone?d.skinMatrix=n.originalMatrix:d.matrix=n.originalMatrix);b=n.prevKey;c=n.nextKey;if(b&&c){if(c.time<=h){if(i&&this.loop){b=l[0];for(c=l[1];c.time<g;)b=c,c=l[b.index+1]}else if(!i)for(var p=l.length-1;c.time<g&&c.index!==p;)b=c,c=l[b.index+1];n.prevKey=b;n.nextKey=c}c.time>=g?b.interpolate(c,g):b.interpolate(c,c.time)}this.data.hierarchy[a].node.updateMatrix();d.matrixWorldNeedsUpdate=!0}}if(this.JITCompile&&void 0===f[0][e]){this.hierarchy[0].updateMatrixWorld(!0);for(a=0;a<this.hierarchy.length;a++)f[a][e]=\nthis.hierarchy[a]instanceof THREE.Bone?this.hierarchy[a].skinMatrix.clone():this.hierarchy[a].matrix.clone()}}}};THREE.KeyFrameAnimation.prototype.getNextKeyWith=function(a,b,c){b=this.data.hierarchy[b].keys;for(c%=b.length;c<b.length;c++)if(b[c].hasTarget(a))return b[c];return b[0]};THREE.KeyFrameAnimation.prototype.getPrevKeyWith=function(a,b,c){b=this.data.hierarchy[b].keys;for(c=0<=c?c:c+b.length;0<=c;c--)if(b[c].hasTarget(a))return b[c];return b[b.length-1]};THREE.CubeCamera=function(a,b,c){THREE.Object3D.call(this);var d=new THREE.PerspectiveCamera(90,1,a,b);d.up.set(0,-1,0);d.lookAt(new THREE.Vector3(1,0,0));this.add(d);var e=new THREE.PerspectiveCamera(90,1,a,b);e.up.set(0,-1,0);e.lookAt(new THREE.Vector3(-1,0,0));this.add(e);var f=new THREE.PerspectiveCamera(90,1,a,b);f.up.set(0,0,1);f.lookAt(new THREE.Vector3(0,1,0));this.add(f);var g=new THREE.PerspectiveCamera(90,1,a,b);g.up.set(0,0,-1);g.lookAt(new THREE.Vector3(0,-1,0));this.add(g);var h=new THREE.PerspectiveCamera(90,\n1,a,b);h.up.set(0,-1,0);h.lookAt(new THREE.Vector3(0,0,1));this.add(h);var i=new THREE.PerspectiveCamera(90,1,a,b);i.up.set(0,-1,0);i.lookAt(new THREE.Vector3(0,0,-1));this.add(i);this.renderTarget=new THREE.WebGLRenderTargetCube(c,c,{format:THREE.RGBFormat,magFilter:THREE.LinearFilter,minFilter:THREE.LinearFilter});this.updateCubeMap=function(a,b){var c=this.renderTarget,p=c.generateMipmaps;c.generateMipmaps=!1;c.activeCubeFace=0;a.render(b,d,c);c.activeCubeFace=1;a.render(b,e,c);c.activeCubeFace=\n2;a.render(b,f,c);c.activeCubeFace=3;a.render(b,g,c);c.activeCubeFace=4;a.render(b,h,c);c.generateMipmaps=p;c.activeCubeFace=5;a.render(b,i,c)}};THREE.CubeCamera.prototype=Object.create(THREE.Object3D.prototype);THREE.CombinedCamera=function(a,b,c,d,e,f,g){THREE.Camera.call(this);this.fov=c;this.left=-a/2;this.right=a/2;this.top=b/2;this.bottom=-b/2;this.cameraO=new THREE.OrthographicCamera(a/-2,a/2,b/2,b/-2,f,g);this.cameraP=new THREE.PerspectiveCamera(c,a/b,d,e);this.zoom=1;this.toPerspective()};THREE.CombinedCamera.prototype=Object.create(THREE.Camera.prototype);\nTHREE.CombinedCamera.prototype.toPerspective=function(){this.near=this.cameraP.near;this.far=this.cameraP.far;this.cameraP.fov=this.fov/this.zoom;this.cameraP.updateProjectionMatrix();this.projectionMatrix=this.cameraP.projectionMatrix;this.inPerspectiveMode=!0;this.inOrthographicMode=!1};\nTHREE.CombinedCamera.prototype.toOrthographic=function(){var a=this.cameraP.aspect,b=(this.cameraP.near+this.cameraP.far)/2,b=Math.tan(this.fov/2)*b,a=2*b*a/2,b=b/this.zoom,a=a/this.zoom;this.cameraO.left=-a;this.cameraO.right=a;this.cameraO.top=b;this.cameraO.bottom=-b;this.cameraO.updateProjectionMatrix();this.near=this.cameraO.near;this.far=this.cameraO.far;this.projectionMatrix=this.cameraO.projectionMatrix;this.inPerspectiveMode=!1;this.inOrthographicMode=!0};\nTHREE.CombinedCamera.prototype.setSize=function(a,b){this.cameraP.aspect=a/b;this.left=-a/2;this.right=a/2;this.top=b/2;this.bottom=-b/2};THREE.CombinedCamera.prototype.setFov=function(a){this.fov=a;this.inPerspectiveMode?this.toPerspective():this.toOrthographic()};THREE.CombinedCamera.prototype.updateProjectionMatrix=function(){this.inPerspectiveMode?this.toPerspective():(this.toPerspective(),this.toOrthographic())};\nTHREE.CombinedCamera.prototype.setLens=function(a,b){void 0===b&&(b=24);var c=2*THREE.Math.radToDeg(Math.atan(b/(2*a)));this.setFov(c);return c};THREE.CombinedCamera.prototype.setZoom=function(a){this.zoom=a;this.inPerspectiveMode?this.toPerspective():this.toOrthographic()};THREE.CombinedCamera.prototype.toFrontView=function(){this.rotation.x=0;this.rotation.y=0;this.rotation.z=0;this.rotationAutoUpdate=!1};\nTHREE.CombinedCamera.prototype.toBackView=function(){this.rotation.x=0;this.rotation.y=Math.PI;this.rotation.z=0;this.rotationAutoUpdate=!1};THREE.CombinedCamera.prototype.toLeftView=function(){this.rotation.x=0;this.rotation.y=-Math.PI/2;this.rotation.z=0;this.rotationAutoUpdate=!1};THREE.CombinedCamera.prototype.toRightView=function(){this.rotation.x=0;this.rotation.y=Math.PI/2;this.rotation.z=0;this.rotationAutoUpdate=!1};\nTHREE.CombinedCamera.prototype.toTopView=function(){this.rotation.x=-Math.PI/2;this.rotation.y=0;this.rotation.z=0;this.rotationAutoUpdate=!1};THREE.CombinedCamera.prototype.toBottomView=function(){this.rotation.x=Math.PI/2;this.rotation.y=0;this.rotation.z=0;this.rotationAutoUpdate=!1};THREE.CircleGeometry=function(a,b,c,d){THREE.Geometry.call(this);this.radius=a=a||50;this.segments=b=void 0!==b?Math.max(3,b):8;this.thetaStart=c=void 0!==c?c:0;this.thetaLength=d=void 0!==d?d:2*Math.PI;var e,f=[];e=new THREE.Vector3;var g=new THREE.Vector2(0.5,0.5);this.vertices.push(e);f.push(g);for(e=0;e<=b;e++){var h=new THREE.Vector3,i=c+e/b*d;h.x=a*Math.cos(i);h.y=a*Math.sin(i);this.vertices.push(h);f.push(new THREE.Vector2((h.x/a+1)/2,(h.y/a+1)/2))}c=new THREE.Vector3(0,0,1);for(e=1;e<=b;e++)this.faces.push(new THREE.Face3(e,\ne+1,0,[c.clone(),c.clone(),c.clone()])),this.faceVertexUvs[0].push([f[e].clone(),f[e+1].clone(),g.clone()]);this.computeCentroids();this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,a)};THREE.CircleGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.CubeGeometry=function(a,b,c,d,e,f){function g(a,b,c,d,e,f,g,m){var q,u=h.widthSegments,s=h.heightSegments,v=e/2,z=f/2,G=h.vertices.length;if(\"x\"===a&&\"y\"===b||\"y\"===a&&\"x\"===b)q=\"z\";else if(\"x\"===a&&\"z\"===b||\"z\"===a&&\"x\"===b)q=\"y\",s=h.depthSegments;else if(\"z\"===a&&\"y\"===b||\"y\"===a&&\"z\"===b)q=\"x\",u=h.depthSegments;var N=u+1,C=s+1,B=e/u,x=f/s,F=new THREE.Vector3;F[q]=0<g?1:-1;for(e=0;e<C;e++)for(f=0;f<N;f++){var L=new THREE.Vector3;L[a]=(f*B-v)*c;L[b]=(e*x-z)*d;L[q]=g;h.vertices.push(L)}for(e=\n0;e<s;e++)for(f=0;f<u;f++)z=f+N*e,a=f+N*(e+1),b=f+1+N*(e+1),c=f+1+N*e,d=new THREE.Vector2(f/u,1-e/s),g=new THREE.Vector2(f/u,1-(e+1)/s),q=new THREE.Vector2((f+1)/u,1-(e+1)/s),v=new THREE.Vector2((f+1)/u,1-e/s),z=new THREE.Face3(z+G,a+G,c+G),z.normal.copy(F),z.vertexNormals.push(F.clone(),F.clone(),F.clone()),z.materialIndex=m,h.faces.push(z),h.faceVertexUvs[0].push([d,g,v]),z=new THREE.Face3(a+G,b+G,c+G),z.normal.copy(F),z.vertexNormals.push(F.clone(),F.clone(),F.clone()),z.materialIndex=m,h.faces.push(z),\nh.faceVertexUvs[0].push([g.clone(),q,v.clone()])}THREE.Geometry.call(this);var h=this;this.width=a;this.height=b;this.depth=c;this.widthSegments=d||1;this.heightSegments=e||1;this.depthSegments=f||1;a=this.width/2;b=this.height/2;c=this.depth/2;g(\"z\",\"y\",-1,-1,this.depth,this.height,a,0);g(\"z\",\"y\",1,-1,this.depth,this.height,-a,1);g(\"x\",\"z\",1,1,this.width,this.depth,b,2);g(\"x\",\"z\",1,-1,this.width,this.depth,-b,3);g(\"x\",\"y\",1,-1,this.width,this.height,c,4);g(\"x\",\"y\",-1,-1,this.width,this.height,-c,\n5);this.computeCentroids();this.mergeVertices()};THREE.CubeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.CylinderGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);this.radiusTop=a=void 0!==a?a:20;this.radiusBottom=b=void 0!==b?b:20;this.height=c=void 0!==c?c:100;this.radialSegments=d=d||8;this.heightSegments=e=e||1;this.openEnded=f=void 0!==f?f:!1;var g=c/2,h,i,k=[],l=[];for(i=0;i<=e;i++){var n=[],p=[],t=i/e,r=t*(b-a)+a;for(h=0;h<=d;h++){var m=h/d,q=new THREE.Vector3;q.x=r*Math.sin(2*m*Math.PI);q.y=-t*c+g;q.z=r*Math.cos(2*m*Math.PI);this.vertices.push(q);n.push(this.vertices.length-1);p.push(new THREE.Vector2(m,\n1-t))}k.push(n);l.push(p)}c=(b-a)/c;for(h=0;h<d;h++){0!==a?(n=this.vertices[k[0][h]].clone(),p=this.vertices[k[0][h+1]].clone()):(n=this.vertices[k[1][h]].clone(),p=this.vertices[k[1][h+1]].clone());n.setY(Math.sqrt(n.x*n.x+n.z*n.z)*c).normalize();p.setY(Math.sqrt(p.x*p.x+p.z*p.z)*c).normalize();for(i=0;i<e;i++){var t=k[i][h],r=k[i+1][h],m=k[i+1][h+1],q=k[i][h+1],u=n.clone(),s=n.clone(),v=p.clone(),z=p.clone(),G=l[i][h].clone(),N=l[i+1][h].clone(),C=l[i+1][h+1].clone(),B=l[i][h+1].clone();this.faces.push(new THREE.Face3(t,\nr,q,[u,s,z]));this.faceVertexUvs[0].push([G,N,B]);this.faces.push(new THREE.Face3(r,m,q,[s.clone(),v,z.clone()]));this.faceVertexUvs[0].push([N.clone(),C,B.clone()])}}if(!1===f&&0<a){this.vertices.push(new THREE.Vector3(0,g,0));for(h=0;h<d;h++)t=k[0][h],r=k[0][h+1],m=this.vertices.length-1,u=new THREE.Vector3(0,1,0),s=new THREE.Vector3(0,1,0),v=new THREE.Vector3(0,1,0),G=l[0][h].clone(),N=l[0][h+1].clone(),C=new THREE.Vector2(N.x,0),this.faces.push(new THREE.Face3(t,r,m,[u,s,v])),this.faceVertexUvs[0].push([G,\nN,C])}if(!1===f&&0<b){this.vertices.push(new THREE.Vector3(0,-g,0));for(h=0;h<d;h++)t=k[i][h+1],r=k[i][h],m=this.vertices.length-1,u=new THREE.Vector3(0,-1,0),s=new THREE.Vector3(0,-1,0),v=new THREE.Vector3(0,-1,0),G=l[i][h+1].clone(),N=l[i][h].clone(),C=new THREE.Vector2(N.x,1),this.faces.push(new THREE.Face3(t,r,m,[u,s,v])),this.faceVertexUvs[0].push([G,N,C])}this.computeCentroids();this.computeFaceNormals()};THREE.CylinderGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ExtrudeGeometry=function(a,b){\"undefined\"!==typeof a&&(THREE.Geometry.call(this),a=a instanceof Array?a:[a],this.shapebb=a[a.length-1].getBoundingBox(),this.addShapeList(a,b),this.computeCentroids(),this.computeFaceNormals())};THREE.ExtrudeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ExtrudeGeometry.prototype.addShapeList=function(a,b){for(var c=a.length,d=0;d<c;d++)this.addShape(a[d],b)};\nTHREE.ExtrudeGeometry.prototype.addShape=function(a,b){function c(a,b,c){b||console.log(\"die\");return b.clone().multiplyScalar(c).add(a)}function d(a,b,c){var d=THREE.ExtrudeGeometry.__v1,e=THREE.ExtrudeGeometry.__v2,f=THREE.ExtrudeGeometry.__v3,g=THREE.ExtrudeGeometry.__v4,h=THREE.ExtrudeGeometry.__v5,i=THREE.ExtrudeGeometry.__v6;d.set(a.x-b.x,a.y-b.y);e.set(a.x-c.x,a.y-c.y);d=d.normalize();e=e.normalize();f.set(-d.y,d.x);g.set(e.y,-e.x);h.copy(a).add(f);i.copy(a).add(g);if(h.equals(i))return g.clone();\nh.copy(b).add(f);i.copy(c).add(g);f=d.dot(g);g=i.sub(h).dot(g);0===f&&(console.log(\"Either infinite or no solutions!\"),0===g?console.log(\"Its finite solutions.\"):console.log(\"Too bad, no solutions.\"));g/=f;return 0>g?(b=Math.atan2(b.y-a.y,b.x-a.x),a=Math.atan2(c.y-a.y,c.x-a.x),b>a&&(a+=2*Math.PI),c=(b+a)/2,a=-Math.cos(c),c=-Math.sin(c),new THREE.Vector2(a,c)):d.multiplyScalar(g).add(h).sub(a).clone()}function e(c,d){var e,f;for(O=c.length;0<=--O;){e=O;f=O-1;0>f&&(f=c.length-1);for(var g=0,h=t+2*l,\ng=0;g<h;g++){var i=da*g,k=da*(g+1),m=d+e+i,i=d+f+i,n=d+f+k,k=d+e+k,p=c,q=g,r=h,u=e,z=f,m=m+w,i=i+w,n=n+w,k=k+w;L.faces.push(new THREE.Face3(m,i,k,null,null,s));L.faces.push(new THREE.Face3(i,n,k,null,null,s));m=v.generateSideWallUV(L,a,p,b,m,i,n,k,q,r,u,z);L.faceVertexUvs[0].push([m[0],m[1],m[3]]);L.faceVertexUvs[0].push([m[1],m[2],m[3]])}}}function f(a,b,c){L.vertices.push(new THREE.Vector3(a,b,c))}function g(c,d,e,f){c+=w;d+=w;e+=w;L.faces.push(new THREE.Face3(c,d,e,null,null,u));c=f?v.generateBottomUV(L,\na,b,c,d,e):v.generateTopUV(L,a,b,c,d,e);L.faceVertexUvs[0].push(c)}var h=void 0!==b.amount?b.amount:100,i=void 0!==b.bevelThickness?b.bevelThickness:6,k=void 0!==b.bevelSize?b.bevelSize:i-2,l=void 0!==b.bevelSegments?b.bevelSegments:3,n=void 0!==b.bevelEnabled?b.bevelEnabled:!0,p=void 0!==b.curveSegments?b.curveSegments:12,t=void 0!==b.steps?b.steps:1,r=b.extrudePath,m,q=!1,u=b.material,s=b.extrudeMaterial,v=void 0!==b.UVGenerator?b.UVGenerator:THREE.ExtrudeGeometry.WorldUVGenerator,z,G,N,C;r&&(m=\nr.getSpacedPoints(t),q=!0,n=!1,z=void 0!==b.frames?b.frames:new THREE.TubeGeometry.FrenetFrames(r,t,!1),G=new THREE.Vector3,N=new THREE.Vector3,C=new THREE.Vector3);n||(k=i=l=0);var B,x,F,L=this,w=this.vertices.length,p=a.extractPoints(p),E=p.shape,p=p.holes;if(r=!THREE.Shape.Utils.isClockWise(E)){E=E.reverse();x=0;for(F=p.length;x<F;x++)B=p[x],THREE.Shape.Utils.isClockWise(B)&&(p[x]=B.reverse());r=!1}var y=THREE.Shape.Utils.triangulateShape(E,p),r=E;x=0;for(F=p.length;x<F;x++)B=p[x],E=E.concat(B);\nvar D,H,K,A,da=E.length,ha=y.length,ua=[],O=0,T=r.length;D=T-1;for(H=O+1;O<T;O++,D++,H++)D===T&&(D=0),H===T&&(H=0),ua[O]=d(r[O],r[D],r[H]);var ea=[],I,P=ua.concat();x=0;for(F=p.length;x<F;x++){B=p[x];I=[];O=0;T=B.length;D=T-1;for(H=O+1;O<T;O++,D++,H++)D===T&&(D=0),H===T&&(H=0),I[O]=d(B[O],B[D],B[H]);ea.push(I);P=P.concat(I)}for(D=0;D<l;D++){B=D/l;K=i*(1-B);H=k*Math.sin(B*Math.PI/2);O=0;for(T=r.length;O<T;O++)A=c(r[O],ua[O],H),f(A.x,A.y,-K);x=0;for(F=p.length;x<F;x++){B=p[x];I=ea[x];O=0;for(T=B.length;O<\nT;O++)A=c(B[O],I[O],H),f(A.x,A.y,-K)}}H=k;for(O=0;O<da;O++)A=n?c(E[O],P[O],H):E[O],q?(N.copy(z.normals[0]).multiplyScalar(A.x),G.copy(z.binormals[0]).multiplyScalar(A.y),C.copy(m[0]).add(N).add(G),f(C.x,C.y,C.z)):f(A.x,A.y,0);for(B=1;B<=t;B++)for(O=0;O<da;O++)A=n?c(E[O],P[O],H):E[O],q?(N.copy(z.normals[B]).multiplyScalar(A.x),G.copy(z.binormals[B]).multiplyScalar(A.y),C.copy(m[B]).add(N).add(G),f(C.x,C.y,C.z)):f(A.x,A.y,h/t*B);for(D=l-1;0<=D;D--){B=D/l;K=i*(1-B);H=k*Math.sin(B*Math.PI/2);O=0;for(T=\nr.length;O<T;O++)A=c(r[O],ua[O],H),f(A.x,A.y,h+K);x=0;for(F=p.length;x<F;x++){B=p[x];I=ea[x];O=0;for(T=B.length;O<T;O++)A=c(B[O],I[O],H),q?f(A.x,A.y+m[t-1].y,m[t-1].x+K):f(A.x,A.y,h+K)}}if(n){i=0*da;for(O=0;O<ha;O++)h=y[O],g(h[2]+i,h[1]+i,h[0]+i,!0);i=da*(t+2*l);for(O=0;O<ha;O++)h=y[O],g(h[0]+i,h[1]+i,h[2]+i,!1)}else{for(O=0;O<ha;O++)h=y[O],g(h[2],h[1],h[0],!0);for(O=0;O<ha;O++)h=y[O],g(h[0]+da*t,h[1]+da*t,h[2]+da*t,!1)}h=0;e(r,h);h+=r.length;x=0;for(F=p.length;x<F;x++)B=p[x],e(B,h),h+=B.length};\nTHREE.ExtrudeGeometry.WorldUVGenerator={generateTopUV:function(a,b,c,d,e,f){b=a.vertices[e].x;e=a.vertices[e].y;c=a.vertices[f].x;f=a.vertices[f].y;return[new THREE.Vector2(a.vertices[d].x,a.vertices[d].y),new THREE.Vector2(b,e),new THREE.Vector2(c,f)]},generateBottomUV:function(a,b,c,d,e,f){return this.generateTopUV(a,b,c,d,e,f)},generateSideWallUV:function(a,b,c,d,e,f,g,h){var b=a.vertices[e].x,c=a.vertices[e].y,e=a.vertices[e].z,d=a.vertices[f].x,i=a.vertices[f].y,f=a.vertices[f].z,k=a.vertices[g].x,\nl=a.vertices[g].y,g=a.vertices[g].z,n=a.vertices[h].x,p=a.vertices[h].y,a=a.vertices[h].z;return 0.01>Math.abs(c-i)?[new THREE.Vector2(b,1-e),new THREE.Vector2(d,1-f),new THREE.Vector2(k,1-g),new THREE.Vector2(n,1-a)]:[new THREE.Vector2(c,1-e),new THREE.Vector2(i,1-f),new THREE.Vector2(l,1-g),new THREE.Vector2(p,1-a)]}};THREE.ExtrudeGeometry.__v1=new THREE.Vector2;THREE.ExtrudeGeometry.__v2=new THREE.Vector2;THREE.ExtrudeGeometry.__v3=new THREE.Vector2;THREE.ExtrudeGeometry.__v4=new THREE.Vector2;\nTHREE.ExtrudeGeometry.__v5=new THREE.Vector2;THREE.ExtrudeGeometry.__v6=new THREE.Vector2;THREE.ShapeGeometry=function(a,b){THREE.Geometry.call(this);!1===a instanceof Array&&(a=[a]);this.shapebb=a[a.length-1].getBoundingBox();this.addShapeList(a,b);this.computeCentroids();this.computeFaceNormals()};THREE.ShapeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ShapeGeometry.prototype.addShapeList=function(a,b){for(var c=0,d=a.length;c<d;c++)this.addShape(a[c],b);return this};\nTHREE.ShapeGeometry.prototype.addShape=function(a,b){void 0===b&&(b={});var c=b.material,d=void 0===b.UVGenerator?THREE.ExtrudeGeometry.WorldUVGenerator:b.UVGenerator,e,f,g,h=this.vertices.length;e=a.extractPoints(void 0!==b.curveSegments?b.curveSegments:12);var i=e.shape,k=e.holes;if(!THREE.Shape.Utils.isClockWise(i)){i=i.reverse();e=0;for(f=k.length;e<f;e++)g=k[e],THREE.Shape.Utils.isClockWise(g)&&(k[e]=g.reverse())}var l=THREE.Shape.Utils.triangulateShape(i,k);e=0;for(f=k.length;e<f;e++)g=k[e],\ni=i.concat(g);k=i.length;f=l.length;for(e=0;e<k;e++)g=i[e],this.vertices.push(new THREE.Vector3(g.x,g.y,0));for(e=0;e<f;e++)k=l[e],i=k[0]+h,g=k[1]+h,k=k[2]+h,this.faces.push(new THREE.Face3(i,g,k,null,null,c)),this.faceVertexUvs[0].push(d.generateBottomUV(this,a,b,i,g,k))};THREE.LatheGeometry=function(a,b,c,d){THREE.Geometry.call(this);for(var b=b||12,c=c||0,d=d||2*Math.PI,e=1/(a.length-1),f=1/b,g=0,h=b;g<=h;g++)for(var i=c+g*f*d,k=Math.cos(i),l=Math.sin(i),i=0,n=a.length;i<n;i++){var p=a[i],t=new THREE.Vector3;t.x=k*p.x-l*p.y;t.y=l*p.x+k*p.y;t.z=p.z;this.vertices.push(t)}c=a.length;g=0;for(h=b;g<h;g++){i=0;for(n=a.length-1;i<n;i++){var b=l=i+c*g,d=l+c,k=l+1+c,l=l+1,p=g*f,t=i*e,r=p+f,m=t+e;this.faces.push(new THREE.Face3(b,d,l));this.faceVertexUvs[0].push([new THREE.Vector2(p,\nt),new THREE.Vector2(r,t),new THREE.Vector2(p,m)]);this.faces.push(new THREE.Face3(d,k,l));this.faceVertexUvs[0].push([new THREE.Vector2(r,t),new THREE.Vector2(r,m),new THREE.Vector2(p,m)])}}this.mergeVertices();this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.LatheGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.PlaneGeometry=function(a,b,c,d){THREE.Geometry.call(this);this.width=a;this.height=b;this.widthSegments=c||1;this.heightSegments=d||1;for(var e=a/2,f=b/2,c=this.widthSegments,d=this.heightSegments,g=c+1,h=d+1,i=this.width/c,k=this.height/d,l=new THREE.Vector3(0,0,1),a=0;a<h;a++)for(b=0;b<g;b++)this.vertices.push(new THREE.Vector3(b*i-e,-(a*k-f),0));for(a=0;a<d;a++)for(b=0;b<c;b++){var n=b+g*a,e=b+g*(a+1),f=b+1+g*(a+1),h=b+1+g*a,i=new THREE.Vector2(b/c,1-a/d),k=new THREE.Vector2(b/c,1-(a+1)/\nd),p=new THREE.Vector2((b+1)/c,1-(a+1)/d),t=new THREE.Vector2((b+1)/c,1-a/d),n=new THREE.Face3(n,e,h);n.normal.copy(l);n.vertexNormals.push(l.clone(),l.clone(),l.clone());this.faces.push(n);this.faceVertexUvs[0].push([i,k,t]);n=new THREE.Face3(e,f,h);n.normal.copy(l);n.vertexNormals.push(l.clone(),l.clone(),l.clone());this.faces.push(n);this.faceVertexUvs[0].push([k.clone(),p,t.clone()])}this.computeCentroids()};THREE.PlaneGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.RingGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);for(var a=a||0,b=b||50,e=void 0!==e?e:0,f=void 0!==f?f:2*Math.PI,c=void 0!==c?Math.max(3,c):8,d=void 0!==d?Math.max(3,d):8,g,h=[],i=a,k=(b-a)/d,a=0;a<=d;a++){for(g=0;g<=c;g++){var l=new THREE.Vector3,n=e+g/c*f;l.x=i*Math.cos(n);l.y=i*Math.sin(n);this.vertices.push(l);h.push(new THREE.Vector2((l.x/b+1)/2,(l.y/b+1)/2))}i+=k}b=new THREE.Vector3(0,0,1);for(a=0;a<d;a++){e=a*c;for(g=0;g<=c;g++)n=g+e,f=n+a,k=n+c+a,l=n+c+1+a,this.faces.push(new THREE.Face3(f,\nk,l,[b.clone(),b.clone(),b.clone()])),this.faceVertexUvs[0].push([h[f].clone(),h[k].clone(),h[l].clone()]),f=n+a,k=n+c+1+a,l=n+1+a,this.faces.push(new THREE.Face3(f,k,l,[b.clone(),b.clone(),b.clone()])),this.faceVertexUvs[0].push([h[f].clone(),h[k].clone(),h[l].clone()])}this.computeCentroids();this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,i)};THREE.RingGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.SphereGeometry=function(a,b,c,d,e,f,g){THREE.Geometry.call(this);this.radius=a=a||50;this.widthSegments=b=Math.max(3,Math.floor(b)||8);this.heightSegments=c=Math.max(2,Math.floor(c)||6);this.phiStart=d=void 0!==d?d:0;this.phiLength=e=void 0!==e?e:2*Math.PI;this.thetaStart=f=void 0!==f?f:0;this.thetaLength=g=void 0!==g?g:Math.PI;var h,i,k=[],l=[];for(i=0;i<=c;i++){var n=[],p=[];for(h=0;h<=b;h++){var t=h/b,r=i/c,m=new THREE.Vector3;m.x=-a*Math.cos(d+t*e)*Math.sin(f+r*g);m.y=a*Math.cos(f+r*g);\nm.z=a*Math.sin(d+t*e)*Math.sin(f+r*g);this.vertices.push(m);n.push(this.vertices.length-1);p.push(new THREE.Vector2(t,1-r))}k.push(n);l.push(p)}for(i=0;i<this.heightSegments;i++)for(h=0;h<this.widthSegments;h++){var b=k[i][h+1],c=k[i][h],d=k[i+1][h],e=k[i+1][h+1],f=this.vertices[b].clone().normalize(),g=this.vertices[c].clone().normalize(),n=this.vertices[d].clone().normalize(),p=this.vertices[e].clone().normalize(),t=l[i][h+1].clone(),r=l[i][h].clone(),m=l[i+1][h].clone(),q=l[i+1][h+1].clone();Math.abs(this.vertices[b].y)===\nthis.radius?(t.x=(t.x+r.x)/2,this.faces.push(new THREE.Face3(b,d,e,[f,n,p])),this.faceVertexUvs[0].push([t,m,q])):Math.abs(this.vertices[d].y)===this.radius?(m.x=(m.x+q.x)/2,this.faces.push(new THREE.Face3(b,c,d,[f,g,n])),this.faceVertexUvs[0].push([t,r,m])):(this.faces.push(new THREE.Face3(b,c,e,[f,g,p])),this.faceVertexUvs[0].push([t,r,q]),this.faces.push(new THREE.Face3(c,d,e,[g.clone(),n,p.clone()])),this.faceVertexUvs[0].push([r.clone(),m,q.clone()]))}this.computeCentroids();this.computeFaceNormals();\nthis.boundingSphere=new THREE.Sphere(new THREE.Vector3,a)};THREE.SphereGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TextGeometry=function(a,b){var b=b||{},c=THREE.FontUtils.generateShapes(a,b);b.amount=void 0!==b.height?b.height:50;void 0===b.bevelThickness&&(b.bevelThickness=10);void 0===b.bevelSize&&(b.bevelSize=8);void 0===b.bevelEnabled&&(b.bevelEnabled=!1);THREE.ExtrudeGeometry.call(this,c,b)};THREE.TextGeometry.prototype=Object.create(THREE.ExtrudeGeometry.prototype);THREE.TorusGeometry=function(a,b,c,d,e){THREE.Geometry.call(this);this.radius=a||100;this.tube=b||40;this.radialSegments=c||8;this.tubularSegments=d||6;this.arc=e||2*Math.PI;e=new THREE.Vector3;a=[];b=[];for(c=0;c<=this.radialSegments;c++)for(d=0;d<=this.tubularSegments;d++){var f=d/this.tubularSegments*this.arc,g=2*c/this.radialSegments*Math.PI;e.x=this.radius*Math.cos(f);e.y=this.radius*Math.sin(f);var h=new THREE.Vector3;h.x=(this.radius+this.tube*Math.cos(g))*Math.cos(f);h.y=(this.radius+this.tube*\nMath.cos(g))*Math.sin(f);h.z=this.tube*Math.sin(g);this.vertices.push(h);a.push(new THREE.Vector2(d/this.tubularSegments,c/this.radialSegments));b.push(h.clone().sub(e).normalize())}for(c=1;c<=this.radialSegments;c++)for(d=1;d<=this.tubularSegments;d++){var e=(this.tubularSegments+1)*c+d-1,f=(this.tubularSegments+1)*(c-1)+d-1,g=(this.tubularSegments+1)*(c-1)+d,h=(this.tubularSegments+1)*c+d,i=new THREE.Face3(e,f,h,[b[e].clone(),b[f].clone(),b[h].clone()]);this.faces.push(i);this.faceVertexUvs[0].push([a[e].clone(),\na[f].clone(),a[h].clone()]);i=new THREE.Face3(f,g,h,[b[f].clone(),b[g].clone(),b[h].clone()]);this.faces.push(i);this.faceVertexUvs[0].push([a[f].clone(),a[g].clone(),a[h].clone()])}this.computeCentroids();this.computeFaceNormals()};THREE.TorusGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TorusKnotGeometry=function(a,b,c,d,e,f,g){function h(a,b,c,d,e){var f=Math.cos(a),g=Math.sin(a),a=b/c*a,b=Math.cos(a),f=0.5*(d*(2+b))*f,g=0.5*d*(2+b)*g,d=0.5*e*d*Math.sin(a);return new THREE.Vector3(f,g,d)}THREE.Geometry.call(this);this.radius=a||100;this.tube=b||40;this.radialSegments=c||64;this.tubularSegments=d||8;this.p=e||2;this.q=f||3;this.heightScale=g||1;this.grid=Array(this.radialSegments);c=new THREE.Vector3;d=new THREE.Vector3;e=new THREE.Vector3;for(a=0;a<this.radialSegments;++a){this.grid[a]=\nArray(this.tubularSegments);b=2*(a/this.radialSegments)*this.p*Math.PI;f=h(b,this.q,this.p,this.radius,this.heightScale);b=h(b+0.01,this.q,this.p,this.radius,this.heightScale);c.subVectors(b,f);d.addVectors(b,f);e.crossVectors(c,d);d.crossVectors(e,c);e.normalize();d.normalize();for(b=0;b<this.tubularSegments;++b){var i=2*(b/this.tubularSegments)*Math.PI,g=-this.tube*Math.cos(i),i=this.tube*Math.sin(i),k=new THREE.Vector3;k.x=f.x+g*d.x+i*e.x;k.y=f.y+g*d.y+i*e.y;k.z=f.z+g*d.z+i*e.z;this.grid[a][b]=\nthis.vertices.push(k)-1}}for(a=0;a<this.radialSegments;++a)for(b=0;b<this.tubularSegments;++b){var e=(a+1)%this.radialSegments,f=(b+1)%this.tubularSegments,c=this.grid[a][b],d=this.grid[e][b],e=this.grid[e][f],f=this.grid[a][f],g=new THREE.Vector2(a/this.radialSegments,b/this.tubularSegments),i=new THREE.Vector2((a+1)/this.radialSegments,b/this.tubularSegments),k=new THREE.Vector2((a+1)/this.radialSegments,(b+1)/this.tubularSegments),l=new THREE.Vector2(a/this.radialSegments,(b+1)/this.tubularSegments);\nthis.faces.push(new THREE.Face3(c,d,f));this.faceVertexUvs[0].push([g,i,l]);this.faces.push(new THREE.Face3(d,e,f));this.faceVertexUvs[0].push([i.clone(),k,l.clone()])}this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.TorusKnotGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TubeGeometry=function(a,b,c,d,e){THREE.Geometry.call(this);this.path=a;this.segments=b||64;this.radius=c||1;this.radialSegments=d||8;this.closed=e||!1;this.grid=[];var f,g,d=this.segments+1,h,i,k,e=new THREE.Vector3,l,n,b=new THREE.TubeGeometry.FrenetFrames(this.path,this.segments,this.closed);l=b.normals;n=b.binormals;this.tangents=b.tangents;this.normals=l;this.binormals=n;for(b=0;b<d;b++){this.grid[b]=[];c=b/(d-1);k=a.getPointAt(c);f=l[b];g=n[b];for(c=0;c<this.radialSegments;c++)h=2*(c/this.radialSegments)*\nMath.PI,i=-this.radius*Math.cos(h),h=this.radius*Math.sin(h),e.copy(k),e.x+=i*f.x+h*g.x,e.y+=i*f.y+h*g.y,e.z+=i*f.z+h*g.z,this.grid[b][c]=this.vertices.push(new THREE.Vector3(e.x,e.y,e.z))-1}for(b=0;b<this.segments;b++)for(c=0;c<this.radialSegments;c++)e=this.closed?(b+1)%this.segments:b+1,l=(c+1)%this.radialSegments,a=this.grid[b][c],d=this.grid[e][c],e=this.grid[e][l],l=this.grid[b][l],n=new THREE.Vector2(b/this.segments,c/this.radialSegments),f=new THREE.Vector2((b+1)/this.segments,c/this.radialSegments),\ng=new THREE.Vector2((b+1)/this.segments,(c+1)/this.radialSegments),i=new THREE.Vector2(b/this.segments,(c+1)/this.radialSegments),this.faces.push(new THREE.Face3(a,d,l)),this.faceVertexUvs[0].push([n,f,i]),this.faces.push(new THREE.Face3(d,e,l)),this.faceVertexUvs[0].push([f.clone(),g,i.clone()]);this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.TubeGeometry.prototype=Object.create(THREE.Geometry.prototype);\nTHREE.TubeGeometry.FrenetFrames=function(a,b,c){new THREE.Vector3;var d=new THREE.Vector3;new THREE.Vector3;var e=[],f=[],g=[],h=new THREE.Vector3,i=new THREE.Matrix4,b=b+1,k,l,n;this.tangents=e;this.normals=f;this.binormals=g;for(k=0;k<b;k++)l=k/(b-1),e[k]=a.getTangentAt(l),e[k].normalize();f[0]=new THREE.Vector3;g[0]=new THREE.Vector3;a=Number.MAX_VALUE;k=Math.abs(e[0].x);l=Math.abs(e[0].y);n=Math.abs(e[0].z);k<=a&&(a=k,d.set(1,0,0));l<=a&&(a=l,d.set(0,1,0));n<=a&&d.set(0,0,1);h.crossVectors(e[0],\nd).normalize();f[0].crossVectors(e[0],h);g[0].crossVectors(e[0],f[0]);for(k=1;k<b;k++)f[k]=f[k-1].clone(),g[k]=g[k-1].clone(),h.crossVectors(e[k-1],e[k]),1E-4<h.length()&&(h.normalize(),d=Math.acos(THREE.Math.clamp(e[k-1].dot(e[k]),-1,1)),f[k].applyMatrix4(i.makeRotationAxis(h,d))),g[k].crossVectors(e[k],f[k]);if(c){d=Math.acos(THREE.Math.clamp(f[0].dot(f[b-1]),-1,1));d/=b-1;0<e[0].dot(h.crossVectors(f[0],f[b-1]))&&(d=-d);for(k=1;k<b;k++)f[k].applyMatrix4(i.makeRotationAxis(e[k],d*k)),g[k].crossVectors(e[k],\nf[k])}};THREE.PolyhedronGeometry=function(a,b,c,d){function e(a){var b=a.normalize().clone();b.index=h.vertices.push(b)-1;var c=Math.atan2(a.z,-a.x)/2/Math.PI+0.5,a=Math.atan2(-a.y,Math.sqrt(a.x*a.x+a.z*a.z))/Math.PI+0.5;b.uv=new THREE.Vector2(c,1-a);return b}function f(a,b,c){var d=new THREE.Face3(a.index,b.index,c.index,[a.clone(),b.clone(),c.clone()]);d.centroid.add(a).add(b).add(c).divideScalar(3);h.faces.push(d);d=Math.atan2(d.centroid.z,-d.centroid.x);h.faceVertexUvs[0].push([g(a.uv,a,d),g(b.uv,b,d),\ng(c.uv,c,d)])}function g(a,b,c){0>c&&1===a.x&&(a=new THREE.Vector2(a.x-1,a.y));0===b.x&&0===b.z&&(a=new THREE.Vector2(c/2/Math.PI+0.5,a.y));return a.clone()}THREE.Geometry.call(this);for(var c=c||1,d=d||0,h=this,i=0,k=a.length;i<k;i++)e(new THREE.Vector3(a[i][0],a[i][1],a[i][2]));for(var l=this.vertices,a=[],i=0,k=b.length;i<k;i++){var n=l[b[i][0]],p=l[b[i][1]],t=l[b[i][2]];a[i]=new THREE.Face3(n.index,p.index,t.index,[n.clone(),p.clone(),t.clone()])}i=0;for(k=a.length;i<k;i++){p=a[i];l=d;b=Math.pow(2,\nl);Math.pow(4,l);for(var l=e(h.vertices[p.a]),n=e(h.vertices[p.b]),r=e(h.vertices[p.c]),p=[],t=0;t<=b;t++){p[t]=[];for(var m=e(l.clone().lerp(r,t/b)),q=e(n.clone().lerp(r,t/b)),u=b-t,s=0;s<=u;s++)p[t][s]=0==s&&t==b?m:e(m.clone().lerp(q,s/u))}for(t=0;t<b;t++)for(s=0;s<2*(b-t)-1;s++)l=Math.floor(s/2),0==s%2?f(p[t][l+1],p[t+1][l],p[t][l]):f(p[t][l+1],p[t+1][l+1],p[t+1][l])}i=0;for(k=this.faceVertexUvs[0].length;i<k;i++)d=this.faceVertexUvs[0][i],a=d[0].x,b=d[1].x,l=d[2].x,n=Math.max(a,Math.max(b,l)),\np=Math.min(a,Math.min(b,l)),0.9<n&&0.1>p&&(0.2>a&&(d[0].x+=1),0.2>b&&(d[1].x+=1),0.2>l&&(d[2].x+=1));i=0;for(k=this.vertices.length;i<k;i++)this.vertices[i].multiplyScalar(c);this.mergeVertices();this.computeCentroids();this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,c)};THREE.PolyhedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.IcosahedronGeometry=function(a,b){this.radius=a;this.detail=b;var c=(1+Math.sqrt(5))/2;THREE.PolyhedronGeometry.call(this,[[-1,c,0],[1,c,0],[-1,-c,0],[1,-c,0],[0,-1,c],[0,1,c],[0,-1,-c],[0,1,-c],[c,0,-1],[c,0,1],[-c,0,-1],[-c,0,1]],[[0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],[1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],[3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],[4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]],a,b)};THREE.IcosahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.OctahedronGeometry=function(a,b){THREE.PolyhedronGeometry.call(this,[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]],[[0,2,4],[0,4,3],[0,3,5],[0,5,2],[1,2,5],[1,5,3],[1,3,4],[1,4,2]],a,b)};THREE.OctahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TetrahedronGeometry=function(a,b){THREE.PolyhedronGeometry.call(this,[[1,1,1],[-1,-1,1],[-1,1,-1],[1,-1,-1]],[[2,1,0],[0,3,2],[1,3,0],[2,3,1]],a,b)};THREE.TetrahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ParametricGeometry=function(a,b,c){THREE.Geometry.call(this);var d=this.vertices,e=this.faces,f=this.faceVertexUvs[0],g,h,i,k,l=b+1;for(g=0;g<=c;g++){k=g/c;for(h=0;h<=b;h++)i=h/b,i=a(i,k),d.push(i)}var n,p,t,r;for(g=0;g<c;g++)for(h=0;h<b;h++)a=g*l+h,d=g*l+h+1,k=(g+1)*l+h+1,i=(g+1)*l+h,n=new THREE.Vector2(h/b,g/c),p=new THREE.Vector2((h+1)/b,g/c),t=new THREE.Vector2((h+1)/b,(g+1)/c),r=new THREE.Vector2(h/b,(g+1)/c),e.push(new THREE.Face3(a,d,i)),f.push([n,p,r]),e.push(new THREE.Face3(d,k,i)),\nf.push([p.clone(),t,r.clone()]);this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.ParametricGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.AxisHelper=function(a){var a=a||1,b=new THREE.Geometry;b.vertices.push(new THREE.Vector3,new THREE.Vector3(a,0,0),new THREE.Vector3,new THREE.Vector3(0,a,0),new THREE.Vector3,new THREE.Vector3(0,0,a));b.colors.push(new THREE.Color(16711680),new THREE.Color(16755200),new THREE.Color(65280),new THREE.Color(11206400),new THREE.Color(255),new THREE.Color(43775));a=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});THREE.Line.call(this,b,a,THREE.LinePieces)};\nTHREE.AxisHelper.prototype=Object.create(THREE.Line.prototype);THREE.ArrowHelper=function(a,b,c,d,e,f){THREE.Object3D.call(this);void 0===d&&(d=16776960);void 0===c&&(c=1);void 0===e&&(e=0.2*c);void 0===f&&(f=0.2*e);this.position=b;b=new THREE.Geometry;b.vertices.push(new THREE.Vector3(0,0,0));b.vertices.push(new THREE.Vector3(0,1,0));this.line=new THREE.Line(b,new THREE.LineBasicMaterial({color:d}));this.line.matrixAutoUpdate=!1;this.add(this.line);b=new THREE.CylinderGeometry(0,0.5,1,5,1);b.applyMatrix((new THREE.Matrix4).makeTranslation(0,-0.5,0));this.cone=\nnew THREE.Mesh(b,new THREE.MeshBasicMaterial({color:d}));this.cone.matrixAutoUpdate=!1;this.add(this.cone);this.setDirection(a);this.setLength(c,e,f)};THREE.ArrowHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.ArrowHelper.prototype.setDirection=function(){var a=new THREE.Vector3,b;return function(c){0.99999<c.y?this.quaternion.set(0,0,0,1):-0.99999>c.y?this.quaternion.set(1,0,0,0):(a.set(c.z,0,-c.x).normalize(),b=Math.acos(c.y),this.quaternion.setFromAxisAngle(a,b))}}();\nTHREE.ArrowHelper.prototype.setLength=function(a,b,c){void 0===b&&(b=0.2*a);void 0===c&&(c=0.2*b);this.line.scale.set(1,a,1);this.line.updateMatrix();this.cone.scale.set(c,b,c);this.cone.position.y=a;this.cone.updateMatrix()};THREE.ArrowHelper.prototype.setColor=function(a){this.line.material.color.setHex(a);this.cone.material.color.setHex(a)};THREE.BoxHelper=function(a){var b=[new THREE.Vector3(1,1,1),new THREE.Vector3(-1,1,1),new THREE.Vector3(-1,-1,1),new THREE.Vector3(1,-1,1),new THREE.Vector3(1,1,-1),new THREE.Vector3(-1,1,-1),new THREE.Vector3(-1,-1,-1),new THREE.Vector3(1,-1,-1)];this.vertices=b;var c=new THREE.Geometry;c.vertices.push(b[0],b[1],b[1],b[2],b[2],b[3],b[3],b[0],b[4],b[5],b[5],b[6],b[6],b[7],b[7],b[4],b[0],b[4],b[1],b[5],b[2],b[6],b[3],b[7]);THREE.Line.call(this,c,new THREE.LineBasicMaterial({color:16776960}),THREE.LinePieces);\nvoid 0!==a&&this.update(a)};THREE.BoxHelper.prototype=Object.create(THREE.Line.prototype);\nTHREE.BoxHelper.prototype.update=function(a){var b=a.geometry;null===b.boundingBox&&b.computeBoundingBox();var c=b.boundingBox.min,b=b.boundingBox.max,d=this.vertices;d[0].set(b.x,b.y,b.z);d[1].set(c.x,b.y,b.z);d[2].set(c.x,c.y,b.z);d[3].set(b.x,c.y,b.z);d[4].set(b.x,b.y,c.z);d[5].set(c.x,b.y,c.z);d[6].set(c.x,c.y,c.z);d[7].set(b.x,c.y,c.z);this.geometry.computeBoundingSphere();this.geometry.verticesNeedUpdate=!0;this.matrixAutoUpdate=!1;this.matrixWorld=a.matrixWorld};THREE.BoundingBoxHelper=function(a,b){var c=void 0!==b?b:8947848;this.object=a;this.box=new THREE.Box3;THREE.Mesh.call(this,new THREE.CubeGeometry(1,1,1),new THREE.MeshBasicMaterial({color:c,wireframe:!0}))};THREE.BoundingBoxHelper.prototype=Object.create(THREE.Mesh.prototype);THREE.BoundingBoxHelper.prototype.update=function(){this.box.setFromObject(this.object);this.box.size(this.scale);this.box.center(this.position)};THREE.CameraHelper=function(a){function b(a,b,d){c(a,d);c(b,d)}function c(a,b){d.vertices.push(new THREE.Vector3);d.colors.push(new THREE.Color(b));void 0===f[a]&&(f[a]=[]);f[a].push(d.vertices.length-1)}var d=new THREE.Geometry,e=new THREE.LineBasicMaterial({color:16777215,vertexColors:THREE.FaceColors}),f={};b(\"n1\",\"n2\",16755200);b(\"n2\",\"n4\",16755200);b(\"n4\",\"n3\",16755200);b(\"n3\",\"n1\",16755200);b(\"f1\",\"f2\",16755200);b(\"f2\",\"f4\",16755200);b(\"f4\",\"f3\",16755200);b(\"f3\",\"f1\",16755200);b(\"n1\",\"f1\",16755200);\nb(\"n2\",\"f2\",16755200);b(\"n3\",\"f3\",16755200);b(\"n4\",\"f4\",16755200);b(\"p\",\"n1\",16711680);b(\"p\",\"n2\",16711680);b(\"p\",\"n3\",16711680);b(\"p\",\"n4\",16711680);b(\"u1\",\"u2\",43775);b(\"u2\",\"u3\",43775);b(\"u3\",\"u1\",43775);b(\"c\",\"t\",16777215);b(\"p\",\"c\",3355443);b(\"cn1\",\"cn2\",3355443);b(\"cn3\",\"cn4\",3355443);b(\"cf1\",\"cf2\",3355443);b(\"cf3\",\"cf4\",3355443);THREE.Line.call(this,d,e,THREE.LinePieces);this.camera=a;this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;this.pointMap=f;this.update()};\nTHREE.CameraHelper.prototype=Object.create(THREE.Line.prototype);\nTHREE.CameraHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Camera,c=new THREE.Projector;return function(){function d(d,g,h,i){a.set(g,h,i);c.unprojectVector(a,b);d=e.pointMap[d];if(void 0!==d){g=0;for(h=d.length;g<h;g++)e.geometry.vertices[d[g]].copy(a)}}var e=this;b.projectionMatrix.copy(this.camera.projectionMatrix);d(\"c\",0,0,-1);d(\"t\",0,0,1);d(\"n1\",-1,-1,-1);d(\"n2\",1,-1,-1);d(\"n3\",-1,1,-1);d(\"n4\",1,1,-1);d(\"f1\",-1,-1,1);d(\"f2\",1,-1,1);d(\"f3\",-1,1,1);d(\"f4\",1,1,1);d(\"u1\",\n0.7,1.1,-1);d(\"u2\",-0.7,1.1,-1);d(\"u3\",0,2,-1);d(\"cf1\",-1,0,1);d(\"cf2\",1,0,1);d(\"cf3\",0,-1,1);d(\"cf4\",0,1,1);d(\"cn1\",-1,0,-1);d(\"cn2\",1,0,-1);d(\"cn3\",0,-1,-1);d(\"cn4\",0,1,-1);this.geometry.verticesNeedUpdate=!0}}();THREE.DirectionalLightHelper=function(a,b){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;var b=b||1,c=new THREE.PlaneGeometry(b,b),d=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});d.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.lightPlane=new THREE.Mesh(c,d);this.add(this.lightPlane);c=new THREE.Geometry;c.vertices.push(new THREE.Vector3);c.vertices.push(new THREE.Vector3);d=new THREE.LineBasicMaterial({fog:!1});\nd.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.targetLine=new THREE.Line(c,d);this.add(this.targetLine);this.update()};THREE.DirectionalLightHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.DirectionalLightHelper.prototype.dispose=function(){this.lightPlane.geometry.dispose();this.lightPlane.material.dispose();this.targetLine.geometry.dispose();this.targetLine.material.dispose()};\nTHREE.DirectionalLightHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(){a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);c.subVectors(b,a);this.lightPlane.lookAt(c);this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.targetLine.geometry.vertices[1].copy(c);this.targetLine.geometry.verticesNeedUpdate=!0;this.targetLine.material.color.copy(this.lightPlane.material.color)}}();THREE.EdgesHelper=function(a,b){var c=void 0!==b?b:16777215,d=[0,0],e={},f=function(a,b){return a-b},g=[\"a\",\"b\",\"c\"],h=new THREE.BufferGeometry,i=a.geometry.clone();i.mergeVertices();i.computeFaceNormals();for(var k=i.vertices,i=i.faces,l=0,n=0,p=i.length;n<p;n++)for(var t=i[n],r=0;3>r;r++){d[0]=t[g[r]];d[1]=t[g[(r+1)%3]];d.sort(f);var m=d.toString();void 0===e[m]?(e[m]={vert1:d[0],vert2:d[1],face1:n,face2:void 0},l++):e[m].face2=n}h.addAttribute(\"position\",Float32Array,2*l,3);d=h.attributes.position.array;\nf=0;for(m in e)if(g=e[m],void 0===g.face2||0.9999>i[g.face1].normal.dot(i[g.face2].normal))l=k[g.vert1],d[f++]=l.x,d[f++]=l.y,d[f++]=l.z,l=k[g.vert2],d[f++]=l.x,d[f++]=l.y,d[f++]=l.z;THREE.Line.call(this,h,new THREE.LineBasicMaterial({color:c}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.matrixWorld=a.matrixWorld};THREE.EdgesHelper.prototype=Object.create(THREE.Line.prototype);THREE.FaceNormalsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;for(var a=void 0!==c?c:16776960,d=void 0!==d?d:1,b=new THREE.Geometry,c=0,e=this.object.geometry.faces.length;c<e;c++)b.vertices.push(new THREE.Vector3),b.vertices.push(new THREE.Vector3);THREE.Line.call(this,b,new THREE.LineBasicMaterial({color:a,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.normalMatrix=new THREE.Matrix3;this.update()};THREE.FaceNormalsHelper.prototype=Object.create(THREE.Line.prototype);\nTHREE.FaceNormalsHelper.prototype.update=function(){var a=new THREE.Vector3;return function(){this.object.updateMatrixWorld(!0);this.normalMatrix.getNormalMatrix(this.object.matrixWorld);for(var b=this.geometry.vertices,c=this.object.geometry.faces,d=this.object.matrixWorld,e=0,f=c.length;e<f;e++){var g=c[e];a.copy(g.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);var h=2*e;b[h].copy(g.centroid).applyMatrix4(d);b[h+1].addVectors(b[h],a)}this.geometry.verticesNeedUpdate=\n!0;return this}}();THREE.GridHelper=function(a,b){var c=new THREE.Geometry,d=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});this.color1=new THREE.Color(4473924);this.color2=new THREE.Color(8947848);for(var e=-a;e<=a;e+=b){c.vertices.push(new THREE.Vector3(-a,0,e),new THREE.Vector3(a,0,e),new THREE.Vector3(e,0,-a),new THREE.Vector3(e,0,a));var f=0===e?this.color1:this.color2;c.colors.push(f,f,f,f)}THREE.Line.call(this,c,d,THREE.LinePieces)};THREE.GridHelper.prototype=Object.create(THREE.Line.prototype);\nTHREE.GridHelper.prototype.setColors=function(a,b){this.color1.set(a);this.color2.set(b);this.geometry.colorsNeedUpdate=!0};THREE.HemisphereLightHelper=function(a,b){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;this.colors=[new THREE.Color,new THREE.Color];var c=new THREE.SphereGeometry(b,4,2);c.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI/2));for(var d=0;8>d;d++)c.faces[d].color=this.colors[4>d?0:1];d=new THREE.MeshBasicMaterial({vertexColors:THREE.FaceColors,wireframe:!0});this.lightSphere=new THREE.Mesh(c,d);this.add(this.lightSphere);\nthis.update()};THREE.HemisphereLightHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.HemisphereLightHelper.prototype.dispose=function(){this.lightSphere.geometry.dispose();this.lightSphere.material.dispose()};\nTHREE.HemisphereLightHelper.prototype.update=function(){var a=new THREE.Vector3;return function(){this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());this.lightSphere.geometry.colorsNeedUpdate=!0}}();THREE.PointLightHelper=function(a,b){this.light=a;this.light.updateMatrixWorld();var c=new THREE.SphereGeometry(b,4,2),d=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});d.color.copy(this.light.color).multiplyScalar(this.light.intensity);THREE.Mesh.call(this,c,d);this.matrixWorld=this.light.matrixWorld;this.matrixAutoUpdate=!1};THREE.PointLightHelper.prototype=Object.create(THREE.Mesh.prototype);THREE.PointLightHelper.prototype.dispose=function(){this.geometry.dispose();this.material.dispose()};\nTHREE.PointLightHelper.prototype.update=function(){this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)};THREE.SpotLightHelper=function(a){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;a=new THREE.CylinderGeometry(0,1,1,8,1,!0);a.applyMatrix((new THREE.Matrix4).makeTranslation(0,-0.5,0));a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI/2));var b=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});this.cone=new THREE.Mesh(a,b);this.add(this.cone);this.update()};THREE.SpotLightHelper.prototype=Object.create(THREE.Object3D.prototype);\nTHREE.SpotLightHelper.prototype.dispose=function(){this.cone.geometry.dispose();this.cone.material.dispose()};THREE.SpotLightHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(){var c=this.light.distance?this.light.distance:1E4,d=c*Math.tan(this.light.angle);this.cone.scale.set(d,d,c);a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(b.sub(a));this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)}}();THREE.VertexNormalsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;for(var b=void 0!==c?c:16711680,d=void 0!==d?d:1,c=new THREE.Geometry,a=a.geometry.faces,e=0,f=a.length;e<f;e++)for(var g=0,h=a[e].vertexNormals.length;g<h;g++)c.vertices.push(new THREE.Vector3),c.vertices.push(new THREE.Vector3);THREE.Line.call(this,c,new THREE.LineBasicMaterial({color:b,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.normalMatrix=new THREE.Matrix3;this.update()};\nTHREE.VertexNormalsHelper.prototype=Object.create(THREE.Line.prototype);\nTHREE.VertexNormalsHelper.prototype.update=function(){var a=new THREE.Vector3;return function(){var b=[\"a\",\"b\",\"c\",\"d\"];this.object.updateMatrixWorld(!0);this.normalMatrix.getNormalMatrix(this.object.matrixWorld);for(var c=this.geometry.vertices,d=this.object.geometry.vertices,e=this.object.geometry.faces,f=this.object.matrixWorld,g=0,h=0,i=e.length;h<i;h++)for(var k=e[h],l=0,n=k.vertexNormals.length;l<n;l++){var p=k.vertexNormals[l];c[g].copy(d[k[b[l]]]).applyMatrix4(f);a.copy(p).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);\na.add(c[g]);g+=1;c[g].copy(a);g+=1}this.geometry.verticesNeedUpdate=!0;return this}}();THREE.VertexTangentsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;for(var b=void 0!==c?c:255,d=void 0!==d?d:1,c=new THREE.Geometry,a=a.geometry.faces,e=0,f=a.length;e<f;e++)for(var g=0,h=a[e].vertexTangents.length;g<h;g++)c.vertices.push(new THREE.Vector3),c.vertices.push(new THREE.Vector3);THREE.Line.call(this,c,new THREE.LineBasicMaterial({color:b,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.update()};THREE.VertexTangentsHelper.prototype=Object.create(THREE.Line.prototype);\nTHREE.VertexTangentsHelper.prototype.update=function(){var a=new THREE.Vector3;return function(){var b=[\"a\",\"b\",\"c\",\"d\"];this.object.updateMatrixWorld(!0);for(var c=this.geometry.vertices,d=this.object.geometry.vertices,e=this.object.geometry.faces,f=this.object.matrixWorld,g=0,h=0,i=e.length;h<i;h++)for(var k=e[h],l=0,n=k.vertexTangents.length;l<n;l++){var p=k.vertexTangents[l];c[g].copy(d[k[b[l]]]).applyMatrix4(f);a.copy(p).transformDirection(f).multiplyScalar(this.size);a.add(c[g]);g+=1;c[g].copy(a);\ng+=1}this.geometry.verticesNeedUpdate=!0;return this}}();THREE.WireframeHelper=function(a,b){var c=void 0!==b?b:16777215,d=[0,0],e={},f=function(a,b){return a-b},g=[\"a\",\"b\",\"c\"],h=new THREE.BufferGeometry;if(a.geometry instanceof THREE.Geometry){for(var i=a.geometry.vertices,k=a.geometry.faces,l=0,n=new Uint32Array(6*k.length),p=0,t=k.length;p<t;p++)for(var r=k[p],m=0;3>m;m++){d[0]=r[g[m]];d[1]=r[g[(m+1)%3]];d.sort(f);var q=d.toString();void 0===e[q]&&(n[2*l]=d[0],n[2*l+1]=d[1],e[q]=!0,l++)}h.addAttribute(\"position\",Float32Array,2*l,3);d=h.attributes.position.array;\np=0;for(t=l;p<t;p++)for(m=0;2>m;m++)l=i[n[2*p+m]],g=6*p+3*m,d[g+0]=l.x,d[g+1]=l.y,d[g+2]=l.z}else if(a.geometry instanceof THREE.BufferGeometry&&void 0!==a.geometry.attributes.index){for(var i=a.geometry.attributes.position.array,t=a.geometry.attributes.index.array,k=a.geometry.offsets,l=0,n=new Uint32Array(2*t.length),r=0,u=k.length;r<u;++r)for(var m=k[r].start,q=k[r].count,g=k[r].index,p=m,s=m+q;p<s;p+=3)for(m=0;3>m;m++)d[0]=g+t[p+m],d[1]=g+t[p+(m+1)%3],d.sort(f),q=d.toString(),void 0===e[q]&&(n[2*\nl]=d[0],n[2*l+1]=d[1],e[q]=!0,l++);h.addAttribute(\"position\",Float32Array,2*l,3);d=h.attributes.position.array;p=0;for(t=l;p<t;p++)for(m=0;2>m;m++)g=6*p+3*m,l=3*n[2*p+m],d[g+0]=i[l],d[g+1]=i[l+1],d[g+2]=i[l+2]}else if(a.geometry instanceof THREE.BufferGeometry){i=a.geometry.attributes.position.array;l=i.length/3;n=l/3;h.addAttribute(\"position\",Float32Array,2*l,3);d=h.attributes.position.array;p=0;for(t=n;p<t;p++)for(m=0;3>m;m++)g=18*p+6*m,n=9*p+3*m,d[g+0]=i[n],d[g+1]=i[n+1],d[g+2]=i[n+2],l=9*p+3*\n((m+1)%3),d[g+3]=i[l],d[g+4]=i[l+1],d[g+5]=i[l+2]}THREE.Line.call(this,h,new THREE.LineBasicMaterial({color:c}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.matrixWorld=a.matrixWorld};THREE.WireframeHelper.prototype=Object.create(THREE.Line.prototype);THREE.ImmediateRenderObject=function(){THREE.Object3D.call(this);this.render=function(){}};THREE.ImmediateRenderObject.prototype=Object.create(THREE.Object3D.prototype);THREE.LensFlare=function(a,b,c,d,e){THREE.Object3D.call(this);this.lensFlares=[];this.positionScreen=new THREE.Vector3;this.customUpdateCallback=void 0;void 0!==a&&this.add(a,b,c,d,e)};THREE.LensFlare.prototype=Object.create(THREE.Object3D.prototype);\nTHREE.LensFlare.prototype.add=function(a,b,c,d,e,f){void 0===b&&(b=-1);void 0===c&&(c=0);void 0===f&&(f=1);void 0===e&&(e=new THREE.Color(16777215));void 0===d&&(d=THREE.NormalBlending);c=Math.min(c,Math.max(0,c));this.lensFlares.push({texture:a,size:b,distance:c,x:0,y:0,z:0,scale:1,rotation:1,opacity:f,color:e,blending:d})};\nTHREE.LensFlare.prototype.updateLensFlares=function(){var a,b=this.lensFlares.length,c,d=2*-this.positionScreen.x,e=2*-this.positionScreen.y;for(a=0;a<b;a++)c=this.lensFlares[a],c.x=this.positionScreen.x+d*c.distance,c.y=this.positionScreen.y+e*c.distance,c.wantedRotation=0.25*c.x*Math.PI,c.rotation+=0.25*(c.wantedRotation-c.rotation)};THREE.MorphBlendMesh=function(a,b){THREE.Mesh.call(this,a,b);this.animationsMap={};this.animationsList=[];var c=this.geometry.morphTargets.length;this.createAnimation(\"__default\",0,c-1,c/1);this.setAnimationWeight(\"__default\",1)};THREE.MorphBlendMesh.prototype=Object.create(THREE.Mesh.prototype);\nTHREE.MorphBlendMesh.prototype.createAnimation=function(a,b,c,d){b={startFrame:b,endFrame:c,length:c-b+1,fps:d,duration:(c-b)/d,lastFrame:0,currentFrame:0,active:!1,time:0,direction:1,weight:1,directionBackwards:!1,mirroredLoop:!1};this.animationsMap[a]=b;this.animationsList.push(b)};\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations=function(a){for(var b=/([a-z]+)(\\d+)/,c,d={},e=this.geometry,f=0,g=e.morphTargets.length;f<g;f++){var h=e.morphTargets[f].name.match(b);if(h&&1<h.length){var i=h[1];d[i]||(d[i]={start:Infinity,end:-Infinity});h=d[i];f<h.start&&(h.start=f);f>h.end&&(h.end=f);c||(c=i)}}for(i in d)h=d[i],this.createAnimation(i,h.start,h.end,a);this.firstAnimation=c};\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward=function(a){if(a=this.animationsMap[a])a.direction=1,a.directionBackwards=!1};THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward=function(a){if(a=this.animationsMap[a])a.direction=-1,a.directionBackwards=!0};THREE.MorphBlendMesh.prototype.setAnimationFPS=function(a,b){var c=this.animationsMap[a];c&&(c.fps=b,c.duration=(c.end-c.start)/c.fps)};\nTHREE.MorphBlendMesh.prototype.setAnimationDuration=function(a,b){var c=this.animationsMap[a];c&&(c.duration=b,c.fps=(c.end-c.start)/c.duration)};THREE.MorphBlendMesh.prototype.setAnimationWeight=function(a,b){var c=this.animationsMap[a];c&&(c.weight=b)};THREE.MorphBlendMesh.prototype.setAnimationTime=function(a,b){var c=this.animationsMap[a];c&&(c.time=b)};THREE.MorphBlendMesh.prototype.getAnimationTime=function(a){var b=0;if(a=this.animationsMap[a])b=a.time;return b};\nTHREE.MorphBlendMesh.prototype.getAnimationDuration=function(a){var b=-1;if(a=this.animationsMap[a])b=a.duration;return b};THREE.MorphBlendMesh.prototype.playAnimation=function(a){var b=this.animationsMap[a];b?(b.time=0,b.active=!0):console.warn(\"animation[\"+a+\"] undefined\")};THREE.MorphBlendMesh.prototype.stopAnimation=function(a){if(a=this.animationsMap[a])a.active=!1};\nTHREE.MorphBlendMesh.prototype.update=function(a){for(var b=0,c=this.animationsList.length;b<c;b++){var d=this.animationsList[b];if(d.active){var e=d.duration/d.length;d.time+=d.direction*a;if(d.mirroredLoop){if(d.time>d.duration||0>d.time)d.direction*=-1,d.time>d.duration&&(d.time=d.duration,d.directionBackwards=!0),0>d.time&&(d.time=0,d.directionBackwards=!1)}else d.time%=d.duration,0>d.time&&(d.time+=d.duration);var f=d.startFrame+THREE.Math.clamp(Math.floor(d.time/e),0,d.length-1),g=d.weight;\nf!==d.currentFrame&&(this.morphTargetInfluences[d.lastFrame]=0,this.morphTargetInfluences[d.currentFrame]=1*g,this.morphTargetInfluences[f]=0,d.lastFrame=d.currentFrame,d.currentFrame=f);e=d.time%e/e;d.directionBackwards&&(e=1-e);this.morphTargetInfluences[d.currentFrame]=e*g;this.morphTargetInfluences[d.lastFrame]=(1-e)*g}}};THREE.LensFlarePlugin=function(){function a(a,c){var d=b.createProgram(),e=b.createShader(b.FRAGMENT_SHADER),f=b.createShader(b.VERTEX_SHADER),g=\"precision \"+c+\" float;\\n\";b.shaderSource(e,g+a.fragmentShader);b.shaderSource(f,g+a.vertexShader);b.compileShader(e);b.compileShader(f);b.attachShader(d,e);b.attachShader(d,f);b.linkProgram(d);return d}var b,c,d,e,f,g,h,i,k,l,n,p,t;this.init=function(r){b=r.context;c=r;d=r.getPrecision();e=new Float32Array(16);f=new Uint16Array(6);r=0;e[r++]=-1;e[r++]=-1;\ne[r++]=0;e[r++]=0;e[r++]=1;e[r++]=-1;e[r++]=1;e[r++]=0;e[r++]=1;e[r++]=1;e[r++]=1;e[r++]=1;e[r++]=-1;e[r++]=1;e[r++]=0;e[r++]=1;r=0;f[r++]=0;f[r++]=1;f[r++]=2;f[r++]=0;f[r++]=2;f[r++]=3;g=b.createBuffer();h=b.createBuffer();b.bindBuffer(b.ARRAY_BUFFER,g);b.bufferData(b.ARRAY_BUFFER,e,b.STATIC_DRAW);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,h);b.bufferData(b.ELEMENT_ARRAY_BUFFER,f,b.STATIC_DRAW);i=b.createTexture();k=b.createTexture();b.bindTexture(b.TEXTURE_2D,i);b.texImage2D(b.TEXTURE_2D,0,b.RGB,16,16,\n0,b.RGB,b.UNSIGNED_BYTE,null);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.NEAREST);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.NEAREST);b.bindTexture(b.TEXTURE_2D,k);b.texImage2D(b.TEXTURE_2D,0,b.RGBA,16,16,0,b.RGBA,b.UNSIGNED_BYTE,null);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE);\nb.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.NEAREST);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.NEAREST);0>=b.getParameter(b.MAX_VERTEX_TEXTURE_IMAGE_UNITS)?(l=!1,n=a(THREE.ShaderFlares.lensFlare,d)):(l=!0,n=a(THREE.ShaderFlares.lensFlareVertexTexture,d));p={};t={};p.vertex=b.getAttribLocation(n,\"position\");p.uv=b.getAttribLocation(n,\"uv\");t.renderType=b.getUniformLocation(n,\"renderType\");t.map=b.getUniformLocation(n,\"map\");t.occlusionMap=b.getUniformLocation(n,\"occlusionMap\");t.opacity=\nb.getUniformLocation(n,\"opacity\");t.color=b.getUniformLocation(n,\"color\");t.scale=b.getUniformLocation(n,\"scale\");t.rotation=b.getUniformLocation(n,\"rotation\");t.screenPosition=b.getUniformLocation(n,\"screenPosition\")};this.render=function(a,d,e,f){var a=a.__webglFlares,s=a.length;if(s){var v=new THREE.Vector3,z=f/e,G=0.5*e,N=0.5*f,C=16/f,B=new THREE.Vector2(C*z,C),x=new THREE.Vector3(1,1,0),F=new THREE.Vector2(1,1),L=t,C=p;b.useProgram(n);b.enableVertexAttribArray(p.vertex);b.enableVertexAttribArray(p.uv);\nb.uniform1i(L.occlusionMap,0);b.uniform1i(L.map,1);b.bindBuffer(b.ARRAY_BUFFER,g);b.vertexAttribPointer(C.vertex,2,b.FLOAT,!1,16,0);b.vertexAttribPointer(C.uv,2,b.FLOAT,!1,16,8);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,h);b.disable(b.CULL_FACE);b.depthMask(!1);var w,E,y,D,H;for(w=0;w<s;w++)if(C=16/f,B.set(C*z,C),D=a[w],v.set(D.matrixWorld.elements[12],D.matrixWorld.elements[13],D.matrixWorld.elements[14]),v.applyMatrix4(d.matrixWorldInverse),v.applyProjection(d.projectionMatrix),x.copy(v),F.x=x.x*G+G,\nF.y=x.y*N+N,l||0<F.x&&F.x<e&&0<F.y&&F.y<f){b.activeTexture(b.TEXTURE1);b.bindTexture(b.TEXTURE_2D,i);b.copyTexImage2D(b.TEXTURE_2D,0,b.RGB,F.x-8,F.y-8,16,16,0);b.uniform1i(L.renderType,0);b.uniform2f(L.scale,B.x,B.y);b.uniform3f(L.screenPosition,x.x,x.y,x.z);b.disable(b.BLEND);b.enable(b.DEPTH_TEST);b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0);b.activeTexture(b.TEXTURE0);b.bindTexture(b.TEXTURE_2D,k);b.copyTexImage2D(b.TEXTURE_2D,0,b.RGBA,F.x-8,F.y-8,16,16,0);b.uniform1i(L.renderType,1);b.disable(b.DEPTH_TEST);\nb.activeTexture(b.TEXTURE1);b.bindTexture(b.TEXTURE_2D,i);b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0);D.positionScreen.copy(x);D.customUpdateCallback?D.customUpdateCallback(D):D.updateLensFlares();b.uniform1i(L.renderType,2);b.enable(b.BLEND);E=0;for(y=D.lensFlares.length;E<y;E++)H=D.lensFlares[E],0.001<H.opacity&&0.001<H.scale&&(x.x=H.x,x.y=H.y,x.z=H.z,C=H.size*H.scale/f,B.x=C*z,B.y=C,b.uniform3f(L.screenPosition,x.x,x.y,x.z),b.uniform2f(L.scale,B.x,B.y),b.uniform1f(L.rotation,H.rotation),b.uniform1f(L.opacity,\nH.opacity),b.uniform3f(L.color,H.color.r,H.color.g,H.color.b),c.setBlending(H.blending,H.blendEquation,H.blendSrc,H.blendDst),c.setTexture(H.texture,1),b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0))}b.enable(b.CULL_FACE);b.enable(b.DEPTH_TEST);b.depthMask(!0)}}};THREE.ShadowMapPlugin=function(){var a,b,c,d,e,f,g=new THREE.Frustum,h=new THREE.Matrix4,i=new THREE.Vector3,k=new THREE.Vector3,l=new THREE.Vector3;this.init=function(g){a=g.context;b=g;var g=THREE.ShaderLib.depthRGBA,h=THREE.UniformsUtils.clone(g.uniforms);c=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h});d=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:!0});e=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,\nvertexShader:g.vertexShader,uniforms:h,skinning:!0});f=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:!0,skinning:!0});c._shadowPass=!0;d._shadowPass=!0;e._shadowPass=!0;f._shadowPass=!0};this.render=function(a,c){b.shadowMapEnabled&&b.shadowMapAutoUpdate&&this.update(a,c)};this.update=function(n,p){var t,r,m,q,u,s,v,z,G,N=[];q=0;a.clearColor(1,1,1,1);a.disable(a.BLEND);a.enable(a.CULL_FACE);a.frontFace(a.CCW);b.shadowMapCullFace===THREE.CullFaceFront?\na.cullFace(a.FRONT):a.cullFace(a.BACK);b.setDepthTest(!0);t=0;for(r=n.__lights.length;t<r;t++)if(m=n.__lights[t],m.castShadow)if(m instanceof THREE.DirectionalLight&&m.shadowCascade)for(u=0;u<m.shadowCascadeCount;u++){var C;if(m.shadowCascadeArray[u])C=m.shadowCascadeArray[u];else{G=m;v=u;C=new THREE.DirectionalLight;C.isVirtual=!0;C.onlyShadow=!0;C.castShadow=!0;C.shadowCameraNear=G.shadowCameraNear;C.shadowCameraFar=G.shadowCameraFar;C.shadowCameraLeft=G.shadowCameraLeft;C.shadowCameraRight=G.shadowCameraRight;\nC.shadowCameraBottom=G.shadowCameraBottom;C.shadowCameraTop=G.shadowCameraTop;C.shadowCameraVisible=G.shadowCameraVisible;C.shadowDarkness=G.shadowDarkness;C.shadowBias=G.shadowCascadeBias[v];C.shadowMapWidth=G.shadowCascadeWidth[v];C.shadowMapHeight=G.shadowCascadeHeight[v];C.pointsWorld=[];C.pointsFrustum=[];z=C.pointsWorld;s=C.pointsFrustum;for(var B=0;8>B;B++)z[B]=new THREE.Vector3,s[B]=new THREE.Vector3;z=G.shadowCascadeNearZ[v];G=G.shadowCascadeFarZ[v];s[0].set(-1,-1,z);s[1].set(1,-1,z);s[2].set(-1,\n1,z);s[3].set(1,1,z);s[4].set(-1,-1,G);s[5].set(1,-1,G);s[6].set(-1,1,G);s[7].set(1,1,G);C.originalCamera=p;s=new THREE.Gyroscope;s.position=m.shadowCascadeOffset;s.add(C);s.add(C.target);p.add(s);m.shadowCascadeArray[u]=C;console.log(\"Created virtualLight\",C)}v=m;z=u;G=v.shadowCascadeArray[z];G.position.copy(v.position);G.target.position.copy(v.target.position);G.lookAt(G.target);G.shadowCameraVisible=v.shadowCameraVisible;G.shadowDarkness=v.shadowDarkness;G.shadowBias=v.shadowCascadeBias[z];s=v.shadowCascadeNearZ[z];\nv=v.shadowCascadeFarZ[z];G=G.pointsFrustum;G[0].z=s;G[1].z=s;G[2].z=s;G[3].z=s;G[4].z=v;G[5].z=v;G[6].z=v;G[7].z=v;N[q]=C;q++}else N[q]=m,q++;t=0;for(r=N.length;t<r;t++){m=N[t];m.shadowMap||(u=THREE.LinearFilter,b.shadowMapType===THREE.PCFSoftShadowMap&&(u=THREE.NearestFilter),m.shadowMap=new THREE.WebGLRenderTarget(m.shadowMapWidth,m.shadowMapHeight,{minFilter:u,magFilter:u,format:THREE.RGBAFormat}),m.shadowMapSize=new THREE.Vector2(m.shadowMapWidth,m.shadowMapHeight),m.shadowMatrix=new THREE.Matrix4);\nif(!m.shadowCamera){if(m instanceof THREE.SpotLight)m.shadowCamera=new THREE.PerspectiveCamera(m.shadowCameraFov,m.shadowMapWidth/m.shadowMapHeight,m.shadowCameraNear,m.shadowCameraFar);else if(m instanceof THREE.DirectionalLight)m.shadowCamera=new THREE.OrthographicCamera(m.shadowCameraLeft,m.shadowCameraRight,m.shadowCameraTop,m.shadowCameraBottom,m.shadowCameraNear,m.shadowCameraFar);else{console.error(\"Unsupported light type for shadow\");continue}n.add(m.shadowCamera);!0===n.autoUpdate&&n.updateMatrixWorld()}m.shadowCameraVisible&&\n!m.cameraHelper&&(m.cameraHelper=new THREE.CameraHelper(m.shadowCamera),m.shadowCamera.add(m.cameraHelper));if(m.isVirtual&&C.originalCamera==p){u=p;q=m.shadowCamera;s=m.pointsFrustum;G=m.pointsWorld;i.set(Infinity,Infinity,Infinity);k.set(-Infinity,-Infinity,-Infinity);for(v=0;8>v;v++)z=G[v],z.copy(s[v]),THREE.ShadowMapPlugin.__projector.unprojectVector(z,u),z.applyMatrix4(q.matrixWorldInverse),z.x<i.x&&(i.x=z.x),z.x>k.x&&(k.x=z.x),z.y<i.y&&(i.y=z.y),z.y>k.y&&(k.y=z.y),z.z<i.z&&(i.z=z.z),z.z>k.z&&\n(k.z=z.z);q.left=i.x;q.right=k.x;q.top=k.y;q.bottom=i.y;q.updateProjectionMatrix()}q=m.shadowMap;s=m.shadowMatrix;u=m.shadowCamera;u.position.setFromMatrixPosition(m.matrixWorld);l.setFromMatrixPosition(m.target.matrixWorld);u.lookAt(l);u.updateMatrixWorld();u.matrixWorldInverse.getInverse(u.matrixWorld);m.cameraHelper&&(m.cameraHelper.visible=m.shadowCameraVisible);m.shadowCameraVisible&&m.cameraHelper.update();s.set(0.5,0,0,0.5,0,0.5,0,0.5,0,0,0.5,0.5,0,0,0,1);s.multiply(u.projectionMatrix);s.multiply(u.matrixWorldInverse);\nh.multiplyMatrices(u.projectionMatrix,u.matrixWorldInverse);g.setFromMatrix(h);b.setRenderTarget(q);b.clear();G=n.__webglObjects;m=0;for(q=G.length;m<q;m++)if(v=G[m],s=v.object,v.render=!1,s.visible&&s.castShadow&&(!(s instanceof THREE.Mesh||s instanceof THREE.ParticleSystem)||!s.frustumCulled||g.intersectsObject(s)))s._modelViewMatrix.multiplyMatrices(u.matrixWorldInverse,s.matrixWorld),v.render=!0;m=0;for(q=G.length;m<q;m++)v=G[m],v.render&&(s=v.object,v=v.buffer,B=s.material instanceof THREE.MeshFaceMaterial?\ns.material.materials[0]:s.material,z=0<s.geometry.morphTargets.length&&B.morphTargets,B=s instanceof THREE.SkinnedMesh&&B.skinning,z=s.customDepthMaterial?s.customDepthMaterial:B?z?f:e:z?d:c,v instanceof THREE.BufferGeometry?b.renderBufferDirect(u,n.__lights,null,z,v,s):b.renderBuffer(u,n.__lights,null,z,v,s));G=n.__webglObjectsImmediate;m=0;for(q=G.length;m<q;m++)v=G[m],s=v.object,s.visible&&s.castShadow&&(s._modelViewMatrix.multiplyMatrices(u.matrixWorldInverse,s.matrixWorld),b.renderImmediateObject(u,\nn.__lights,null,c,s))}t=b.getClearColor();r=b.getClearAlpha();a.clearColor(t.r,t.g,t.b,r);a.enable(a.BLEND);b.shadowMapCullFace===THREE.CullFaceFront&&a.cullFace(a.BACK)}};THREE.ShadowMapPlugin.__projector=new THREE.Projector;THREE.SpritePlugin=function(){var a,b,c,d,e,f,g,h,i,k,l,n,p,t,r,m,q;function u(a,b){return a.z!==b.z?b.z-a.z:b.id-a.id}var s,v,z,G,N,C,B,x;this.init=function(u){s=u.context;v=u;G=new Float32Array([-0.5,-0.5,0,0,0.5,-0.5,1,0,0.5,0.5,1,1,-0.5,0.5,0,1]);N=new Uint16Array([0,1,2,0,2,3]);C=s.createBuffer();B=s.createBuffer();s.bindBuffer(s.ARRAY_BUFFER,C);s.bufferData(s.ARRAY_BUFFER,G,s.STATIC_DRAW);s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,B);s.bufferData(s.ELEMENT_ARRAY_BUFFER,N,s.STATIC_DRAW);var u=s.createProgram(),\nL=s.createShader(s.VERTEX_SHADER),w=s.createShader(s.FRAGMENT_SHADER);s.shaderSource(L,[\"precision \"+v.getPrecision()+\" float;\",\"uniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform float rotation;\\nuniform vec2 scale;\\nuniform vec2 uvOffset;\\nuniform vec2 uvScale;\\nattribute vec2 position;\\nattribute vec2 uv;\\nvarying vec2 vUV;\\nvoid main() {\\nvUV = uvOffset + uv * uvScale;\\nvec2 alignedPosition = position * scale;\\nvec2 rotatedPosition;\\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\nvec4 finalPosition;\\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\nfinalPosition.xy += rotatedPosition;\\nfinalPosition = projectionMatrix * finalPosition;\\ngl_Position = finalPosition;\\n}\"].join(\"\\n\"));\ns.shaderSource(w,[\"precision \"+v.getPrecision()+\" float;\",\"uniform vec3 color;\\nuniform sampler2D map;\\nuniform float opacity;\\nuniform int fogType;\\nuniform vec3 fogColor;\\nuniform float fogDensity;\\nuniform float fogNear;\\nuniform float fogFar;\\nuniform float alphaTest;\\nvarying vec2 vUV;\\nvoid main() {\\nvec4 texture = texture2D( map, vUV );\\nif ( texture.a < alphaTest ) discard;\\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\\nif ( fogType > 0 ) {\\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\nfloat fogFactor = 0.0;\\nif ( fogType == 1 ) {\\nfogFactor = smoothstep( fogNear, fogFar, depth );\\n} else {\\nconst float LOG2 = 1.442695;\\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\\n}\\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n}\\n}\"].join(\"\\n\"));\ns.compileShader(L);s.compileShader(w);s.attachShader(u,L);s.attachShader(u,w);s.linkProgram(u);x=u;m=s.getAttribLocation(x,\"position\");q=s.getAttribLocation(x,\"uv\");a=s.getUniformLocation(x,\"uvOffset\");b=s.getUniformLocation(x,\"uvScale\");c=s.getUniformLocation(x,\"rotation\");d=s.getUniformLocation(x,\"scale\");e=s.getUniformLocation(x,\"color\");f=s.getUniformLocation(x,\"map\");g=s.getUniformLocation(x,\"opacity\");h=s.getUniformLocation(x,\"modelViewMatrix\");i=s.getUniformLocation(x,\"projectionMatrix\");k=\ns.getUniformLocation(x,\"fogType\");l=s.getUniformLocation(x,\"fogDensity\");n=s.getUniformLocation(x,\"fogNear\");p=s.getUniformLocation(x,\"fogFar\");t=s.getUniformLocation(x,\"fogColor\");r=s.getUniformLocation(x,\"alphaTest\");u=document.createElement(\"canvas\");u.width=8;u.height=8;L=u.getContext(\"2d\");L.fillStyle=\"#ffffff\";L.fillRect(0,0,u.width,u.height);z=new THREE.Texture(u);z.needsUpdate=!0};this.render=function(F,G){var w=F.__webglSprites,E=w.length;if(E){s.useProgram(x);s.enableVertexAttribArray(m);\ns.enableVertexAttribArray(q);s.disable(s.CULL_FACE);s.enable(s.BLEND);s.bindBuffer(s.ARRAY_BUFFER,C);s.vertexAttribPointer(m,2,s.FLOAT,!1,16,0);s.vertexAttribPointer(q,2,s.FLOAT,!1,16,8);s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,B);s.uniformMatrix4fv(i,!1,G.projectionMatrix.elements);s.activeTexture(s.TEXTURE0);s.uniform1i(f,0);var y=0,D=0,H=F.fog;H?(s.uniform3f(t,H.color.r,H.color.g,H.color.b),H instanceof THREE.Fog?(s.uniform1f(n,H.near),s.uniform1f(p,H.far),s.uniform1i(k,1),D=y=1):H instanceof THREE.FogExp2&&\n(s.uniform1f(l,H.density),s.uniform1i(k,2),D=y=2)):(s.uniform1i(k,0),D=y=0);for(var K,A,N=[],H=0;H<E;H++)K=w[H],!1!==K.visible&&(K._modelViewMatrix.multiplyMatrices(G.matrixWorldInverse,K.matrixWorld),K.z=-K._modelViewMatrix.elements[14]);w.sort(u);for(H=0;H<E;H++)K=w[H],!1!==K.visible&&(A=K.material,s.uniform1f(r,A.alphaTest),s.uniformMatrix4fv(h,!1,K._modelViewMatrix.elements),N[0]=K.scale.x,N[1]=K.scale.y,K=F.fog&&A.fog?D:0,y!==K&&(s.uniform1i(k,K),y=K),null!==A.map?(s.uniform2f(a,A.map.offset.x,\nA.map.offset.y),s.uniform2f(b,A.map.repeat.x,A.map.repeat.y)):(s.uniform2f(a,0,0),s.uniform2f(b,1,1)),s.uniform1f(g,A.opacity),s.uniform3f(e,A.color.r,A.color.g,A.color.b),s.uniform1f(c,A.rotation),s.uniform2fv(d,N),v.setBlending(A.blending,A.blendEquation,A.blendSrc,A.blendDst),v.setDepthTest(A.depthTest),v.setDepthWrite(A.depthWrite),A.map&&A.map.image&&A.map.image.width?v.setTexture(A.map,0):v.setTexture(z,0),s.drawElements(s.TRIANGLES,6,s.UNSIGNED_SHORT,0));s.enable(s.CULL_FACE)}}};THREE.DepthPassPlugin=function(){this.enabled=!1;this.renderTarget=null;var a,b,c,d,e,f,g=new THREE.Frustum,h=new THREE.Matrix4;this.init=function(g){a=g.context;b=g;var g=THREE.ShaderLib.depthRGBA,h=THREE.UniformsUtils.clone(g.uniforms);c=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h});d=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:!0});e=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,\nvertexShader:g.vertexShader,uniforms:h,skinning:!0});f=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:!0,skinning:!0});c._shadowPass=!0;d._shadowPass=!0;e._shadowPass=!0;f._shadowPass=!0};this.render=function(a,b){this.enabled&&this.update(a,b)};this.update=function(i,k){var l,n,p,t,r,m;a.clearColor(1,1,1,1);a.disable(a.BLEND);b.setDepthTest(!0);!0===i.autoUpdate&&i.updateMatrixWorld();k.matrixWorldInverse.getInverse(k.matrixWorld);h.multiplyMatrices(k.projectionMatrix,\nk.matrixWorldInverse);g.setFromMatrix(h);b.setRenderTarget(this.renderTarget);b.clear();m=i.__webglObjects;l=0;for(n=m.length;l<n;l++)if(p=m[l],r=p.object,p.render=!1,r.visible&&(!(r instanceof THREE.Mesh||r instanceof THREE.ParticleSystem)||!r.frustumCulled||g.intersectsObject(r)))r._modelViewMatrix.multiplyMatrices(k.matrixWorldInverse,r.matrixWorld),p.render=!0;var q;l=0;for(n=m.length;l<n;l++)if(p=m[l],p.render&&(r=p.object,p=p.buffer,!(r instanceof THREE.ParticleSystem)||r.customDepthMaterial))(q=\nr.material instanceof THREE.MeshFaceMaterial?r.material.materials[0]:r.material)&&b.setMaterialFaces(r.material),t=0<r.geometry.morphTargets.length&&q.morphTargets,q=r instanceof THREE.SkinnedMesh&&q.skinning,t=r.customDepthMaterial?r.customDepthMaterial:q?t?f:e:t?d:c,p instanceof THREE.BufferGeometry?b.renderBufferDirect(k,i.__lights,null,t,p,r):b.renderBuffer(k,i.__lights,null,t,p,r);m=i.__webglObjectsImmediate;l=0;for(n=m.length;l<n;l++)p=m[l],r=p.object,r.visible&&(r._modelViewMatrix.multiplyMatrices(k.matrixWorldInverse,\nr.matrixWorld),b.renderImmediateObject(k,i.__lights,null,c,r));l=b.getClearColor();n=b.getClearAlpha();a.clearColor(l.r,l.g,l.b,n);a.enable(a.BLEND)}};THREE.ShaderFlares={lensFlareVertexTexture:{vertexShader:\"uniform lowp int renderType;\\nuniform vec3 screenPosition;\\nuniform vec2 scale;\\nuniform float rotation;\\nuniform sampler2D occlusionMap;\\nattribute vec2 position;\\nattribute vec2 uv;\\nvarying vec2 vUV;\\nvarying float vVisibility;\\nvoid main() {\\nvUV = uv;\\nvec2 pos = position;\\nif( renderType == 2 ) {\\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\\nvVisibility =        visibility.r / 9.0;\\nvVisibility *= 1.0 - visibility.g / 9.0;\\nvVisibility *=       visibility.b / 9.0;\\nvVisibility *= 1.0 - visibility.a / 9.0;\\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\\n}\\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\\n}\",\nfragmentShader:\"uniform lowp int renderType;\\nuniform sampler2D map;\\nuniform float opacity;\\nuniform vec3 color;\\nvarying vec2 vUV;\\nvarying float vVisibility;\\nvoid main() {\\nif( renderType == 0 ) {\\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\\n} else if( renderType == 1 ) {\\ngl_FragColor = texture2D( map, vUV );\\n} else {\\nvec4 texture = texture2D( map, vUV );\\ntexture.a *= opacity * vVisibility;\\ngl_FragColor = texture;\\ngl_FragColor.rgb *= color;\\n}\\n}\"},lensFlare:{vertexShader:\"uniform lowp int renderType;\\nuniform vec3 screenPosition;\\nuniform vec2 scale;\\nuniform float rotation;\\nattribute vec2 position;\\nattribute vec2 uv;\\nvarying vec2 vUV;\\nvoid main() {\\nvUV = uv;\\nvec2 pos = position;\\nif( renderType == 2 ) {\\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\\n}\\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\\n}\",\nfragmentShader:\"precision mediump float;\\nuniform lowp int renderType;\\nuniform sampler2D map;\\nuniform sampler2D occlusionMap;\\nuniform float opacity;\\nuniform vec3 color;\\nvarying vec2 vUV;\\nvoid main() {\\nif( renderType == 0 ) {\\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\\n} else if( renderType == 1 ) {\\ngl_FragColor = texture2D( map, vUV );\\n} else {\\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\\nvisibility = ( 1.0 - visibility / 4.0 );\\nvec4 texture = texture2D( map, vUV );\\ntexture.a *= opacity * visibility;\\ngl_FragColor = texture;\\ngl_FragColor.rgb *= color;\\n}\\n}\"}};\n",
      "content": "// three.js - http://github.com/mrdoob/three.js\n'use strict';var THREE={REVISION:\"65\"};self.console=self.console||{info:function(){},log:function(){},debug:function(){},warn:function(){},error:function(){}};String.prototype.trim=String.prototype.trim||function(){return this.replace(/^\\s+|\\s+$/g,\"\")};THREE.extend=function(a,b){if(Object.keys)for(var c=Object.keys(b),d=0,e=c.length;d<e;d++){var f=c[d];Object.defineProperty(a,f,Object.getOwnPropertyDescriptor(b,f))}else for(f in c={}.hasOwnProperty,b)c.call(b,f)&&(a[f]=b[f]);return a};\n(function(){for(var a=0,b=[\"ms\",\"moz\",\"webkit\",\"o\"],c=0;c<b.length&&!self.requestAnimationFrame;++c)self.requestAnimationFrame=self[b[c]+\"RequestAnimationFrame\"],self.cancelAnimationFrame=self[b[c]+\"CancelAnimationFrame\"]||self[b[c]+\"CancelRequestAnimationFrame\"];void 0===self.requestAnimationFrame&&void 0!==self.setTimeout&&(self.requestAnimationFrame=function(b){var c=Date.now(),f=Math.max(0,16-(c-a)),g=self.setTimeout(function(){b(c+f)},f);a=c+f;return g});void 0===self.cancelAnimationFrame&&void 0!==\nself.clearTimeout&&(self.cancelAnimationFrame=function(a){self.clearTimeout(a)})})();THREE.CullFaceNone=0;THREE.CullFaceBack=1;THREE.CullFaceFront=2;THREE.CullFaceFrontBack=3;THREE.FrontFaceDirectionCW=0;THREE.FrontFaceDirectionCCW=1;THREE.BasicShadowMap=0;THREE.PCFShadowMap=1;THREE.PCFSoftShadowMap=2;THREE.FrontSide=0;THREE.BackSide=1;THREE.DoubleSide=2;THREE.NoShading=0;THREE.FlatShading=1;THREE.SmoothShading=2;THREE.NoColors=0;THREE.FaceColors=1;THREE.VertexColors=2;THREE.NoBlending=0;\nTHREE.NormalBlending=1;THREE.AdditiveBlending=2;THREE.SubtractiveBlending=3;THREE.MultiplyBlending=4;THREE.CustomBlending=5;THREE.AddEquation=100;THREE.SubtractEquation=101;THREE.ReverseSubtractEquation=102;THREE.ZeroFactor=200;THREE.OneFactor=201;THREE.SrcColorFactor=202;THREE.OneMinusSrcColorFactor=203;THREE.SrcAlphaFactor=204;THREE.OneMinusSrcAlphaFactor=205;THREE.DstAlphaFactor=206;THREE.OneMinusDstAlphaFactor=207;THREE.DstColorFactor=208;THREE.OneMinusDstColorFactor=209;\nTHREE.SrcAlphaSaturateFactor=210;THREE.MultiplyOperation=0;THREE.MixOperation=1;THREE.AddOperation=2;THREE.UVMapping=function(){};THREE.CubeReflectionMapping=function(){};THREE.CubeRefractionMapping=function(){};THREE.SphericalReflectionMapping=function(){};THREE.SphericalRefractionMapping=function(){};THREE.RepeatWrapping=1E3;THREE.ClampToEdgeWrapping=1001;THREE.MirroredRepeatWrapping=1002;THREE.NearestFilter=1003;THREE.NearestMipMapNearestFilter=1004;THREE.NearestMipMapLinearFilter=1005;\nTHREE.LinearFilter=1006;THREE.LinearMipMapNearestFilter=1007;THREE.LinearMipMapLinearFilter=1008;THREE.UnsignedByteType=1009;THREE.ByteType=1010;THREE.ShortType=1011;THREE.UnsignedShortType=1012;THREE.IntType=1013;THREE.UnsignedIntType=1014;THREE.FloatType=1015;THREE.UnsignedShort4444Type=1016;THREE.UnsignedShort5551Type=1017;THREE.UnsignedShort565Type=1018;THREE.AlphaFormat=1019;THREE.RGBFormat=1020;THREE.RGBAFormat=1021;THREE.LuminanceFormat=1022;THREE.LuminanceAlphaFormat=1023;\nTHREE.RGB_S3TC_DXT1_Format=2001;THREE.RGBA_S3TC_DXT1_Format=2002;THREE.RGBA_S3TC_DXT3_Format=2003;THREE.RGBA_S3TC_DXT5_Format=2004;THREE.Color=function(a){void 0!==a&&this.set(a);return this};\nTHREE.Color.prototype={constructor:THREE.Color,r:1,g:1,b:1,set:function(a){a instanceof THREE.Color?this.copy(a):\"number\"===typeof a?this.setHex(a):\"string\"===typeof a&&this.setStyle(a);return this},setHex:function(a){a=Math.floor(a);this.r=(a>>16&255)/255;this.g=(a>>8&255)/255;this.b=(a&255)/255;return this},setRGB:function(a,b,c){this.r=a;this.g=b;this.b=c;return this},setHSL:function(a,b,c){if(0===b)this.r=this.g=this.b=c;else{var d=function(a,b,c){0>c&&(c+=1);1<c&&(c-=1);return c<1/6?a+6*(b-a)*\nc:0.5>c?b:c<2/3?a+6*(b-a)*(2/3-c):a},b=0.5>=c?c*(1+b):c+b-c*b,c=2*c-b;this.r=d(c,b,a+1/3);this.g=d(c,b,a);this.b=d(c,b,a-1/3)}return this},setStyle:function(a){if(/^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.test(a))return a=/^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.exec(a),this.r=Math.min(255,parseInt(a[1],10))/255,this.g=Math.min(255,parseInt(a[2],10))/255,this.b=Math.min(255,parseInt(a[3],10))/255,this;if(/^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.test(a))return a=/^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.exec(a),this.r=\nMath.min(100,parseInt(a[1],10))/100,this.g=Math.min(100,parseInt(a[2],10))/100,this.b=Math.min(100,parseInt(a[3],10))/100,this;if(/^\\#([0-9a-f]{6})$/i.test(a))return a=/^\\#([0-9a-f]{6})$/i.exec(a),this.setHex(parseInt(a[1],16)),this;if(/^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a))return a=/^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a),this.setHex(parseInt(a[1]+a[1]+a[2]+a[2]+a[3]+a[3],16)),this;if(/^(\\w+)$/i.test(a))return this.setHex(THREE.ColorKeywords[a]),this},copy:function(a){this.r=a.r;this.g=\na.g;this.b=a.b;return this},copyGammaToLinear:function(a){this.r=a.r*a.r;this.g=a.g*a.g;this.b=a.b*a.b;return this},copyLinearToGamma:function(a){this.r=Math.sqrt(a.r);this.g=Math.sqrt(a.g);this.b=Math.sqrt(a.b);return this},convertGammaToLinear:function(){var a=this.r,b=this.g,c=this.b;this.r=a*a;this.g=b*b;this.b=c*c;return this},convertLinearToGamma:function(){this.r=Math.sqrt(this.r);this.g=Math.sqrt(this.g);this.b=Math.sqrt(this.b);return this},getHex:function(){return 255*this.r<<16^255*this.g<<\n8^255*this.b<<0},getHexString:function(){return(\"000000\"+this.getHex().toString(16)).slice(-6)},getHSL:function(a){var a=a||{h:0,s:0,l:0},b=this.r,c=this.g,d=this.b,e=Math.max(b,c,d),f=Math.min(b,c,d),g,h=(f+e)/2;if(f===e)f=g=0;else{var i=e-f,f=0.5>=h?i/(e+f):i/(2-e-f);switch(e){case b:g=(c-d)/i+(c<d?6:0);break;case c:g=(d-b)/i+2;break;case d:g=(b-c)/i+4}g/=6}a.h=g;a.s=f;a.l=h;return a},getStyle:function(){return\"rgb(\"+(255*this.r|0)+\",\"+(255*this.g|0)+\",\"+(255*this.b|0)+\")\"},offsetHSL:function(a,\nb,c){var d=this.getHSL();d.h+=a;d.s+=b;d.l+=c;this.setHSL(d.h,d.s,d.l);return this},add:function(a){this.r+=a.r;this.g+=a.g;this.b+=a.b;return this},addColors:function(a,b){this.r=a.r+b.r;this.g=a.g+b.g;this.b=a.b+b.b;return this},addScalar:function(a){this.r+=a;this.g+=a;this.b+=a;return this},multiply:function(a){this.r*=a.r;this.g*=a.g;this.b*=a.b;return this},multiplyScalar:function(a){this.r*=a;this.g*=a;this.b*=a;return this},lerp:function(a,b){this.r+=(a.r-this.r)*b;this.g+=(a.g-this.g)*b;\nthis.b+=(a.b-this.b)*b;return this},equals:function(a){return a.r===this.r&&a.g===this.g&&a.b===this.b},fromArray:function(a){this.r=a[0];this.g=a[1];this.b=a[2];return this},toArray:function(){return[this.r,this.g,this.b]},clone:function(){return(new THREE.Color).setRGB(this.r,this.g,this.b)}};\nTHREE.ColorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,\ndarkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,\ngrey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,\nlime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,\npalegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,\ntomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};THREE.Quaternion=function(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._w=void 0!==d?d:1};\nTHREE.Quaternion.prototype={constructor:THREE.Quaternion,_x:0,_y:0,_z:0,_w:0,_euler:void 0,_updateEuler:function(){void 0!==this._euler&&this._euler.setFromQuaternion(this,void 0,!1)},get x(){return this._x},set x(a){this._x=a;this._updateEuler()},get y(){return this._y},set y(a){this._y=a;this._updateEuler()},get z(){return this._z},set z(a){this._z=a;this._updateEuler()},get w(){return this._w},set w(a){this._w=a;this._updateEuler()},set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._w=d;\nthis._updateEuler();return this},copy:function(a){this._x=a._x;this._y=a._y;this._z=a._z;this._w=a._w;this._updateEuler();return this},setFromEuler:function(a,b){if(!1===a instanceof THREE.Euler)throw Error(\"ERROR: Quaternion's .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.\");var c=Math.cos(a._x/2),d=Math.cos(a._y/2),e=Math.cos(a._z/2),f=Math.sin(a._x/2),g=Math.sin(a._y/2),h=Math.sin(a._z/2);\"XYZ\"===a.order?(this._x=f*d*e+c*g*h,this._y=c*g*\ne-f*d*h,this._z=c*d*h+f*g*e,this._w=c*d*e-f*g*h):\"YXZ\"===a.order?(this._x=f*d*e+c*g*h,this._y=c*g*e-f*d*h,this._z=c*d*h-f*g*e,this._w=c*d*e+f*g*h):\"ZXY\"===a.order?(this._x=f*d*e-c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h+f*g*e,this._w=c*d*e-f*g*h):\"ZYX\"===a.order?(this._x=f*d*e-c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h-f*g*e,this._w=c*d*e+f*g*h):\"YZX\"===a.order?(this._x=f*d*e+c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h-f*g*e,this._w=c*d*e-f*g*h):\"XZY\"===a.order&&(this._x=f*d*e-c*g*h,this._y=c*g*e-f*d*h,this._z=\nc*d*h+f*g*e,this._w=c*d*e+f*g*h);!1!==b&&this._updateEuler();return this},setFromAxisAngle:function(a,b){var c=b/2,d=Math.sin(c);this._x=a.x*d;this._y=a.y*d;this._z=a.z*d;this._w=Math.cos(c);this._updateEuler();return this},setFromRotationMatrix:function(a){var b=a.elements,c=b[0],a=b[4],d=b[8],e=b[1],f=b[5],g=b[9],h=b[2],i=b[6],b=b[10],k=c+f+b;0<k?(c=0.5/Math.sqrt(k+1),this._w=0.25/c,this._x=(i-g)*c,this._y=(d-h)*c,this._z=(e-a)*c):c>f&&c>b?(c=2*Math.sqrt(1+c-f-b),this._w=(i-g)/c,this._x=0.25*c,\nthis._y=(a+e)/c,this._z=(d+h)/c):f>b?(c=2*Math.sqrt(1+f-c-b),this._w=(d-h)/c,this._x=(a+e)/c,this._y=0.25*c,this._z=(g+i)/c):(c=2*Math.sqrt(1+b-c-f),this._w=(e-a)/c,this._x=(d+h)/c,this._y=(g+i)/c,this._z=0.25*c);this._updateEuler();return this},inverse:function(){this.conjugate().normalize();return this},conjugate:function(){this._x*=-1;this._y*=-1;this._z*=-1;this._updateEuler();return this},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*\nthis._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var a=this.length();0===a?(this._z=this._y=this._x=0,this._w=1):(a=1/a,this._x*=a,this._y*=a,this._z*=a,this._w*=a);return this},multiply:function(a,b){return void 0!==b?(console.warn(\"DEPRECATED: Quaternion's .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.\"),this.multiplyQuaternions(a,b)):this.multiplyQuaternions(this,a)},multiplyQuaternions:function(a,b){var c=a._x,d=a._y,e=a._z,f=\na._w,g=b._x,h=b._y,i=b._z,k=b._w;this._x=c*k+f*g+d*i-e*h;this._y=d*k+f*h+e*g-c*i;this._z=e*k+f*i+c*h-d*g;this._w=f*k-c*g-d*h-e*i;this._updateEuler();return this},multiplyVector3:function(a){console.warn(\"DEPRECATED: Quaternion's .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.\");return a.applyQuaternion(this)},slerp:function(a,b){var c=this._x,d=this._y,e=this._z,f=this._w,g=f*a._w+c*a._x+d*a._y+e*a._z;0>g?(this._w=-a._w,this._x=-a._x,this._y=-a._y,this._z=\n-a._z,g=-g):this.copy(a);if(1<=g)return this._w=f,this._x=c,this._y=d,this._z=e,this;var h=Math.acos(g),i=Math.sqrt(1-g*g);if(0.001>Math.abs(i))return this._w=0.5*(f+this._w),this._x=0.5*(c+this._x),this._y=0.5*(d+this._y),this._z=0.5*(e+this._z),this;g=Math.sin((1-b)*h)/i;h=Math.sin(b*h)/i;this._w=f*g+this._w*h;this._x=c*g+this._x*h;this._y=d*g+this._y*h;this._z=e*g+this._z*h;this._updateEuler();return this},equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._w===this._w},\nfromArray:function(a){this._x=a[0];this._y=a[1];this._z=a[2];this._w=a[3];this._updateEuler();return this},toArray:function(){return[this._x,this._y,this._z,this._w]},clone:function(){return new THREE.Quaternion(this._x,this._y,this._z,this._w)}};THREE.Quaternion.slerp=function(a,b,c,d){return c.copy(a).slerp(b,d)};THREE.Vector2=function(a,b){this.x=a||0;this.y=b||0};\nTHREE.Vector2.prototype={constructor:THREE.Vector2,set:function(a,b){this.x=a;this.y=b;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;default:throw Error(\"index is out of range: \"+a);}},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;default:throw Error(\"index is out of range: \"+a);}},copy:function(a){this.x=a.x;this.y=a.y;return this},add:function(a,\nb){if(void 0!==b)return console.warn(\"DEPRECATED: Vector2's .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this},addScalar:function(a){this.x+=a;this.y+=a;return this},sub:function(a,b){if(void 0!==b)return console.warn(\"DEPRECATED: Vector2's .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"),this.subVectors(a,b);this.x-=a.x;this.y-=\na.y;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a):this.y=this.x=0;return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=a.y);return this},clamp:function(a,b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y);\nreturn this},negate:function(){return this.multiplyScalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},normalize:function(){return this.divideScalar(this.length())},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x,a=this.y-a.y;return b*b+a*a},setLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/\nb);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;return this},equals:function(a){return a.x===this.x&&a.y===this.y},fromArray:function(a){this.x=a[0];this.y=a[1];return this},toArray:function(){return[this.x,this.y]},clone:function(){return new THREE.Vector2(this.x,this.y)}};THREE.Vector3=function(a,b,c){this.x=a||0;this.y=b||0;this.z=c||0};\nTHREE.Vector3.prototype={constructor:THREE.Vector3,set:function(a,b,c){this.x=a;this.y=b;this.z=c;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;default:throw Error(\"index is out of range: \"+a);}},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw Error(\"index is out of range: \"+\na);}},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;return this},add:function(a,b){if(void 0!==b)return console.warn(\"DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this},sub:function(a,b){if(void 0!==b)return console.warn(\"DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"),\nthis.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this},multiply:function(a,b){if(void 0!==b)return console.warn(\"DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.\"),this.multiplyVectors(a,b);this.x*=a.x;this.y*=a.y;this.z*=a.z;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;return this},multiplyVectors:function(a,b){this.x=a.x*\nb.x;this.y=a.y*b.y;this.z=a.z*b.z;return this},applyMatrix3:function(a){var b=this.x,c=this.y,d=this.z,a=a.elements;this.x=a[0]*b+a[3]*c+a[6]*d;this.y=a[1]*b+a[4]*c+a[7]*d;this.z=a[2]*b+a[5]*c+a[8]*d;return this},applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z,a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12];this.y=a[1]*b+a[5]*c+a[9]*d+a[13];this.z=a[2]*b+a[6]*c+a[10]*d+a[14];return this},applyProjection:function(a){var b=this.x,c=this.y,d=this.z,a=a.elements,e=1/(a[3]*b+a[7]*c+a[11]*d+a[15]);\nthis.x=(a[0]*b+a[4]*c+a[8]*d+a[12])*e;this.y=(a[1]*b+a[5]*c+a[9]*d+a[13])*e;this.z=(a[2]*b+a[6]*c+a[10]*d+a[14])*e;return this},applyQuaternion:function(a){var b=this.x,c=this.y,d=this.z,e=a.x,f=a.y,g=a.z,a=a.w,h=a*b+f*d-g*c,i=a*c+g*b-e*d,k=a*d+e*c-f*b,b=-e*b-f*c-g*d;this.x=h*a+b*-e+i*-g-k*-f;this.y=i*a+b*-f+k*-e-h*-g;this.z=k*a+b*-g+h*-f-i*-e;return this},transformDirection:function(a){var b=this.x,c=this.y,d=this.z,a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d;this.y=a[1]*b+a[5]*c+a[9]*d;this.z=a[2]*\nb+a[6]*c+a[10]*d;this.normalize();return this},divide:function(a){this.x/=a.x;this.y/=a.y;this.z/=a.z;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a,this.z*=a):this.z=this.y=this.x=0;return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);this.z>a.z&&(this.z=a.z);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=a.y);this.z<a.z&&(this.z=a.z);return this},clamp:function(a,b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<\na.y?this.y=a.y:this.y>b.y&&(this.y=b.y);this.z<a.z?this.z=a.z:this.z>b.z&&(this.z=b.z);return this},negate:function(){return this.multiplyScalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length())},\nsetLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/b);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;return this},cross:function(a,b){if(void 0!==b)return console.warn(\"DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.\"),this.crossVectors(a,b);var c=this.x,d=this.y,e=this.z;this.x=d*a.z-e*a.y;this.y=e*a.x-c*a.z;this.z=c*a.y-d*a.x;return this},crossVectors:function(a,b){var c=\na.x,d=a.y,e=a.z,f=b.x,g=b.y,h=b.z;this.x=d*h-e*g;this.y=e*f-c*h;this.z=c*g-d*f;return this},angleTo:function(a){a=this.dot(a)/(this.length()*a.length());return Math.acos(THREE.Math.clamp(a,-1,1))},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x,c=this.y-a.y,a=this.z-a.z;return b*b+c*c+a*a},setEulerFromRotationMatrix:function(){console.error(\"REMOVED: Vector3's setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.\")},\nsetEulerFromQuaternion:function(){console.error(\"REMOVED: Vector3's setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.\")},getPositionFromMatrix:function(a){console.warn(\"DEPRECATED: Vector3's .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code.\");return this.setFromMatrixPosition(a)},getScaleFromMatrix:function(a){console.warn(\"DEPRECATED: Vector3's .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code.\");\nreturn this.setFromMatrixScale(a)},getColumnFromMatrix:function(a,b){console.warn(\"DEPRECATED: Vector3's .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code.\");return this.setFromMatrixColumn(a,b)},setFromMatrixPosition:function(a){this.x=a.elements[12];this.y=a.elements[13];this.z=a.elements[14];return this},setFromMatrixScale:function(a){var b=this.set(a.elements[0],a.elements[1],a.elements[2]).length(),c=this.set(a.elements[4],a.elements[5],a.elements[6]).length(),\na=this.set(a.elements[8],a.elements[9],a.elements[10]).length();this.x=b;this.y=c;this.z=a;return this},setFromMatrixColumn:function(a,b){var c=4*a,d=b.elements;this.x=d[c];this.y=d[c+1];this.z=d[c+2];return this},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z},fromArray:function(a){this.x=a[0];this.y=a[1];this.z=a[2];return this},toArray:function(){return[this.x,this.y,this.z]},clone:function(){return new THREE.Vector3(this.x,this.y,this.z)}};\nTHREE.extend(THREE.Vector3.prototype,{applyEuler:function(){var a=new THREE.Quaternion;return function(b){!1===b instanceof THREE.Euler&&console.error(\"ERROR: Vector3's .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.\");this.applyQuaternion(a.setFromEuler(b));return this}}(),applyAxisAngle:function(){var a=new THREE.Quaternion;return function(b,c){this.applyQuaternion(a.setFromAxisAngle(b,c));return this}}(),projectOnVector:function(){var a=new THREE.Vector3;\nreturn function(b){a.copy(b).normalize();b=this.dot(a);return this.copy(a).multiplyScalar(b)}}(),projectOnPlane:function(){var a=new THREE.Vector3;return function(b){a.copy(this).projectOnVector(b);return this.sub(a)}}(),reflect:function(){var a=new THREE.Vector3;return function(b){a.copy(this).projectOnVector(b).multiplyScalar(2);return this.subVectors(a,this)}}()});THREE.Vector4=function(a,b,c,d){this.x=a||0;this.y=b||0;this.z=c||0;this.w=void 0!==d?d:1};\nTHREE.Vector4.prototype={constructor:THREE.Vector4,set:function(a,b,c,d){this.x=a;this.y=b;this.z=c;this.w=d;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setW:function(a){this.w=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;case 3:this.w=b;break;default:throw Error(\"index is out of range: \"+a);}},getComponent:function(a){switch(a){case 0:return this.x;\ncase 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error(\"index is out of range: \"+a);}},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;this.w=void 0!==a.w?a.w:1;return this},add:function(a,b){if(void 0!==b)return console.warn(\"DEPRECATED: Vector4's .add() now only accepts one argument. Use .addVectors( a, b ) instead.\"),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;this.w+=a.w;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;this.w+=a;return this},\naddVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this},sub:function(a,b){if(void 0!==b)return console.warn(\"DEPRECATED: Vector4's .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\"),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;this.w-=a.w;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;this.w*=a;return this},\napplyMatrix4:function(a){var b=this.x,c=this.y,d=this.z,e=this.w,a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12]*e;this.y=a[1]*b+a[5]*c+a[9]*d+a[13]*e;this.z=a[2]*b+a[6]*c+a[10]*d+a[14]*e;this.w=a[3]*b+a[7]*c+a[11]*d+a[15]*e;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a,this.z*=a,this.w*=a):(this.z=this.y=this.x=0,this.w=1);return this},setAxisAngleFromQuaternion:function(a){this.w=2*Math.acos(a.w);var b=Math.sqrt(1-a.w*a.w);1E-4>b?(this.x=1,this.z=this.y=0):(this.x=a.x/b,\nthis.y=a.y/b,this.z=a.z/b);return this},setAxisAngleFromRotationMatrix:function(a){var b,c,d,a=a.elements,e=a[0];d=a[4];var f=a[8],g=a[1],h=a[5],i=a[9];c=a[2];b=a[6];var k=a[10];if(0.01>Math.abs(d-g)&&0.01>Math.abs(f-c)&&0.01>Math.abs(i-b)){if(0.1>Math.abs(d+g)&&0.1>Math.abs(f+c)&&0.1>Math.abs(i+b)&&0.1>Math.abs(e+h+k-3))return this.set(1,0,0,0),this;a=Math.PI;e=(e+1)/2;h=(h+1)/2;k=(k+1)/2;d=(d+g)/4;f=(f+c)/4;i=(i+b)/4;e>h&&e>k?0.01>e?(b=0,d=c=0.707106781):(b=Math.sqrt(e),c=d/b,d=f/b):h>k?0.01>h?\n(b=0.707106781,c=0,d=0.707106781):(c=Math.sqrt(h),b=d/c,d=i/c):0.01>k?(c=b=0.707106781,d=0):(d=Math.sqrt(k),b=f/d,c=i/d);this.set(b,c,d,a);return this}a=Math.sqrt((b-i)*(b-i)+(f-c)*(f-c)+(g-d)*(g-d));0.001>Math.abs(a)&&(a=1);this.x=(b-i)/a;this.y=(f-c)/a;this.z=(g-d)/a;this.w=Math.acos((e+h+k-1)/2);return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);this.z>a.z&&(this.z=a.z);this.w>a.w&&(this.w=a.w);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=\na.y);this.z<a.z&&(this.z=a.z);this.w<a.w&&(this.w=a.w);return this},clamp:function(a,b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y);this.z<a.z?this.z=a.z:this.z>b.z&&(this.z=b.z);this.w<a.w?this.w=a.w:this.w>b.w&&(this.w=b.w);return this},negate:function(){return this.multiplyScalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z+this.w*a.w},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},length:function(){return Math.sqrt(this.x*\nthis.x+this.y*this.y+this.z*this.z+this.w*this.w)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)},normalize:function(){return this.divideScalar(this.length())},setLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/b);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;this.w+=(a.w-this.w)*b;return this},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z&&\na.w===this.w},fromArray:function(a){this.x=a[0];this.y=a[1];this.z=a[2];this.w=a[3];return this},toArray:function(){return[this.x,this.y,this.z,this.w]},clone:function(){return new THREE.Vector4(this.x,this.y,this.z,this.w)}};THREE.Euler=function(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._order=d||THREE.Euler.DefaultOrder};THREE.Euler.RotationOrders=\"XYZ YZX ZXY XZY YXZ ZYX\".split(\" \");THREE.Euler.DefaultOrder=\"XYZ\";\nTHREE.Euler.prototype={constructor:THREE.Euler,_x:0,_y:0,_z:0,_order:THREE.Euler.DefaultOrder,_quaternion:void 0,_updateQuaternion:function(){void 0!==this._quaternion&&this._quaternion.setFromEuler(this,!1)},get x(){return this._x},set x(a){this._x=a;this._updateQuaternion()},get y(){return this._y},set y(a){this._y=a;this._updateQuaternion()},get z(){return this._z},set z(a){this._z=a;this._updateQuaternion()},get order(){return this._order},set order(a){this._order=a;this._updateQuaternion()},\nset:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._order=d||this._order;this._updateQuaternion();return this},copy:function(a){this._x=a._x;this._y=a._y;this._z=a._z;this._order=a._order;this._updateQuaternion();return this},setFromRotationMatrix:function(a,b){function c(a){return Math.min(Math.max(a,-1),1)}var d=a.elements,e=d[0],f=d[4],g=d[8],h=d[1],i=d[5],k=d[9],l=d[2],n=d[6],d=d[10],b=b||this._order;\"XYZ\"===b?(this._y=Math.asin(c(g)),0.99999>Math.abs(g)?(this._x=Math.atan2(-k,d),this._z=\nMath.atan2(-f,e)):(this._x=Math.atan2(n,i),this._z=0)):\"YXZ\"===b?(this._x=Math.asin(-c(k)),0.99999>Math.abs(k)?(this._y=Math.atan2(g,d),this._z=Math.atan2(h,i)):(this._y=Math.atan2(-l,e),this._z=0)):\"ZXY\"===b?(this._x=Math.asin(c(n)),0.99999>Math.abs(n)?(this._y=Math.atan2(-l,d),this._z=Math.atan2(-f,i)):(this._y=0,this._z=Math.atan2(h,e))):\"ZYX\"===b?(this._y=Math.asin(-c(l)),0.99999>Math.abs(l)?(this._x=Math.atan2(n,d),this._z=Math.atan2(h,e)):(this._x=0,this._z=Math.atan2(-f,i))):\"YZX\"===b?(this._z=\nMath.asin(c(h)),0.99999>Math.abs(h)?(this._x=Math.atan2(-k,i),this._y=Math.atan2(-l,e)):(this._x=0,this._y=Math.atan2(g,d))):\"XZY\"===b?(this._z=Math.asin(-c(f)),0.99999>Math.abs(f)?(this._x=Math.atan2(n,i),this._y=Math.atan2(g,e)):(this._x=Math.atan2(-k,d),this._y=0)):console.warn(\"WARNING: Euler.setFromRotationMatrix() given unsupported order: \"+b);this._order=b;this._updateQuaternion();return this},setFromQuaternion:function(a,b,c){function d(a){return Math.min(Math.max(a,-1),1)}var e=a.x*a.x,f=\na.y*a.y,g=a.z*a.z,h=a.w*a.w,b=b||this._order;\"XYZ\"===b?(this._x=Math.atan2(2*(a.x*a.w-a.y*a.z),h-e-f+g),this._y=Math.asin(d(2*(a.x*a.z+a.y*a.w))),this._z=Math.atan2(2*(a.z*a.w-a.x*a.y),h+e-f-g)):\"YXZ\"===b?(this._x=Math.asin(d(2*(a.x*a.w-a.y*a.z))),this._y=Math.atan2(2*(a.x*a.z+a.y*a.w),h-e-f+g),this._z=Math.atan2(2*(a.x*a.y+a.z*a.w),h-e+f-g)):\"ZXY\"===b?(this._x=Math.asin(d(2*(a.x*a.w+a.y*a.z))),this._y=Math.atan2(2*(a.y*a.w-a.z*a.x),h-e-f+g),this._z=Math.atan2(2*(a.z*a.w-a.x*a.y),h-e+f-g)):\"ZYX\"===\nb?(this._x=Math.atan2(2*(a.x*a.w+a.z*a.y),h-e-f+g),this._y=Math.asin(d(2*(a.y*a.w-a.x*a.z))),this._z=Math.atan2(2*(a.x*a.y+a.z*a.w),h+e-f-g)):\"YZX\"===b?(this._x=Math.atan2(2*(a.x*a.w-a.z*a.y),h-e+f-g),this._y=Math.atan2(2*(a.y*a.w-a.x*a.z),h+e-f-g),this._z=Math.asin(d(2*(a.x*a.y+a.z*a.w)))):\"XZY\"===b?(this._x=Math.atan2(2*(a.x*a.w+a.y*a.z),h-e+f-g),this._y=Math.atan2(2*(a.x*a.z+a.y*a.w),h+e-f-g),this._z=Math.asin(d(2*(a.z*a.w-a.x*a.y)))):console.warn(\"WARNING: Euler.setFromQuaternion() given unsupported order: \"+\nb);this._order=b;!1!==c&&this._updateQuaternion();return this},reorder:function(){var a=new THREE.Quaternion;return function(b){a.setFromEuler(this);this.setFromQuaternion(a,b)}}(),fromArray:function(a){this._x=a[0];this._y=a[1];this._z=a[2];void 0!==a[3]&&(this._order=a[3]);this._updateQuaternion();return this},toArray:function(){return[this._x,this._y,this._z,this._order]},equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._order===this._order},clone:function(){return new THREE.Euler(this._x,\nthis._y,this._z,this._order)}};THREE.Line3=function(a,b){this.start=void 0!==a?a:new THREE.Vector3;this.end=void 0!==b?b:new THREE.Vector3};\nTHREE.Line3.prototype={constructor:THREE.Line3,set:function(a,b){this.start.copy(a);this.end.copy(b);return this},copy:function(a){this.start.copy(a.start);this.end.copy(a.end);return this},center:function(a){return(a||new THREE.Vector3).addVectors(this.start,this.end).multiplyScalar(0.5)},delta:function(a){return(a||new THREE.Vector3).subVectors(this.end,this.start)},distanceSq:function(){return this.start.distanceToSquared(this.end)},distance:function(){return this.start.distanceTo(this.end)},at:function(a,\nb){var c=b||new THREE.Vector3;return this.delta(c).multiplyScalar(a).add(this.start)},closestPointToPointParameter:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d){a.subVectors(c,this.start);b.subVectors(this.end,this.start);var e=b.dot(b),e=b.dot(a)/e;d&&(e=THREE.Math.clamp(e,0,1));return e}}(),closestPointToPoint:function(a,b,c){a=this.closestPointToPointParameter(a,b);c=c||new THREE.Vector3;return this.delta(c).multiplyScalar(a).add(this.start)},applyMatrix4:function(a){this.start.applyMatrix4(a);\nthis.end.applyMatrix4(a);return this},equals:function(a){return a.start.equals(this.start)&&a.end.equals(this.end)},clone:function(){return(new THREE.Line3).copy(this)}};THREE.Box2=function(a,b){this.min=void 0!==a?a:new THREE.Vector2(Infinity,Infinity);this.max=void 0!==b?b:new THREE.Vector2(-Infinity,-Infinity)};\nTHREE.Box2.prototype={constructor:THREE.Box2,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},setFromPoints:function(a){if(0<a.length){var b=a[0];this.min.copy(b);this.max.copy(b);for(var c=1,d=a.length;c<d;c++)b=a[c],b.x<this.min.x?this.min.x=b.x:b.x>this.max.x&&(this.max.x=b.x),b.y<this.min.y?this.min.y=b.y:b.y>this.max.y&&(this.max.y=b.y)}else this.makeEmpty();return this},setFromCenterAndSize:function(){var a=new THREE.Vector2;return function(b,c){var d=a.copy(c).multiplyScalar(0.5);\nthis.min.copy(b).sub(d);this.max.copy(b).add(d);return this}}(),copy:function(a){this.min.copy(a.min);this.max.copy(a.max);return this},makeEmpty:function(){this.min.x=this.min.y=Infinity;this.max.x=this.max.y=-Infinity;return this},empty:function(){return this.max.x<this.min.x||this.max.y<this.min.y},center:function(a){return(a||new THREE.Vector2).addVectors(this.min,this.max).multiplyScalar(0.5)},size:function(a){return(a||new THREE.Vector2).subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);\nthis.max.max(a);return this},expandByVector:function(a){this.min.sub(a);this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y?!0:!1},getParameter:function(a,b){return(b||new THREE.Vector2).set((a.x-this.min.x)/(this.max.x-this.min.x),\n(a.y-this.min.y)/(this.max.y-this.min.y))},isIntersectionBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y?!1:!0},clampPoint:function(a,b){return(b||new THREE.Vector2).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new THREE.Vector2;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);return this},union:function(a){this.min.min(a.min);this.max.max(a.max);\nreturn this},translate:function(a){this.min.add(a);this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)},clone:function(){return(new THREE.Box2).copy(this)}};THREE.Box3=function(a,b){this.min=void 0!==a?a:new THREE.Vector3(Infinity,Infinity,Infinity);this.max=void 0!==b?b:new THREE.Vector3(-Infinity,-Infinity,-Infinity)};\nTHREE.Box3.prototype={constructor:THREE.Box3,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},addPoint:function(a){a.x<this.min.x?this.min.x=a.x:a.x>this.max.x&&(this.max.x=a.x);a.y<this.min.y?this.min.y=a.y:a.y>this.max.y&&(this.max.y=a.y);a.z<this.min.z?this.min.z=a.z:a.z>this.max.z&&(this.max.z=a.z)},setFromPoints:function(a){if(0<a.length){var b=a[0];this.min.copy(b);this.max.copy(b);for(var b=1,c=a.length;b<c;b++)this.addPoint(a[b])}else this.makeEmpty();return this},setFromCenterAndSize:function(){var a=\nnew THREE.Vector3;return function(b,c){var d=a.copy(c).multiplyScalar(0.5);this.min.copy(b).sub(d);this.max.copy(b).add(d);return this}}(),setFromObject:function(){var a=new THREE.Vector3;return function(b){var c=this;b.updateMatrixWorld(!0);this.makeEmpty();b.traverse(function(b){if(void 0!==b.geometry&&void 0!==b.geometry.vertices)for(var e=b.geometry.vertices,f=0,g=e.length;f<g;f++)a.copy(e[f]),a.applyMatrix4(b.matrixWorld),c.expandByPoint(a)});return this}}(),copy:function(a){this.min.copy(a.min);\nthis.max.copy(a.max);return this},makeEmpty:function(){this.min.x=this.min.y=this.min.z=Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this},empty:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z},center:function(a){return(a||new THREE.Vector3).addVectors(this.min,this.max).multiplyScalar(0.5)},size:function(a){return(a||new THREE.Vector3).subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);\nthis.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y||a.z<this.min.z||a.z>this.max.z?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y&&this.min.z<=a.min.z&&a.max.z<=this.max.z?!0:!1},getParameter:function(a,b){return(b||new THREE.Vector3).set((a.x-this.min.x)/(this.max.x-\nthis.min.x),(a.y-this.min.y)/(this.max.y-this.min.y),(a.z-this.min.z)/(this.max.z-this.min.z))},isIntersectionBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y||a.max.z<this.min.z||a.min.z>this.max.z?!1:!0},clampPoint:function(a,b){return(b||new THREE.Vector3).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new THREE.Vector3;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),getBoundingSphere:function(){var a=\nnew THREE.Vector3;return function(b){b=b||new THREE.Sphere;b.center=this.center();b.radius=0.5*this.size(a).length();return b}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);return this},union:function(a){this.min.min(a.min);this.max.max(a.max);return this},applyMatrix4:function(){var a=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];return function(b){a[0].set(this.min.x,this.min.y,\nthis.min.z).applyMatrix4(b);a[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(b);a[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(b);a[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(b);a[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(b);a[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(b);a[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(b);a[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(b);this.makeEmpty();this.setFromPoints(a);return this}}(),translate:function(a){this.min.add(a);\nthis.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)},clone:function(){return(new THREE.Box3).copy(this)}};THREE.Matrix3=function(a,b,c,d,e,f,g,h,i){this.elements=new Float32Array(9);this.set(void 0!==a?a:1,b||0,c||0,d||0,void 0!==e?e:1,f||0,g||0,h||0,void 0!==i?i:1)};\nTHREE.Matrix3.prototype={constructor:THREE.Matrix3,set:function(a,b,c,d,e,f,g,h,i){var k=this.elements;k[0]=a;k[3]=b;k[6]=c;k[1]=d;k[4]=e;k[7]=f;k[2]=g;k[5]=h;k[8]=i;return this},identity:function(){this.set(1,0,0,0,1,0,0,0,1);return this},copy:function(a){a=a.elements;this.set(a[0],a[3],a[6],a[1],a[4],a[7],a[2],a[5],a[8]);return this},multiplyVector3:function(a){console.warn(\"DEPRECATED: Matrix3's .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.\");return a.applyMatrix3(this)},\nmultiplyVector3Array:function(){var a=new THREE.Vector3;return function(b){for(var c=0,d=b.length;c<d;c+=3)a.x=b[c],a.y=b[c+1],a.z=b[c+2],a.applyMatrix3(this),b[c]=a.x,b[c+1]=a.y,b[c+2]=a.z;return b}}(),multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[3]*=a;b[6]*=a;b[1]*=a;b[4]*=a;b[7]*=a;b[2]*=a;b[5]*=a;b[8]*=a;return this},determinant:function(){var a=this.elements,b=a[0],c=a[1],d=a[2],e=a[3],f=a[4],g=a[5],h=a[6],i=a[7],a=a[8];return b*f*a-b*g*i-c*e*a+c*g*h+d*e*i-d*f*h},getInverse:function(a,\nb){var c=a.elements,d=this.elements;d[0]=c[10]*c[5]-c[6]*c[9];d[1]=-c[10]*c[1]+c[2]*c[9];d[2]=c[6]*c[1]-c[2]*c[5];d[3]=-c[10]*c[4]+c[6]*c[8];d[4]=c[10]*c[0]-c[2]*c[8];d[5]=-c[6]*c[0]+c[2]*c[4];d[6]=c[9]*c[4]-c[5]*c[8];d[7]=-c[9]*c[0]+c[1]*c[8];d[8]=c[5]*c[0]-c[1]*c[4];c=c[0]*d[0]+c[1]*d[3]+c[2]*d[6];if(0===c){if(b)throw Error(\"Matrix3.getInverse(): can't invert matrix, determinant is 0\");console.warn(\"Matrix3.getInverse(): can't invert matrix, determinant is 0\");this.identity();return this}this.multiplyScalar(1/\nc);return this},transpose:function(){var a,b=this.elements;a=b[1];b[1]=b[3];b[3]=a;a=b[2];b[2]=b[6];b[6]=a;a=b[5];b[5]=b[7];b[7]=a;return this},getNormalMatrix:function(a){this.getInverse(a).transpose();return this},transposeIntoArray:function(a){var b=this.elements;a[0]=b[0];a[1]=b[3];a[2]=b[6];a[3]=b[1];a[4]=b[4];a[5]=b[7];a[6]=b[2];a[7]=b[5];a[8]=b[8];return this},fromArray:function(a){this.elements.set(a);return this},toArray:function(){var a=this.elements;return[a[0],a[1],a[2],a[3],a[4],a[5],\na[6],a[7],a[8]]},clone:function(){var a=this.elements;return new THREE.Matrix3(a[0],a[3],a[6],a[1],a[4],a[7],a[2],a[5],a[8])}};THREE.Matrix4=function(a,b,c,d,e,f,g,h,i,k,l,n,p,t,r,m){var q=this.elements=new Float32Array(16);q[0]=void 0!==a?a:1;q[4]=b||0;q[8]=c||0;q[12]=d||0;q[1]=e||0;q[5]=void 0!==f?f:1;q[9]=g||0;q[13]=h||0;q[2]=i||0;q[6]=k||0;q[10]=void 0!==l?l:1;q[14]=n||0;q[3]=p||0;q[7]=t||0;q[11]=r||0;q[15]=void 0!==m?m:1};\nTHREE.Matrix4.prototype={constructor:THREE.Matrix4,set:function(a,b,c,d,e,f,g,h,i,k,l,n,p,t,r,m){var q=this.elements;q[0]=a;q[4]=b;q[8]=c;q[12]=d;q[1]=e;q[5]=f;q[9]=g;q[13]=h;q[2]=i;q[6]=k;q[10]=l;q[14]=n;q[3]=p;q[7]=t;q[11]=r;q[15]=m;return this},identity:function(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this},copy:function(a){this.elements.set(a.elements);return this},extractPosition:function(a){console.warn(\"DEPRECATED: Matrix4's .extractPosition() has been renamed to .copyPosition().\");\nreturn this.copyPosition(a)},copyPosition:function(a){var b=this.elements,a=a.elements;b[12]=a[12];b[13]=a[13];b[14]=a[14];return this},extractRotation:function(){var a=new THREE.Vector3;return function(b){var c=this.elements,b=b.elements,d=1/a.set(b[0],b[1],b[2]).length(),e=1/a.set(b[4],b[5],b[6]).length(),f=1/a.set(b[8],b[9],b[10]).length();c[0]=b[0]*d;c[1]=b[1]*d;c[2]=b[2]*d;c[4]=b[4]*e;c[5]=b[5]*e;c[6]=b[6]*e;c[8]=b[8]*f;c[9]=b[9]*f;c[10]=b[10]*f;return this}}(),makeRotationFromEuler:function(a){!1===\na instanceof THREE.Euler&&console.error(\"ERROR: Matrix's .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.\");var b=this.elements,c=a.x,d=a.y,e=a.z,f=Math.cos(c),c=Math.sin(c),g=Math.cos(d),d=Math.sin(d),h=Math.cos(e),e=Math.sin(e);if(\"XYZ\"===a.order){var a=f*h,i=f*e,k=c*h,l=c*e;b[0]=g*h;b[4]=-g*e;b[8]=d;b[1]=i+k*d;b[5]=a-l*d;b[9]=-c*g;b[2]=l-a*d;b[6]=k+i*d;b[10]=f*g}else\"YXZ\"===a.order?(a=g*h,i=g*e,k=d*h,l=d*e,b[0]=a+l*c,b[4]=k*c-i,b[8]=\nf*d,b[1]=f*e,b[5]=f*h,b[9]=-c,b[2]=i*c-k,b[6]=l+a*c,b[10]=f*g):\"ZXY\"===a.order?(a=g*h,i=g*e,k=d*h,l=d*e,b[0]=a-l*c,b[4]=-f*e,b[8]=k+i*c,b[1]=i+k*c,b[5]=f*h,b[9]=l-a*c,b[2]=-f*d,b[6]=c,b[10]=f*g):\"ZYX\"===a.order?(a=f*h,i=f*e,k=c*h,l=c*e,b[0]=g*h,b[4]=k*d-i,b[8]=a*d+l,b[1]=g*e,b[5]=l*d+a,b[9]=i*d-k,b[2]=-d,b[6]=c*g,b[10]=f*g):\"YZX\"===a.order?(a=f*g,i=f*d,k=c*g,l=c*d,b[0]=g*h,b[4]=l-a*e,b[8]=k*e+i,b[1]=e,b[5]=f*h,b[9]=-c*h,b[2]=-d*h,b[6]=i*e+k,b[10]=a-l*e):\"XZY\"===a.order&&(a=f*g,i=f*d,k=c*g,l=c*d,b[0]=\ng*h,b[4]=-e,b[8]=d*h,b[1]=a*e+l,b[5]=f*h,b[9]=i*e-k,b[2]=k*e-i,b[6]=c*h,b[10]=l*e+a);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},setRotationFromQuaternion:function(a){console.warn(\"DEPRECATED: Matrix4's .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.\");return this.makeRotationFromQuaternion(a)},makeRotationFromQuaternion:function(a){var b=this.elements,c=a.x,d=a.y,e=a.z,f=a.w,g=c+c,h=d+d,i=e+e,a=c*g,k=c*h,c=\nc*i,l=d*h,d=d*i,e=e*i,g=f*g,h=f*h,f=f*i;b[0]=1-(l+e);b[4]=k-f;b[8]=c+h;b[1]=k+f;b[5]=1-(a+e);b[9]=d-g;b[2]=c-h;b[6]=d+g;b[10]=1-(a+l);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},lookAt:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(d,e,f){var g=this.elements;c.subVectors(d,e).normalize();0===c.length()&&(c.z=1);a.crossVectors(f,c).normalize();0===a.length()&&(c.x+=1E-4,a.crossVectors(f,c).normalize());b.crossVectors(c,a);g[0]=a.x;\ng[4]=b.x;g[8]=c.x;g[1]=a.y;g[5]=b.y;g[9]=c.y;g[2]=a.z;g[6]=b.z;g[10]=c.z;return this}}(),multiply:function(a,b){return void 0!==b?(console.warn(\"DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.\"),this.multiplyMatrices(a,b)):this.multiplyMatrices(this,a)},multiplyMatrices:function(a,b){var c=a.elements,d=b.elements,e=this.elements,f=c[0],g=c[4],h=c[8],i=c[12],k=c[1],l=c[5],n=c[9],p=c[13],t=c[2],r=c[6],m=c[10],q=c[14],u=c[3],s=c[7],v=c[11],c=c[15],\nz=d[0],G=d[4],N=d[8],C=d[12],B=d[1],x=d[5],F=d[9],L=d[13],w=d[2],E=d[6],y=d[10],D=d[14],H=d[3],K=d[7],A=d[11],d=d[15];e[0]=f*z+g*B+h*w+i*H;e[4]=f*G+g*x+h*E+i*K;e[8]=f*N+g*F+h*y+i*A;e[12]=f*C+g*L+h*D+i*d;e[1]=k*z+l*B+n*w+p*H;e[5]=k*G+l*x+n*E+p*K;e[9]=k*N+l*F+n*y+p*A;e[13]=k*C+l*L+n*D+p*d;e[2]=t*z+r*B+m*w+q*H;e[6]=t*G+r*x+m*E+q*K;e[10]=t*N+r*F+m*y+q*A;e[14]=t*C+r*L+m*D+q*d;e[3]=u*z+s*B+v*w+c*H;e[7]=u*G+s*x+v*E+c*K;e[11]=u*N+s*F+v*y+c*A;e[15]=u*C+s*L+v*D+c*d;return this},multiplyToArray:function(a,b,\nc){var d=this.elements;this.multiplyMatrices(a,b);c[0]=d[0];c[1]=d[1];c[2]=d[2];c[3]=d[3];c[4]=d[4];c[5]=d[5];c[6]=d[6];c[7]=d[7];c[8]=d[8];c[9]=d[9];c[10]=d[10];c[11]=d[11];c[12]=d[12];c[13]=d[13];c[14]=d[14];c[15]=d[15];return this},multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[4]*=a;b[8]*=a;b[12]*=a;b[1]*=a;b[5]*=a;b[9]*=a;b[13]*=a;b[2]*=a;b[6]*=a;b[10]*=a;b[14]*=a;b[3]*=a;b[7]*=a;b[11]*=a;b[15]*=a;return this},multiplyVector3:function(a){console.warn(\"DEPRECATED: Matrix4's .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.\");\nreturn a.applyProjection(this)},multiplyVector4:function(a){console.warn(\"DEPRECATED: Matrix4's .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.\");return a.applyMatrix4(this)},multiplyVector3Array:function(){var a=new THREE.Vector3;return function(b){for(var c=0,d=b.length;c<d;c+=3)a.x=b[c],a.y=b[c+1],a.z=b[c+2],a.applyProjection(this),b[c]=a.x,b[c+1]=a.y,b[c+2]=a.z;return b}}(),rotateAxis:function(a){console.warn(\"DEPRECATED: Matrix4's .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.\");\na.transformDirection(this)},crossVector:function(a){console.warn(\"DEPRECATED: Matrix4's .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.\");return a.applyMatrix4(this)},determinant:function(){var a=this.elements,b=a[0],c=a[4],d=a[8],e=a[12],f=a[1],g=a[5],h=a[9],i=a[13],k=a[2],l=a[6],n=a[10],p=a[14];return a[3]*(+e*h*l-d*i*l-e*g*n+c*i*n+d*g*p-c*h*p)+a[7]*(+b*h*p-b*i*n+e*f*n-d*f*p+d*i*k-e*h*k)+a[11]*(+b*i*l-b*g*p-e*f*l+c*f*p+e*g*k-c*i*k)+a[15]*(-d*g*k-b*h*l+b*g*n+d*f*l-c*f*\nn+c*h*k)},transpose:function(){var a=this.elements,b;b=a[1];a[1]=a[4];a[4]=b;b=a[2];a[2]=a[8];a[8]=b;b=a[6];a[6]=a[9];a[9]=b;b=a[3];a[3]=a[12];a[12]=b;b=a[7];a[7]=a[13];a[13]=b;b=a[11];a[11]=a[14];a[14]=b;return this},flattenToArray:function(a){var b=this.elements;a[0]=b[0];a[1]=b[1];a[2]=b[2];a[3]=b[3];a[4]=b[4];a[5]=b[5];a[6]=b[6];a[7]=b[7];a[8]=b[8];a[9]=b[9];a[10]=b[10];a[11]=b[11];a[12]=b[12];a[13]=b[13];a[14]=b[14];a[15]=b[15];return a},flattenToArrayOffset:function(a,b){var c=this.elements;\na[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];a[b+9]=c[9];a[b+10]=c[10];a[b+11]=c[11];a[b+12]=c[12];a[b+13]=c[13];a[b+14]=c[14];a[b+15]=c[15];return a},getPosition:function(){var a=new THREE.Vector3;return function(){console.warn(\"DEPRECATED: Matrix4's .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.\");var b=this.elements;return a.set(b[12],b[13],b[14])}}(),setPosition:function(a){var b=this.elements;\nb[12]=a.x;b[13]=a.y;b[14]=a.z;return this},getInverse:function(a,b){var c=this.elements,d=a.elements,e=d[0],f=d[4],g=d[8],h=d[12],i=d[1],k=d[5],l=d[9],n=d[13],p=d[2],t=d[6],r=d[10],m=d[14],q=d[3],u=d[7],s=d[11],d=d[15];c[0]=l*m*u-n*r*u+n*t*s-k*m*s-l*t*d+k*r*d;c[4]=h*r*u-g*m*u-h*t*s+f*m*s+g*t*d-f*r*d;c[8]=g*n*u-h*l*u+h*k*s-f*n*s-g*k*d+f*l*d;c[12]=h*l*t-g*n*t-h*k*r+f*n*r+g*k*m-f*l*m;c[1]=n*r*q-l*m*q-n*p*s+i*m*s+l*p*d-i*r*d;c[5]=g*m*q-h*r*q+h*p*s-e*m*s-g*p*d+e*r*d;c[9]=h*l*q-g*n*q-h*i*s+e*n*s+g*i*d-\ne*l*d;c[13]=g*n*p-h*l*p+h*i*r-e*n*r-g*i*m+e*l*m;c[2]=k*m*q-n*t*q+n*p*u-i*m*u-k*p*d+i*t*d;c[6]=h*t*q-f*m*q-h*p*u+e*m*u+f*p*d-e*t*d;c[10]=f*n*q-h*k*q+h*i*u-e*n*u-f*i*d+e*k*d;c[14]=h*k*p-f*n*p-h*i*t+e*n*t+f*i*m-e*k*m;c[3]=l*t*q-k*r*q-l*p*u+i*r*u+k*p*s-i*t*s;c[7]=f*r*q-g*t*q+g*p*u-e*r*u-f*p*s+e*t*s;c[11]=g*k*q-f*l*q-g*i*u+e*l*u+f*i*s-e*k*s;c[15]=f*l*p-g*k*p+g*i*t-e*l*t-f*i*r+e*k*r;c=e*c[0]+i*c[4]+p*c[8]+q*c[12];if(0==c){if(b)throw Error(\"Matrix4.getInverse(): can't invert matrix, determinant is 0\");console.warn(\"Matrix4.getInverse(): can't invert matrix, determinant is 0\");\nthis.identity();return this}this.multiplyScalar(1/c);return this},translate:function(){console.warn(\"DEPRECATED: Matrix4's .translate() has been removed.\")},rotateX:function(){console.warn(\"DEPRECATED: Matrix4's .rotateX() has been removed.\")},rotateY:function(){console.warn(\"DEPRECATED: Matrix4's .rotateY() has been removed.\")},rotateZ:function(){console.warn(\"DEPRECATED: Matrix4's .rotateZ() has been removed.\")},rotateByAxis:function(){console.warn(\"DEPRECATED: Matrix4's .rotateByAxis() has been removed.\")},\nscale:function(a){var b=this.elements,c=a.x,d=a.y,a=a.z;b[0]*=c;b[4]*=d;b[8]*=a;b[1]*=c;b[5]*=d;b[9]*=a;b[2]*=c;b[6]*=d;b[10]*=a;b[3]*=c;b[7]*=d;b[11]*=a;return this},getMaxScaleOnAxis:function(){var a=this.elements;return Math.sqrt(Math.max(a[0]*a[0]+a[1]*a[1]+a[2]*a[2],Math.max(a[4]*a[4]+a[5]*a[5]+a[6]*a[6],a[8]*a[8]+a[9]*a[9]+a[10]*a[10])))},makeTranslation:function(a,b,c){this.set(1,0,0,a,0,1,0,b,0,0,1,c,0,0,0,1);return this},makeRotationX:function(a){var b=Math.cos(a),a=Math.sin(a);this.set(1,\n0,0,0,0,b,-a,0,0,a,b,0,0,0,0,1);return this},makeRotationY:function(a){var b=Math.cos(a),a=Math.sin(a);this.set(b,0,a,0,0,1,0,0,-a,0,b,0,0,0,0,1);return this},makeRotationZ:function(a){var b=Math.cos(a),a=Math.sin(a);this.set(b,-a,0,0,a,b,0,0,0,0,1,0,0,0,0,1);return this},makeRotationAxis:function(a,b){var c=Math.cos(b),d=Math.sin(b),e=1-c,f=a.x,g=a.y,h=a.z,i=e*f,k=e*g;this.set(i*f+c,i*g-d*h,i*h+d*g,0,i*g+d*h,k*g+c,k*h-d*f,0,i*h-d*g,k*h+d*f,e*h*h+c,0,0,0,0,1);return this},makeScale:function(a,b,c){this.set(a,\n0,0,0,0,b,0,0,0,0,c,0,0,0,0,1);return this},compose:function(a,b,c){this.makeRotationFromQuaternion(b);this.scale(c);this.setPosition(a);return this},decompose:function(){var a=new THREE.Vector3,b=new THREE.Matrix4;return function(c,d,e){var f=this.elements,g=a.set(f[0],f[1],f[2]).length(),h=a.set(f[4],f[5],f[6]).length(),i=a.set(f[8],f[9],f[10]).length();0>this.determinant()&&(g=-g);c.x=f[12];c.y=f[13];c.z=f[14];b.elements.set(this.elements);var c=1/g,f=1/h,k=1/i;b.elements[0]*=c;b.elements[1]*=\nc;b.elements[2]*=c;b.elements[4]*=f;b.elements[5]*=f;b.elements[6]*=f;b.elements[8]*=k;b.elements[9]*=k;b.elements[10]*=k;d.setFromRotationMatrix(b);e.x=g;e.y=h;e.z=i;return this}}(),makeFrustum:function(a,b,c,d,e,f){var g=this.elements;g[0]=2*e/(b-a);g[4]=0;g[8]=(b+a)/(b-a);g[12]=0;g[1]=0;g[5]=2*e/(d-c);g[9]=(d+c)/(d-c);g[13]=0;g[2]=0;g[6]=0;g[10]=-(f+e)/(f-e);g[14]=-2*f*e/(f-e);g[3]=0;g[7]=0;g[11]=-1;g[15]=0;return this},makePerspective:function(a,b,c,d){var a=c*Math.tan(THREE.Math.degToRad(0.5*\na)),e=-a;return this.makeFrustum(e*b,a*b,e,a,c,d)},makeOrthographic:function(a,b,c,d,e,f){var g=this.elements,h=b-a,i=c-d,k=f-e;g[0]=2/h;g[4]=0;g[8]=0;g[12]=-((b+a)/h);g[1]=0;g[5]=2/i;g[9]=0;g[13]=-((c+d)/i);g[2]=0;g[6]=0;g[10]=-2/k;g[14]=-((f+e)/k);g[3]=0;g[7]=0;g[11]=0;g[15]=1;return this},fromArray:function(a){this.elements.set(a);return this},toArray:function(){var a=this.elements;return[a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15]]},clone:function(){var a=\nthis.elements;return new THREE.Matrix4(a[0],a[4],a[8],a[12],a[1],a[5],a[9],a[13],a[2],a[6],a[10],a[14],a[3],a[7],a[11],a[15])}};THREE.Ray=function(a,b){this.origin=void 0!==a?a:new THREE.Vector3;this.direction=void 0!==b?b:new THREE.Vector3};\nTHREE.Ray.prototype={constructor:THREE.Ray,set:function(a,b){this.origin.copy(a);this.direction.copy(b);return this},copy:function(a){this.origin.copy(a.origin);this.direction.copy(a.direction);return this},at:function(a,b){return(b||new THREE.Vector3).copy(this.direction).multiplyScalar(a).add(this.origin)},recast:function(){var a=new THREE.Vector3;return function(b){this.origin.copy(this.at(b,a));return this}}(),closestPointToPoint:function(a,b){var c=b||new THREE.Vector3;c.subVectors(a,this.origin);\nvar d=c.dot(this.direction);return 0>d?c.copy(this.origin):c.copy(this.direction).multiplyScalar(d).add(this.origin)},distanceToPoint:function(){var a=new THREE.Vector3;return function(b){var c=a.subVectors(b,this.origin).dot(this.direction);if(0>c)return this.origin.distanceTo(b);a.copy(this.direction).multiplyScalar(c).add(this.origin);return a.distanceTo(b)}}(),distanceSqToSegment:function(a,b,c,d){var e=a.clone().add(b).multiplyScalar(0.5),f=b.clone().sub(a).normalize(),g=0.5*a.distanceTo(b),\nh=this.origin.clone().sub(e),a=-this.direction.dot(f),b=h.dot(this.direction),i=-h.dot(f),k=h.lengthSq(),l=Math.abs(1-a*a),n,p;0<=l?(h=a*i-b,n=a*b-i,p=g*l,0<=h?n>=-p?n<=p?(g=1/l,h*=g,n*=g,a=h*(h+a*n+2*b)+n*(a*h+n+2*i)+k):(n=g,h=Math.max(0,-(a*n+b)),a=-h*h+n*(n+2*i)+k):(n=-g,h=Math.max(0,-(a*n+b)),a=-h*h+n*(n+2*i)+k):n<=-p?(h=Math.max(0,-(-a*g+b)),n=0<h?-g:Math.min(Math.max(-g,-i),g),a=-h*h+n*(n+2*i)+k):n<=p?(h=0,n=Math.min(Math.max(-g,-i),g),a=n*(n+2*i)+k):(h=Math.max(0,-(a*g+b)),n=0<h?g:Math.min(Math.max(-g,\n-i),g),a=-h*h+n*(n+2*i)+k)):(n=0<a?-g:g,h=Math.max(0,-(a*n+b)),a=-h*h+n*(n+2*i)+k);c&&c.copy(this.direction.clone().multiplyScalar(h).add(this.origin));d&&d.copy(f.clone().multiplyScalar(n).add(e));return a},isIntersectionSphere:function(a){return this.distanceToPoint(a.center)<=a.radius},isIntersectionPlane:function(a){var b=a.distanceToPoint(this.origin);return 0===b||0>a.normal.dot(this.direction)*b?!0:!1},distanceToPlane:function(a){var b=a.normal.dot(this.direction);if(0==b)return 0==a.distanceToPoint(this.origin)?\n0:null;a=-(this.origin.dot(a.normal)+a.constant)/b;return 0<=a?a:null},intersectPlane:function(a,b){var c=this.distanceToPlane(a);return null===c?null:this.at(c,b)},isIntersectionBox:function(){var a=new THREE.Vector3;return function(b){return null!==this.intersectBox(b,a)}}(),intersectBox:function(a,b){var c,d,e,f,g;d=1/this.direction.x;f=1/this.direction.y;g=1/this.direction.z;var h=this.origin;0<=d?(c=(a.min.x-h.x)*d,d*=a.max.x-h.x):(c=(a.max.x-h.x)*d,d*=a.min.x-h.x);0<=f?(e=(a.min.y-h.y)*f,f*=\na.max.y-h.y):(e=(a.max.y-h.y)*f,f*=a.min.y-h.y);if(c>f||e>d)return null;if(e>c||c!==c)c=e;if(f<d||d!==d)d=f;0<=g?(e=(a.min.z-h.z)*g,g*=a.max.z-h.z):(e=(a.max.z-h.z)*g,g*=a.min.z-h.z);if(c>g||e>d)return null;if(e>c||c!==c)c=e;if(g<d||d!==d)d=g;return 0>d?null:this.at(0<=c?c:d,b)},intersectTriangle:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3,d=new THREE.Vector3;return function(e,f,g,h,i){b.subVectors(f,e);c.subVectors(g,e);d.crossVectors(b,c);f=this.direction.dot(d);if(0<\nf){if(h)return null;h=1}else if(0>f)h=-1,f=-f;else return null;a.subVectors(this.origin,e);e=h*this.direction.dot(c.crossVectors(a,c));if(0>e)return null;g=h*this.direction.dot(b.cross(a));if(0>g||e+g>f)return null;e=-h*a.dot(d);return 0>e?null:this.at(e/f,i)}}(),applyMatrix4:function(a){this.direction.add(this.origin).applyMatrix4(a);this.origin.applyMatrix4(a);this.direction.sub(this.origin);this.direction.normalize();return this},equals:function(a){return a.origin.equals(this.origin)&&a.direction.equals(this.direction)},\nclone:function(){return(new THREE.Ray).copy(this)}};THREE.Sphere=function(a,b){this.center=void 0!==a?a:new THREE.Vector3;this.radius=void 0!==b?b:0};\nTHREE.Sphere.prototype={constructor:THREE.Sphere,set:function(a,b){this.center.copy(a);this.radius=b;return this},setFromPoints:function(){var a=new THREE.Box3;return function(b,c){var d=this.center;void 0!==c?d.copy(c):a.setFromPoints(b).center(d);for(var e=0,f=0,g=b.length;f<g;f++)e=Math.max(e,d.distanceToSquared(b[f]));this.radius=Math.sqrt(e);return this}}(),copy:function(a){this.center.copy(a.center);this.radius=a.radius;return this},empty:function(){return 0>=this.radius},containsPoint:function(a){return a.distanceToSquared(this.center)<=\nthis.radius*this.radius},distanceToPoint:function(a){return a.distanceTo(this.center)-this.radius},intersectsSphere:function(a){var b=this.radius+a.radius;return a.center.distanceToSquared(this.center)<=b*b},clampPoint:function(a,b){var c=this.center.distanceToSquared(a),d=b||new THREE.Vector3;d.copy(a);c>this.radius*this.radius&&(d.sub(this.center).normalize(),d.multiplyScalar(this.radius).add(this.center));return d},getBoundingBox:function(a){a=a||new THREE.Box3;a.set(this.center,this.center);a.expandByScalar(this.radius);\nreturn a},applyMatrix4:function(a){this.center.applyMatrix4(a);this.radius*=a.getMaxScaleOnAxis();return this},translate:function(a){this.center.add(a);return this},equals:function(a){return a.center.equals(this.center)&&a.radius===this.radius},clone:function(){return(new THREE.Sphere).copy(this)}};THREE.Frustum=function(a,b,c,d,e,f){this.planes=[void 0!==a?a:new THREE.Plane,void 0!==b?b:new THREE.Plane,void 0!==c?c:new THREE.Plane,void 0!==d?d:new THREE.Plane,void 0!==e?e:new THREE.Plane,void 0!==f?f:new THREE.Plane]};\nTHREE.Frustum.prototype={constructor:THREE.Frustum,set:function(a,b,c,d,e,f){var g=this.planes;g[0].copy(a);g[1].copy(b);g[2].copy(c);g[3].copy(d);g[4].copy(e);g[5].copy(f);return this},copy:function(a){for(var b=this.planes,c=0;6>c;c++)b[c].copy(a.planes[c]);return this},setFromMatrix:function(a){var b=this.planes,c=a.elements,a=c[0],d=c[1],e=c[2],f=c[3],g=c[4],h=c[5],i=c[6],k=c[7],l=c[8],n=c[9],p=c[10],t=c[11],r=c[12],m=c[13],q=c[14],c=c[15];b[0].setComponents(f-a,k-g,t-l,c-r).normalize();b[1].setComponents(f+\na,k+g,t+l,c+r).normalize();b[2].setComponents(f+d,k+h,t+n,c+m).normalize();b[3].setComponents(f-d,k-h,t-n,c-m).normalize();b[4].setComponents(f-e,k-i,t-p,c-q).normalize();b[5].setComponents(f+e,k+i,t+p,c+q).normalize();return this},intersectsObject:function(){var a=new THREE.Sphere;return function(b){var c=b.geometry;null===c.boundingSphere&&c.computeBoundingSphere();a.copy(c.boundingSphere);a.applyMatrix4(b.matrixWorld);return this.intersectsSphere(a)}}(),intersectsSphere:function(a){for(var b=this.planes,\nc=a.center,a=-a.radius,d=0;6>d;d++)if(b[d].distanceToPoint(c)<a)return!1;return!0},intersectsBox:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c){for(var d=this.planes,e=0;6>e;e++){var f=d[e];a.x=0<f.normal.x?c.min.x:c.max.x;b.x=0<f.normal.x?c.max.x:c.min.x;a.y=0<f.normal.y?c.min.y:c.max.y;b.y=0<f.normal.y?c.max.y:c.min.y;a.z=0<f.normal.z?c.min.z:c.max.z;b.z=0<f.normal.z?c.max.z:c.min.z;var g=f.distanceToPoint(a),f=f.distanceToPoint(b);if(0>g&&0>f)return!1}return!0}}(),containsPoint:function(a){for(var b=\nthis.planes,c=0;6>c;c++)if(0>b[c].distanceToPoint(a))return!1;return!0},clone:function(){return(new THREE.Frustum).copy(this)}};THREE.Plane=function(a,b){this.normal=void 0!==a?a:new THREE.Vector3(1,0,0);this.constant=void 0!==b?b:0};\nTHREE.Plane.prototype={constructor:THREE.Plane,set:function(a,b){this.normal.copy(a);this.constant=b;return this},setComponents:function(a,b,c,d){this.normal.set(a,b,c);this.constant=d;return this},setFromNormalAndCoplanarPoint:function(a,b){this.normal.copy(a);this.constant=-b.dot(this.normal);return this},setFromCoplanarPoints:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d,e){d=a.subVectors(e,d).cross(b.subVectors(c,d)).normalize();this.setFromNormalAndCoplanarPoint(d,\nc);return this}}(),copy:function(a){this.normal.copy(a.normal);this.constant=a.constant;return this},normalize:function(){var a=1/this.normal.length();this.normal.multiplyScalar(a);this.constant*=a;return this},negate:function(){this.constant*=-1;this.normal.negate();return this},distanceToPoint:function(a){return this.normal.dot(a)+this.constant},distanceToSphere:function(a){return this.distanceToPoint(a.center)-a.radius},projectPoint:function(a,b){return this.orthoPoint(a,b).sub(a).negate()},orthoPoint:function(a,\nb){var c=this.distanceToPoint(a);return(b||new THREE.Vector3).copy(this.normal).multiplyScalar(c)},isIntersectionLine:function(a){var b=this.distanceToPoint(a.start),a=this.distanceToPoint(a.end);return 0>b&&0<a||0>a&&0<b},intersectLine:function(){var a=new THREE.Vector3;return function(b,c){var d=c||new THREE.Vector3,e=b.delta(a),f=this.normal.dot(e);if(0==f){if(0==this.distanceToPoint(b.start))return d.copy(b.start)}else return f=-(b.start.dot(this.normal)+this.constant)/f,0>f||1<f?void 0:d.copy(e).multiplyScalar(f).add(b.start)}}(),\ncoplanarPoint:function(a){return(a||new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)},applyMatrix4:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Matrix3;return function(d,e){var f=e||c.getNormalMatrix(d),f=a.copy(this.normal).applyMatrix3(f),g=this.coplanarPoint(b);g.applyMatrix4(d);this.setFromNormalAndCoplanarPoint(f,g);return this}}(),translate:function(a){this.constant-=a.dot(this.normal);return this},equals:function(a){return a.normal.equals(this.normal)&&\na.constant==this.constant},clone:function(){return(new THREE.Plane).copy(this)}};THREE.Math={PI2:2*Math.PI,generateUUID:function(){var a=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\".split(\"\"),b=Array(36),c=0,d;return function(){for(var e=0;36>e;e++)8==e||13==e||18==e||23==e?b[e]=\"-\":14==e?b[e]=\"4\":(2>=c&&(c=33554432+16777216*Math.random()|0),d=c&15,c>>=4,b[e]=a[19==e?d&3|8:d]);return b.join(\"\")}}(),clamp:function(a,b,c){return a<b?b:a>c?c:a},clampBottom:function(a,b){return a<b?b:a},mapLinear:function(a,b,c,d,e){return d+(a-b)*(e-d)/(c-b)},smoothstep:function(a,\nb,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*(3-2*a)},smootherstep:function(a,b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*a*(a*(6*a-15)+10)},random16:function(){return(65280*Math.random()+255*Math.random())/65535},randInt:function(a,b){return a+Math.floor(Math.random()*(b-a+1))},randFloat:function(a,b){return a+Math.random()*(b-a)},randFloatSpread:function(a){return a*(0.5-Math.random())},sign:function(a){return 0>a?-1:0<a?1:0},degToRad:function(){var a=Math.PI/\n180;return function(b){return b*a}}(),radToDeg:function(){var a=180/Math.PI;return function(b){return b*a}}()};THREE.Spline=function(a){function b(a,b,c,d,e,f,g){a=0.5*(c-a);d=0.5*(d-b);return(2*(b-c)+a+d)*g+(-3*(b-c)-2*a-d)*f+a*e+b}this.points=a;var c=[],d={x:0,y:0,z:0},e,f,g,h,i,k,l,n,p;this.initFromArray=function(a){this.points=[];for(var b=0;b<a.length;b++)this.points[b]={x:a[b][0],y:a[b][1],z:a[b][2]}};this.getPoint=function(a){e=(this.points.length-1)*a;f=Math.floor(e);g=e-f;c[0]=0===f?f:f-1;c[1]=f;c[2]=f>this.points.length-2?this.points.length-1:f+1;c[3]=f>this.points.length-3?this.points.length-1:\nf+2;k=this.points[c[0]];l=this.points[c[1]];n=this.points[c[2]];p=this.points[c[3]];h=g*g;i=g*h;d.x=b(k.x,l.x,n.x,p.x,g,h,i);d.y=b(k.y,l.y,n.y,p.y,g,h,i);d.z=b(k.z,l.z,n.z,p.z,g,h,i);return d};this.getControlPointsArray=function(){var a,b,c=this.points.length,d=[];for(a=0;a<c;a++)b=this.points[a],d[a]=[b.x,b.y,b.z];return d};this.getLength=function(a){var b,c,d,e=b=b=0,f=new THREE.Vector3,g=new THREE.Vector3,h=[],i=0;h[0]=0;a||(a=100);c=this.points.length*a;f.copy(this.points[0]);for(a=1;a<c;a++)b=\na/c,d=this.getPoint(b),g.copy(d),i+=g.distanceTo(f),f.copy(d),b*=this.points.length-1,b=Math.floor(b),b!=e&&(h[b]=i,e=b);h[h.length]=i;return{chunks:h,total:i}};this.reparametrizeByArcLength=function(a){var b,c,d,e,f,g,h=[],i=new THREE.Vector3,k=this.getLength();h.push(i.copy(this.points[0]).clone());for(b=1;b<this.points.length;b++){c=k.chunks[b]-k.chunks[b-1];g=Math.ceil(a*c/k.total);e=(b-1)/(this.points.length-1);f=b/(this.points.length-1);for(c=1;c<g-1;c++)d=e+c*(1/g)*(f-e),d=this.getPoint(d),\nh.push(i.copy(d).clone());h.push(i.copy(this.points[b]).clone())}this.points=h}};THREE.Triangle=function(a,b,c){this.a=void 0!==a?a:new THREE.Vector3;this.b=void 0!==b?b:new THREE.Vector3;this.c=void 0!==c?c:new THREE.Vector3};THREE.Triangle.normal=function(){var a=new THREE.Vector3;return function(b,c,d,e){e=e||new THREE.Vector3;e.subVectors(d,c);a.subVectors(b,c);e.cross(a);b=e.lengthSq();return 0<b?e.multiplyScalar(1/Math.sqrt(b)):e.set(0,0,0)}}();\nTHREE.Triangle.barycoordFromPoint=function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(d,e,f,g,h){a.subVectors(g,e);b.subVectors(f,e);c.subVectors(d,e);var d=a.dot(a),e=a.dot(b),f=a.dot(c),i=b.dot(b),g=b.dot(c),k=d*i-e*e,h=h||new THREE.Vector3;if(0==k)return h.set(-2,-1,-1);k=1/k;i=(i*f-e*g)*k;d=(d*g-e*f)*k;return h.set(1-i-d,d,i)}}();\nTHREE.Triangle.containsPoint=function(){var a=new THREE.Vector3;return function(b,c,d,e){b=THREE.Triangle.barycoordFromPoint(b,c,d,e,a);return 0<=b.x&&0<=b.y&&1>=b.x+b.y}}();\nTHREE.Triangle.prototype={constructor:THREE.Triangle,set:function(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this},setFromPointsAndIndices:function(a,b,c,d){this.a.copy(a[b]);this.b.copy(a[c]);this.c.copy(a[d]);return this},copy:function(a){this.a.copy(a.a);this.b.copy(a.b);this.c.copy(a.c);return this},area:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(){a.subVectors(this.c,this.b);b.subVectors(this.a,this.b);return 0.5*a.cross(b).length()}}(),midpoint:function(a){return(a||\nnew THREE.Vector3).addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},normal:function(a){return THREE.Triangle.normal(this.a,this.b,this.c,a)},plane:function(a){return(a||new THREE.Plane).setFromCoplanarPoints(this.a,this.b,this.c)},barycoordFromPoint:function(a,b){return THREE.Triangle.barycoordFromPoint(a,this.a,this.b,this.c,b)},containsPoint:function(a){return THREE.Triangle.containsPoint(a,this.a,this.b,this.c)},equals:function(a){return a.a.equals(this.a)&&a.b.equals(this.b)&&a.c.equals(this.c)},\nclone:function(){return(new THREE.Triangle).copy(this)}};THREE.Vertex=function(a){console.warn(\"THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.\");return a};THREE.UV=function(a,b){console.warn(\"THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.\");return new THREE.Vector2(a,b)};THREE.Clock=function(a){this.autoStart=void 0!==a?a:!0;this.elapsedTime=this.oldTime=this.startTime=0;this.running=!1};\nTHREE.Clock.prototype={constructor:THREE.Clock,start:function(){this.oldTime=this.startTime=void 0!==self.performance&&void 0!==self.performance.now?self.performance.now():Date.now();this.running=!0},stop:function(){this.getElapsedTime();this.running=!1},getElapsedTime:function(){this.getDelta();return this.elapsedTime},getDelta:function(){var a=0;this.autoStart&&!this.running&&this.start();if(this.running){var b=void 0!==self.performance&&void 0!==self.performance.now?self.performance.now():Date.now(),\na=0.001*(b-this.oldTime);this.oldTime=b;this.elapsedTime+=a}return a}};THREE.EventDispatcher=function(){};\nTHREE.EventDispatcher.prototype={constructor:THREE.EventDispatcher,apply:function(a){a.addEventListener=THREE.EventDispatcher.prototype.addEventListener;a.hasEventListener=THREE.EventDispatcher.prototype.hasEventListener;a.removeEventListener=THREE.EventDispatcher.prototype.removeEventListener;a.dispatchEvent=THREE.EventDispatcher.prototype.dispatchEvent},addEventListener:function(a,b){void 0===this._listeners&&(this._listeners={});var c=this._listeners;void 0===c[a]&&(c[a]=[]);-1===c[a].indexOf(b)&&\nc[a].push(b)},hasEventListener:function(a,b){if(void 0===this._listeners)return!1;var c=this._listeners;return void 0!==c[a]&&-1!==c[a].indexOf(b)?!0:!1},removeEventListener:function(a,b){if(void 0!==this._listeners){var c=this._listeners[a];if(void 0!==c){var d=c.indexOf(b);-1!==d&&c.splice(d,1)}}},dispatchEvent:function(){var a=[];return function(b){if(void 0!==this._listeners){var c=this._listeners[b.type];if(void 0!==c){b.target=this;for(var d=c.length,e=0;e<d;e++)a[e]=c[e];for(e=0;e<d;e++)a[e].call(this,\nb)}}}}()};(function(a){a.Raycaster=function(b,c,d,e){this.ray=new a.Ray(b,c);this.near=d||0;this.far=e||Infinity};var b=new a.Sphere,c=new a.Ray;new a.Plane;new a.Vector3;var d=new a.Vector3,e=new a.Matrix4,f=function(a,b){return a.distance-b.distance},g=new a.Vector3,h=new a.Vector3,i=new a.Vector3,k=function(f,l,t){if(f instanceof a.Sprite){d.setFromMatrixPosition(f.matrixWorld);var r=l.ray.distanceToPoint(d);if(r>f.scale.x)return t;t.push({distance:r,point:f.position,face:null,object:f})}else if(f instanceof\na.LOD)d.setFromMatrixPosition(f.matrixWorld),r=l.ray.origin.distanceTo(d),k(f.getObjectForDistance(r),l,t);else if(f instanceof a.Mesh){var m=f.geometry;null===m.boundingSphere&&m.computeBoundingSphere();b.copy(m.boundingSphere);b.applyMatrix4(f.matrixWorld);if(!1===l.ray.isIntersectionSphere(b))return t;e.getInverse(f.matrixWorld);c.copy(l.ray).applyMatrix4(e);if(null!==m.boundingBox&&!1===c.isIntersectionBox(m.boundingBox))return t;if(m instanceof a.BufferGeometry){var q=f.material;if(void 0===\nq||!1===m.dynamic)return t;var u,s,v=l.precision;if(void 0!==m.attributes.index)for(var z=m.offsets,G=m.attributes.index.array,N=m.attributes.position.array,C=m.offsets.length,B=m.attributes.index.array.length/3,B=0;B<C;++B)for(var r=z[B].start,x=z[B].index,m=r,F=r+z[B].count;m<F;m+=3)r=x+G[m],u=x+G[m+1],s=x+G[m+2],g.set(N[3*r],N[3*r+1],N[3*r+2]),h.set(N[3*u],N[3*u+1],N[3*u+2]),i.set(N[3*s],N[3*s+1],N[3*s+2]),u=q.side===a.BackSide?c.intersectTriangle(i,h,g,!0):c.intersectTriangle(g,h,i,q.side!==a.DoubleSide),\nnull!==u&&(u.applyMatrix4(f.matrixWorld),r=l.ray.origin.distanceTo(u),r<v||(r<l.near||r>l.far)||t.push({distance:r,point:u,face:null,faceIndex:null,object:f}));else{N=m.attributes.position.array;B=m.attributes.position.array.length;for(m=0;m<B;m+=3)r=m,u=m+1,s=m+2,g.set(N[3*r],N[3*r+1],N[3*r+2]),h.set(N[3*u],N[3*u+1],N[3*u+2]),i.set(N[3*s],N[3*s+1],N[3*s+2]),u=q.side===a.BackSide?c.intersectTriangle(i,h,g,!0):c.intersectTriangle(g,h,i,q.side!==a.DoubleSide),null!==u&&(u.applyMatrix4(f.matrixWorld),\nr=l.ray.origin.distanceTo(u),r<v||(r<l.near||r>l.far)||t.push({distance:r,point:u,face:null,faceIndex:null,object:f}))}}else if(m instanceof a.Geometry){G=f.material instanceof a.MeshFaceMaterial;N=!0===G?f.material.materials:null;v=l.precision;z=m.vertices;C=0;for(B=m.faces.length;C<B;C++)if(x=m.faces[C],q=!0===G?N[x.materialIndex]:f.material,void 0!==q){r=z[x.a];u=z[x.b];s=z[x.c];if(!0===q.morphTargets){var F=m.morphTargets,L=f.morphTargetInfluences;g.set(0,0,0);h.set(0,0,0);i.set(0,0,0);for(var w=\n0,E=F.length;w<E;w++){var y=L[w];if(0!==y){var D=F[w].vertices;g.x+=(D[x.a].x-r.x)*y;g.y+=(D[x.a].y-r.y)*y;g.z+=(D[x.a].z-r.z)*y;h.x+=(D[x.b].x-u.x)*y;h.y+=(D[x.b].y-u.y)*y;h.z+=(D[x.b].z-u.z)*y;i.x+=(D[x.c].x-s.x)*y;i.y+=(D[x.c].y-s.y)*y;i.z+=(D[x.c].z-s.z)*y}}g.add(r);h.add(u);i.add(s);r=g;u=h;s=i}u=q.side===a.BackSide?c.intersectTriangle(s,u,r,!0):c.intersectTriangle(r,u,s,q.side!==a.DoubleSide);null!==u&&(u.applyMatrix4(f.matrixWorld),r=l.ray.origin.distanceTo(u),r<v||(r<l.near||r>l.far)||t.push({distance:r,\npoint:u,face:x,faceIndex:C,object:f}))}}}else if(f instanceof a.Line){v=l.linePrecision;q=v*v;m=f.geometry;null===m.boundingSphere&&m.computeBoundingSphere();b.copy(m.boundingSphere);b.applyMatrix4(f.matrixWorld);if(!1===l.ray.isIntersectionSphere(b))return t;e.getInverse(f.matrixWorld);c.copy(l.ray).applyMatrix4(e);if(m instanceof a.Geometry){z=m.vertices;v=z.length;u=new a.Vector3;s=new a.Vector3;B=f.type===a.LineStrip?1:2;for(m=0;m<v-1;m+=B)c.distanceSqToSegment(z[m],z[m+1],s,u)>q||(r=c.origin.distanceTo(s),\nr<l.near||r>l.far||t.push({distance:r,point:u.clone().applyMatrix4(f.matrixWorld),face:null,faceIndex:null,object:f}))}}},l=function(a,b,c){for(var a=a.getDescendants(),d=0,e=a.length;d<e;d++)k(a[d],b,c)};a.Raycaster.prototype.precision=1E-4;a.Raycaster.prototype.linePrecision=1;a.Raycaster.prototype.set=function(a,b){this.ray.set(a,b)};a.Raycaster.prototype.intersectObject=function(a,b){var c=[];!0===b&&l(a,this,c);k(a,this,c);c.sort(f);return c};a.Raycaster.prototype.intersectObjects=function(a,\nb){for(var c=[],d=0,e=a.length;d<e;d++)k(a[d],this,c),!0===b&&l(a[d],this,c);c.sort(f);return c}})(THREE);THREE.Object3D=function(){this.id=THREE.Object3DIdCount++;this.uuid=THREE.Math.generateUUID();this.name=\"\";this.parent=void 0;this.children=[];this.up=new THREE.Vector3(0,1,0);this.position=new THREE.Vector3;this._rotation=new THREE.Euler;this._quaternion=new THREE.Quaternion;this.scale=new THREE.Vector3(1,1,1);this._rotation._quaternion=this.quaternion;this._quaternion._euler=this.rotation;this.renderDepth=null;this.rotationAutoUpdate=!0;this.matrix=new THREE.Matrix4;this.matrixWorld=new THREE.Matrix4;\nthis.visible=this.matrixWorldNeedsUpdate=this.matrixAutoUpdate=!0;this.receiveShadow=this.castShadow=!1;this.frustumCulled=!0;this.userData={}};\nTHREE.Object3D.prototype={constructor:THREE.Object3D,get rotation(){return this._rotation},set rotation(a){this._rotation=a;this._rotation._quaternion=this._quaternion;this._quaternion._euler=this._rotation;this._rotation._updateQuaternion()},get quaternion(){return this._quaternion},set quaternion(a){this._quaternion=a;this._quaternion._euler=this._rotation;this._rotation._quaternion=this._quaternion;this._quaternion._updateEuler()},get eulerOrder(){console.warn(\"DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order.\");\nreturn this.rotation.order},set eulerOrder(a){console.warn(\"DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order.\");this.rotation.order=a},get useQuaternion(){console.warn(\"DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.\")},set useQuaternion(a){console.warn(\"DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.\")},applyMatrix:function(a){this.matrix.multiplyMatrices(a,this.matrix);\nthis.matrix.decompose(this.position,this.quaternion,this.scale)},setRotationFromAxisAngle:function(a,b){this.quaternion.setFromAxisAngle(a,b)},setRotationFromEuler:function(a){this.quaternion.setFromEuler(a,!0)},setRotationFromMatrix:function(a){this.quaternion.setFromRotationMatrix(a)},setRotationFromQuaternion:function(a){this.quaternion.copy(a)},rotateOnAxis:function(){var a=new THREE.Quaternion;return function(b,c){a.setFromAxisAngle(b,c);this.quaternion.multiply(a);return this}}(),rotateX:function(){var a=\nnew THREE.Vector3(1,0,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateY:function(){var a=new THREE.Vector3(0,1,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateZ:function(){var a=new THREE.Vector3(0,0,1);return function(b){return this.rotateOnAxis(a,b)}}(),translateOnAxis:function(){var a=new THREE.Vector3;return function(b,c){a.copy(b);a.applyQuaternion(this.quaternion);this.position.add(a.multiplyScalar(c));return this}}(),translate:function(a,b){console.warn(\"DEPRECATED: Object3D's .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.\");\nreturn this.translateOnAxis(b,a)},translateX:function(){var a=new THREE.Vector3(1,0,0);return function(b){return this.translateOnAxis(a,b)}}(),translateY:function(){var a=new THREE.Vector3(0,1,0);return function(b){return this.translateOnAxis(a,b)}}(),translateZ:function(){var a=new THREE.Vector3(0,0,1);return function(b){return this.translateOnAxis(a,b)}}(),localToWorld:function(a){return a.applyMatrix4(this.matrixWorld)},worldToLocal:function(){var a=new THREE.Matrix4;return function(b){return b.applyMatrix4(a.getInverse(this.matrixWorld))}}(),\nlookAt:function(){var a=new THREE.Matrix4;return function(b){a.lookAt(b,this.position,this.up);this.quaternion.setFromRotationMatrix(a)}}(),add:function(a){if(a===this)console.warn(\"THREE.Object3D.add: An object can't be added as a child of itself.\");else if(a instanceof THREE.Object3D){void 0!==a.parent&&a.parent.remove(a);a.parent=this;a.dispatchEvent({type:\"added\"});this.children.push(a);for(var b=this;void 0!==b.parent;)b=b.parent;void 0!==b&&b instanceof THREE.Scene&&b.__addObject(a)}},remove:function(a){var b=\nthis.children.indexOf(a);if(-1!==b){a.parent=void 0;a.dispatchEvent({type:\"removed\"});this.children.splice(b,1);for(b=this;void 0!==b.parent;)b=b.parent;void 0!==b&&b instanceof THREE.Scene&&b.__removeObject(a)}},traverse:function(a){a(this);for(var b=0,c=this.children.length;b<c;b++)this.children[b].traverse(a)},getObjectById:function(a,b){for(var c=0,d=this.children.length;c<d;c++){var e=this.children[c];if(e.id===a||!0===b&&(e=e.getObjectById(a,b),void 0!==e))return e}},getObjectByName:function(a,\nb){for(var c=0,d=this.children.length;c<d;c++){var e=this.children[c];if(e.name===a||!0===b&&(e=e.getObjectByName(a,b),void 0!==e))return e}},getChildByName:function(a,b){console.warn(\"DEPRECATED: Object3D's .getChildByName() has been renamed to .getObjectByName().\");return this.getObjectByName(a,b)},getDescendants:function(a){void 0===a&&(a=[]);Array.prototype.push.apply(a,this.children);for(var b=0,c=this.children.length;b<c;b++)this.children[b].getDescendants(a);return a},updateMatrix:function(){this.matrix.compose(this.position,\nthis.quaternion,this.scale);this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(a){!0===this.matrixAutoUpdate&&this.updateMatrix();if(!0===this.matrixWorldNeedsUpdate||!0===a)void 0===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,a=!0;for(var b=0,c=this.children.length;b<c;b++)this.children[b].updateMatrixWorld(a)},clone:function(a,b){void 0===a&&(a=new THREE.Object3D);void 0===b&&(b=!0);\na.name=this.name;a.up.copy(this.up);a.position.copy(this.position);a.quaternion.copy(this.quaternion);a.scale.copy(this.scale);a.renderDepth=this.renderDepth;a.rotationAutoUpdate=this.rotationAutoUpdate;a.matrix.copy(this.matrix);a.matrixWorld.copy(this.matrixWorld);a.matrixAutoUpdate=this.matrixAutoUpdate;a.matrixWorldNeedsUpdate=this.matrixWorldNeedsUpdate;a.visible=this.visible;a.castShadow=this.castShadow;a.receiveShadow=this.receiveShadow;a.frustumCulled=this.frustumCulled;a.userData=JSON.parse(JSON.stringify(this.userData));\nif(!0===b)for(var c=0;c<this.children.length;c++)a.add(this.children[c].clone());return a}};THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);THREE.Object3DIdCount=0;THREE.Projector=function(){function a(){if(i===l){var a=new THREE.RenderableVertex;k.push(a);l++;i++;return a}return k[i++]}function b(a,b){return a.z!==b.z?b.z-a.z:a.id!==b.id?a.id-b.id:0}function c(a,b){var c=0,d=1,e=a.z+a.w,f=b.z+b.w,g=-a.z+a.w,h=-b.z+b.w;if(0<=e&&0<=f&&0<=g&&0<=h)return!0;if(0>e&&0>f||0>g&&0>h)return!1;0>e?c=Math.max(c,e/(e-f)):0>f&&(d=Math.min(d,e/(e-f)));0>g?c=Math.max(c,g/(g-h)):0>h&&(d=Math.min(d,g/(g-h)));if(d<c)return!1;a.lerp(b,c);b.lerp(a,1-d);return!0}var d,e,f=[],g=\n0,h,i,k=[],l=0,n,p,t=[],r=0,m,q,u=[],s=0,v,z,G=[],N=0,C={objects:[],sprites:[],lights:[],elements:[]},B=new THREE.Vector3,x=new THREE.Vector3,F=new THREE.Vector3,L=new THREE.Vector3,w=new THREE.Vector4,E=new THREE.Box3(new THREE.Vector3(-1,-1,-1),new THREE.Vector3(1,1,1)),y=new THREE.Box3,D=Array(3),H=new THREE.Matrix4,K=new THREE.Matrix4,A,da=new THREE.Matrix4,ha=new THREE.Matrix3,ua=new THREE.Matrix3,O=new THREE.Vector3,T=new THREE.Frustum,ea=new THREE.Vector4,I=new THREE.Vector4;this.projectVector=\nfunction(a,b){b.matrixWorldInverse.getInverse(b.matrixWorld);K.multiplyMatrices(b.projectionMatrix,b.matrixWorldInverse);return a.applyProjection(K)};var P=new THREE.Matrix4;this.unprojectVector=function(a,b){P.getInverse(b.projectionMatrix);K.multiplyMatrices(b.matrixWorld,P);return a.applyProjection(K)};this.pickingRay=function(a,b){a.z=-1;var c=new THREE.Vector3(a.x,a.y,1);this.unprojectVector(a,b);this.unprojectVector(c,b);c.sub(a).normalize();return new THREE.Raycaster(a,c)};var Q=function(a){if(e===\ng){var b=new THREE.RenderableObject;f.push(b);g++;e++;d=b}else d=f[e++];d.id=a.id;d.object=a;null!==a.renderDepth?d.z=a.renderDepth:(L.setFromMatrixPosition(a.matrixWorld),L.applyProjection(K),d.z=L.z);return d},oa=function(a){var b=a.positionWorld,c=a.positionScreen;b.copy(a.position).applyMatrix4(A);c.copy(b).applyMatrix4(K);b=1/c.w;c.x*=b;c.y*=b;c.z*=b;a.visible=-1<=c.x&&1>=c.x&&-1<=c.y&&1>=c.y&&-1<=c.z&&1>=c.z},va=function(a){if(!1!==a.visible){a instanceof THREE.Light?C.lights.push(a):a instanceof\nTHREE.Mesh||a instanceof THREE.Line?(!1===a.frustumCulled||!0===T.intersectsObject(a))&&C.objects.push(Q(a)):a instanceof THREE.Sprite&&C.sprites.push(Q(a));for(var b=0,c=a.children.length;b<c;b++)va(a.children[b])}};this.projectScene=function(d,f,g,l){var P=!1,L,Q,ba,W,Ka,U,ca,wa,Ua;z=q=p=0;C.elements.length=0;!0===d.autoUpdate&&d.updateMatrixWorld();void 0===f.parent&&f.updateMatrixWorld();H.copy(f.matrixWorldInverse.getInverse(f.matrixWorld));K.multiplyMatrices(f.projectionMatrix,H);ua.getNormalMatrix(H);\nT.setFromMatrix(K);e=0;C.objects.length=0;C.sprites.length=0;C.lights.length=0;va(d);!0===g&&C.objects.sort(b);for(var g=0,Oa=C.objects.length;g<Oa;g++)if(d=C.objects[g].object,A=d.matrixWorld,i=0,d instanceof THREE.Mesh){L=d.geometry;Q=L.vertices;ba=L.faces;Ka=L.faceVertexUvs;ha.getNormalMatrix(A);wa=d.material instanceof THREE.MeshFaceMaterial;Ua=!0===wa?d.material:null;for(var la=0,ia=Q.length;la<ia;la++)h=a(),h.position.copy(Q[la]),oa(h);la=0;for(ia=ba.length;la<ia;la++){Q=ba[la];var Fa=!0===\nwa?Ua.materials[Q.materialIndex]:d.material;if(void 0!==Fa){var Ga=Fa.side;W=k[Q.a];U=k[Q.b];ca=k[Q.c];if(!0===Fa.morphTargets){var P=L.morphTargets,Ba=d.morphTargetInfluences,xa=W.position,Va=U.position,La=ca.position;B.set(0,0,0);x.set(0,0,0);F.set(0,0,0);for(var Ma=0,ya=P.length;Ma<ya;Ma++){var V=Ba[Ma];if(0!==V){var pa=P[Ma].vertices;B.x+=(pa[Q.a].x-xa.x)*V;B.y+=(pa[Q.a].y-xa.y)*V;B.z+=(pa[Q.a].z-xa.z)*V;x.x+=(pa[Q.b].x-Va.x)*V;x.y+=(pa[Q.b].y-Va.y)*V;x.z+=(pa[Q.b].z-Va.z)*V;F.x+=(pa[Q.c].x-La.x)*\nV;F.y+=(pa[Q.c].y-La.y)*V;F.z+=(pa[Q.c].z-La.z)*V}}W.position.add(B);U.position.add(x);ca.position.add(F);oa(W);oa(U);oa(ca)}D[0]=W.positionScreen;D[1]=U.positionScreen;D[2]=ca.positionScreen;if(!0===W.visible||!0===U.visible||!0===ca.visible||E.isIntersectionBox(y.setFromPoints(D)))if(P=0>(ca.positionScreen.x-W.positionScreen.x)*(U.positionScreen.y-W.positionScreen.y)-(ca.positionScreen.y-W.positionScreen.y)*(U.positionScreen.x-W.positionScreen.x),Ga===THREE.DoubleSide||P===(Ga===THREE.FrontSide)){p===\nr?(Ba=new THREE.RenderableFace3,t.push(Ba),r++,p++,n=Ba):n=t[p++];n.id=d.id;n.v1.copy(W);n.v2.copy(U);n.v3.copy(ca);n.normalModel.copy(Q.normal);!1===P&&(Ga===THREE.BackSide||Ga===THREE.DoubleSide)&&n.normalModel.negate();n.normalModel.applyMatrix3(ha).normalize();n.normalModelView.copy(n.normalModel).applyMatrix3(ua);n.centroidModel.copy(Q.centroid).applyMatrix4(A);W=Q.vertexNormals;U=0;for(ca=Math.min(W.length,3);U<ca;U++)Ba=n.vertexNormalsModel[U],Ba.copy(W[U]),!1===P&&(Ga===THREE.BackSide||Ga===\nTHREE.DoubleSide)&&Ba.negate(),Ba.applyMatrix3(ha).normalize(),n.vertexNormalsModelView[U].copy(Ba).applyMatrix3(ua);n.vertexNormalsLength=W.length;U=0;for(Ga=Math.min(Ka.length,3);U<Ga;U++)if(W=Ka[U][la],void 0!==W){ca=0;for(P=W.length;ca<P;ca++)n.uvs[U][ca]=W[ca]}n.color=Q.color;n.material=Fa;O.copy(n.centroidModel).applyProjection(K);n.z=O.z;C.elements.push(n)}}}}else if(d instanceof THREE.Line){da.multiplyMatrices(K,A);Q=d.geometry.vertices;W=a();W.positionScreen.copy(Q[0]).applyMatrix4(da);L=\nd.type===THREE.LinePieces?2:1;la=1;for(ia=Q.length;la<ia;la++)W=a(),W.positionScreen.copy(Q[la]).applyMatrix4(da),0<(la+1)%L||(U=k[i-2],ea.copy(W.positionScreen),I.copy(U.positionScreen),!0===c(ea,I)&&(ea.multiplyScalar(1/ea.w),I.multiplyScalar(1/I.w),q===s?(ba=new THREE.RenderableLine,u.push(ba),s++,q++,m=ba):m=u[q++],m.id=d.id,m.v1.positionScreen.copy(ea),m.v2.positionScreen.copy(I),m.z=Math.max(ea.z,I.z),m.material=d.material,d.material.vertexColors===THREE.VertexColors&&(m.vertexColors[0].copy(d.geometry.colors[la]),\nm.vertexColors[1].copy(d.geometry.colors[la-1])),C.elements.push(m)))}g=0;for(Oa=C.sprites.length;g<Oa;g++)d=C.sprites[g].object,A=d.matrixWorld,w.set(A.elements[12],A.elements[13],A.elements[14],1),w.applyMatrix4(K),L=1/w.w,w.z*=L,-1<=w.z&&1>=w.z&&(z===N?(ba=new THREE.RenderableSprite,G.push(ba),N++,z++,v=ba):v=G[z++],v.id=d.id,v.x=w.x*L,v.y=w.y*L,v.z=w.z,v.object=d,v.rotation=d.rotation,v.scale.x=d.scale.x*Math.abs(v.x-(w.x+f.projectionMatrix.elements[0])/(w.w+f.projectionMatrix.elements[12])),\nv.scale.y=d.scale.y*Math.abs(v.y-(w.y+f.projectionMatrix.elements[5])/(w.w+f.projectionMatrix.elements[13])),v.material=d.material,C.elements.push(v));!0===l&&C.elements.sort(b);return C}};THREE.Face3=function(a,b,c,d,e,f){this.a=a;this.b=b;this.c=c;this.normal=d instanceof THREE.Vector3?d:new THREE.Vector3;this.vertexNormals=d instanceof Array?d:[];this.color=e instanceof THREE.Color?e:new THREE.Color;this.vertexColors=e instanceof Array?e:[];this.vertexTangents=[];this.materialIndex=void 0!==f?f:0;this.centroid=new THREE.Vector3};\nTHREE.Face3.prototype={constructor:THREE.Face3,clone:function(){var a=new THREE.Face3(this.a,this.b,this.c);a.normal.copy(this.normal);a.color.copy(this.color);a.centroid.copy(this.centroid);a.materialIndex=this.materialIndex;var b,c;b=0;for(c=this.vertexNormals.length;b<c;b++)a.vertexNormals[b]=this.vertexNormals[b].clone();b=0;for(c=this.vertexColors.length;b<c;b++)a.vertexColors[b]=this.vertexColors[b].clone();b=0;for(c=this.vertexTangents.length;b<c;b++)a.vertexTangents[b]=this.vertexTangents[b].clone();\nreturn a}};THREE.Face4=function(a,b,c,d,e,f,g){console.warn(\"THREE.Face4 has been removed. A THREE.Face3 will be created instead.\");return new THREE.Face3(a,b,c,e,f,g)};THREE.Geometry=function(){this.id=THREE.GeometryIdCount++;this.uuid=THREE.Math.generateUUID();this.name=\"\";this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphColors=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingSphere=this.boundingBox=null;this.hasTangents=!1;this.dynamic=!0;this.buffersNeedUpdate=this.lineDistancesNeedUpdate=this.colorsNeedUpdate=this.tangentsNeedUpdate=this.normalsNeedUpdate=this.uvsNeedUpdate=\nthis.elementsNeedUpdate=this.verticesNeedUpdate=!1};\nTHREE.Geometry.prototype={constructor:THREE.Geometry,applyMatrix:function(a){for(var b=(new THREE.Matrix3).getNormalMatrix(a),c=0,d=this.vertices.length;c<d;c++)this.vertices[c].applyMatrix4(a);c=0;for(d=this.faces.length;c<d;c++){var e=this.faces[c];e.normal.applyMatrix3(b).normalize();for(var f=0,g=e.vertexNormals.length;f<g;f++)e.vertexNormals[f].applyMatrix3(b).normalize();e.centroid.applyMatrix4(a)}this.boundingBox instanceof THREE.Box3&&this.computeBoundingBox();this.boundingSphere instanceof\nTHREE.Sphere&&this.computeBoundingSphere()},computeCentroids:function(){var a,b,c;a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],c.centroid.set(0,0,0),c.centroid.add(this.vertices[c.a]),c.centroid.add(this.vertices[c.b]),c.centroid.add(this.vertices[c.c]),c.centroid.divideScalar(3)},computeFaceNormals:function(){for(var a=new THREE.Vector3,b=new THREE.Vector3,c=0,d=this.faces.length;c<d;c++){var e=this.faces[c],f=this.vertices[e.a],g=this.vertices[e.b];a.subVectors(this.vertices[e.c],g);b.subVectors(f,\ng);a.cross(b);a.normalize();e.normal.copy(a)}},computeVertexNormals:function(a){var b,c,d;d=Array(this.vertices.length);b=0;for(c=this.vertices.length;b<c;b++)d[b]=new THREE.Vector3;if(a){var e,f,g,h=new THREE.Vector3,i=new THREE.Vector3;new THREE.Vector3;new THREE.Vector3;new THREE.Vector3;a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],e=this.vertices[c.a],f=this.vertices[c.b],g=this.vertices[c.c],h.subVectors(g,f),i.subVectors(e,f),h.cross(i),d[c.a].add(h),d[c.b].add(h),d[c.c].add(h)}else{a=\n0;for(b=this.faces.length;a<b;a++)c=this.faces[a],d[c.a].add(c.normal),d[c.b].add(c.normal),d[c.c].add(c.normal)}b=0;for(c=this.vertices.length;b<c;b++)d[b].normalize();a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],c.vertexNormals[0]=d[c.a].clone(),c.vertexNormals[1]=d[c.b].clone(),c.vertexNormals[2]=d[c.c].clone()},computeMorphNormals:function(){var a,b,c,d,e;c=0;for(d=this.faces.length;c<d;c++){e=this.faces[c];e.__originalFaceNormal?e.__originalFaceNormal.copy(e.normal):e.__originalFaceNormal=\ne.normal.clone();e.__originalVertexNormals||(e.__originalVertexNormals=[]);a=0;for(b=e.vertexNormals.length;a<b;a++)e.__originalVertexNormals[a]?e.__originalVertexNormals[a].copy(e.vertexNormals[a]):e.__originalVertexNormals[a]=e.vertexNormals[a].clone()}var f=new THREE.Geometry;f.faces=this.faces;a=0;for(b=this.morphTargets.length;a<b;a++){if(!this.morphNormals[a]){this.morphNormals[a]={};this.morphNormals[a].faceNormals=[];this.morphNormals[a].vertexNormals=[];e=this.morphNormals[a].faceNormals;\nvar g=this.morphNormals[a].vertexNormals,h,i;c=0;for(d=this.faces.length;c<d;c++)h=new THREE.Vector3,i={a:new THREE.Vector3,b:new THREE.Vector3,c:new THREE.Vector3},e.push(h),g.push(i)}g=this.morphNormals[a];f.vertices=this.morphTargets[a].vertices;f.computeFaceNormals();f.computeVertexNormals();c=0;for(d=this.faces.length;c<d;c++)e=this.faces[c],h=g.faceNormals[c],i=g.vertexNormals[c],h.copy(e.normal),i.a.copy(e.vertexNormals[0]),i.b.copy(e.vertexNormals[1]),i.c.copy(e.vertexNormals[2])}c=0;for(d=\nthis.faces.length;c<d;c++)e=this.faces[c],e.normal=e.__originalFaceNormal,e.vertexNormals=e.__originalVertexNormals},computeTangents:function(){var a,b,c,d,e,f,g,h,i,k,l,n,p,t,r,m,q,u=[],s=[];c=new THREE.Vector3;var v=new THREE.Vector3,z=new THREE.Vector3,G=new THREE.Vector3,N=new THREE.Vector3;a=0;for(b=this.vertices.length;a<b;a++)u[a]=new THREE.Vector3,s[a]=new THREE.Vector3;a=0;for(b=this.faces.length;a<b;a++)e=this.faces[a],f=this.faceVertexUvs[0][a],d=e.a,q=e.b,e=e.c,g=this.vertices[d],h=this.vertices[q],\ni=this.vertices[e],k=f[0],l=f[1],n=f[2],f=h.x-g.x,p=i.x-g.x,t=h.y-g.y,r=i.y-g.y,h=h.z-g.z,g=i.z-g.z,i=l.x-k.x,m=n.x-k.x,l=l.y-k.y,k=n.y-k.y,n=1/(i*k-m*l),c.set((k*f-l*p)*n,(k*t-l*r)*n,(k*h-l*g)*n),v.set((i*p-m*f)*n,(i*r-m*t)*n,(i*g-m*h)*n),u[d].add(c),u[q].add(c),u[e].add(c),s[d].add(v),s[q].add(v),s[e].add(v);v=[\"a\",\"b\",\"c\",\"d\"];a=0;for(b=this.faces.length;a<b;a++){e=this.faces[a];for(c=0;c<Math.min(e.vertexNormals.length,3);c++)N.copy(e.vertexNormals[c]),d=e[v[c]],q=u[d],z.copy(q),z.sub(N.multiplyScalar(N.dot(q))).normalize(),\nG.crossVectors(e.vertexNormals[c],q),d=G.dot(s[d]),d=0>d?-1:1,e.vertexTangents[c]=new THREE.Vector4(z.x,z.y,z.z,d)}this.hasTangents=!0},computeLineDistances:function(){for(var a=0,b=this.vertices,c=0,d=b.length;c<d;c++)0<c&&(a+=b[c].distanceTo(b[c-1])),this.lineDistances[c]=a},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new THREE.Box3);this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere);\nthis.boundingSphere.setFromPoints(this.vertices)},mergeVertices:function(){var a={},b=[],c=[],d,e=Math.pow(10,4),f,g;f=0;for(g=this.vertices.length;f<g;f++)d=this.vertices[f],d=Math.round(d.x*e)+\"_\"+Math.round(d.y*e)+\"_\"+Math.round(d.z*e),void 0===a[d]?(a[d]=f,b.push(this.vertices[f]),c[f]=b.length-1):c[f]=c[a[d]];a=[];f=0;for(g=this.faces.length;f<g;f++){e=this.faces[f];e.a=c[e.a];e.b=c[e.b];e.c=c[e.c];e=[e.a,e.b,e.c];for(d=0;3>d;d++)if(e[d]==e[(d+1)%3]){a.push(f);break}}for(f=a.length-1;0<=f;f--){e=\na[f];this.faces.splice(e,1);c=0;for(g=this.faceVertexUvs.length;c<g;c++)this.faceVertexUvs[c].splice(e,1)}f=this.vertices.length-b.length;this.vertices=b;return f},clone:function(){for(var a=new THREE.Geometry,b=this.vertices,c=0,d=b.length;c<d;c++)a.vertices.push(b[c].clone());b=this.faces;c=0;for(d=b.length;c<d;c++)a.faces.push(b[c].clone());b=this.faceVertexUvs[0];c=0;for(d=b.length;c<d;c++){for(var e=b[c],f=[],g=0,h=e.length;g<h;g++)f.push(new THREE.Vector2(e[g].x,e[g].y));a.faceVertexUvs[0].push(f)}return a},\ndispose:function(){this.dispatchEvent({type:\"dispose\"})}};THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);THREE.GeometryIdCount=0;THREE.BufferGeometry=function(){this.id=THREE.GeometryIdCount++;this.uuid=THREE.Math.generateUUID();this.name=\"\";this.attributes={};this.dynamic=!0;this.offsets=[];this.boundingSphere=this.boundingBox=null;this.hasTangents=!1;this.morphTargets=[]};\nTHREE.BufferGeometry.prototype={constructor:THREE.BufferGeometry,addAttribute:function(a,b,c,d){this.attributes[a]={itemSize:d,array:new b(c*d)}},applyMatrix:function(a){var b,c;this.attributes.position&&(b=this.attributes.position.array);this.attributes.normal&&(c=this.attributes.normal.array);void 0!==b&&(a.multiplyVector3Array(b),this.verticesNeedUpdate=!0);void 0!==c&&((new THREE.Matrix3).getNormalMatrix(a).multiplyVector3Array(c),this.normalizeNormals(),this.normalsNeedUpdate=!0)},computeBoundingBox:function(){null===\nthis.boundingBox&&(this.boundingBox=new THREE.Box3);var a=this.attributes.position.array;if(a){var b=this.boundingBox,c,d,e;3<=a.length&&(b.min.x=b.max.x=a[0],b.min.y=b.max.y=a[1],b.min.z=b.max.z=a[2]);for(var f=3,g=a.length;f<g;f+=3)c=a[f],d=a[f+1],e=a[f+2],c<b.min.x?b.min.x=c:c>b.max.x&&(b.max.x=c),d<b.min.y?b.min.y=d:d>b.max.y&&(b.max.y=d),e<b.min.z?b.min.z=e:e>b.max.z&&(b.max.z=e)}if(void 0===a||0===a.length)this.boundingBox.min.set(0,0,0),this.boundingBox.max.set(0,0,0)},computeBoundingSphere:function(){var a=\nnew THREE.Box3,b=new THREE.Vector3;return function(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere);var c=this.attributes.position.array;if(c){a.makeEmpty();for(var d=this.boundingSphere.center,e=0,f=c.length;e<f;e+=3)b.set(c[e],c[e+1],c[e+2]),a.addPoint(b);a.center(d);for(var g=0,e=0,f=c.length;e<f;e+=3)b.set(c[e],c[e+1],c[e+2]),g=Math.max(g,d.distanceToSquared(b));this.boundingSphere.radius=Math.sqrt(g)}}}(),computeVertexNormals:function(){if(this.attributes.position){var a,\nb,c,d;a=this.attributes.position.array.length;if(void 0===this.attributes.normal)this.attributes.normal={itemSize:3,array:new Float32Array(a)};else{a=0;for(b=this.attributes.normal.array.length;a<b;a++)this.attributes.normal.array[a]=0}var e=this.attributes.position.array,f=this.attributes.normal.array,g,h,i,k,l,n,p=new THREE.Vector3,t=new THREE.Vector3,r=new THREE.Vector3,m=new THREE.Vector3,q=new THREE.Vector3;if(this.attributes.index){var u=this.attributes.index.array,s=this.offsets;c=0;for(d=\ns.length;c<d;++c){b=s[c].start;g=s[c].count;var v=s[c].index;a=b;for(b+=g;a<b;a+=3)g=v+u[a],h=v+u[a+1],i=v+u[a+2],k=e[3*g],l=e[3*g+1],n=e[3*g+2],p.set(k,l,n),k=e[3*h],l=e[3*h+1],n=e[3*h+2],t.set(k,l,n),k=e[3*i],l=e[3*i+1],n=e[3*i+2],r.set(k,l,n),m.subVectors(r,t),q.subVectors(p,t),m.cross(q),f[3*g]+=m.x,f[3*g+1]+=m.y,f[3*g+2]+=m.z,f[3*h]+=m.x,f[3*h+1]+=m.y,f[3*h+2]+=m.z,f[3*i]+=m.x,f[3*i+1]+=m.y,f[3*i+2]+=m.z}}else{a=0;for(b=e.length;a<b;a+=9)k=e[a],l=e[a+1],n=e[a+2],p.set(k,l,n),k=e[a+3],l=e[a+4],\nn=e[a+5],t.set(k,l,n),k=e[a+6],l=e[a+7],n=e[a+8],r.set(k,l,n),m.subVectors(r,t),q.subVectors(p,t),m.cross(q),f[a]=m.x,f[a+1]=m.y,f[a+2]=m.z,f[a+3]=m.x,f[a+4]=m.y,f[a+5]=m.z,f[a+6]=m.x,f[a+7]=m.y,f[a+8]=m.z}this.normalizeNormals();this.normalsNeedUpdate=!0}},normalizeNormals:function(){for(var a=this.attributes.normal.array,b,c,d,e=0,f=a.length;e<f;e+=3)b=a[e],c=a[e+1],d=a[e+2],b=1/Math.sqrt(b*b+c*c+d*d),a[e]*=b,a[e+1]*=b,a[e+2]*=b},computeTangents:function(){function a(a){ha.x=d[3*a];ha.y=d[3*a+1];\nha.z=d[3*a+2];ua.copy(ha);T=h[a];A.copy(T);A.sub(ha.multiplyScalar(ha.dot(T))).normalize();da.crossVectors(ua,T);ea=da.dot(i[a]);O=0>ea?-1:1;g[4*a]=A.x;g[4*a+1]=A.y;g[4*a+2]=A.z;g[4*a+3]=O}if(void 0===this.attributes.index||void 0===this.attributes.position||void 0===this.attributes.normal||void 0===this.attributes.uv)console.warn(\"Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()\");else{var b=this.attributes.index.array,c=this.attributes.position.array,\nd=this.attributes.normal.array,e=this.attributes.uv.array,f=c.length/3;void 0===this.attributes.tangent&&(this.attributes.tangent={itemSize:4,array:new Float32Array(4*f)});for(var g=this.attributes.tangent.array,h=[],i=[],k=0;k<f;k++)h[k]=new THREE.Vector3,i[k]=new THREE.Vector3;var l,n,p,t,r,m,q,u,s,v,z,G,N,C,B,f=new THREE.Vector3,k=new THREE.Vector3,x,F,L,w,E,y,D,H=this.offsets;L=0;for(w=H.length;L<w;++L){F=H[L].start;E=H[L].count;var K=H[L].index;x=F;for(F+=E;x<F;x+=3)E=K+b[x],y=K+b[x+1],D=K+b[x+\n2],l=c[3*E],n=c[3*E+1],p=c[3*E+2],t=c[3*y],r=c[3*y+1],m=c[3*y+2],q=c[3*D],u=c[3*D+1],s=c[3*D+2],v=e[2*E],z=e[2*E+1],G=e[2*y],N=e[2*y+1],C=e[2*D],B=e[2*D+1],t-=l,l=q-l,r-=n,n=u-n,m-=p,p=s-p,G-=v,v=C-v,N-=z,z=B-z,B=1/(G*z-v*N),f.set((z*t-N*l)*B,(z*r-N*n)*B,(z*m-N*p)*B),k.set((G*l-v*t)*B,(G*n-v*r)*B,(G*p-v*m)*B),h[E].add(f),h[y].add(f),h[D].add(f),i[E].add(k),i[y].add(k),i[D].add(k)}var A=new THREE.Vector3,da=new THREE.Vector3,ha=new THREE.Vector3,ua=new THREE.Vector3,O,T,ea;L=0;for(w=H.length;L<w;++L){F=\nH[L].start;E=H[L].count;K=H[L].index;x=F;for(F+=E;x<F;x+=3)E=K+b[x],y=K+b[x+1],D=K+b[x+2],a(E),a(y),a(D)}this.tangentsNeedUpdate=this.hasTangents=!0}},clone:function(){var a=new THREE.BufferGeometry,b=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],c;for(c in this.attributes){for(var d=this.attributes[c],e=d.array,f={itemSize:d.itemSize,numItems:d.numItems,array:null},d=0,g=b.length;d<g;d++){var h=b[d];if(e instanceof h){f.array=new h(e);\nbreak}}a.attributes[c]=f}d=0;for(g=this.offsets.length;d<g;d++)b=this.offsets[d],a.offsets.push({start:b.start,index:b.index,count:b.count});return a},dispose:function(){this.dispatchEvent({type:\"dispose\"})}};THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);THREE.Camera=function(){THREE.Object3D.call(this);this.matrixWorldInverse=new THREE.Matrix4;this.projectionMatrix=new THREE.Matrix4};THREE.Camera.prototype=Object.create(THREE.Object3D.prototype);THREE.Camera.prototype.lookAt=function(){var a=new THREE.Matrix4;return function(b){a.lookAt(this.position,b,this.up);this.quaternion.setFromRotationMatrix(a)}}();\nTHREE.Camera.prototype.clone=function(a){void 0===a&&(a=new THREE.Camera);THREE.Object3D.prototype.clone.call(this,a);a.matrixWorldInverse.copy(this.matrixWorldInverse);a.projectionMatrix.copy(this.projectionMatrix);return a};THREE.OrthographicCamera=function(a,b,c,d,e,f){THREE.Camera.call(this);this.left=a;this.right=b;this.top=c;this.bottom=d;this.near=void 0!==e?e:0.1;this.far=void 0!==f?f:2E3;this.updateProjectionMatrix()};THREE.OrthographicCamera.prototype=Object.create(THREE.Camera.prototype);THREE.OrthographicCamera.prototype.updateProjectionMatrix=function(){this.projectionMatrix.makeOrthographic(this.left,this.right,this.top,this.bottom,this.near,this.far)};\nTHREE.OrthographicCamera.prototype.clone=function(){var a=new THREE.OrthographicCamera;THREE.Camera.prototype.clone.call(this,a);a.left=this.left;a.right=this.right;a.top=this.top;a.bottom=this.bottom;a.near=this.near;a.far=this.far;return a};THREE.PerspectiveCamera=function(a,b,c,d){THREE.Camera.call(this);this.fov=void 0!==a?a:50;this.aspect=void 0!==b?b:1;this.near=void 0!==c?c:0.1;this.far=void 0!==d?d:2E3;this.updateProjectionMatrix()};THREE.PerspectiveCamera.prototype=Object.create(THREE.Camera.prototype);THREE.PerspectiveCamera.prototype.setLens=function(a,b){void 0===b&&(b=24);this.fov=2*THREE.Math.radToDeg(Math.atan(b/(2*a)));this.updateProjectionMatrix()};\nTHREE.PerspectiveCamera.prototype.setViewOffset=function(a,b,c,d,e,f){this.fullWidth=a;this.fullHeight=b;this.x=c;this.y=d;this.width=e;this.height=f;this.updateProjectionMatrix()};\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix=function(){if(this.fullWidth){var a=this.fullWidth/this.fullHeight,b=Math.tan(THREE.Math.degToRad(0.5*this.fov))*this.near,c=-b,d=a*c,a=Math.abs(a*b-d),c=Math.abs(b-c);this.projectionMatrix.makeFrustum(d+this.x*a/this.fullWidth,d+(this.x+this.width)*a/this.fullWidth,b-(this.y+this.height)*c/this.fullHeight,b-this.y*c/this.fullHeight,this.near,this.far)}else this.projectionMatrix.makePerspective(this.fov,this.aspect,this.near,this.far)};\nTHREE.PerspectiveCamera.prototype.clone=function(){var a=new THREE.PerspectiveCamera;THREE.Camera.prototype.clone.call(this,a);a.fov=this.fov;a.aspect=this.aspect;a.near=this.near;a.far=this.far;return a};THREE.Light=function(a){THREE.Object3D.call(this);this.color=new THREE.Color(a)};THREE.Light.prototype=Object.create(THREE.Object3D.prototype);THREE.Light.prototype.clone=function(a){void 0===a&&(a=new THREE.Light);THREE.Object3D.prototype.clone.call(this,a);a.color.copy(this.color);return a};THREE.AmbientLight=function(a){THREE.Light.call(this,a)};THREE.AmbientLight.prototype=Object.create(THREE.Light.prototype);THREE.AmbientLight.prototype.clone=function(){var a=new THREE.AmbientLight;THREE.Light.prototype.clone.call(this,a);return a};THREE.AreaLight=function(a,b){THREE.Light.call(this,a);this.normal=new THREE.Vector3(0,-1,0);this.right=new THREE.Vector3(1,0,0);this.intensity=void 0!==b?b:1;this.height=this.width=1;this.constantAttenuation=1.5;this.linearAttenuation=0.5;this.quadraticAttenuation=0.1};THREE.AreaLight.prototype=Object.create(THREE.Light.prototype);THREE.DirectionalLight=function(a,b){THREE.Light.call(this,a);this.position.set(0,1,0);this.target=new THREE.Object3D;this.intensity=void 0!==b?b:1;this.onlyShadow=this.castShadow=!1;this.shadowCameraNear=50;this.shadowCameraFar=5E3;this.shadowCameraLeft=-500;this.shadowCameraTop=this.shadowCameraRight=500;this.shadowCameraBottom=-500;this.shadowCameraVisible=!1;this.shadowBias=0;this.shadowDarkness=0.5;this.shadowMapHeight=this.shadowMapWidth=512;this.shadowCascade=!1;this.shadowCascadeOffset=new THREE.Vector3(0,\n0,-1E3);this.shadowCascadeCount=2;this.shadowCascadeBias=[0,0,0];this.shadowCascadeWidth=[512,512,512];this.shadowCascadeHeight=[512,512,512];this.shadowCascadeNearZ=[-1,0.99,0.998];this.shadowCascadeFarZ=[0.99,0.998,1];this.shadowCascadeArray=[];this.shadowMatrix=this.shadowCamera=this.shadowMapSize=this.shadowMap=null};THREE.DirectionalLight.prototype=Object.create(THREE.Light.prototype);\nTHREE.DirectionalLight.prototype.clone=function(){var a=new THREE.DirectionalLight;THREE.Light.prototype.clone.call(this,a);a.target=this.target.clone();a.intensity=this.intensity;a.castShadow=this.castShadow;a.onlyShadow=this.onlyShadow;return a};THREE.HemisphereLight=function(a,b,c){THREE.Light.call(this,a);this.position.set(0,100,0);this.groundColor=new THREE.Color(b);this.intensity=void 0!==c?c:1};THREE.HemisphereLight.prototype=Object.create(THREE.Light.prototype);THREE.HemisphereLight.prototype.clone=function(){var a=new THREE.HemisphereLight;THREE.Light.prototype.clone.call(this,a);a.groundColor.copy(this.groundColor);a.intensity=this.intensity;return a};THREE.PointLight=function(a,b,c){THREE.Light.call(this,a);this.intensity=void 0!==b?b:1;this.distance=void 0!==c?c:0};THREE.PointLight.prototype=Object.create(THREE.Light.prototype);THREE.PointLight.prototype.clone=function(){var a=new THREE.PointLight;THREE.Light.prototype.clone.call(this,a);a.intensity=this.intensity;a.distance=this.distance;return a};THREE.SpotLight=function(a,b,c,d,e){THREE.Light.call(this,a);this.position.set(0,1,0);this.target=new THREE.Object3D;this.intensity=void 0!==b?b:1;this.distance=void 0!==c?c:0;this.angle=void 0!==d?d:Math.PI/3;this.exponent=void 0!==e?e:10;this.onlyShadow=this.castShadow=!1;this.shadowCameraNear=50;this.shadowCameraFar=5E3;this.shadowCameraFov=50;this.shadowCameraVisible=!1;this.shadowBias=0;this.shadowDarkness=0.5;this.shadowMapHeight=this.shadowMapWidth=512;this.shadowMatrix=this.shadowCamera=this.shadowMapSize=\nthis.shadowMap=null};THREE.SpotLight.prototype=Object.create(THREE.Light.prototype);THREE.SpotLight.prototype.clone=function(){var a=new THREE.SpotLight;THREE.Light.prototype.clone.call(this,a);a.target=this.target.clone();a.intensity=this.intensity;a.distance=this.distance;a.angle=this.angle;a.exponent=this.exponent;a.castShadow=this.castShadow;a.onlyShadow=this.onlyShadow;return a};THREE.Loader=function(a){this.statusDomElement=(this.showStatus=a)?THREE.Loader.prototype.addStatusElement():null;this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){}};\nTHREE.Loader.prototype={constructor:THREE.Loader,crossOrigin:void 0,addStatusElement:function(){var a=document.createElement(\"div\");a.style.position=\"absolute\";a.style.right=\"0px\";a.style.top=\"0px\";a.style.fontSize=\"0.8em\";a.style.textAlign=\"left\";a.style.background=\"rgba(0,0,0,0.25)\";a.style.color=\"#fff\";a.style.width=\"120px\";a.style.padding=\"0.5em 0.5em 0.5em 0.5em\";a.style.zIndex=1E3;a.innerHTML=\"Loading ...\";return a},updateProgress:function(a){var b=\"Loaded \",b=a.total?b+((100*a.loaded/a.total).toFixed(0)+\n\"%\"):b+((a.loaded/1E3).toFixed(2)+\" KB\");this.statusDomElement.innerHTML=b},extractUrlBase:function(a){a=a.split(\"/\");a.pop();return(1>a.length?\".\":a.join(\"/\"))+\"/\"},initMaterials:function(a,b){for(var c=[],d=0;d<a.length;++d)c[d]=THREE.Loader.prototype.createMaterial(a[d],b);return c},needsTangents:function(a){for(var b=0,c=a.length;b<c;b++)if(a[b]instanceof THREE.ShaderMaterial)return!0;return!1},createMaterial:function(a,b){function c(a){a=Math.log(a)/Math.LN2;return Math.floor(a)==a}function d(a){a=\nMath.log(a)/Math.LN2;return Math.pow(2,Math.round(a))}function e(a,e,f,h,i,k,q){var u=/\\.dds$/i.test(f),s=b+\"/\"+f;if(u){var v=THREE.ImageUtils.loadCompressedTexture(s);a[e]=v}else v=document.createElement(\"canvas\"),a[e]=new THREE.Texture(v);a[e].sourceFile=f;h&&(a[e].repeat.set(h[0],h[1]),1!==h[0]&&(a[e].wrapS=THREE.RepeatWrapping),1!==h[1]&&(a[e].wrapT=THREE.RepeatWrapping));i&&a[e].offset.set(i[0],i[1]);k&&(f={repeat:THREE.RepeatWrapping,mirror:THREE.MirroredRepeatWrapping},void 0!==f[k[0]]&&(a[e].wrapS=\nf[k[0]]),void 0!==f[k[1]]&&(a[e].wrapT=f[k[1]]));q&&(a[e].anisotropy=q);if(!u){var z=a[e],a=new Image;a.onload=function(){if(!c(this.width)||!c(this.height)){var a=d(this.width),b=d(this.height);z.image.width=a;z.image.height=b;z.image.getContext(\"2d\").drawImage(this,0,0,a,b)}else z.image=this;z.needsUpdate=!0};void 0!==g.crossOrigin&&(a.crossOrigin=g.crossOrigin);a.src=s}}function f(a){return(255*a[0]<<16)+(255*a[1]<<8)+255*a[2]}var g=this,h=\"MeshLambertMaterial\",i={color:15658734,opacity:1,map:null,\nlightMap:null,normalMap:null,bumpMap:null,wireframe:!1};if(a.shading){var k=a.shading.toLowerCase();\"phong\"===k?h=\"MeshPhongMaterial\":\"basic\"===k&&(h=\"MeshBasicMaterial\")}void 0!==a.blending&&void 0!==THREE[a.blending]&&(i.blending=THREE[a.blending]);if(void 0!==a.transparent||1>a.opacity)i.transparent=a.transparent;void 0!==a.depthTest&&(i.depthTest=a.depthTest);void 0!==a.depthWrite&&(i.depthWrite=a.depthWrite);void 0!==a.visible&&(i.visible=a.visible);void 0!==a.flipSided&&(i.side=THREE.BackSide);\nvoid 0!==a.doubleSided&&(i.side=THREE.DoubleSide);void 0!==a.wireframe&&(i.wireframe=a.wireframe);void 0!==a.vertexColors&&(\"face\"===a.vertexColors?i.vertexColors=THREE.FaceColors:a.vertexColors&&(i.vertexColors=THREE.VertexColors));a.colorDiffuse?i.color=f(a.colorDiffuse):a.DbgColor&&(i.color=a.DbgColor);a.colorSpecular&&(i.specular=f(a.colorSpecular));a.colorAmbient&&(i.ambient=f(a.colorAmbient));a.transparency&&(i.opacity=a.transparency);a.specularCoef&&(i.shininess=a.specularCoef);a.mapDiffuse&&\nb&&e(i,\"map\",a.mapDiffuse,a.mapDiffuseRepeat,a.mapDiffuseOffset,a.mapDiffuseWrap,a.mapDiffuseAnisotropy);a.mapLight&&b&&e(i,\"lightMap\",a.mapLight,a.mapLightRepeat,a.mapLightOffset,a.mapLightWrap,a.mapLightAnisotropy);a.mapBump&&b&&e(i,\"bumpMap\",a.mapBump,a.mapBumpRepeat,a.mapBumpOffset,a.mapBumpWrap,a.mapBumpAnisotropy);a.mapNormal&&b&&e(i,\"normalMap\",a.mapNormal,a.mapNormalRepeat,a.mapNormalOffset,a.mapNormalWrap,a.mapNormalAnisotropy);a.mapSpecular&&b&&e(i,\"specularMap\",a.mapSpecular,a.mapSpecularRepeat,\na.mapSpecularOffset,a.mapSpecularWrap,a.mapSpecularAnisotropy);a.mapBumpScale&&(i.bumpScale=a.mapBumpScale);a.mapNormal?(h=THREE.ShaderLib.normalmap,k=THREE.UniformsUtils.clone(h.uniforms),k.tNormal.value=i.normalMap,a.mapNormalFactor&&k.uNormalScale.value.set(a.mapNormalFactor,a.mapNormalFactor),i.map&&(k.tDiffuse.value=i.map,k.enableDiffuse.value=!0),i.specularMap&&(k.tSpecular.value=i.specularMap,k.enableSpecular.value=!0),i.lightMap&&(k.tAO.value=i.lightMap,k.enableAO.value=!0),k.diffuse.value.setHex(i.color),\nk.specular.value.setHex(i.specular),k.ambient.value.setHex(i.ambient),k.shininess.value=i.shininess,void 0!==i.opacity&&(k.opacity.value=i.opacity),h=new THREE.ShaderMaterial({fragmentShader:h.fragmentShader,vertexShader:h.vertexShader,uniforms:k,lights:!0,fog:!0}),i.transparent&&(h.transparent=!0)):h=new THREE[h](i);void 0!==a.DbgName&&(h.name=a.DbgName);return h}};THREE.XHRLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};\nTHREE.XHRLoader.prototype={constructor:THREE.XHRLoader,load:function(a,b,c,d){var e=this,f=new XMLHttpRequest;void 0!==b&&f.addEventListener(\"load\",function(c){b(c.target.responseText);e.manager.itemEnd(a)},!1);void 0!==c&&f.addEventListener(\"progress\",function(a){c(a)},!1);void 0!==d&&f.addEventListener(\"error\",function(a){d(a)},!1);void 0!==this.crossOrigin&&(f.crossOrigin=this.crossOrigin);f.open(\"GET\",a,!0);f.send(null);e.manager.itemStart(a)},setCrossOrigin:function(a){this.crossOrigin=a}};THREE.ImageLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};\nTHREE.ImageLoader.prototype={constructor:THREE.ImageLoader,load:function(a,b,c,d){var e=this,f=document.createElement(\"img\");void 0!==b&&f.addEventListener(\"load\",function(){e.manager.itemEnd(a);b(this)},!1);void 0!==c&&f.addEventListener(\"progress\",function(a){c(a)},!1);void 0!==d&&f.addEventListener(\"error\",function(a){d(a)},!1);void 0!==this.crossOrigin&&(f.crossOrigin=this.crossOrigin);f.src=a;e.manager.itemStart(a);return f},setCrossOrigin:function(a){this.crossOrigin=a}};THREE.JSONLoader=function(a){THREE.Loader.call(this,a);this.withCredentials=!1};THREE.JSONLoader.prototype=Object.create(THREE.Loader.prototype);THREE.JSONLoader.prototype.load=function(a,b,c){c=c&&\"string\"===typeof c?c:this.extractUrlBase(a);this.onLoadStart();this.loadAjaxJSON(this,a,b,c)};\nTHREE.JSONLoader.prototype.loadAjaxJSON=function(a,b,c,d,e){var f=new XMLHttpRequest,g=0;f.onreadystatechange=function(){if(f.readyState===f.DONE)if(200===f.status||0===f.status){if(f.responseText){var h=JSON.parse(f.responseText),h=a.parse(h,d);c(h.geometry,h.materials)}else console.warn(\"THREE.JSONLoader: [\"+b+\"] seems to be unreachable or file there is empty\");a.onLoadComplete()}else console.error(\"THREE.JSONLoader: Couldn't load [\"+b+\"] [\"+f.status+\"]\");else f.readyState===f.LOADING?e&&(0===g&&\n(g=f.getResponseHeader(\"Content-Length\")),e({total:g,loaded:f.responseText.length})):f.readyState===f.HEADERS_RECEIVED&&void 0!==e&&(g=f.getResponseHeader(\"Content-Length\"))};f.open(\"GET\",b,!0);f.withCredentials=this.withCredentials;f.send(null)};\nTHREE.JSONLoader.prototype.parse=function(a,b){var c=new THREE.Geometry,d=void 0!==a.scale?1/a.scale:1,e,f,g,h,i,k,l,n,p,t,r,m,q,u,s=a.faces;p=a.vertices;var v=a.normals,z=a.colors,G=0;if(void 0!==a.uvs){for(e=0;e<a.uvs.length;e++)a.uvs[e].length&&G++;for(e=0;e<G;e++)c.faceVertexUvs[e]=[]}h=0;for(i=p.length;h<i;)k=new THREE.Vector3,k.x=p[h++]*d,k.y=p[h++]*d,k.z=p[h++]*d,c.vertices.push(k);h=0;for(i=s.length;h<i;)if(p=s[h++],t=p&1,g=p&2,e=p&8,l=p&16,r=p&32,k=p&64,p&=128,t){t=new THREE.Face3;t.a=s[h];\nt.b=s[h+1];t.c=s[h+3];m=new THREE.Face3;m.a=s[h+1];m.b=s[h+2];m.c=s[h+3];h+=4;g&&(g=s[h++],t.materialIndex=g,m.materialIndex=g);g=c.faces.length;if(e)for(e=0;e<G;e++){q=a.uvs[e];c.faceVertexUvs[e][g]=[];c.faceVertexUvs[e][g+1]=[];for(f=0;4>f;f++)n=s[h++],u=q[2*n],n=q[2*n+1],u=new THREE.Vector2(u,n),2!==f&&c.faceVertexUvs[e][g].push(u),0!==f&&c.faceVertexUvs[e][g+1].push(u)}l&&(l=3*s[h++],t.normal.set(v[l++],v[l++],v[l]),m.normal.copy(t.normal));if(r)for(e=0;4>e;e++)l=3*s[h++],r=new THREE.Vector3(v[l++],\nv[l++],v[l]),2!==e&&t.vertexNormals.push(r),0!==e&&m.vertexNormals.push(r);k&&(k=s[h++],k=z[k],t.color.setHex(k),m.color.setHex(k));if(p)for(e=0;4>e;e++)k=s[h++],k=z[k],2!==e&&t.vertexColors.push(new THREE.Color(k)),0!==e&&m.vertexColors.push(new THREE.Color(k));c.faces.push(t);c.faces.push(m)}else{t=new THREE.Face3;t.a=s[h++];t.b=s[h++];t.c=s[h++];g&&(g=s[h++],t.materialIndex=g);g=c.faces.length;if(e)for(e=0;e<G;e++){q=a.uvs[e];c.faceVertexUvs[e][g]=[];for(f=0;3>f;f++)n=s[h++],u=q[2*n],n=q[2*n+1],\nu=new THREE.Vector2(u,n),c.faceVertexUvs[e][g].push(u)}l&&(l=3*s[h++],t.normal.set(v[l++],v[l++],v[l]));if(r)for(e=0;3>e;e++)l=3*s[h++],r=new THREE.Vector3(v[l++],v[l++],v[l]),t.vertexNormals.push(r);k&&(k=s[h++],t.color.setHex(z[k]));if(p)for(e=0;3>e;e++)k=s[h++],t.vertexColors.push(new THREE.Color(z[k]));c.faces.push(t)}if(a.skinWeights){h=0;for(i=a.skinWeights.length;h<i;h+=2)s=a.skinWeights[h],v=a.skinWeights[h+1],c.skinWeights.push(new THREE.Vector4(s,v,0,0))}if(a.skinIndices){h=0;for(i=a.skinIndices.length;h<\ni;h+=2)s=a.skinIndices[h],v=a.skinIndices[h+1],c.skinIndices.push(new THREE.Vector4(s,v,0,0))}c.bones=a.bones;c.animation=a.animation;c.animations=a.animations;if(void 0!==a.morphTargets){h=0;for(i=a.morphTargets.length;h<i;h++){c.morphTargets[h]={};c.morphTargets[h].name=a.morphTargets[h].name;c.morphTargets[h].vertices=[];z=c.morphTargets[h].vertices;G=a.morphTargets[h].vertices;s=0;for(v=G.length;s<v;s+=3)p=new THREE.Vector3,p.x=G[s]*d,p.y=G[s+1]*d,p.z=G[s+2]*d,z.push(p)}}if(void 0!==a.morphColors){h=\n0;for(i=a.morphColors.length;h<i;h++){c.morphColors[h]={};c.morphColors[h].name=a.morphColors[h].name;c.morphColors[h].colors=[];v=c.morphColors[h].colors;z=a.morphColors[h].colors;d=0;for(s=z.length;d<s;d+=3)G=new THREE.Color(16755200),G.setRGB(z[d],z[d+1],z[d+2]),v.push(G)}}c.computeCentroids();c.computeFaceNormals();c.computeBoundingSphere();if(void 0===a.materials)return{geometry:c};d=this.initMaterials(a.materials,b);this.needsTangents(d)&&c.computeTangents();return{geometry:c,materials:d}};THREE.LoadingManager=function(a,b,c){var d=this,e=0,f=0;this.onLoad=a;this.onProgress=b;this.onError=c;this.itemStart=function(){f++};this.itemEnd=function(a){e++;if(void 0!==d.onProgress)d.onProgress(a,e,f);if(e===f&&void 0!==d.onLoad)d.onLoad()}};THREE.DefaultLoadingManager=new THREE.LoadingManager;THREE.BufferGeometryLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};\nTHREE.BufferGeometryLoader.prototype={constructor:THREE.BufferGeometryLoader,load:function(a,b){var c=this,d=new THREE.XHRLoader;d.setCrossOrigin(this.crossOrigin);d.load(a,function(a){b(c.parse(JSON.parse(a)))})},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a){var b=new THREE.BufferGeometry,c=a.attributes,d=a.offsets,a=a.boundingSphere,e;for(e in c){var f=c[e];b.attributes[e]={itemSize:f.itemSize,array:new self[f.type](f.array)}}void 0!==d&&(b.offsets=JSON.parse(JSON.stringify(d)));\nvoid 0!==a&&(b.boundingSphere=new THREE.Sphere((new THREE.Vector3).fromArray(void 0!==a.center?a.center:[0,0,0]),a.radius));return b}};THREE.GeometryLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};THREE.GeometryLoader.prototype={constructor:THREE.GeometryLoader,load:function(a,b){var c=this,d=new THREE.XHRLoader;d.setCrossOrigin(this.crossOrigin);d.load(a,function(a){b(c.parse(JSON.parse(a)))})},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(){}};THREE.MaterialLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};\nTHREE.MaterialLoader.prototype={constructor:THREE.MaterialLoader,load:function(a,b){var c=this,d=new THREE.XHRLoader;d.setCrossOrigin(this.crossOrigin);d.load(a,function(a){b(c.parse(JSON.parse(a)))})},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a){var b=new THREE[a.type];void 0!==a.color&&b.color.setHex(a.color);void 0!==a.ambient&&b.ambient.setHex(a.ambient);void 0!==a.emissive&&b.emissive.setHex(a.emissive);void 0!==a.specular&&b.specular.setHex(a.specular);void 0!==a.shininess&&\n(b.shininess=a.shininess);void 0!==a.vertexColors&&(b.vertexColors=a.vertexColors);void 0!==a.blending&&(b.blending=a.blending);void 0!==a.side&&(b.side=a.side);void 0!==a.opacity&&(b.opacity=a.opacity);void 0!==a.transparent&&(b.transparent=a.transparent);void 0!==a.wireframe&&(b.wireframe=a.wireframe);if(void 0!==a.materials)for(var c=0,d=a.materials.length;c<d;c++)b.materials.push(this.parse(a.materials[c]));return b}};THREE.ObjectLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};\nTHREE.ObjectLoader.prototype={constructor:THREE.ObjectLoader,load:function(a,b){var c=this,d=new THREE.XHRLoader(c.manager);d.setCrossOrigin(this.crossOrigin);d.load(a,function(a){b(c.parse(JSON.parse(a)))})},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a){var b=this.parseGeometries(a.geometries),c=this.parseMaterials(a.materials);return this.parseObject(a.object,b,c)},parseGeometries:function(a){var b={};if(void 0!==a)for(var c=new THREE.JSONLoader,d=new THREE.BufferGeometryLoader,\ne=0,f=a.length;e<f;e++){var g,h=a[e];switch(h.type){case \"PlaneGeometry\":g=new THREE.PlaneGeometry(h.width,h.height,h.widthSegments,h.heightSegments);break;case \"CircleGeometry\":g=new THREE.CircleGeometry(h.radius,h.segments);break;case \"CubeGeometry\":g=new THREE.CubeGeometry(h.width,h.height,h.depth,h.widthSegments,h.heightSegments,h.depthSegments);break;case \"CylinderGeometry\":g=new THREE.CylinderGeometry(h.radiusTop,h.radiusBottom,h.height,h.radialSegments,h.heightSegments,h.openEnded);break;case \"SphereGeometry\":g=\nnew THREE.SphereGeometry(h.radius,h.widthSegments,h.heightSegments,h.phiStart,h.phiLength,h.thetaStart,h.thetaLength);break;case \"IcosahedronGeometry\":g=new THREE.IcosahedronGeometry(h.radius,h.detail);break;case \"TorusGeometry\":g=new THREE.TorusGeometry(h.radius,h.tube,h.radialSegments,h.tubularSegments,h.arc);break;case \"TorusKnotGeometry\":g=new THREE.TorusKnotGeometry(h.radius,h.tube,h.radialSegments,h.tubularSegments,h.p,h.q,h.heightScale);break;case \"BufferGeometry\":g=d.parse(h.data);break;case \"Geometry\":g=\nc.parse(h.data).geometry}g.uuid=h.uuid;void 0!==h.name&&(g.name=h.name);b[h.uuid]=g}return b},parseMaterials:function(a){var b={};if(void 0!==a)for(var c=new THREE.MaterialLoader,d=0,e=a.length;d<e;d++){var f=a[d],g=c.parse(f);g.uuid=f.uuid;void 0!==f.name&&(g.name=f.name);b[f.uuid]=g}return b},parseObject:function(){var a=new THREE.Matrix4;return function(b,c,d){var e;switch(b.type){case \"Scene\":e=new THREE.Scene;break;case \"PerspectiveCamera\":e=new THREE.PerspectiveCamera(b.fov,b.aspect,b.near,\nb.far);break;case \"OrthographicCamera\":e=new THREE.OrthographicCamera(b.left,b.right,b.top,b.bottom,b.near,b.far);break;case \"AmbientLight\":e=new THREE.AmbientLight(b.color);break;case \"DirectionalLight\":e=new THREE.DirectionalLight(b.color,b.intensity);break;case \"PointLight\":e=new THREE.PointLight(b.color,b.intensity,b.distance);break;case \"SpotLight\":e=new THREE.SpotLight(b.color,b.intensity,b.distance,b.angle,b.exponent);break;case \"HemisphereLight\":e=new THREE.HemisphereLight(b.color,b.groundColor,\nb.intensity);break;case \"Mesh\":e=c[b.geometry];var f=d[b.material];void 0===e&&console.error(\"THREE.ObjectLoader: Undefined geometry \"+b.geometry);void 0===f&&console.error(\"THREE.ObjectLoader: Undefined material \"+b.material);e=new THREE.Mesh(e,f);break;case \"Sprite\":f=d[b.material];void 0===f&&console.error(\"THREE.ObjectLoader: Undefined material \"+b.material);e=new THREE.Sprite(f);break;default:e=new THREE.Object3D}e.uuid=b.uuid;void 0!==b.name&&(e.name=b.name);void 0!==b.matrix?(a.fromArray(b.matrix),\na.decompose(e.position,e.quaternion,e.scale)):(void 0!==b.position&&e.position.fromArray(b.position),void 0!==b.rotation&&e.rotation.fromArray(b.rotation),void 0!==b.scale&&e.scale.fromArray(b.scale));void 0!==b.visible&&(e.visible=b.visible);void 0!==b.userData&&(e.userData=b.userData);if(void 0!==b.children)for(var g in b.children)e.add(this.parseObject(b.children[g],c,d));return e}}()};THREE.SceneLoader=function(){this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){};this.callbackSync=function(){};this.callbackProgress=function(){};this.geometryHandlers={};this.hierarchyHandlers={};this.addGeometryHandler(\"ascii\",THREE.JSONLoader)};\nTHREE.SceneLoader.prototype={constructor:THREE.SceneLoader,load:function(a,b){var c=this,d=new THREE.XHRLoader(c.manager);d.setCrossOrigin(this.crossOrigin);d.load(a,function(d){c.parse(JSON.parse(d),b,a)})},setCrossOrigin:function(a){this.crossOrigin=a},addGeometryHandler:function(a,b){this.geometryHandlers[a]={loaderClass:b}},addHierarchyHandler:function(a,b){this.hierarchyHandlers[a]={loaderClass:b}},parse:function(a,b,c){function d(a,b){return\"relativeToHTML\"==b?a:p+\"/\"+a}function e(){f(C.scene,\nx.objects)}function f(a,b){var c,e,g,i,k,l;for(l in b){var p=C.objects[l],q=b[l];if(void 0===p){if(q.type&&q.type in n.hierarchyHandlers){if(void 0===q.loading){c={type:1,url:1,material:1,position:1,rotation:1,scale:1,visible:1,children:1,userData:1,skin:1,morph:1,mirroredLoop:1,duration:1};var u={},v;for(v in q)v in c||(u[v]=q[v]);r=C.materials[q.material];q.loading=!0;c=n.hierarchyHandlers[q.type].loaderObject;c.options?c.load(d(q.url,x.urlBaseType),h(l,a,r,q)):c.load(d(q.url,x.urlBaseType),h(l,\na,r,q),u)}}else if(void 0!==q.geometry){if(t=C.geometries[q.geometry]){p=!1;r=C.materials[q.material];p=r instanceof THREE.ShaderMaterial;e=q.position;g=q.rotation;i=q.scale;c=q.matrix;k=q.quaternion;q.material||(r=new THREE.MeshFaceMaterial(C.face_materials[q.geometry]));r instanceof THREE.MeshFaceMaterial&&0===r.materials.length&&(r=new THREE.MeshFaceMaterial(C.face_materials[q.geometry]));if(r instanceof THREE.MeshFaceMaterial)for(u=0;u<r.materials.length;u++)p=p||r.materials[u]instanceof THREE.ShaderMaterial;\np&&t.computeTangents();q.skin?p=new THREE.SkinnedMesh(t,r):q.morph?(p=new THREE.MorphAnimMesh(t,r),void 0!==q.duration&&(p.duration=q.duration),void 0!==q.time&&(p.time=q.time),void 0!==q.mirroredLoop&&(p.mirroredLoop=q.mirroredLoop),r.morphNormals&&t.computeMorphNormals()):p=new THREE.Mesh(t,r);p.name=l;c?(p.matrixAutoUpdate=!1,p.matrix.set(c[0],c[1],c[2],c[3],c[4],c[5],c[6],c[7],c[8],c[9],c[10],c[11],c[12],c[13],c[14],c[15])):(p.position.fromArray(e),k?p.quaternion.fromArray(k):p.rotation.fromArray(g),\np.scale.fromArray(i));p.visible=q.visible;p.castShadow=q.castShadow;p.receiveShadow=q.receiveShadow;a.add(p);C.objects[l]=p}}else if(\"AmbientLight\"===q.type||\"PointLight\"===q.type||\"DirectionalLight\"===q.type||\"SpotLight\"===q.type||\"HemisphereLight\"===q.type||\"AreaLight\"===q.type){u=q.color;c=q.intensity;e=q.distance;g=q.position;i=q.rotation;switch(q.type){case \"AmbientLight\":s=new THREE.AmbientLight(u);break;case \"PointLight\":s=new THREE.PointLight(u,c,e);s.position.fromArray(g);break;case \"DirectionalLight\":s=\nnew THREE.DirectionalLight(u,c);s.position.fromArray(q.direction);break;case \"SpotLight\":s=new THREE.SpotLight(u,c,e,1);s.angle=q.angle;s.position.fromArray(g);s.target.set(g[0],g[1]-e,g[2]);s.target.applyEuler(new THREE.Euler(i[0],i[1],i[2],\"XYZ\"));break;case \"HemisphereLight\":s=new THREE.DirectionalLight(u,c,e);s.target.set(g[0],g[1]-e,g[2]);s.target.applyEuler(new THREE.Euler(i[0],i[1],i[2],\"XYZ\"));break;case \"AreaLight\":s=new THREE.AreaLight(u,c),s.position.fromArray(g),s.width=q.size,s.height=\nq.size_y}a.add(s);s.name=l;C.lights[l]=s;C.objects[l]=s}else\"PerspectiveCamera\"===q.type||\"OrthographicCamera\"===q.type?(e=q.position,g=q.rotation,k=q.quaternion,\"PerspectiveCamera\"===q.type?m=new THREE.PerspectiveCamera(q.fov,q.aspect,q.near,q.far):\"OrthographicCamera\"===q.type&&(m=new THREE.OrthographicCamera(q.left,q.right,q.top,q.bottom,q.near,q.far)),m.name=l,m.position.fromArray(e),void 0!==k?m.quaternion.fromArray(k):void 0!==g&&m.rotation.fromArray(g),a.add(m),C.cameras[l]=m,C.objects[l]=\nm):(e=q.position,g=q.rotation,i=q.scale,k=q.quaternion,p=new THREE.Object3D,p.name=l,p.position.fromArray(e),k?p.quaternion.fromArray(k):p.rotation.fromArray(g),p.scale.fromArray(i),p.visible=void 0!==q.visible?q.visible:!1,a.add(p),C.objects[l]=p,C.empties[l]=p);if(p){if(void 0!==q.userData)for(var z in q.userData)p.userData[z]=q.userData[z];if(void 0!==q.groups)for(u=0;u<q.groups.length;u++)c=q.groups[u],void 0===C.groups[c]&&(C.groups[c]=[]),C.groups[c].push(l)}}void 0!==p&&void 0!==q.children&&\nf(p,q.children)}}function g(a){return function(b,c){b.name=a;C.geometries[a]=b;C.face_materials[a]=c;e();v-=1;n.onLoadComplete();k()}}function h(a,b,c,d){return function(f){var f=f.content?f.content:f.dae?f.scene:f,g=d.rotation,h=d.quaternion,i=d.scale;f.position.fromArray(d.position);h?f.quaternion.fromArray(h):f.rotation.fromArray(g);f.scale.fromArray(i);c&&f.traverse(function(a){a.material=c});var l=void 0!==d.visible?d.visible:!0;f.traverse(function(a){a.visible=l});b.add(f);f.name=a;C.objects[a]=\nf;e();v-=1;n.onLoadComplete();k()}}function i(a){return function(b,c){b.name=a;C.geometries[a]=b;C.face_materials[a]=c}}function k(){n.callbackProgress({totalModels:G,totalTextures:N,loadedModels:G-v,loadedTextures:N-z},C);n.onLoadProgress();if(0===v&&0===z){for(var a=0;a<B.length;a++){var c=B[a],d=C.objects[c.targetName];d?c.object.target=d:(c.object.target=new THREE.Object3D,C.scene.add(c.object.target));c.object.target.userData.targetInverse=c.object}b(C)}}function l(a,b){b(a);if(void 0!==a.children)for(var c in a.children)l(a.children[c],\nb)}var n=this,p=THREE.Loader.prototype.extractUrlBase(c),t,r,m,q,u,s,v,z,G,N,C,B=[],x=a,F;for(F in this.geometryHandlers)a=this.geometryHandlers[F].loaderClass,this.geometryHandlers[F].loaderObject=new a;for(F in this.hierarchyHandlers)a=this.hierarchyHandlers[F].loaderClass,this.hierarchyHandlers[F].loaderObject=new a;z=v=0;C={scene:new THREE.Scene,geometries:{},face_materials:{},materials:{},textures:{},objects:{},cameras:{},lights:{},fogs:{},empties:{},groups:{}};if(x.transform&&(F=x.transform.position,\na=x.transform.rotation,c=x.transform.scale,F&&C.scene.position.fromArray(F),a&&C.scene.rotation.fromArray(a),c&&C.scene.scale.fromArray(c),F||a||c))C.scene.updateMatrix(),C.scene.updateMatrixWorld();F=function(a){return function(){z-=a;k();n.onLoadComplete()}};for(var L in x.fogs)a=x.fogs[L],\"linear\"===a.type?q=new THREE.Fog(0,a.near,a.far):\"exp2\"===a.type&&(q=new THREE.FogExp2(0,a.density)),a=a.color,q.color.setRGB(a[0],a[1],a[2]),C.fogs[L]=q;for(var w in x.geometries)q=x.geometries[w],q.type in\nthis.geometryHandlers&&(v+=1,n.onLoadStart());for(var E in x.objects)l(x.objects[E],function(a){a.type&&a.type in n.hierarchyHandlers&&(v+=1,n.onLoadStart())});G=v;for(w in x.geometries)if(q=x.geometries[w],\"cube\"===q.type)t=new THREE.CubeGeometry(q.width,q.height,q.depth,q.widthSegments,q.heightSegments,q.depthSegments),t.name=w,C.geometries[w]=t;else if(\"plane\"===q.type)t=new THREE.PlaneGeometry(q.width,q.height,q.widthSegments,q.heightSegments),t.name=w,C.geometries[w]=t;else if(\"sphere\"===q.type)t=\nnew THREE.SphereGeometry(q.radius,q.widthSegments,q.heightSegments),t.name=w,C.geometries[w]=t;else if(\"cylinder\"===q.type)t=new THREE.CylinderGeometry(q.topRad,q.botRad,q.height,q.radSegs,q.heightSegs),t.name=w,C.geometries[w]=t;else if(\"torus\"===q.type)t=new THREE.TorusGeometry(q.radius,q.tube,q.segmentsR,q.segmentsT),t.name=w,C.geometries[w]=t;else if(\"icosahedron\"===q.type)t=new THREE.IcosahedronGeometry(q.radius,q.subdivisions),t.name=w,C.geometries[w]=t;else if(q.type in this.geometryHandlers){E=\n{};for(u in q)\"type\"!==u&&\"url\"!==u&&(E[u]=q[u]);this.geometryHandlers[q.type].loaderObject.load(d(q.url,x.urlBaseType),g(w),E)}else\"embedded\"===q.type&&(E=x.embeds[q.id],E.metadata=x.metadata,E&&(E=this.geometryHandlers.ascii.loaderObject.parse(E,\"\"),i(w)(E.geometry,E.materials)));for(var y in x.textures)if(w=x.textures[y],w.url instanceof Array){z+=w.url.length;for(u=0;u<w.url.length;u++)n.onLoadStart()}else z+=1,n.onLoadStart();N=z;for(y in x.textures){w=x.textures[y];void 0!==w.mapping&&void 0!==\nTHREE[w.mapping]&&(w.mapping=new THREE[w.mapping]);if(w.url instanceof Array){E=w.url.length;q=[];for(u=0;u<E;u++)q[u]=d(w.url[u],x.urlBaseType);u=(u=/\\.dds$/i.test(q[0]))?THREE.ImageUtils.loadCompressedTextureCube(q,w.mapping,F(E)):THREE.ImageUtils.loadTextureCube(q,w.mapping,F(E))}else u=/\\.dds$/i.test(w.url),E=d(w.url,x.urlBaseType),q=F(1),u=u?THREE.ImageUtils.loadCompressedTexture(E,w.mapping,q):THREE.ImageUtils.loadTexture(E,w.mapping,q),void 0!==THREE[w.minFilter]&&(u.minFilter=THREE[w.minFilter]),\nvoid 0!==THREE[w.magFilter]&&(u.magFilter=THREE[w.magFilter]),w.anisotropy&&(u.anisotropy=w.anisotropy),w.repeat&&(u.repeat.set(w.repeat[0],w.repeat[1]),1!==w.repeat[0]&&(u.wrapS=THREE.RepeatWrapping),1!==w.repeat[1]&&(u.wrapT=THREE.RepeatWrapping)),w.offset&&u.offset.set(w.offset[0],w.offset[1]),w.wrap&&(E={repeat:THREE.RepeatWrapping,mirror:THREE.MirroredRepeatWrapping},void 0!==E[w.wrap[0]]&&(u.wrapS=E[w.wrap[0]]),void 0!==E[w.wrap[1]]&&(u.wrapT=E[w.wrap[1]]));C.textures[y]=u}var D,H;for(D in x.materials){y=\nx.materials[D];for(H in y.parameters)\"envMap\"===H||\"map\"===H||\"lightMap\"===H||\"bumpMap\"===H?y.parameters[H]=C.textures[y.parameters[H]]:\"shading\"===H?y.parameters[H]=\"flat\"===y.parameters[H]?THREE.FlatShading:THREE.SmoothShading:\"side\"===H?y.parameters[H]=\"double\"==y.parameters[H]?THREE.DoubleSide:\"back\"==y.parameters[H]?THREE.BackSide:THREE.FrontSide:\"blending\"===H?y.parameters[H]=y.parameters[H]in THREE?THREE[y.parameters[H]]:THREE.NormalBlending:\"combine\"===H?y.parameters[H]=y.parameters[H]in THREE?\nTHREE[y.parameters[H]]:THREE.MultiplyOperation:\"vertexColors\"===H?\"face\"==y.parameters[H]?y.parameters[H]=THREE.FaceColors:y.parameters[H]&&(y.parameters[H]=THREE.VertexColors):\"wrapRGB\"===H&&(F=y.parameters[H],y.parameters[H]=new THREE.Vector3(F[0],F[1],F[2]));void 0!==y.parameters.opacity&&1>y.parameters.opacity&&(y.parameters.transparent=!0);y.parameters.normalMap?(F=THREE.ShaderLib.normalmap,w=THREE.UniformsUtils.clone(F.uniforms),u=y.parameters.color,E=y.parameters.specular,q=y.parameters.ambient,\nL=y.parameters.shininess,w.tNormal.value=C.textures[y.parameters.normalMap],y.parameters.normalScale&&w.uNormalScale.value.set(y.parameters.normalScale[0],y.parameters.normalScale[1]),y.parameters.map&&(w.tDiffuse.value=y.parameters.map,w.enableDiffuse.value=!0),y.parameters.envMap&&(w.tCube.value=y.parameters.envMap,w.enableReflection.value=!0,w.reflectivity.value=y.parameters.reflectivity),y.parameters.lightMap&&(w.tAO.value=y.parameters.lightMap,w.enableAO.value=!0),y.parameters.specularMap&&(w.tSpecular.value=\nC.textures[y.parameters.specularMap],w.enableSpecular.value=!0),y.parameters.displacementMap&&(w.tDisplacement.value=C.textures[y.parameters.displacementMap],w.enableDisplacement.value=!0,w.uDisplacementBias.value=y.parameters.displacementBias,w.uDisplacementScale.value=y.parameters.displacementScale),w.diffuse.value.setHex(u),w.specular.value.setHex(E),w.ambient.value.setHex(q),w.shininess.value=L,y.parameters.opacity&&(w.opacity.value=y.parameters.opacity),r=new THREE.ShaderMaterial({fragmentShader:F.fragmentShader,\nvertexShader:F.vertexShader,uniforms:w,lights:!0,fog:!0})):r=new THREE[y.type](y.parameters);r.name=D;C.materials[D]=r}for(D in x.materials)if(y=x.materials[D],y.parameters.materials){H=[];for(u=0;u<y.parameters.materials.length;u++)H.push(C.materials[y.parameters.materials[u]]);C.materials[D].materials=H}e();C.cameras&&x.defaults.camera&&(C.currentCamera=C.cameras[x.defaults.camera]);C.fogs&&x.defaults.fog&&(C.scene.fog=C.fogs[x.defaults.fog]);n.callbackSync(C);k()}};THREE.TextureLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};THREE.TextureLoader.prototype={constructor:THREE.TextureLoader,load:function(a,b){var c=new THREE.ImageLoader(this.manager);c.setCrossOrigin(this.crossOrigin);c.load(a,function(a){a=new THREE.Texture(a);a.needsUpdate=!0;void 0!==b&&b(a)})},setCrossOrigin:function(a){this.crossOrigin=a}};THREE.Material=function(){this.id=THREE.MaterialIdCount++;this.uuid=THREE.Math.generateUUID();this.name=\"\";this.side=THREE.FrontSide;this.opacity=1;this.transparent=!1;this.blending=THREE.NormalBlending;this.blendSrc=THREE.SrcAlphaFactor;this.blendDst=THREE.OneMinusSrcAlphaFactor;this.blendEquation=THREE.AddEquation;this.depthWrite=this.depthTest=!0;this.polygonOffset=!1;this.overdraw=this.alphaTest=this.polygonOffsetUnits=this.polygonOffsetFactor=0;this.needsUpdate=this.visible=!0};\nTHREE.Material.prototype={constructor:THREE.Material,setValues:function(a){if(void 0!==a)for(var b in a){var c=a[b];if(void 0===c)console.warn(\"THREE.Material: '\"+b+\"' parameter is undefined.\");else if(b in this){var d=this[b];d instanceof THREE.Color?d.set(c):d instanceof THREE.Vector3&&c instanceof THREE.Vector3?d.copy(c):this[b]=\"overdraw\"==b?Number(c):c}}},clone:function(a){void 0===a&&(a=new THREE.Material);a.name=this.name;a.side=this.side;a.opacity=this.opacity;a.transparent=this.transparent;\na.blending=this.blending;a.blendSrc=this.blendSrc;a.blendDst=this.blendDst;a.blendEquation=this.blendEquation;a.depthTest=this.depthTest;a.depthWrite=this.depthWrite;a.polygonOffset=this.polygonOffset;a.polygonOffsetFactor=this.polygonOffsetFactor;a.polygonOffsetUnits=this.polygonOffsetUnits;a.alphaTest=this.alphaTest;a.overdraw=this.overdraw;a.visible=this.visible;return a},dispose:function(){this.dispatchEvent({type:\"dispose\"})}};THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);\nTHREE.MaterialIdCount=0;THREE.LineBasicMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.linewidth=1;this.linejoin=this.linecap=\"round\";this.vertexColors=!1;this.fog=!0;this.setValues(a)};THREE.LineBasicMaterial.prototype=Object.create(THREE.Material.prototype);\nTHREE.LineBasicMaterial.prototype.clone=function(){var a=new THREE.LineBasicMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.linewidth=this.linewidth;a.linecap=this.linecap;a.linejoin=this.linejoin;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};THREE.LineDashedMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.scale=this.linewidth=1;this.dashSize=3;this.gapSize=1;this.vertexColors=!1;this.fog=!0;this.setValues(a)};THREE.LineDashedMaterial.prototype=Object.create(THREE.Material.prototype);\nTHREE.LineDashedMaterial.prototype.clone=function(){var a=new THREE.LineDashedMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.linewidth=this.linewidth;a.scale=this.scale;a.dashSize=this.dashSize;a.gapSize=this.gapSize;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};THREE.MeshBasicMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.envMap=this.specularMap=this.lightMap=this.map=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=\"round\";this.vertexColors=THREE.NoColors;this.morphTargets=this.skinning=!1;this.setValues(a)};\nTHREE.MeshBasicMaterial.prototype=Object.create(THREE.Material.prototype);\nTHREE.MeshBasicMaterial.prototype.clone=function(){var a=new THREE.MeshBasicMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.lightMap=this.lightMap;a.specularMap=this.specularMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=\nthis.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;return a};THREE.MeshLambertMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.ambient=new THREE.Color(16777215);this.emissive=new THREE.Color(0);this.wrapAround=!1;this.wrapRGB=new THREE.Vector3(1,1,1);this.envMap=this.specularMap=this.lightMap=this.map=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=\n\"round\";this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshLambertMaterial.prototype=Object.create(THREE.Material.prototype);\nTHREE.MeshLambertMaterial.prototype.clone=function(){var a=new THREE.MeshLambertMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.ambient.copy(this.ambient);a.emissive.copy(this.emissive);a.wrapAround=this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map=this.map;a.lightMap=this.lightMap;a.specularMap=this.specularMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;\na.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;a.morphNormals=this.morphNormals;return a};THREE.MeshPhongMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.ambient=new THREE.Color(16777215);this.emissive=new THREE.Color(0);this.specular=new THREE.Color(1118481);this.shininess=30;this.metal=!1;this.perPixel=!0;this.wrapAround=!1;this.wrapRGB=new THREE.Vector3(1,1,1);this.bumpMap=this.lightMap=this.map=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new THREE.Vector2(1,1);this.envMap=this.specularMap=null;this.combine=THREE.MultiplyOperation;\nthis.reflectivity=1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=\"round\";this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshPhongMaterial.prototype=Object.create(THREE.Material.prototype);\nTHREE.MeshPhongMaterial.prototype.clone=function(){var a=new THREE.MeshPhongMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.ambient.copy(this.ambient);a.emissive.copy(this.emissive);a.specular.copy(this.specular);a.shininess=this.shininess;a.metal=this.metal;a.perPixel=this.perPixel;a.wrapAround=this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map=this.map;a.lightMap=this.lightMap;a.bumpMap=this.bumpMap;a.bumpScale=this.bumpScale;a.normalMap=this.normalMap;a.normalScale.copy(this.normalScale);\na.specularMap=this.specularMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;a.morphNormals=this.morphNormals;return a};THREE.MeshDepthMaterial=function(a){THREE.Material.call(this);this.wireframe=!1;this.wireframeLinewidth=1;this.setValues(a)};THREE.MeshDepthMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshDepthMaterial.prototype.clone=function(){var a=new THREE.MeshDepthMaterial;THREE.Material.prototype.clone.call(this,a);a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;return a};THREE.MeshNormalMaterial=function(a){THREE.Material.call(this,a);this.shading=THREE.FlatShading;this.wireframe=!1;this.wireframeLinewidth=1;this.morphTargets=!1;this.setValues(a)};THREE.MeshNormalMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshNormalMaterial.prototype.clone=function(){var a=new THREE.MeshNormalMaterial;THREE.Material.prototype.clone.call(this,a);a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;return a};THREE.MeshFaceMaterial=function(a){this.materials=a instanceof Array?a:[]};THREE.MeshFaceMaterial.prototype.clone=function(){for(var a=new THREE.MeshFaceMaterial,b=0;b<this.materials.length;b++)a.materials.push(this.materials[b].clone());return a};THREE.ParticleSystemMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.map=null;this.size=1;this.sizeAttenuation=!0;this.vertexColors=!1;this.fog=!0;this.setValues(a)};THREE.ParticleSystemMaterial.prototype=Object.create(THREE.Material.prototype);\nTHREE.ParticleSystemMaterial.prototype.clone=function(){var a=new THREE.ParticleSystemMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.size=this.size;a.sizeAttenuation=this.sizeAttenuation;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};THREE.ParticleBasicMaterial=THREE.ParticleSystemMaterial;THREE.ShaderMaterial=function(a){THREE.Material.call(this);this.vertexShader=this.fragmentShader=\"void main() {}\";this.uniforms={};this.defines={};this.attributes=null;this.shading=THREE.SmoothShading;this.linewidth=1;this.wireframe=!1;this.wireframeLinewidth=1;this.lights=this.fog=!1;this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]};this.index0AttributeName=\"position\";this.setValues(a)};\nTHREE.ShaderMaterial.prototype=Object.create(THREE.Material.prototype);\nTHREE.ShaderMaterial.prototype.clone=function(){var a=new THREE.ShaderMaterial;THREE.Material.prototype.clone.call(this,a);a.fragmentShader=this.fragmentShader;a.vertexShader=this.vertexShader;a.uniforms=THREE.UniformsUtils.clone(this.uniforms);a.attributes=this.attributes;a.defines=this.defines;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.fog=this.fog;a.lights=this.lights;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=\nthis.morphTargets;a.morphNormals=this.morphNormals;return a};THREE.SpriteMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.map=null;this.rotation=0;this.fog=!1;this.setValues(a)};THREE.SpriteMaterial.prototype=Object.create(THREE.Material.prototype);THREE.SpriteMaterial.prototype.clone=function(){var a=new THREE.SpriteMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.rotation=this.rotation;a.fog=this.fog;return a};THREE.SpriteCanvasMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.program=function(){};this.setValues(a)};THREE.SpriteCanvasMaterial.prototype=Object.create(THREE.Material.prototype);THREE.SpriteCanvasMaterial.prototype.clone=function(){var a=new THREE.SpriteCanvasMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.program=this.program;return a};THREE.ParticleCanvasMaterial=THREE.SpriteCanvasMaterial;THREE.Texture=function(a,b,c,d,e,f,g,h,i){this.id=THREE.TextureIdCount++;this.uuid=THREE.Math.generateUUID();this.name=\"\";this.image=a;this.mipmaps=[];this.mapping=void 0!==b?b:new THREE.UVMapping;this.wrapS=void 0!==c?c:THREE.ClampToEdgeWrapping;this.wrapT=void 0!==d?d:THREE.ClampToEdgeWrapping;this.magFilter=void 0!==e?e:THREE.LinearFilter;this.minFilter=void 0!==f?f:THREE.LinearMipMapLinearFilter;this.anisotropy=void 0!==i?i:1;this.format=void 0!==g?g:THREE.RGBAFormat;this.type=void 0!==h?h:THREE.UnsignedByteType;\nthis.offset=new THREE.Vector2(0,0);this.repeat=new THREE.Vector2(1,1);this.generateMipmaps=!0;this.premultiplyAlpha=!1;this.flipY=!0;this.unpackAlignment=4;this._needsUpdate=!1;this.onUpdate=null};\nTHREE.Texture.prototype={constructor:THREE.Texture,get needsUpdate(){return this._needsUpdate},set needsUpdate(a){!0===a&&this.update();this._needsUpdate=a},clone:function(a){void 0===a&&(a=new THREE.Texture);a.image=this.image;a.mipmaps=this.mipmaps.slice(0);a.mapping=this.mapping;a.wrapS=this.wrapS;a.wrapT=this.wrapT;a.magFilter=this.magFilter;a.minFilter=this.minFilter;a.anisotropy=this.anisotropy;a.format=this.format;a.type=this.type;a.offset.copy(this.offset);a.repeat.copy(this.repeat);a.generateMipmaps=\nthis.generateMipmaps;a.premultiplyAlpha=this.premultiplyAlpha;a.flipY=this.flipY;a.unpackAlignment=this.unpackAlignment;return a},update:function(){this.dispatchEvent({type:\"update\"})},dispose:function(){this.dispatchEvent({type:\"dispose\"})}};THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);THREE.TextureIdCount=0;THREE.CompressedTexture=function(a,b,c,d,e,f,g,h,i,k,l){THREE.Texture.call(this,null,f,g,h,i,k,d,e,l);this.image={width:b,height:c};this.mipmaps=a;this.generateMipmaps=!1};THREE.CompressedTexture.prototype=Object.create(THREE.Texture.prototype);THREE.CompressedTexture.prototype.clone=function(){var a=new THREE.CompressedTexture;THREE.Texture.prototype.clone.call(this,a);return a};THREE.DataTexture=function(a,b,c,d,e,f,g,h,i,k,l){THREE.Texture.call(this,null,f,g,h,i,k,d,e,l);this.image={data:a,width:b,height:c}};THREE.DataTexture.prototype=Object.create(THREE.Texture.prototype);THREE.DataTexture.prototype.clone=function(){var a=new THREE.DataTexture;THREE.Texture.prototype.clone.call(this,a);return a};THREE.ParticleSystem=function(a,b){THREE.Object3D.call(this);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.ParticleSystemMaterial({color:16777215*Math.random()});this.frustumCulled=this.sortParticles=!1};THREE.ParticleSystem.prototype=Object.create(THREE.Object3D.prototype);\nTHREE.ParticleSystem.prototype.clone=function(a){void 0===a&&(a=new THREE.ParticleSystem(this.geometry,this.material));a.sortParticles=this.sortParticles;THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Line=function(a,b,c){THREE.Object3D.call(this);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.LineBasicMaterial({color:16777215*Math.random()});this.type=void 0!==c?c:THREE.LineStrip};THREE.LineStrip=0;THREE.LinePieces=1;THREE.Line.prototype=Object.create(THREE.Object3D.prototype);THREE.Line.prototype.clone=function(a){void 0===a&&(a=new THREE.Line(this.geometry,this.material,this.type));THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Mesh=function(a,b){THREE.Object3D.call(this);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.MeshBasicMaterial({color:16777215*Math.random()});this.updateMorphTargets()};THREE.Mesh.prototype=Object.create(THREE.Object3D.prototype);\nTHREE.Mesh.prototype.updateMorphTargets=function(){if(0<this.geometry.morphTargets.length){this.morphTargetBase=-1;this.morphTargetForcedOrder=[];this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var a=0,b=this.geometry.morphTargets.length;a<b;a++)this.morphTargetInfluences.push(0),this.morphTargetDictionary[this.geometry.morphTargets[a].name]=a}};\nTHREE.Mesh.prototype.getMorphTargetIndexByName=function(a){if(void 0!==this.morphTargetDictionary[a])return this.morphTargetDictionary[a];console.log(\"THREE.Mesh.getMorphTargetIndexByName: morph target \"+a+\" does not exist. Returning 0.\");return 0};THREE.Mesh.prototype.clone=function(a){void 0===a&&(a=new THREE.Mesh(this.geometry,this.material));THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Bone=function(a){THREE.Object3D.call(this);this.skin=a;this.skinMatrix=new THREE.Matrix4};THREE.Bone.prototype=Object.create(THREE.Object3D.prototype);THREE.Bone.prototype.update=function(a,b){this.matrixAutoUpdate&&(b|=this.updateMatrix());if(b||this.matrixWorldNeedsUpdate)a?this.skinMatrix.multiplyMatrices(a,this.matrix):this.skinMatrix.copy(this.matrix),this.matrixWorldNeedsUpdate=!1,b=!0;var c,d=this.children.length;for(c=0;c<d;c++)this.children[c].update(this.skinMatrix,b)};THREE.SkinnedMesh=function(a,b,c){THREE.Mesh.call(this,a,b);this.useVertexTexture=void 0!==c?c:!0;this.identityMatrix=new THREE.Matrix4;this.bones=[];this.boneMatrices=[];var d,e,f;if(this.geometry&&void 0!==this.geometry.bones){for(a=0;a<this.geometry.bones.length;a++)c=this.geometry.bones[a],d=c.pos,e=c.rotq,f=c.scl,b=this.addBone(),b.name=c.name,b.position.set(d[0],d[1],d[2]),b.quaternion.set(e[0],e[1],e[2],e[3]),void 0!==f?b.scale.set(f[0],f[1],f[2]):b.scale.set(1,1,1);for(a=0;a<this.bones.length;a++)c=\nthis.geometry.bones[a],b=this.bones[a],-1===c.parent?this.add(b):this.bones[c.parent].add(b);a=this.bones.length;this.useVertexTexture?(this.boneTextureHeight=this.boneTextureWidth=a=256<a?64:64<a?32:16<a?16:8,this.boneMatrices=new Float32Array(4*this.boneTextureWidth*this.boneTextureHeight),this.boneTexture=new THREE.DataTexture(this.boneMatrices,this.boneTextureWidth,this.boneTextureHeight,THREE.RGBAFormat,THREE.FloatType),this.boneTexture.minFilter=THREE.NearestFilter,this.boneTexture.magFilter=\nTHREE.NearestFilter,this.boneTexture.generateMipmaps=!1,this.boneTexture.flipY=!1):this.boneMatrices=new Float32Array(16*a);this.pose()}};THREE.SkinnedMesh.prototype=Object.create(THREE.Mesh.prototype);THREE.SkinnedMesh.prototype.addBone=function(a){void 0===a&&(a=new THREE.Bone(this));this.bones.push(a);return a};\nTHREE.SkinnedMesh.prototype.updateMatrixWorld=function(){var a=new THREE.Matrix4;return function(b){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||b)this.parent?this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix):this.matrixWorld.copy(this.matrix),this.matrixWorldNeedsUpdate=!1;for(var b=0,c=this.children.length;b<c;b++){var d=this.children[b];d instanceof THREE.Bone?d.update(this.identityMatrix,!1):d.updateMatrixWorld(!0)}if(void 0==this.boneInverses){this.boneInverses=\n[];b=0;for(c=this.bones.length;b<c;b++)d=new THREE.Matrix4,d.getInverse(this.bones[b].skinMatrix),this.boneInverses.push(d)}b=0;for(c=this.bones.length;b<c;b++)a.multiplyMatrices(this.bones[b].skinMatrix,this.boneInverses[b]),a.flattenToArrayOffset(this.boneMatrices,16*b);this.useVertexTexture&&(this.boneTexture.needsUpdate=!0)}}();THREE.SkinnedMesh.prototype.pose=function(){this.updateMatrixWorld(!0);this.normalizeSkinWeights()};\nTHREE.SkinnedMesh.prototype.normalizeSkinWeights=function(){if(this.geometry instanceof THREE.Geometry)for(var a=0;a<this.geometry.skinIndices.length;a++){var b=this.geometry.skinWeights[a],c=1/b.lengthManhattan();Infinity!==c?b.multiplyScalar(c):b.set(1)}};THREE.SkinnedMesh.prototype.clone=function(a){void 0===a&&(a=new THREE.SkinnedMesh(this.geometry,this.material,this.useVertexTexture));THREE.Mesh.prototype.clone.call(this,a);return a};THREE.MorphAnimMesh=function(a,b){THREE.Mesh.call(this,a,b);this.duration=1E3;this.mirroredLoop=!1;this.currentKeyframe=this.lastKeyframe=this.time=0;this.direction=1;this.directionBackwards=!1;this.setFrameRange(0,this.geometry.morphTargets.length-1)};THREE.MorphAnimMesh.prototype=Object.create(THREE.Mesh.prototype);THREE.MorphAnimMesh.prototype.setFrameRange=function(a,b){this.startKeyframe=a;this.endKeyframe=b;this.length=this.endKeyframe-this.startKeyframe+1};\nTHREE.MorphAnimMesh.prototype.setDirectionForward=function(){this.direction=1;this.directionBackwards=!1};THREE.MorphAnimMesh.prototype.setDirectionBackward=function(){this.direction=-1;this.directionBackwards=!0};\nTHREE.MorphAnimMesh.prototype.parseAnimations=function(){var a=this.geometry;a.animations||(a.animations={});for(var b,c=a.animations,d=/([a-z]+)(\\d+)/,e=0,f=a.morphTargets.length;e<f;e++){var g=a.morphTargets[e].name.match(d);if(g&&1<g.length){g=g[1];c[g]||(c[g]={start:Infinity,end:-Infinity});var h=c[g];e<h.start&&(h.start=e);e>h.end&&(h.end=e);b||(b=g)}}a.firstAnimation=b};\nTHREE.MorphAnimMesh.prototype.setAnimationLabel=function(a,b,c){this.geometry.animations||(this.geometry.animations={});this.geometry.animations[a]={start:b,end:c}};THREE.MorphAnimMesh.prototype.playAnimation=function(a,b){var c=this.geometry.animations[a];c?(this.setFrameRange(c.start,c.end),this.duration=1E3*((c.end-c.start)/b),this.time=0):console.warn(\"animation[\"+a+\"] undefined\")};\nTHREE.MorphAnimMesh.prototype.updateAnimation=function(a){var b=this.duration/this.length;this.time+=this.direction*a;if(this.mirroredLoop){if(this.time>this.duration||0>this.time)this.direction*=-1,this.time>this.duration&&(this.time=this.duration,this.directionBackwards=!0),0>this.time&&(this.time=0,this.directionBackwards=!1)}else this.time%=this.duration,0>this.time&&(this.time+=this.duration);a=this.startKeyframe+THREE.Math.clamp(Math.floor(this.time/b),0,this.length-1);a!==this.currentKeyframe&&\n(this.morphTargetInfluences[this.lastKeyframe]=0,this.morphTargetInfluences[this.currentKeyframe]=1,this.morphTargetInfluences[a]=0,this.lastKeyframe=this.currentKeyframe,this.currentKeyframe=a);b=this.time%b/b;this.directionBackwards&&(b=1-b);this.morphTargetInfluences[this.currentKeyframe]=b;this.morphTargetInfluences[this.lastKeyframe]=1-b};\nTHREE.MorphAnimMesh.prototype.clone=function(a){void 0===a&&(a=new THREE.MorphAnimMesh(this.geometry,this.material));a.duration=this.duration;a.mirroredLoop=this.mirroredLoop;a.time=this.time;a.lastKeyframe=this.lastKeyframe;a.currentKeyframe=this.currentKeyframe;a.direction=this.direction;a.directionBackwards=this.directionBackwards;THREE.Mesh.prototype.clone.call(this,a);return a};THREE.LOD=function(){THREE.Object3D.call(this);this.objects=[]};THREE.LOD.prototype=Object.create(THREE.Object3D.prototype);THREE.LOD.prototype.addLevel=function(a,b){void 0===b&&(b=0);for(var b=Math.abs(b),c=0;c<this.objects.length&&!(b<this.objects[c].distance);c++);this.objects.splice(c,0,{distance:b,object:a});this.add(a)};THREE.LOD.prototype.getObjectForDistance=function(a){for(var b=1,c=this.objects.length;b<c&&!(a<this.objects[b].distance);b++);return this.objects[b-1].object};\nTHREE.LOD.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c){if(1<this.objects.length){a.setFromMatrixPosition(c.matrixWorld);b.setFromMatrixPosition(this.matrixWorld);c=a.distanceTo(b);this.objects[0].object.visible=!0;for(var d=1,e=this.objects.length;d<e;d++)if(c>=this.objects[d].distance)this.objects[d-1].object.visible=!1,this.objects[d].object.visible=!0;else break;for(;d<e;d++)this.objects[d].object.visible=!1}}}();THREE.LOD.prototype.clone=function(){};THREE.Sprite=function(a){THREE.Object3D.call(this);this.material=void 0!==a?a:new THREE.SpriteMaterial};THREE.Sprite.prototype=Object.create(THREE.Object3D.prototype);THREE.Sprite.prototype.updateMatrix=function(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=!0};THREE.Sprite.prototype.clone=function(a){void 0===a&&(a=new THREE.Sprite(this.material));THREE.Object3D.prototype.clone.call(this,a);return a};THREE.Particle=THREE.Sprite;THREE.Scene=function(){THREE.Object3D.call(this);this.overrideMaterial=this.fog=null;this.autoUpdate=!0;this.matrixAutoUpdate=!1;this.__lights=[];this.__objectsAdded=[];this.__objectsRemoved=[]};THREE.Scene.prototype=Object.create(THREE.Object3D.prototype);\nTHREE.Scene.prototype.__addObject=function(a){if(a instanceof THREE.Light)-1===this.__lights.indexOf(a)&&this.__lights.push(a),a.target&&void 0===a.target.parent&&this.add(a.target);else if(!(a instanceof THREE.Camera||a instanceof THREE.Bone)){this.__objectsAdded.push(a);var b=this.__objectsRemoved.indexOf(a);-1!==b&&this.__objectsRemoved.splice(b,1)}this.dispatchEvent({type:\"objectAdded\",object:a});a.dispatchEvent({type:\"addedToScene\",scene:this});for(b=0;b<a.children.length;b++)this.__addObject(a.children[b])};\nTHREE.Scene.prototype.__removeObject=function(a){if(a instanceof THREE.Light){var b=this.__lights.indexOf(a);-1!==b&&this.__lights.splice(b,1);if(a.shadowCascadeArray)for(b=0;b<a.shadowCascadeArray.length;b++)this.__removeObject(a.shadowCascadeArray[b])}else a instanceof THREE.Camera||(this.__objectsRemoved.push(a),b=this.__objectsAdded.indexOf(a),-1!==b&&this.__objectsAdded.splice(b,1));this.dispatchEvent({type:\"objectRemoved\",object:a});a.dispatchEvent({type:\"removedFromScene\",scene:this});for(b=\n0;b<a.children.length;b++)this.__removeObject(a.children[b])};THREE.Scene.prototype.clone=function(a){void 0===a&&(a=new THREE.Scene);THREE.Object3D.prototype.clone.call(this,a);null!==this.fog&&(a.fog=this.fog.clone());null!==this.overrideMaterial&&(a.overrideMaterial=this.overrideMaterial.clone());a.autoUpdate=this.autoUpdate;a.matrixAutoUpdate=this.matrixAutoUpdate;return a};THREE.Fog=function(a,b,c){this.name=\"\";this.color=new THREE.Color(a);this.near=void 0!==b?b:1;this.far=void 0!==c?c:1E3};THREE.Fog.prototype.clone=function(){return new THREE.Fog(this.color.getHex(),this.near,this.far)};THREE.FogExp2=function(a,b){this.name=\"\";this.color=new THREE.Color(a);this.density=void 0!==b?b:2.5E-4};THREE.FogExp2.prototype.clone=function(){return new THREE.FogExp2(this.color.getHex(),this.density)};THREE.CanvasRenderer=function(a){function b(a,b,c){for(var d=0,e=N.length;d<e;d++){var f=N[d];wa.copy(f.color);if(f instanceof THREE.DirectionalLight){var g=Na.setFromMatrixPosition(f.matrixWorld).normalize(),h=b.dot(g);0>=h||(h*=f.intensity,c.add(wa.multiplyScalar(h)))}else f instanceof THREE.PointLight&&(g=Na.setFromMatrixPosition(f.matrixWorld),h=b.dot(Na.subVectors(g,a).normalize()),0>=h||(h*=0==f.distance?1:1-Math.min(a.distanceTo(g)/f.distance,1),0!=h&&(h*=f.intensity,c.add(wa.multiplyScalar(h)))))}}\nfunction c(a,b,c,d){p(b);t(c);r(d);m(a.getStyle());E.stroke();pa.expandByScalar(2*b)}function d(a){q(a.getStyle());E.fill()}function e(a){f(a.target)}function f(a){var b=a.wrapS===THREE.RepeatWrapping,c=a.wrapT===THREE.RepeatWrapping,d=a.image,e=document.createElement(\"canvas\");e.width=d.width;e.height=d.height;var f=e.getContext(\"2d\");f.setTransform(1,0,0,-1,0,d.height);f.drawImage(d,0,0);Ua[a.id]=E.createPattern(e,!0===b&&!0===c?\"repeat\":!0===b&&!1===c?\"repeat-x\":!1===b&&!0===c?\"repeat-y\":\"no-repeat\")}\nfunction g(a,b,c,d,g,h,j,i,k,l,n,p,m){if(!(m instanceof THREE.DataTexture)){!1===m.hasEventListener(\"update\",e)&&(void 0!==m.image&&0<m.image.width&&f(m),m.addEventListener(\"update\",e));var t=Ua[m.id];if(void 0!==t){q(t);var t=m.offset.x/m.repeat.x,r=m.offset.y/m.repeat.y,s=m.image.width*m.repeat.x,m=m.image.height*m.repeat.y,j=(j+t)*s,i=(i+r)*m,c=c-a,d=d-b,g=g-a,h=h-b,k=(k+t)*s-j,l=(l+r)*m-i,n=(n+t)*s-j,p=(p+r)*m-i,m=k*p-n*l;0!==m&&(t=1/m,m=(p*c-l*g)*t,l=(p*d-l*h)*t,c=(k*g-n*c)*t,d=(k*h-n*d)*t,a=\na-m*j-c*i,b=b-l*j-d*i,E.save(),E.transform(m,l,c,d,a,b),E.fill(),E.restore())}else q(\"rgba(0,0,0,1)\"),E.fill()}}function h(a,b,c,d,e,f,g,h,j,i,k,l,n){var m,p;m=n.width-1;p=n.height-1;g*=m;h*=p;c-=a;d-=b;e-=a;f-=b;j=j*m-g;i=i*p-h;k=k*m-g;l=l*p-h;p=1/(j*l-k*i);m=(l*c-i*e)*p;i=(l*d-i*f)*p;c=(j*e-k*c)*p;d=(j*f-k*d)*p;a=a-m*g-c*h;b=b-i*g-d*h;E.save();E.transform(m,i,c,d,a,b);E.clip();E.drawImage(n,0,0);E.restore()}function i(a,b,c,d){qa[0]=255*a.r|0;qa[1]=255*a.g|0;qa[2]=255*a.b|0;qa[4]=255*b.r|0;qa[5]=\n255*b.g|0;qa[6]=255*b.b|0;qa[8]=255*c.r|0;qa[9]=255*c.g|0;qa[10]=255*c.b|0;qa[12]=255*d.r|0;qa[13]=255*d.g|0;qa[14]=255*d.b|0;Pa.putImageData(Wa,0,0);hb.drawImage(j,0,0);return ta}function k(a,b,c){var d=b.x-a.x,e=b.y-a.y,f=d*d+e*e;0!==f&&(c/=Math.sqrt(f),d*=c,e*=c,b.x+=d,b.y+=e,a.x-=d,a.y-=e)}function l(a){H!==a&&(H=E.globalAlpha=a)}function n(a){K!==a&&(a===THREE.NormalBlending?E.globalCompositeOperation=\"source-over\":a===THREE.AdditiveBlending?E.globalCompositeOperation=\"lighter\":a===THREE.SubtractiveBlending&&\n(E.globalCompositeOperation=\"darker\"),K=a)}function p(a){ha!==a&&(ha=E.lineWidth=a)}function t(a){ua!==a&&(ua=E.lineCap=a)}function r(a){O!==a&&(O=E.lineJoin=a)}function m(a){A!==a&&(A=E.strokeStyle=a)}function q(a){da!==a&&(da=E.fillStyle=a)}function u(a,b){if(T!==a||ea!==b)E.setLineDash([a,b]),T=a,ea=b}console.log(\"THREE.CanvasRenderer\",THREE.REVISION);var s=THREE.Math.smoothstep,a=a||{},v=this,z,G,N,C=new THREE.Projector,B=void 0!==a.canvas?a.canvas:document.createElement(\"canvas\"),x=B.width,F=\nB.height,L=Math.floor(x/2),w=Math.floor(F/2),E=B.getContext(\"2d\"),y=new THREE.Color(0),D=0,H=1,K=0,A=null,da=null,ha=null,ua=null,O=null,T=null,ea=0,I,P,Q,oa;new THREE.RenderableVertex;new THREE.RenderableVertex;var va,Ea,za,Ha,Ta,Ja,sa=new THREE.Color,Aa=new THREE.Color,ba=new THREE.Color,W=new THREE.Color,Ka=new THREE.Color,U=new THREE.Color,ca=new THREE.Color,wa=new THREE.Color,Ua={},Oa,la,ia,Fa,Ga,Ba,xa,Va,La,Ma,ya=new THREE.Box2,V=new THREE.Box2,pa=new THREE.Box2,ja=new THREE.Color,fa=new THREE.Color,\nZa=new THREE.Color,Na=new THREE.Vector3,j,Pa,Wa,qa,ta,hb,db=16;j=document.createElement(\"canvas\");j.width=j.height=2;Pa=j.getContext(\"2d\");Pa.fillStyle=\"rgba(0,0,0,1)\";Pa.fillRect(0,0,2,2);Wa=Pa.getImageData(0,0,2,2);qa=Wa.data;ta=document.createElement(\"canvas\");ta.width=ta.height=db;hb=ta.getContext(\"2d\");hb.translate(-db/2,-db/2);hb.scale(db,db);db--;void 0===E.setLineDash&&(E.setLineDash=void 0!==E.mozDash?function(a){E.mozDash=null!==a[0]?a:null}:function(){});this.domElement=B;this.devicePixelRatio=\nvoid 0!==a.devicePixelRatio?a.devicePixelRatio:void 0!==self.devicePixelRatio?self.devicePixelRatio:1;this.sortElements=this.sortObjects=this.autoClear=!0;this.info={render:{vertices:0,faces:0}};this.supportsVertexTextures=function(){};this.setFaceCulling=function(){};this.setSize=function(a,b,c){x=a*this.devicePixelRatio;F=b*this.devicePixelRatio;L=Math.floor(x/2);w=Math.floor(F/2);B.width=x;B.height=F;1!==this.devicePixelRatio&&!1!==c&&(B.style.width=a+\"px\",B.style.height=b+\"px\");ya.set(new THREE.Vector2(-L,\n-w),new THREE.Vector2(L,w));V.set(new THREE.Vector2(-L,-w),new THREE.Vector2(L,w));H=1;K=0;O=ua=ha=da=A=null};this.setClearColor=function(a,b){y.set(a);D=void 0!==b?b:1;V.set(new THREE.Vector2(-L,-w),new THREE.Vector2(L,w))};this.setClearColorHex=function(a,b){console.warn(\"DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.\");this.setClearColor(a,b)};this.getMaxAnisotropy=function(){return 0};this.clear=function(){E.setTransform(1,0,0,-1,L,w);!1===V.empty()&&(V.intersect(ya),\nV.expandByScalar(2),1>D&&E.clearRect(V.min.x|0,V.min.y|0,V.max.x-V.min.x|0,V.max.y-V.min.y|0),0<D&&(n(THREE.NormalBlending),l(1),q(\"rgba(\"+Math.floor(255*y.r)+\",\"+Math.floor(255*y.g)+\",\"+Math.floor(255*y.b)+\",\"+D+\")\"),E.fillRect(V.min.x|0,V.min.y|0,V.max.x-V.min.x|0,V.max.y-V.min.y|0)),V.makeEmpty())};this.clearColor=function(){};this.clearDepth=function(){};this.clearStencil=function(){};this.render=function(a,j){if(!1===j instanceof THREE.Camera)console.error(\"THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.\");\nelse{!0===this.autoClear&&this.clear();E.setTransform(1,0,0,-1,L,w);v.info.render.vertices=0;v.info.render.faces=0;z=C.projectScene(a,j,this.sortObjects,this.sortElements);G=z.elements;N=z.lights;I=j;ja.setRGB(0,0,0);fa.setRGB(0,0,0);Za.setRGB(0,0,0);for(var x=0,H=N.length;x<H;x++){var B=N[x],F=B.color;B instanceof THREE.AmbientLight?ja.add(F):B instanceof THREE.DirectionalLight?fa.add(F):B instanceof THREE.PointLight&&Za.add(F)}x=0;for(H=G.length;x<H;x++){var y=G[x],D=y.material;if(!(void 0===D||\n!1===D.visible)){pa.makeEmpty();if(y instanceof THREE.RenderableSprite){P=y;P.x*=L;P.y*=w;B=P;F=D;l(F.opacity);n(F.blending);var A=y.scale.x*L,y=y.scale.y*w,D=0.5*Math.sqrt(A*A+y*y);pa.min.set(B.x-D,B.y-D);pa.max.set(B.x+D,B.y+D);if(!1===ya.isIntersectionBox(pa))pa.makeEmpty();else if(F instanceof THREE.SpriteMaterial||F instanceof THREE.ParticleSystemMaterial){var O=F.map;if(null!==O){!1===O.hasEventListener(\"update\",e)&&(void 0!==O.image&&0<O.image.width&&f(O),O.addEventListener(\"update\",e));D=\nUa[O.id];void 0!==D?q(D):q(\"rgba( 0, 0, 0, 1 )\");var K=O.image,D=K.width*O.offset.x,T=K.height*O.offset.y,da=K.width*O.repeat.x,O=K.height*O.repeat.y,K=A/da,ha=y/O;E.save();E.translate(B.x,B.y);0!==F.rotation&&E.rotate(F.rotation);E.translate(-A/2,-y/2);E.scale(K,ha);E.translate(-D,-T);E.fillRect(D,T,da,O)}else q(F.color.getStyle()),E.save(),E.translate(B.x,B.y),0!==F.rotation&&E.rotate(F.rotation),E.scale(A,-y),E.fillRect(-0.5,-0.5,1,1);E.restore()}else F instanceof THREE.SpriteCanvasMaterial&&(m(F.color.getStyle()),\nq(F.color.getStyle()),E.save(),E.translate(B.x,B.y),0!==F.rotation&&E.rotate(F.rotation),E.scale(A,y),F.program(E),E.restore())}else if(y instanceof THREE.RenderableLine){if(P=y.v1,Q=y.v2,P.positionScreen.x*=L,P.positionScreen.y*=w,Q.positionScreen.x*=L,Q.positionScreen.y*=w,pa.setFromPoints([P.positionScreen,Q.positionScreen]),!0===ya.isIntersectionBox(pa))if(B=P,F=Q,A=y,y=D,l(y.opacity),n(y.blending),E.beginPath(),E.moveTo(B.positionScreen.x,B.positionScreen.y),E.lineTo(F.positionScreen.x,F.positionScreen.y),\ny instanceof THREE.LineBasicMaterial){p(y.linewidth);t(y.linecap);r(y.linejoin);if(y.vertexColors!==THREE.VertexColors)m(y.color.getStyle());else if(D=A.vertexColors[0].getStyle(),A=A.vertexColors[1].getStyle(),D===A)m(D);else{try{var ea=E.createLinearGradient(B.positionScreen.x,B.positionScreen.y,F.positionScreen.x,F.positionScreen.y);ea.addColorStop(0,D);ea.addColorStop(1,A)}catch(qa){ea=D}m(ea)}E.stroke();pa.expandByScalar(2*y.linewidth)}else y instanceof THREE.LineDashedMaterial&&(p(y.linewidth),\nt(y.linecap),r(y.linejoin),m(y.color.getStyle()),u(y.dashSize,y.gapSize),E.stroke(),pa.expandByScalar(2*y.linewidth),u(null,null))}else if(y instanceof THREE.RenderableFace3){P=y.v1;Q=y.v2;oa=y.v3;if(-1>P.positionScreen.z||1<P.positionScreen.z)continue;if(-1>Q.positionScreen.z||1<Q.positionScreen.z)continue;if(-1>oa.positionScreen.z||1<oa.positionScreen.z)continue;P.positionScreen.x*=L;P.positionScreen.y*=w;Q.positionScreen.x*=L;Q.positionScreen.y*=w;oa.positionScreen.x*=L;oa.positionScreen.y*=w;\n0<D.overdraw&&(k(P.positionScreen,Q.positionScreen,D.overdraw),k(Q.positionScreen,oa.positionScreen,D.overdraw),k(oa.positionScreen,P.positionScreen,D.overdraw));pa.setFromPoints([P.positionScreen,Q.positionScreen,oa.positionScreen]);if(!0===ya.isIntersectionBox(pa)){B=P;F=Q;A=oa;v.info.render.vertices+=3;v.info.render.faces++;l(D.opacity);n(D.blending);va=B.positionScreen.x;Ea=B.positionScreen.y;za=F.positionScreen.x;Ha=F.positionScreen.y;Ta=A.positionScreen.x;Ja=A.positionScreen.y;var T=va,da=Ea,\nO=za,K=Ha,ha=Ta,ua=Ja;E.beginPath();E.moveTo(T,da);E.lineTo(O,K);E.lineTo(ha,ua);E.closePath();(D instanceof THREE.MeshLambertMaterial||D instanceof THREE.MeshPhongMaterial)&&null===D.map?(U.copy(D.color),ca.copy(D.emissive),D.vertexColors===THREE.FaceColors&&U.multiply(y.color),!1===D.wireframe&&D.shading===THREE.SmoothShading&&3===y.vertexNormalsLength?(Aa.copy(ja),ba.copy(ja),W.copy(ja),b(y.v1.positionWorld,y.vertexNormalsModel[0],Aa),b(y.v2.positionWorld,y.vertexNormalsModel[1],ba),b(y.v3.positionWorld,\ny.vertexNormalsModel[2],W),Aa.multiply(U).add(ca),ba.multiply(U).add(ca),W.multiply(U).add(ca),Ka.addColors(ba,W).multiplyScalar(0.5),ia=i(Aa,ba,W,Ka),h(va,Ea,za,Ha,Ta,Ja,0,0,1,0,0,1,ia)):(sa.copy(ja),b(y.centroidModel,y.normalModel,sa),sa.multiply(U).add(ca),!0===D.wireframe?c(sa,D.wireframeLinewidth,D.wireframeLinecap,D.wireframeLinejoin):d(sa))):D instanceof THREE.MeshBasicMaterial||D instanceof THREE.MeshLambertMaterial||D instanceof THREE.MeshPhongMaterial?null!==D.map?D.map.mapping instanceof\nTHREE.UVMapping&&(Fa=y.uvs[0],g(va,Ea,za,Ha,Ta,Ja,Fa[0].x,Fa[0].y,Fa[1].x,Fa[1].y,Fa[2].x,Fa[2].y,D.map)):null!==D.envMap?D.envMap.mapping instanceof THREE.SphericalReflectionMapping&&(Na.copy(y.vertexNormalsModelView[0]),Ga=0.5*Na.x+0.5,Ba=0.5*Na.y+0.5,Na.copy(y.vertexNormalsModelView[1]),xa=0.5*Na.x+0.5,Va=0.5*Na.y+0.5,Na.copy(y.vertexNormalsModelView[2]),La=0.5*Na.x+0.5,Ma=0.5*Na.y+0.5,g(va,Ea,za,Ha,Ta,Ja,Ga,Ba,xa,Va,La,Ma,D.envMap)):(sa.copy(D.color),D.vertexColors===THREE.FaceColors&&sa.multiply(y.color),\n!0===D.wireframe?c(sa,D.wireframeLinewidth,D.wireframeLinecap,D.wireframeLinejoin):d(sa)):D instanceof THREE.MeshDepthMaterial?(Oa=I.near,la=I.far,Aa.r=Aa.g=Aa.b=1-s(B.positionScreen.z*B.positionScreen.w,Oa,la),ba.r=ba.g=ba.b=1-s(F.positionScreen.z*F.positionScreen.w,Oa,la),W.r=W.g=W.b=1-s(A.positionScreen.z*A.positionScreen.w,Oa,la),Ka.addColors(ba,W).multiplyScalar(0.5),ia=i(Aa,ba,W,Ka),h(va,Ea,za,Ha,Ta,Ja,0,0,1,0,0,1,ia)):D instanceof THREE.MeshNormalMaterial&&(B=void 0,D.shading===THREE.FlatShading?\n(B=y.normalModelView,sa.setRGB(B.x,B.y,B.z).multiplyScalar(0.5).addScalar(0.5),!0===D.wireframe?c(sa,D.wireframeLinewidth,D.wireframeLinecap,D.wireframeLinejoin):d(sa)):D.shading===THREE.SmoothShading&&(B=y.vertexNormalsModelView[0],Aa.setRGB(B.x,B.y,B.z).multiplyScalar(0.5).addScalar(0.5),B=y.vertexNormalsModelView[1],ba.setRGB(B.x,B.y,B.z).multiplyScalar(0.5).addScalar(0.5),B=y.vertexNormalsModelView[2],W.setRGB(B.x,B.y,B.z).multiplyScalar(0.5).addScalar(0.5),Ka.addColors(ba,W).multiplyScalar(0.5),\nia=i(Aa,ba,W,Ka),h(va,Ea,za,Ha,Ta,Ja,0,0,1,0,0,1,ia)))}}V.union(pa)}}E.setTransform(1,0,0,1,0,0)}}};THREE.ShaderChunk={fog_pars_fragment:\"#ifdef USE_FOG\\nuniform vec3 fogColor;\\n#ifdef FOG_EXP2\\nuniform float fogDensity;\\n#else\\nuniform float fogNear;\\nuniform float fogFar;\\n#endif\\n#endif\",fog_fragment:\"#ifdef USE_FOG\\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n#ifdef FOG_EXP2\\nconst float LOG2 = 1.442695;\\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\\n#else\\nfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n#endif\\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n#endif\",\nenvmap_pars_fragment:\"#ifdef USE_ENVMAP\\nuniform float reflectivity;\\nuniform samplerCube envMap;\\nuniform float flipEnvMap;\\nuniform int combine;\\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\nuniform bool useRefract;\\nuniform float refractionRatio;\\n#else\\nvarying vec3 vReflect;\\n#endif\\n#endif\",envmap_fragment:\"#ifdef USE_ENVMAP\\nvec3 reflectVec;\\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\nif ( useRefract ) {\\nreflectVec = refract( cameraToVertex, normal, refractionRatio );\\n} else { \\nreflectVec = reflect( cameraToVertex, normal );\\n}\\n#else\\nreflectVec = vReflect;\\n#endif\\n#ifdef DOUBLE_SIDED\\nfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\nvec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n#else\\nvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n#endif\\n#ifdef GAMMA_INPUT\\ncubeColor.xyz *= cubeColor.xyz;\\n#endif\\nif ( combine == 1 ) {\\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\\n} else if ( combine == 2 ) {\\ngl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\\n} else {\\ngl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\\n}\\n#endif\",\nenvmap_pars_vertex:\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\\nvarying vec3 vReflect;\\nuniform float refractionRatio;\\nuniform bool useRefract;\\n#endif\",worldpos_vertex:\"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n#ifdef USE_SKINNING\\nvec4 worldPosition = modelMatrix * skinned;\\n#endif\\n#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\\nvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\\n#endif\\n#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n#endif\\n#endif\",\nenvmap_vertex:\"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\\nvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\\nworldNormal = normalize( worldNormal );\\nvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\nif ( useRefract ) {\\nvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n} else {\\nvReflect = reflect( cameraToVertex, worldNormal );\\n}\\n#endif\",map_particle_pars_fragment:\"#ifdef USE_MAP\\nuniform sampler2D map;\\n#endif\",\nmap_particle_fragment:\"#ifdef USE_MAP\\ngl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\\n#endif\",map_pars_vertex:\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\\nvarying vec2 vUv;\\nuniform vec4 offsetRepeat;\\n#endif\",map_pars_fragment:\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\\nvarying vec2 vUv;\\n#endif\\n#ifdef USE_MAP\\nuniform sampler2D map;\\n#endif\",\nmap_vertex:\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\\nvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\",map_fragment:\"#ifdef USE_MAP\\nvec4 texelColor = texture2D( map, vUv );\\n#ifdef GAMMA_INPUT\\ntexelColor.xyz *= texelColor.xyz;\\n#endif\\ngl_FragColor = gl_FragColor * texelColor;\\n#endif\",lightmap_pars_fragment:\"#ifdef USE_LIGHTMAP\\nvarying vec2 vUv2;\\nuniform sampler2D lightMap;\\n#endif\",lightmap_pars_vertex:\"#ifdef USE_LIGHTMAP\\nvarying vec2 vUv2;\\n#endif\",\nlightmap_fragment:\"#ifdef USE_LIGHTMAP\\ngl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\\n#endif\",lightmap_vertex:\"#ifdef USE_LIGHTMAP\\nvUv2 = uv2;\\n#endif\",bumpmap_pars_fragment:\"#ifdef USE_BUMPMAP\\nuniform sampler2D bumpMap;\\nuniform float bumpScale;\\nvec2 dHdxy_fwd() {\\nvec2 dSTdx = dFdx( vUv );\\nvec2 dSTdy = dFdy( vUv );\\nfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\nfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\nfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\nreturn vec2( dBx, dBy );\\n}\\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\nvec3 vSigmaX = dFdx( surf_pos );\\nvec3 vSigmaY = dFdy( surf_pos );\\nvec3 vN = surf_norm;\\nvec3 R1 = cross( vSigmaY, vN );\\nvec3 R2 = cross( vN, vSigmaX );\\nfloat fDet = dot( vSigmaX, R1 );\\nvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\nreturn normalize( abs( fDet ) * surf_norm - vGrad );\\n}\\n#endif\",\nnormalmap_pars_fragment:\"#ifdef USE_NORMALMAP\\nuniform sampler2D normalMap;\\nuniform vec2 normalScale;\\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\nvec3 q0 = dFdx( eye_pos.xyz );\\nvec3 q1 = dFdy( eye_pos.xyz );\\nvec2 st0 = dFdx( vUv.st );\\nvec2 st1 = dFdy( vUv.st );\\nvec3 S = normalize(  q0 * st1.t - q1 * st0.t );\\nvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\nvec3 N = normalize( surf_norm );\\nvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\nmapN.xy = normalScale * mapN.xy;\\nmat3 tsn = mat3( S, T, N );\\nreturn normalize( tsn * mapN );\\n}\\n#endif\",\nspecularmap_pars_fragment:\"#ifdef USE_SPECULARMAP\\nuniform sampler2D specularMap;\\n#endif\",specularmap_fragment:\"float specularStrength;\\n#ifdef USE_SPECULARMAP\\nvec4 texelSpecular = texture2D( specularMap, vUv );\\nspecularStrength = texelSpecular.r;\\n#else\\nspecularStrength = 1.0;\\n#endif\",lights_lambert_pars_vertex:\"uniform vec3 ambient;\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 ambientLightColor;\\n#if MAX_DIR_LIGHTS > 0\\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n#endif\\n#ifdef WRAP_AROUND\\nuniform vec3 wrapRGB;\\n#endif\",\nlights_lambert_vertex:\"vLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\nvLightBack = vec3( 0.0 );\\n#endif\\ntransformedNormal = normalize( transformedNormal );\\n#if MAX_DIR_LIGHTS > 0\\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\nvec3 dirVector = normalize( lDirection.xyz );\\nfloat dotProduct = dot( transformedNormal, dirVector );\\nvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n#ifdef DOUBLE_SIDED\\nvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n#ifdef WRAP_AROUND\\nvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n#endif\\n#endif\\n#ifdef WRAP_AROUND\\nvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\ndirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\\n#ifdef DOUBLE_SIDED\\ndirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\\n#endif\\n#endif\\nvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\\n#ifdef DOUBLE_SIDED\\nvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\\n#endif\\n}\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\\nfloat lDistance = 1.0;\\nif ( pointLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\nlVector = normalize( lVector );\\nfloat dotProduct = dot( transformedNormal, lVector );\\nvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n#ifdef DOUBLE_SIDED\\nvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n#ifdef WRAP_AROUND\\nvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n#endif\\n#endif\\n#ifdef WRAP_AROUND\\nvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\npointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\\n#ifdef DOUBLE_SIDED\\npointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\\n#endif\\n#endif\\nvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\\n#ifdef DOUBLE_SIDED\\nvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\\n#endif\\n}\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\\nif ( spotEffect > spotLightAngleCos[ i ] ) {\\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\\nfloat lDistance = 1.0;\\nif ( spotLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\\nlVector = normalize( lVector );\\nfloat dotProduct = dot( transformedNormal, lVector );\\nvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n#ifdef DOUBLE_SIDED\\nvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n#ifdef WRAP_AROUND\\nvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n#endif\\n#endif\\n#ifdef WRAP_AROUND\\nvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\nspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\\n#ifdef DOUBLE_SIDED\\nspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\\n#endif\\n#endif\\nvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\\n#ifdef DOUBLE_SIDED\\nvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\\n#endif\\n}\\n}\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\\nvec3 lVector = normalize( lDirection.xyz );\\nfloat dotProduct = dot( transformedNormal, lVector );\\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\nfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\\nvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n#ifdef DOUBLE_SIDED\\nvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\\n#endif\\n}\\n#endif\\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\\n#ifdef DOUBLE_SIDED\\nvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\\n#endif\",\nlights_phong_pars_vertex:\"#ifndef PHONG_PER_PIXEL\\n#if MAX_POINT_LIGHTS > 0\\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\nvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\nvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\\n#endif\\n#endif\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\\nvarying vec3 vWorldPosition;\\n#endif\",\nlights_phong_vertex:\"#ifndef PHONG_PER_PIXEL\\n#if MAX_POINT_LIGHTS > 0\\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\\nfloat lDistance = 1.0;\\nif ( pointLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\nvPointLight[ i ] = vec4( lVector, lDistance );\\n}\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\\nfloat lDistance = 1.0;\\nif ( spotLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\\nvSpotLight[ i ] = vec4( lVector, lDistance );\\n}\\n#endif\\n#endif\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\\nvWorldPosition = worldPosition.xyz;\\n#endif\",\nlights_phong_pars_fragment:\"uniform vec3 ambientLightColor;\\n#if MAX_DIR_LIGHTS > 0\\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n#ifdef PHONG_PER_PIXEL\\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n#else\\nvarying vec4 vPointLight[ MAX_POINT_LIGHTS ];\\n#endif\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n#ifdef PHONG_PER_PIXEL\\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n#else\\nvarying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];\\n#endif\\n#endif\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )\\nvarying vec3 vWorldPosition;\\n#endif\\n#ifdef WRAP_AROUND\\nuniform vec3 wrapRGB;\\n#endif\\nvarying vec3 vViewPosition;\\nvarying vec3 vNormal;\",\nlights_phong_fragment:\"vec3 normal = normalize( vNormal );\\nvec3 viewPosition = normalize( vViewPosition );\\n#ifdef DOUBLE_SIDED\\nnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n#endif\\n#ifdef USE_NORMALMAP\\nnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\nnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\nvec3 pointDiffuse  = vec3( 0.0 );\\nvec3 pointSpecular = vec3( 0.0 );\\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n#ifdef PHONG_PER_PIXEL\\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\nfloat lDistance = 1.0;\\nif ( pointLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\nlVector = normalize( lVector );\\n#else\\nvec3 lVector = normalize( vPointLight[ i ].xyz );\\nfloat lDistance = vPointLight[ i ].w;\\n#endif\\nfloat dotProduct = dot( normal, lVector );\\n#ifdef WRAP_AROUND\\nfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\\nfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n#else\\nfloat pointDiffuseWeight = max( dotProduct, 0.0 );\\n#endif\\npointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\\nvec3 pointHalfVector = normalize( lVector + viewPosition );\\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\nfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );\\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\\n}\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nvec3 spotDiffuse  = vec3( 0.0 );\\nvec3 spotSpecular = vec3( 0.0 );\\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n#ifdef PHONG_PER_PIXEL\\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\nfloat lDistance = 1.0;\\nif ( spotLightDistance[ i ] > 0.0 )\\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\\nlVector = normalize( lVector );\\n#else\\nvec3 lVector = normalize( vSpotLight[ i ].xyz );\\nfloat lDistance = vSpotLight[ i ].w;\\n#endif\\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\\nif ( spotEffect > spotLightAngleCos[ i ] ) {\\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\\nfloat dotProduct = dot( normal, lVector );\\n#ifdef WRAP_AROUND\\nfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\\nfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\\n#else\\nfloat spotDiffuseWeight = max( dotProduct, 0.0 );\\n#endif\\nspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\\nvec3 spotHalfVector = normalize( lVector + viewPosition );\\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\\nfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );\\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\\n}\\n}\\n#endif\\n#if MAX_DIR_LIGHTS > 0\\nvec3 dirDiffuse  = vec3( 0.0 );\\nvec3 dirSpecular = vec3( 0.0 );\\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\nvec3 dirVector = normalize( lDirection.xyz );\\nfloat dotProduct = dot( normal, dirVector );\\n#ifdef WRAP_AROUND\\nfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\\nfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\nvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\\n#else\\nfloat dirDiffuseWeight = max( dotProduct, 0.0 );\\n#endif\\ndirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\nfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n}\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nvec3 hemiDiffuse  = vec3( 0.0 );\\nvec3 hemiSpecular = vec3( 0.0 );\\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\\nvec3 lVector = normalize( lDirection.xyz );\\nfloat dotProduct = dot( normal, lVector );\\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\nhemiDiffuse += diffuse * hemiColor;\\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\\nfloat hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\\nvec3 lVectorGround = -lVector;\\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\\nfloat hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\\nfloat dotProductGround = dot( normal, lVectorGround );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\\n}\\n#endif\\nvec3 totalDiffuse = vec3( 0.0 );\\nvec3 totalSpecular = vec3( 0.0 );\\n#if MAX_DIR_LIGHTS > 0\\ntotalDiffuse += dirDiffuse;\\ntotalSpecular += dirSpecular;\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\ntotalDiffuse += hemiDiffuse;\\ntotalSpecular += hemiSpecular;\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\ntotalDiffuse += pointDiffuse;\\ntotalSpecular += pointSpecular;\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\ntotalDiffuse += spotDiffuse;\\ntotalSpecular += spotSpecular;\\n#endif\\n#ifdef METAL\\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\\n#else\\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\\n#endif\",\ncolor_pars_fragment:\"#ifdef USE_COLOR\\nvarying vec3 vColor;\\n#endif\",color_fragment:\"#ifdef USE_COLOR\\ngl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\\n#endif\",color_pars_vertex:\"#ifdef USE_COLOR\\nvarying vec3 vColor;\\n#endif\",color_vertex:\"#ifdef USE_COLOR\\n#ifdef GAMMA_INPUT\\nvColor = color * color;\\n#else\\nvColor = color;\\n#endif\\n#endif\",skinning_pars_vertex:\"#ifdef USE_SKINNING\\n#ifdef BONE_TEXTURE\\nuniform sampler2D boneTexture;\\nuniform int boneTextureWidth;\\nuniform int boneTextureHeight;\\nmat4 getBoneMatrix( const in float i ) {\\nfloat j = i * 4.0;\\nfloat x = mod( j, float( boneTextureWidth ) );\\nfloat y = floor( j / float( boneTextureWidth ) );\\nfloat dx = 1.0 / float( boneTextureWidth );\\nfloat dy = 1.0 / float( boneTextureHeight );\\ny = dy * ( y + 0.5 );\\nvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\nvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\nvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\nvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\nmat4 bone = mat4( v1, v2, v3, v4 );\\nreturn bone;\\n}\\n#else\\nuniform mat4 boneGlobalMatrices[ MAX_BONES ];\\nmat4 getBoneMatrix( const in float i ) {\\nmat4 bone = boneGlobalMatrices[ int(i) ];\\nreturn bone;\\n}\\n#endif\\n#endif\",\nskinbase_vertex:\"#ifdef USE_SKINNING\\nmat4 boneMatX = getBoneMatrix( skinIndex.x );\\nmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n#endif\",skinning_vertex:\"#ifdef USE_SKINNING\\n#ifdef USE_MORPHTARGETS\\nvec4 skinVertex = vec4( morphed, 1.0 );\\n#else\\nvec4 skinVertex = vec4( position, 1.0 );\\n#endif\\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\\nskinned \\t  += boneMatY * skinVertex * skinWeight.y;\\n#endif\",morphtarget_pars_vertex:\"#ifdef USE_MORPHTARGETS\\n#ifndef USE_MORPHNORMALS\\nuniform float morphTargetInfluences[ 8 ];\\n#else\\nuniform float morphTargetInfluences[ 4 ];\\n#endif\\n#endif\",\nmorphtarget_vertex:\"#ifdef USE_MORPHTARGETS\\nvec3 morphed = vec3( 0.0 );\\nmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\nmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\nmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\nmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n#ifndef USE_MORPHNORMALS\\nmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\nmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\nmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\nmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n#endif\\nmorphed += position;\\n#endif\",\ndefault_vertex:\"vec4 mvPosition;\\n#ifdef USE_SKINNING\\nmvPosition = modelViewMatrix * skinned;\\n#endif\\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\\nmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\\n#endif\\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\\nmvPosition = modelViewMatrix * vec4( position, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\",morphnormal_vertex:\"#ifdef USE_MORPHNORMALS\\nvec3 morphedNormal = vec3( 0.0 );\\nmorphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\nmorphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\nmorphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\nmorphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\nmorphedNormal += normal;\\n#endif\",\nskinnormal_vertex:\"#ifdef USE_SKINNING\\nmat4 skinMatrix = skinWeight.x * boneMatX;\\nskinMatrix \\t+= skinWeight.y * boneMatY;\\n#ifdef USE_MORPHNORMALS\\nvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\\n#else\\nvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\\n#endif\\n#endif\",defaultnormal_vertex:\"vec3 objectNormal;\\n#ifdef USE_SKINNING\\nobjectNormal = skinnedNormal.xyz;\\n#endif\\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\\nobjectNormal = morphedNormal;\\n#endif\\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\\nobjectNormal = normal;\\n#endif\\n#ifdef FLIP_SIDED\\nobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\",\nshadowmap_pars_fragment:\"#ifdef USE_SHADOWMAP\\nuniform sampler2D shadowMap[ MAX_SHADOWS ];\\nuniform vec2 shadowMapSize[ MAX_SHADOWS ];\\nuniform float shadowDarkness[ MAX_SHADOWS ];\\nuniform float shadowBias[ MAX_SHADOWS ];\\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\nfloat unpackDepth( const in vec4 rgba_depth ) {\\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\nfloat depth = dot( rgba_depth, bit_shift );\\nreturn depth;\\n}\\n#endif\",shadowmap_fragment:\"#ifdef USE_SHADOWMAP\\n#ifdef SHADOWMAP_DEBUG\\nvec3 frustumColors[3];\\nfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\\nfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\\nfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\\n#endif\\n#ifdef SHADOWMAP_CASCADE\\nint inFrustumCount = 0;\\n#endif\\nfloat fDepth;\\nvec3 shadowColor = vec3( 1.0 );\\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\nvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\\nbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\nbool inFrustum = all( inFrustumVec );\\n#ifdef SHADOWMAP_CASCADE\\ninFrustumCount += int( inFrustum );\\nbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\\n#else\\nbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n#endif\\nbool frustumTest = all( frustumTestVec );\\nif ( frustumTest ) {\\nshadowCoord.z += shadowBias[ i ];\\n#if defined( SHADOWMAP_TYPE_PCF )\\nfloat shadow = 0.0;\\nconst float shadowDelta = 1.0 / 9.0;\\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\nfloat dx0 = -1.25 * xPixelOffset;\\nfloat dy0 = -1.25 * yPixelOffset;\\nfloat dx1 = 1.25 * xPixelOffset;\\nfloat dy1 = 1.25 * yPixelOffset;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\nfloat shadow = 0.0;\\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\nfloat dx0 = -1.0 * xPixelOffset;\\nfloat dy0 = -1.0 * yPixelOffset;\\nfloat dx1 = 1.0 * xPixelOffset;\\nfloat dy1 = 1.0 * yPixelOffset;\\nmat3 shadowKernel;\\nmat3 depthKernel;\\ndepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\ndepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\ndepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\ndepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\ndepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\ndepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\ndepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\ndepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\ndepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\nvec3 shadowZ = vec3( shadowCoord.z );\\nshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\\nshadowKernel[0] *= vec3(0.25);\\nshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\\nshadowKernel[1] *= vec3(0.25);\\nshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\\nshadowKernel[2] *= vec3(0.25);\\nvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\\nshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\\nshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\\nvec4 shadowValues;\\nshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\\nshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\\nshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\\nshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\\nshadow = dot( shadowValues, vec4( 1.0 ) );\\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n#else\\nvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\\nfloat fDepth = unpackDepth( rgbaDepth );\\nif ( fDepth < shadowCoord.z )\\nshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\\n#endif\\n}\\n#ifdef SHADOWMAP_DEBUG\\n#ifdef SHADOWMAP_CASCADE\\nif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\\n#else\\nif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\\n#endif\\n#endif\\n}\\n#ifdef GAMMA_OUTPUT\\nshadowColor *= shadowColor;\\n#endif\\ngl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\\n#endif\",\nshadowmap_pars_vertex:\"#ifdef USE_SHADOWMAP\\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\\nuniform mat4 shadowMatrix[ MAX_SHADOWS ];\\n#endif\",shadowmap_vertex:\"#ifdef USE_SHADOWMAP\\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\\n}\\n#endif\",alphatest_fragment:\"#ifdef ALPHATEST\\nif ( gl_FragColor.a < ALPHATEST ) discard;\\n#endif\",linear_to_gamma_fragment:\"#ifdef GAMMA_OUTPUT\\ngl_FragColor.xyz = sqrt( gl_FragColor.xyz );\\n#endif\"};THREE.UniformsUtils={merge:function(a){var b,c,d,e={};for(b=0;b<a.length;b++)for(c in d=this.clone(a[b]),d)e[c]=d[c];return e},clone:function(a){var b,c,d,e={};for(b in a)for(c in e[b]={},a[b])d=a[b][c],e[b][c]=d instanceof THREE.Color||d instanceof THREE.Vector2||d instanceof THREE.Vector3||d instanceof THREE.Vector4||d instanceof THREE.Matrix4||d instanceof THREE.Texture?d.clone():d instanceof Array?d.slice():d;return e}};THREE.UniformsLib={common:{diffuse:{type:\"c\",value:new THREE.Color(15658734)},opacity:{type:\"f\",value:1},map:{type:\"t\",value:null},offsetRepeat:{type:\"v4\",value:new THREE.Vector4(0,0,1,1)},lightMap:{type:\"t\",value:null},specularMap:{type:\"t\",value:null},envMap:{type:\"t\",value:null},flipEnvMap:{type:\"f\",value:-1},useRefract:{type:\"i\",value:0},reflectivity:{type:\"f\",value:1},refractionRatio:{type:\"f\",value:0.98},combine:{type:\"i\",value:0},morphTargetInfluences:{type:\"f\",value:0}},bump:{bumpMap:{type:\"t\",\nvalue:null},bumpScale:{type:\"f\",value:1}},normalmap:{normalMap:{type:\"t\",value:null},normalScale:{type:\"v2\",value:new THREE.Vector2(1,1)}},fog:{fogDensity:{type:\"f\",value:2.5E-4},fogNear:{type:\"f\",value:1},fogFar:{type:\"f\",value:2E3},fogColor:{type:\"c\",value:new THREE.Color(16777215)}},lights:{ambientLightColor:{type:\"fv\",value:[]},directionalLightDirection:{type:\"fv\",value:[]},directionalLightColor:{type:\"fv\",value:[]},hemisphereLightDirection:{type:\"fv\",value:[]},hemisphereLightSkyColor:{type:\"fv\",\nvalue:[]},hemisphereLightGroundColor:{type:\"fv\",value:[]},pointLightColor:{type:\"fv\",value:[]},pointLightPosition:{type:\"fv\",value:[]},pointLightDistance:{type:\"fv1\",value:[]},spotLightColor:{type:\"fv\",value:[]},spotLightPosition:{type:\"fv\",value:[]},spotLightDirection:{type:\"fv\",value:[]},spotLightDistance:{type:\"fv1\",value:[]},spotLightAngleCos:{type:\"fv1\",value:[]},spotLightExponent:{type:\"fv1\",value:[]}},particle:{psColor:{type:\"c\",value:new THREE.Color(15658734)},opacity:{type:\"f\",value:1},size:{type:\"f\",\nvalue:1},scale:{type:\"f\",value:1},map:{type:\"t\",value:null},fogDensity:{type:\"f\",value:2.5E-4},fogNear:{type:\"f\",value:1},fogFar:{type:\"f\",value:2E3},fogColor:{type:\"c\",value:new THREE.Color(16777215)}},shadowmap:{shadowMap:{type:\"tv\",value:[]},shadowMapSize:{type:\"v2v\",value:[]},shadowBias:{type:\"fv1\",value:[]},shadowDarkness:{type:\"fv1\",value:[]},shadowMatrix:{type:\"m4v\",value:[]}}};THREE.ShaderLib={basic:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,THREE.UniformsLib.shadowmap]),vertexShader:[THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,\"void main() {\",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,\nTHREE.ShaderChunk.skinbase_vertex,\"#ifdef USE_ENVMAP\",THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,\"#endif\",THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.shadowmap_vertex,\"}\"].join(\"\\n\"),fragmentShader:[\"uniform vec3 diffuse;\\nuniform float opacity;\",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,\nTHREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,\"void main() {\\ngl_FragColor = vec4( diffuse, opacity );\",THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,THREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,\nTHREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,\"}\"].join(\"\\n\")},lambert:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{ambient:{type:\"c\",value:new THREE.Color(16777215)},emissive:{type:\"c\",value:new THREE.Color(0)},wrapRGB:{type:\"v3\",value:new THREE.Vector3(1,1,1)}}]),vertexShader:[\"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\nvarying vec3 vLightBack;\\n#endif\",\nTHREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.lights_lambert_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,\"void main() {\",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,\nTHREE.ShaderChunk.defaultnormal_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.lights_lambert_vertex,THREE.ShaderChunk.shadowmap_vertex,\"}\"].join(\"\\n\"),fragmentShader:[\"uniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\nvarying vec3 vLightBack;\\n#endif\",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,\nTHREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,\"void main() {\\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,\"#ifdef DOUBLE_SIDED\\nif ( gl_FrontFacing )\\ngl_FragColor.xyz *= vLightFront;\\nelse\\ngl_FragColor.xyz *= vLightBack;\\n#else\\ngl_FragColor.xyz *= vLightFront;\\n#endif\",THREE.ShaderChunk.lightmap_fragment,\nTHREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,\"}\"].join(\"\\n\")},phong:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.bump,THREE.UniformsLib.normalmap,THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{ambient:{type:\"c\",value:new THREE.Color(16777215)},emissive:{type:\"c\",value:new THREE.Color(0)},specular:{type:\"c\",\nvalue:new THREE.Color(1118481)},shininess:{type:\"f\",value:30},wrapRGB:{type:\"v3\",value:new THREE.Vector3(1,1,1)}}]),vertexShader:[\"#define PHONG\\nvarying vec3 vViewPosition;\\nvarying vec3 vNormal;\",THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.lights_phong_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,\n\"void main() {\",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,\"vNormal = normalize( transformedNormal );\",THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,\"vViewPosition = -mvPosition.xyz;\",THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,\nTHREE.ShaderChunk.lights_phong_vertex,THREE.ShaderChunk.shadowmap_vertex,\"}\"].join(\"\\n\"),fragmentShader:[\"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform vec3 ambient;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.lights_phong_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,\nTHREE.ShaderChunk.bumpmap_pars_fragment,THREE.ShaderChunk.normalmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,\"void main() {\\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );\",THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,THREE.ShaderChunk.lights_phong_fragment,THREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,\nTHREE.ShaderChunk.fog_fragment,\"}\"].join(\"\\n\")},particle_basic:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.particle,THREE.UniformsLib.shadowmap]),vertexShader:[\"uniform float size;\\nuniform float scale;\",THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,\"void main() {\",THREE.ShaderChunk.color_vertex,\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n#ifdef USE_SIZEATTENUATION\\ngl_PointSize = size * ( scale / length( mvPosition.xyz ) );\\n#else\\ngl_PointSize = size;\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\",\nTHREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.shadowmap_vertex,\"}\"].join(\"\\n\"),fragmentShader:[\"uniform vec3 psColor;\\nuniform float opacity;\",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_particle_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,\"void main() {\\ngl_FragColor = vec4( psColor, opacity );\",THREE.ShaderChunk.map_particle_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.shadowmap_fragment,\nTHREE.ShaderChunk.fog_fragment,\"}\"].join(\"\\n\")},dashed:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,{scale:{type:\"f\",value:1},dashSize:{type:\"f\",value:1},totalSize:{type:\"f\",value:2}}]),vertexShader:[\"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\",THREE.ShaderChunk.color_pars_vertex,\"void main() {\",THREE.ShaderChunk.color_vertex,\"vLineDistance = scale * lineDistance;\\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\\n}\"].join(\"\\n\"),\nfragmentShader:[\"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,\"void main() {\\nif ( mod( vLineDistance, totalSize ) > dashSize ) {\\ndiscard;\\n}\\ngl_FragColor = vec4( diffuse, opacity );\",THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.fog_fragment,\"}\"].join(\"\\n\")},depth:{uniforms:{mNear:{type:\"f\",value:1},mFar:{type:\"f\",value:2E3},opacity:{type:\"f\",\nvalue:1}},vertexShader:\"void main() {\\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"uniform float mNear;\\nuniform float mFar;\\nuniform float opacity;\\nvoid main() {\\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\nfloat color = 1.0 - smoothstep( mNear, mFar, depth );\\ngl_FragColor = vec4( vec3( color ), opacity );\\n}\"},normal:{uniforms:{opacity:{type:\"f\",value:1}},vertexShader:[\"varying vec3 vNormal;\",THREE.ShaderChunk.morphtarget_pars_vertex,\"void main() {\\nvNormal = normalize( normalMatrix * normal );\",\nTHREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.default_vertex,\"}\"].join(\"\\n\"),fragmentShader:\"uniform float opacity;\\nvarying vec3 vNormal;\\nvoid main() {\\ngl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\\n}\"},normalmap:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{enableAO:{type:\"i\",value:0},enableDiffuse:{type:\"i\",value:0},enableSpecular:{type:\"i\",value:0},enableReflection:{type:\"i\",value:0},enableDisplacement:{type:\"i\",\nvalue:0},tDisplacement:{type:\"t\",value:null},tDiffuse:{type:\"t\",value:null},tCube:{type:\"t\",value:null},tNormal:{type:\"t\",value:null},tSpecular:{type:\"t\",value:null},tAO:{type:\"t\",value:null},uNormalScale:{type:\"v2\",value:new THREE.Vector2(1,1)},uDisplacementBias:{type:\"f\",value:0},uDisplacementScale:{type:\"f\",value:1},diffuse:{type:\"c\",value:new THREE.Color(16777215)},specular:{type:\"c\",value:new THREE.Color(1118481)},ambient:{type:\"c\",value:new THREE.Color(16777215)},shininess:{type:\"f\",value:30},\nopacity:{type:\"f\",value:1},useRefract:{type:\"i\",value:0},refractionRatio:{type:\"f\",value:0.98},reflectivity:{type:\"f\",value:0.5},uOffset:{type:\"v2\",value:new THREE.Vector2(0,0)},uRepeat:{type:\"v2\",value:new THREE.Vector2(1,1)},wrapRGB:{type:\"v3\",value:new THREE.Vector3(1,1,1)}}]),fragmentShader:[\"uniform vec3 ambient;\\nuniform vec3 diffuse;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\nuniform bool enableDiffuse;\\nuniform bool enableSpecular;\\nuniform bool enableAO;\\nuniform bool enableReflection;\\nuniform sampler2D tDiffuse;\\nuniform sampler2D tNormal;\\nuniform sampler2D tSpecular;\\nuniform sampler2D tAO;\\nuniform samplerCube tCube;\\nuniform vec2 uNormalScale;\\nuniform bool useRefract;\\nuniform float refractionRatio;\\nuniform float reflectivity;\\nvarying vec3 vTangent;\\nvarying vec3 vBinormal;\\nvarying vec3 vNormal;\\nvarying vec2 vUv;\\nuniform vec3 ambientLightColor;\\n#if MAX_DIR_LIGHTS > 0\\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n#endif\\n#ifdef WRAP_AROUND\\nuniform vec3 wrapRGB;\\n#endif\\nvarying vec3 vWorldPosition;\\nvarying vec3 vViewPosition;\",\nTHREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,\"void main() {\\ngl_FragColor = vec4( vec3( 1.0 ), opacity );\\nvec3 specularTex = vec3( 1.0 );\\nvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\\nnormalTex.xy *= uNormalScale;\\nnormalTex = normalize( normalTex );\\nif( enableDiffuse ) {\\n#ifdef GAMMA_INPUT\\nvec4 texelColor = texture2D( tDiffuse, vUv );\\ntexelColor.xyz *= texelColor.xyz;\\ngl_FragColor = gl_FragColor * texelColor;\\n#else\\ngl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\\n#endif\\n}\\nif( enableAO ) {\\n#ifdef GAMMA_INPUT\\nvec4 aoColor = texture2D( tAO, vUv );\\naoColor.xyz *= aoColor.xyz;\\ngl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\\n#else\\ngl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\\n#endif\\n}\\nif( enableSpecular )\\nspecularTex = texture2D( tSpecular, vUv ).xyz;\\nmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\\nvec3 finalNormal = tsb * normalTex;\\n#ifdef FLIP_SIDED\\nfinalNormal = -finalNormal;\\n#endif\\nvec3 normal = normalize( finalNormal );\\nvec3 viewPosition = normalize( vViewPosition );\\n#if MAX_POINT_LIGHTS > 0\\nvec3 pointDiffuse = vec3( 0.0 );\\nvec3 pointSpecular = vec3( 0.0 );\\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\nvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\\nfloat pointDistance = 1.0;\\nif ( pointLightDistance[ i ] > 0.0 )\\npointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\\npointVector = normalize( pointVector );\\n#ifdef WRAP_AROUND\\nfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\\nfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n#else\\nfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\\n#endif\\npointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\\nvec3 pointHalfVector = normalize( pointVector + viewPosition );\\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\nfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\\n}\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\nvec3 spotDiffuse = vec3( 0.0 );\\nvec3 spotSpecular = vec3( 0.0 );\\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\nvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\\nfloat spotDistance = 1.0;\\nif ( spotLightDistance[ i ] > 0.0 )\\nspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\\nspotVector = normalize( spotVector );\\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\\nif ( spotEffect > spotLightAngleCos[ i ] ) {\\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\\n#ifdef WRAP_AROUND\\nfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\\nfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\\n#else\\nfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\\n#endif\\nspotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\\nvec3 spotHalfVector = normalize( spotVector + viewPosition );\\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\\nfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\\n}\\n}\\n#endif\\n#if MAX_DIR_LIGHTS > 0\\nvec3 dirDiffuse = vec3( 0.0 );\\nvec3 dirSpecular = vec3( 0.0 );\\nfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\nvec3 dirVector = normalize( lDirection.xyz );\\n#ifdef WRAP_AROUND\\nfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\\nfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\\nvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\\n#else\\nfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\\n#endif\\ndirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\nfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n}\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\nvec3 hemiDiffuse  = vec3( 0.0 );\\nvec3 hemiSpecular = vec3( 0.0 );\\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\\nvec3 lVector = normalize( lDirection.xyz );\\nfloat dotProduct = dot( normal, lVector );\\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\nhemiDiffuse += diffuse * hemiColor;\\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\\nfloat hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\\nvec3 lVectorGround = -lVector;\\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\\nfloat hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\\nfloat dotProductGround = dot( normal, lVectorGround );\\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\\n}\\n#endif\\nvec3 totalDiffuse = vec3( 0.0 );\\nvec3 totalSpecular = vec3( 0.0 );\\n#if MAX_DIR_LIGHTS > 0\\ntotalDiffuse += dirDiffuse;\\ntotalSpecular += dirSpecular;\\n#endif\\n#if MAX_HEMI_LIGHTS > 0\\ntotalDiffuse += hemiDiffuse;\\ntotalSpecular += hemiSpecular;\\n#endif\\n#if MAX_POINT_LIGHTS > 0\\ntotalDiffuse += pointDiffuse;\\ntotalSpecular += pointSpecular;\\n#endif\\n#if MAX_SPOT_LIGHTS > 0\\ntotalDiffuse += spotDiffuse;\\ntotalSpecular += spotSpecular;\\n#endif\\n#ifdef METAL\\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\\n#else\\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\\n#endif\\nif ( enableReflection ) {\\nvec3 vReflect;\\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\nif ( useRefract ) {\\nvReflect = refract( cameraToVertex, normal, refractionRatio );\\n} else {\\nvReflect = reflect( cameraToVertex, normal );\\n}\\nvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\\n#ifdef GAMMA_INPUT\\ncubeColor.xyz *= cubeColor.xyz;\\n#endif\\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\\n}\",\nTHREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,\"}\"].join(\"\\n\"),vertexShader:[\"attribute vec4 tangent;\\nuniform vec2 uOffset;\\nuniform vec2 uRepeat;\\nuniform bool enableDisplacement;\\n#ifdef VERTEX_TEXTURES\\nuniform sampler2D tDisplacement;\\nuniform float uDisplacementScale;\\nuniform float uDisplacementBias;\\n#endif\\nvarying vec3 vTangent;\\nvarying vec3 vBinormal;\\nvarying vec3 vNormal;\\nvarying vec2 vUv;\\nvarying vec3 vWorldPosition;\\nvarying vec3 vViewPosition;\",\nTHREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,\"void main() {\",THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,\"#ifdef USE_SKINNING\\nvNormal = normalize( normalMatrix * skinnedNormal.xyz );\\nvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\\nvTangent = normalize( normalMatrix * skinnedTangent.xyz );\\n#else\\nvNormal = normalize( normalMatrix * normal );\\nvTangent = normalize( normalMatrix * tangent.xyz );\\n#endif\\nvBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\\nvUv = uv * uRepeat + uOffset;\\nvec3 displacedPosition;\\n#ifdef VERTEX_TEXTURES\\nif ( enableDisplacement ) {\\nvec3 dv = texture2D( tDisplacement, uv ).xyz;\\nfloat df = uDisplacementScale * dv.x + uDisplacementBias;\\ndisplacedPosition = position + normalize( normal ) * df;\\n} else {\\n#ifdef USE_SKINNING\\nvec4 skinVertex = vec4( position, 1.0 );\\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\\nskinned \\t  += boneMatY * skinVertex * skinWeight.y;\\ndisplacedPosition  = skinned.xyz;\\n#else\\ndisplacedPosition = position;\\n#endif\\n}\\n#else\\n#ifdef USE_SKINNING\\nvec4 skinVertex = vec4( position, 1.0 );\\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\\nskinned \\t  += boneMatY * skinVertex * skinWeight.y;\\ndisplacedPosition  = skinned.xyz;\\n#else\\ndisplacedPosition = position;\\n#endif\\n#endif\\nvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\\nvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\\ngl_Position = projectionMatrix * mvPosition;\\nvWorldPosition = worldPosition.xyz;\\nvViewPosition = -mvPosition.xyz;\\n#ifdef USE_SHADOWMAP\\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\\n}\\n#endif\\n}\"].join(\"\\n\")},\ncube:{uniforms:{tCube:{type:\"t\",value:null},tFlip:{type:\"f\",value:-1}},vertexShader:\"varying vec3 vWorldPosition;\\nvoid main() {\\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\nvWorldPosition = worldPosition.xyz;\\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\",fragmentShader:\"uniform samplerCube tCube;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\nvoid main() {\\ngl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n}\"},\ndepthRGBA:{uniforms:{},vertexShader:[THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,\"void main() {\",THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,\"}\"].join(\"\\n\"),fragmentShader:\"vec4 pack_depth( const in float depth ) {\\nconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\\nconst vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\\nvec4 res = fract( depth * bit_shift );\\nres -= res.xxyz * bit_mask;\\nreturn res;\\n}\\nvoid main() {\\ngl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\\n}\"}};THREE.WebGLRenderer=function(a){function b(a,b){var c=a.vertices.length,d=b.material;if(d.attributes){void 0===a.__webglCustomAttributesList&&(a.__webglCustomAttributesList=[]);for(var e in d.attributes){var f=d.attributes[e];if(!f.__webglInitialized||f.createUniqueBuffers){f.__webglInitialized=!0;var g=1;\"v2\"===f.type?g=2:\"v3\"===f.type?g=3:\"v4\"===f.type?g=4:\"c\"===f.type&&(g=3);f.size=g;f.array=new Float32Array(c*g);f.buffer=j.createBuffer();f.buffer.belongsToAttribute=e;f.needsUpdate=!0}a.__webglCustomAttributesList.push(f)}}}\nfunction c(a,b){var c=b.geometry,g=a.faces3,h=3*g.length,i=1*g.length,k=3*g.length,g=d(b,a),l=f(g),m=e(g),n=g.vertexColors?g.vertexColors:!1;a.__vertexArray=new Float32Array(3*h);m&&(a.__normalArray=new Float32Array(3*h));c.hasTangents&&(a.__tangentArray=new Float32Array(4*h));n&&(a.__colorArray=new Float32Array(3*h));l&&(0<c.faceVertexUvs.length&&(a.__uvArray=new Float32Array(2*h)),1<c.faceVertexUvs.length&&(a.__uv2Array=new Float32Array(2*h)));b.geometry.skinWeights.length&&b.geometry.skinIndices.length&&\n(a.__skinIndexArray=new Float32Array(4*h),a.__skinWeightArray=new Float32Array(4*h));a.__faceArray=new Uint16Array(3*i);a.__lineArray=new Uint16Array(2*k);if(a.numMorphTargets){a.__morphTargetsArrays=[];c=0;for(l=a.numMorphTargets;c<l;c++)a.__morphTargetsArrays.push(new Float32Array(3*h))}if(a.numMorphNormals){a.__morphNormalsArrays=[];c=0;for(l=a.numMorphNormals;c<l;c++)a.__morphNormalsArrays.push(new Float32Array(3*h))}a.__webglFaceCount=3*i;a.__webglLineCount=2*k;if(g.attributes){void 0===a.__webglCustomAttributesList&&\n(a.__webglCustomAttributesList=[]);for(var p in g.attributes){var i=g.attributes[p],k={},q;for(q in i)k[q]=i[q];if(!k.__webglInitialized||k.createUniqueBuffers)k.__webglInitialized=!0,c=1,\"v2\"===k.type?c=2:\"v3\"===k.type?c=3:\"v4\"===k.type?c=4:\"c\"===k.type&&(c=3),k.size=c,k.array=new Float32Array(h*c),k.buffer=j.createBuffer(),k.buffer.belongsToAttribute=p,i.needsUpdate=!0,k.__original=i;a.__webglCustomAttributesList.push(k)}}a.__inittedArrays=!0}function d(a,b){return a.material instanceof THREE.MeshFaceMaterial?\na.material.materials[b.materialIndex]:a.material}function e(a){return a instanceof THREE.MeshBasicMaterial&&!a.envMap||a instanceof THREE.MeshDepthMaterial?!1:a&&void 0!==a.shading&&a.shading===THREE.SmoothShading?THREE.SmoothShading:THREE.FlatShading}function f(a){return a.map||a.lightMap||a.bumpMap||a.normalMap||a.specularMap||a instanceof THREE.ShaderMaterial?!0:!1}function g(a){Ma[a]||(j.enableVertexAttribArray(a),Ma[a]=!0)}function h(){for(var a in Ma)Ma[a]&&(j.disableVertexAttribArray(a),Ma[a]=\n!1)}function i(a,b){return a.z!==b.z?b.z-a.z:a.id-b.id}function k(a,b){return b[0]-a[0]}function l(a,b,c){if(a.length)for(var d=0,e=a.length;d<e;d++)Ha=oa=null,Ea=za=Aa=sa=wa=ca=ba=-1,Za=!0,a[d].render(b,c,Va,La),Ha=oa=null,Ea=za=Aa=sa=wa=ca=ba=-1,Za=!0}function n(a,b,c,d,e,f,g,h){var j,i,k,l;b?(i=a.length-1,l=b=-1):(i=0,b=a.length,l=1);for(var m=i;m!==b;m+=l)if(j=a[m],j.render){i=j.object;k=j.buffer;if(h)j=h;else{j=j[c];if(!j)continue;g&&I.setBlending(j.blending,j.blendEquation,j.blendSrc,j.blendDst);\nI.setDepthTest(j.depthTest);I.setDepthWrite(j.depthWrite);x(j.polygonOffset,j.polygonOffsetFactor,j.polygonOffsetUnits)}I.setMaterialFaces(j);k instanceof THREE.BufferGeometry?I.renderBufferDirect(d,e,f,j,k,i):I.renderBuffer(d,e,f,j,k,i)}}function p(a,b,c,d,e,f,g){for(var h,j,i=0,k=a.length;i<k;i++)if(h=a[i],j=h.object,j.visible){if(g)h=g;else{h=h[b];if(!h)continue;f&&I.setBlending(h.blending,h.blendEquation,h.blendSrc,h.blendDst);I.setDepthTest(h.depthTest);I.setDepthWrite(h.depthWrite);x(h.polygonOffset,\nh.polygonOffsetFactor,h.polygonOffsetUnits)}I.renderImmediateObject(c,d,e,h,j)}}function t(a,d){var e,f,g,h;if(void 0===a.__webglInit&&(a.__webglInit=!0,a._modelViewMatrix=new THREE.Matrix4,a._normalMatrix=new THREE.Matrix3,void 0!==a.geometry&&void 0===a.geometry.__webglInit&&(a.geometry.__webglInit=!0,a.geometry.addEventListener(\"dispose\",Lb)),f=a.geometry,void 0!==f))if(f instanceof THREE.BufferGeometry){var i,k;for(i in f.attributes)k=\"index\"===i?j.ELEMENT_ARRAY_BUFFER:j.ARRAY_BUFFER,h=f.attributes[i],\nvoid 0===h.numItems&&(h.numItems=h.array.length),h.buffer=j.createBuffer(),j.bindBuffer(k,h.buffer),j.bufferData(k,h.array,j.STATIC_DRAW)}else if(a instanceof THREE.Mesh){g=a.material;if(void 0===f.geometryGroups){i=f;var l,m,n;k={};var p=i.morphTargets.length,q=i.morphNormals.length,t=g instanceof THREE.MeshFaceMaterial;i.geometryGroups={};g=0;for(l=i.faces.length;g<l;g++)m=i.faces[g],m=t?m.materialIndex:0,void 0===k[m]&&(k[m]={hash:m,counter:0}),n=k[m].hash+\"_\"+k[m].counter,void 0===i.geometryGroups[n]&&\n(i.geometryGroups[n]={faces3:[],materialIndex:m,vertices:0,numMorphTargets:p,numMorphNormals:q}),65535<i.geometryGroups[n].vertices+3&&(k[m].counter+=1,n=k[m].hash+\"_\"+k[m].counter,void 0===i.geometryGroups[n]&&(i.geometryGroups[n]={faces3:[],materialIndex:m,vertices:0,numMorphTargets:p,numMorphNormals:q})),i.geometryGroups[n].faces3.push(g),i.geometryGroups[n].vertices+=3;i.geometryGroupsList=[];for(h in i.geometryGroups)i.geometryGroups[h].id=Ta++,i.geometryGroupsList.push(i.geometryGroups[h])}for(e in f.geometryGroups)if(h=\nf.geometryGroups[e],!h.__webglVertexBuffer){i=h;i.__webglVertexBuffer=j.createBuffer();i.__webglNormalBuffer=j.createBuffer();i.__webglTangentBuffer=j.createBuffer();i.__webglColorBuffer=j.createBuffer();i.__webglUVBuffer=j.createBuffer();i.__webglUV2Buffer=j.createBuffer();i.__webglSkinIndicesBuffer=j.createBuffer();i.__webglSkinWeightsBuffer=j.createBuffer();i.__webglFaceBuffer=j.createBuffer();i.__webglLineBuffer=j.createBuffer();p=k=void 0;if(i.numMorphTargets){i.__webglMorphTargetsBuffers=[];\nk=0;for(p=i.numMorphTargets;k<p;k++)i.__webglMorphTargetsBuffers.push(j.createBuffer())}if(i.numMorphNormals){i.__webglMorphNormalsBuffers=[];k=0;for(p=i.numMorphNormals;k<p;k++)i.__webglMorphNormalsBuffers.push(j.createBuffer())}I.info.memory.geometries++;c(h,a);f.verticesNeedUpdate=!0;f.morphTargetsNeedUpdate=!0;f.elementsNeedUpdate=!0;f.uvsNeedUpdate=!0;f.normalsNeedUpdate=!0;f.tangentsNeedUpdate=!0;f.colorsNeedUpdate=!0}}else a instanceof THREE.Line?f.__webglVertexBuffer||(h=f,h.__webglVertexBuffer=\nj.createBuffer(),h.__webglColorBuffer=j.createBuffer(),h.__webglLineDistanceBuffer=j.createBuffer(),I.info.memory.geometries++,h=f,i=h.vertices.length,h.__vertexArray=new Float32Array(3*i),h.__colorArray=new Float32Array(3*i),h.__lineDistanceArray=new Float32Array(1*i),h.__webglLineCount=i,b(h,a),f.verticesNeedUpdate=!0,f.colorsNeedUpdate=!0,f.lineDistancesNeedUpdate=!0):a instanceof THREE.ParticleSystem&&!f.__webglVertexBuffer&&(h=f,h.__webglVertexBuffer=j.createBuffer(),h.__webglColorBuffer=j.createBuffer(),\nI.info.memory.geometries++,h=f,i=h.vertices.length,h.__vertexArray=new Float32Array(3*i),h.__colorArray=new Float32Array(3*i),h.__sortArray=[],h.__webglParticleCount=i,b(h,a),f.verticesNeedUpdate=!0,f.colorsNeedUpdate=!0);if(void 0===a.__webglActive){if(a instanceof THREE.Mesh)if(f=a.geometry,f instanceof THREE.BufferGeometry)r(d.__webglObjects,f,a);else{if(f instanceof THREE.Geometry)for(e in f.geometryGroups)h=f.geometryGroups[e],r(d.__webglObjects,h,a)}else a instanceof THREE.Line||a instanceof\nTHREE.ParticleSystem?(f=a.geometry,r(d.__webglObjects,f,a)):a instanceof THREE.ImmediateRenderObject||a.immediateRenderCallback?d.__webglObjectsImmediate.push({id:null,object:a,opaque:null,transparent:null,z:0}):a instanceof THREE.Sprite?d.__webglSprites.push(a):a instanceof THREE.LensFlare&&d.__webglFlares.push(a);a.__webglActive=!0}}function r(a,b,c){a.push({id:null,buffer:b,object:c,opaque:null,transparent:null,z:0})}function m(a){for(var b in a.attributes)if(a.attributes[b].needsUpdate)return!0;\nreturn!1}function q(a){for(var b in a.attributes)a.attributes[b].needsUpdate=!1}function u(a,b){a instanceof THREE.Mesh||a instanceof THREE.ParticleSystem||a instanceof THREE.Line?s(b.__webglObjects,a):a instanceof THREE.Sprite?v(b.__webglSprites,a):a instanceof THREE.LensFlare?v(b.__webglFlares,a):(a instanceof THREE.ImmediateRenderObject||a.immediateRenderCallback)&&s(b.__webglObjectsImmediate,a);delete a.__webglActive}function s(a,b){for(var c=a.length-1;0<=c;c--)a[c].object===b&&a.splice(c,1)}\nfunction v(a,b){for(var c=a.length-1;0<=c;c--)a[c]===b&&a.splice(c,1)}function z(a,b,c,d,e){Ja=0;d.needsUpdate&&(d.program&&Eb(d),I.initMaterial(d,b,c,e),d.needsUpdate=!1);d.morphTargets&&!e.__webglMorphTargetInfluences&&(e.__webglMorphTargetInfluences=new Float32Array(I.maxMorphTargets));var f=!1,g=d.program,h=g.uniforms,i=d.uniforms;g!==oa&&(j.useProgram(g),oa=g,f=!0);d.id!==Ea&&(Ea=d.id,f=!0);if(f||a!==Ha)j.uniformMatrix4fv(h.projectionMatrix,!1,a.projectionMatrix.elements),a!==Ha&&(Ha=a);if(d.skinning)if(tb&&\ne.useVertexTexture){if(null!==h.boneTexture){var k=G();j.uniform1i(h.boneTexture,k);I.setTexture(e.boneTexture,k)}null!==h.boneTextureWidth&&j.uniform1i(h.boneTextureWidth,e.boneTextureWidth);null!==h.boneTextureHeight&&j.uniform1i(h.boneTextureHeight,e.boneTextureHeight)}else null!==h.boneGlobalMatrices&&j.uniformMatrix4fv(h.boneGlobalMatrices,!1,e.boneMatrices);if(f){c&&d.fog&&(i.fogColor.value=c.color,c instanceof THREE.Fog?(i.fogNear.value=c.near,i.fogFar.value=c.far):c instanceof THREE.FogExp2&&\n(i.fogDensity.value=c.density));if(d instanceof THREE.MeshPhongMaterial||d instanceof THREE.MeshLambertMaterial||d.lights){if(Za){for(var l,m=k=0,n=0,p,q,t,r=Na,s=r.directional.colors,u=r.directional.positions,v=r.point.colors,z=r.point.positions,y=r.point.distances,x=r.spot.colors,B=r.spot.positions,F=r.spot.distances,E=r.spot.directions,L=r.spot.anglesCos,A=r.spot.exponents,O=r.hemi.skyColors,Q=r.hemi.groundColors,K=r.hemi.positions,P=0,W=0,T=0,va=0,sa=0,Y=0,Z=0,X=0,U=l=0,c=t=U=0,f=b.length;c<f;c++)l=\nb[c],l.onlyShadow||(p=l.color,q=l.intensity,t=l.distance,l instanceof THREE.AmbientLight?l.visible&&(I.gammaInput?(k+=p.r*p.r,m+=p.g*p.g,n+=p.b*p.b):(k+=p.r,m+=p.g,n+=p.b)):l instanceof THREE.DirectionalLight?(sa+=1,l.visible&&(fa.setFromMatrixPosition(l.matrixWorld),ja.setFromMatrixPosition(l.target.matrixWorld),fa.sub(ja),fa.normalize(),0===fa.x&&0===fa.y&&0===fa.z||(l=3*P,u[l]=fa.x,u[l+1]=fa.y,u[l+2]=fa.z,I.gammaInput?N(s,l,p,q*q):C(s,l,p,q),P+=1))):l instanceof THREE.PointLight?(Y+=1,l.visible&&\n(U=3*W,I.gammaInput?N(v,U,p,q*q):C(v,U,p,q),ja.setFromMatrixPosition(l.matrixWorld),z[U]=ja.x,z[U+1]=ja.y,z[U+2]=ja.z,y[W]=t,W+=1)):l instanceof THREE.SpotLight?(Z+=1,l.visible&&(U=3*T,I.gammaInput?N(x,U,p,q*q):C(x,U,p,q),ja.setFromMatrixPosition(l.matrixWorld),B[U]=ja.x,B[U+1]=ja.y,B[U+2]=ja.z,F[T]=t,fa.copy(ja),ja.setFromMatrixPosition(l.target.matrixWorld),fa.sub(ja),fa.normalize(),E[U]=fa.x,E[U+1]=fa.y,E[U+2]=fa.z,L[T]=Math.cos(l.angle),A[T]=l.exponent,T+=1)):l instanceof THREE.HemisphereLight&&\n(X+=1,l.visible&&(fa.setFromMatrixPosition(l.matrixWorld),fa.normalize(),0===fa.x&&0===fa.y&&0===fa.z||(t=3*va,K[t]=fa.x,K[t+1]=fa.y,K[t+2]=fa.z,p=l.color,l=l.groundColor,I.gammaInput?(q*=q,N(O,t,p,q),N(Q,t,l,q)):(C(O,t,p,q),C(Q,t,l,q)),va+=1))));c=3*P;for(f=Math.max(s.length,3*sa);c<f;c++)s[c]=0;c=3*W;for(f=Math.max(v.length,3*Y);c<f;c++)v[c]=0;c=3*T;for(f=Math.max(x.length,3*Z);c<f;c++)x[c]=0;c=3*va;for(f=Math.max(O.length,3*X);c<f;c++)O[c]=0;c=3*va;for(f=Math.max(Q.length,3*X);c<f;c++)Q[c]=0;r.directional.length=\nP;r.point.length=W;r.spot.length=T;r.hemi.length=va;r.ambient[0]=k;r.ambient[1]=m;r.ambient[2]=n;Za=!1}c=Na;i.ambientLightColor.value=c.ambient;i.directionalLightColor.value=c.directional.colors;i.directionalLightDirection.value=c.directional.positions;i.pointLightColor.value=c.point.colors;i.pointLightPosition.value=c.point.positions;i.pointLightDistance.value=c.point.distances;i.spotLightColor.value=c.spot.colors;i.spotLightPosition.value=c.spot.positions;i.spotLightDistance.value=c.spot.distances;\ni.spotLightDirection.value=c.spot.directions;i.spotLightAngleCos.value=c.spot.anglesCos;i.spotLightExponent.value=c.spot.exponents;i.hemisphereLightSkyColor.value=c.hemi.skyColors;i.hemisphereLightGroundColor.value=c.hemi.groundColors;i.hemisphereLightDirection.value=c.hemi.positions}if(d instanceof THREE.MeshBasicMaterial||d instanceof THREE.MeshLambertMaterial||d instanceof THREE.MeshPhongMaterial){i.opacity.value=d.opacity;I.gammaInput?i.diffuse.value.copyGammaToLinear(d.color):i.diffuse.value=\nd.color;i.map.value=d.map;i.lightMap.value=d.lightMap;i.specularMap.value=d.specularMap;d.bumpMap&&(i.bumpMap.value=d.bumpMap,i.bumpScale.value=d.bumpScale);d.normalMap&&(i.normalMap.value=d.normalMap,i.normalScale.value.copy(d.normalScale));var V;d.map?V=d.map:d.specularMap?V=d.specularMap:d.normalMap?V=d.normalMap:d.bumpMap&&(V=d.bumpMap);void 0!==V&&(c=V.offset,V=V.repeat,i.offsetRepeat.value.set(c.x,c.y,V.x,V.y));i.envMap.value=d.envMap;i.flipEnvMap.value=d.envMap instanceof THREE.WebGLRenderTargetCube?\n1:-1;i.reflectivity.value=d.reflectivity;i.refractionRatio.value=d.refractionRatio;i.combine.value=d.combine;i.useRefract.value=d.envMap&&d.envMap.mapping instanceof THREE.CubeRefractionMapping}d instanceof THREE.LineBasicMaterial?(i.diffuse.value=d.color,i.opacity.value=d.opacity):d instanceof THREE.LineDashedMaterial?(i.diffuse.value=d.color,i.opacity.value=d.opacity,i.dashSize.value=d.dashSize,i.totalSize.value=d.dashSize+d.gapSize,i.scale.value=d.scale):d instanceof THREE.ParticleSystemMaterial?\n(i.psColor.value=d.color,i.opacity.value=d.opacity,i.size.value=d.size,i.scale.value=H.height/2,i.map.value=d.map):d instanceof THREE.MeshPhongMaterial?(i.shininess.value=d.shininess,I.gammaInput?(i.ambient.value.copyGammaToLinear(d.ambient),i.emissive.value.copyGammaToLinear(d.emissive),i.specular.value.copyGammaToLinear(d.specular)):(i.ambient.value=d.ambient,i.emissive.value=d.emissive,i.specular.value=d.specular),d.wrapAround&&i.wrapRGB.value.copy(d.wrapRGB)):d instanceof THREE.MeshLambertMaterial?\n(I.gammaInput?(i.ambient.value.copyGammaToLinear(d.ambient),i.emissive.value.copyGammaToLinear(d.emissive)):(i.ambient.value=d.ambient,i.emissive.value=d.emissive),d.wrapAround&&i.wrapRGB.value.copy(d.wrapRGB)):d instanceof THREE.MeshDepthMaterial?(i.mNear.value=a.near,i.mFar.value=a.far,i.opacity.value=d.opacity):d instanceof THREE.MeshNormalMaterial&&(i.opacity.value=d.opacity);if(e.receiveShadow&&!d._shadowPass&&i.shadowMatrix){c=V=0;for(f=b.length;c<f;c++)if(k=b[c],k.castShadow&&(k instanceof\nTHREE.SpotLight||k instanceof THREE.DirectionalLight&&!k.shadowCascade))i.shadowMap.value[V]=k.shadowMap,i.shadowMapSize.value[V]=k.shadowMapSize,i.shadowMatrix.value[V]=k.shadowMatrix,i.shadowDarkness.value[V]=k.shadowDarkness,i.shadowBias.value[V]=k.shadowBias,V++}b=d.uniformsList;i=0;for(V=b.length;i<V;i++)if(f=g.uniforms[b[i][1]])if(c=b[i][0],m=c.type,k=c.value,\"i\"===m)j.uniform1i(f,k);else if(\"f\"===m)j.uniform1f(f,k);else if(\"v2\"===m)j.uniform2f(f,k.x,k.y);else if(\"v3\"===m)j.uniform3f(f,k.x,\nk.y,k.z);else if(\"v4\"===m)j.uniform4f(f,k.x,k.y,k.z,k.w);else if(\"c\"===m)j.uniform3f(f,k.r,k.g,k.b);else if(\"iv1\"===m)j.uniform1iv(f,k);else if(\"iv\"===m)j.uniform3iv(f,k);else if(\"fv1\"===m)j.uniform1fv(f,k);else if(\"fv\"===m)j.uniform3fv(f,k);else if(\"v2v\"===m){void 0===c._array&&(c._array=new Float32Array(2*k.length));m=0;for(n=k.length;m<n;m++)r=2*m,c._array[r]=k[m].x,c._array[r+1]=k[m].y;j.uniform2fv(f,c._array)}else if(\"v3v\"===m){void 0===c._array&&(c._array=new Float32Array(3*k.length));m=0;for(n=\nk.length;m<n;m++)r=3*m,c._array[r]=k[m].x,c._array[r+1]=k[m].y,c._array[r+2]=k[m].z;j.uniform3fv(f,c._array)}else if(\"v4v\"===m){void 0===c._array&&(c._array=new Float32Array(4*k.length));m=0;for(n=k.length;m<n;m++)r=4*m,c._array[r]=k[m].x,c._array[r+1]=k[m].y,c._array[r+2]=k[m].z,c._array[r+3]=k[m].w;j.uniform4fv(f,c._array)}else if(\"m4\"===m)void 0===c._array&&(c._array=new Float32Array(16)),k.flattenToArray(c._array),j.uniformMatrix4fv(f,!1,c._array);else if(\"m4v\"===m){void 0===c._array&&(c._array=\nnew Float32Array(16*k.length));m=0;for(n=k.length;m<n;m++)k[m].flattenToArrayOffset(c._array,16*m);j.uniformMatrix4fv(f,!1,c._array)}else if(\"t\"===m){if(r=k,k=G(),j.uniform1i(f,k),r)if(r.image instanceof Array&&6===r.image.length){if(c=r,f=k,6===c.image.length)if(c.needsUpdate){c.image.__webglTextureCube||(c.addEventListener(\"dispose\",Bb),c.image.__webglTextureCube=j.createTexture(),I.info.memory.textures++);j.activeTexture(j.TEXTURE0+f);j.bindTexture(j.TEXTURE_CUBE_MAP,c.image.__webglTextureCube);\nj.pixelStorei(j.UNPACK_FLIP_Y_WEBGL,c.flipY);f=c instanceof THREE.CompressedTexture;k=[];for(m=0;6>m;m++)I.autoScaleCubemaps&&!f?(n=k,r=m,s=c.image[m],v=Yb,s.width<=v&&s.height<=v||(z=Math.max(s.width,s.height),u=Math.floor(s.width*v/z),v=Math.floor(s.height*v/z),z=document.createElement(\"canvas\"),z.width=u,z.height=v,z.getContext(\"2d\").drawImage(s,0,0,s.width,s.height,0,0,u,v),s=z),n[r]=s):k[m]=c.image[m];m=k[0];n=0===(m.width&m.width-1)&&0===(m.height&m.height-1);r=D(c.format);s=D(c.type);w(j.TEXTURE_CUBE_MAP,\nc,n);for(m=0;6>m;m++)if(f){v=k[m].mipmaps;z=0;for(y=v.length;z<y;z++)u=v[z],c.format!==THREE.RGBAFormat?j.compressedTexImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X+m,z,r,u.width,u.height,0,u.data):j.texImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X+m,z,r,u.width,u.height,0,r,s,u.data)}else j.texImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X+m,0,r,r,s,k[m]);c.generateMipmaps&&n&&j.generateMipmap(j.TEXTURE_CUBE_MAP);c.needsUpdate=!1;if(c.onUpdate)c.onUpdate()}else j.activeTexture(j.TEXTURE0+f),j.bindTexture(j.TEXTURE_CUBE_MAP,\nc.image.__webglTextureCube)}else r instanceof THREE.WebGLRenderTargetCube?(c=r,j.activeTexture(j.TEXTURE0+k),j.bindTexture(j.TEXTURE_CUBE_MAP,c.__webglTexture)):I.setTexture(r,k)}else if(\"tv\"===m){void 0===c._array&&(c._array=[]);m=0;for(n=c.value.length;m<n;m++)c._array[m]=G();j.uniform1iv(f,c._array);m=0;for(n=c.value.length;m<n;m++)r=c.value[m],k=c._array[m],r&&I.setTexture(r,k)}else console.warn(\"THREE.WebGLRenderer: Unknown uniform type: \"+m);if((d instanceof THREE.ShaderMaterial||d instanceof\nTHREE.MeshPhongMaterial||d.envMap)&&null!==h.cameraPosition)ja.setFromMatrixPosition(a.matrixWorld),j.uniform3f(h.cameraPosition,ja.x,ja.y,ja.z);(d instanceof THREE.MeshPhongMaterial||d instanceof THREE.MeshLambertMaterial||d instanceof THREE.ShaderMaterial||d.skinning)&&null!==h.viewMatrix&&j.uniformMatrix4fv(h.viewMatrix,!1,a.matrixWorldInverse.elements)}j.uniformMatrix4fv(h.modelViewMatrix,!1,e._modelViewMatrix.elements);h.normalMatrix&&j.uniformMatrix3fv(h.normalMatrix,!1,e._normalMatrix.elements);\nnull!==h.modelMatrix&&j.uniformMatrix4fv(h.modelMatrix,!1,e.matrixWorld.elements);return g}function G(){var a=Ja;a>=Ab&&console.warn(\"WebGLRenderer: trying to use \"+a+\" texture units while this GPU supports only \"+Ab);Ja+=1;return a}function N(a,b,c,d){a[b]=c.r*c.r*d;a[b+1]=c.g*c.g*d;a[b+2]=c.b*c.b*d}function C(a,b,c,d){a[b]=c.r*d;a[b+1]=c.g*d;a[b+2]=c.b*d}function B(a){a!==ia&&(j.lineWidth(a),ia=a)}function x(a,b,c){Ua!==a&&(a?j.enable(j.POLYGON_OFFSET_FILL):j.disable(j.POLYGON_OFFSET_FILL),Ua=a);\nif(a&&(Oa!==b||la!==c))j.polygonOffset(b,c),Oa=b,la=c}function F(a){for(var a=a.split(\"\\n\"),b=0,c=a.length;b<c;b++)a[b]=b+1+\": \"+a[b];return a.join(\"\\n\")}function L(a,b){var c;\"fragment\"===a?c=j.createShader(j.FRAGMENT_SHADER):\"vertex\"===a&&(c=j.createShader(j.VERTEX_SHADER));j.shaderSource(c,b);j.compileShader(c);return!j.getShaderParameter(c,j.COMPILE_STATUS)?(console.error(j.getShaderInfoLog(c)),console.error(F(b)),null):c}function w(a,b,c){c?(j.texParameteri(a,j.TEXTURE_WRAP_S,D(b.wrapS)),j.texParameteri(a,\nj.TEXTURE_WRAP_T,D(b.wrapT)),j.texParameteri(a,j.TEXTURE_MAG_FILTER,D(b.magFilter)),j.texParameteri(a,j.TEXTURE_MIN_FILTER,D(b.minFilter))):(j.texParameteri(a,j.TEXTURE_WRAP_S,j.CLAMP_TO_EDGE),j.texParameteri(a,j.TEXTURE_WRAP_T,j.CLAMP_TO_EDGE),j.texParameteri(a,j.TEXTURE_MAG_FILTER,y(b.magFilter)),j.texParameteri(a,j.TEXTURE_MIN_FILTER,y(b.minFilter)));if(qa&&b.type!==THREE.FloatType&&(1<b.anisotropy||b.__oldAnisotropy))j.texParameterf(a,qa.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(b.anisotropy,Jb)),b.__oldAnisotropy=\nb.anisotropy}function E(a,b){j.bindRenderbuffer(j.RENDERBUFFER,a);b.depthBuffer&&!b.stencilBuffer?(j.renderbufferStorage(j.RENDERBUFFER,j.DEPTH_COMPONENT16,b.width,b.height),j.framebufferRenderbuffer(j.FRAMEBUFFER,j.DEPTH_ATTACHMENT,j.RENDERBUFFER,a)):b.depthBuffer&&b.stencilBuffer?(j.renderbufferStorage(j.RENDERBUFFER,j.DEPTH_STENCIL,b.width,b.height),j.framebufferRenderbuffer(j.FRAMEBUFFER,j.DEPTH_STENCIL_ATTACHMENT,j.RENDERBUFFER,a)):j.renderbufferStorage(j.RENDERBUFFER,j.RGBA4,b.width,b.height)}\nfunction y(a){return a===THREE.NearestFilter||a===THREE.NearestMipMapNearestFilter||a===THREE.NearestMipMapLinearFilter?j.NEAREST:j.LINEAR}function D(a){if(a===THREE.RepeatWrapping)return j.REPEAT;if(a===THREE.ClampToEdgeWrapping)return j.CLAMP_TO_EDGE;if(a===THREE.MirroredRepeatWrapping)return j.MIRRORED_REPEAT;if(a===THREE.NearestFilter)return j.NEAREST;if(a===THREE.NearestMipMapNearestFilter)return j.NEAREST_MIPMAP_NEAREST;if(a===THREE.NearestMipMapLinearFilter)return j.NEAREST_MIPMAP_LINEAR;if(a===\nTHREE.LinearFilter)return j.LINEAR;if(a===THREE.LinearMipMapNearestFilter)return j.LINEAR_MIPMAP_NEAREST;if(a===THREE.LinearMipMapLinearFilter)return j.LINEAR_MIPMAP_LINEAR;if(a===THREE.UnsignedByteType)return j.UNSIGNED_BYTE;if(a===THREE.UnsignedShort4444Type)return j.UNSIGNED_SHORT_4_4_4_4;if(a===THREE.UnsignedShort5551Type)return j.UNSIGNED_SHORT_5_5_5_1;if(a===THREE.UnsignedShort565Type)return j.UNSIGNED_SHORT_5_6_5;if(a===THREE.ByteType)return j.BYTE;if(a===THREE.ShortType)return j.SHORT;if(a===\nTHREE.UnsignedShortType)return j.UNSIGNED_SHORT;if(a===THREE.IntType)return j.INT;if(a===THREE.UnsignedIntType)return j.UNSIGNED_INT;if(a===THREE.FloatType)return j.FLOAT;if(a===THREE.AlphaFormat)return j.ALPHA;if(a===THREE.RGBFormat)return j.RGB;if(a===THREE.RGBAFormat)return j.RGBA;if(a===THREE.LuminanceFormat)return j.LUMINANCE;if(a===THREE.LuminanceAlphaFormat)return j.LUMINANCE_ALPHA;if(a===THREE.AddEquation)return j.FUNC_ADD;if(a===THREE.SubtractEquation)return j.FUNC_SUBTRACT;if(a===THREE.ReverseSubtractEquation)return j.FUNC_REVERSE_SUBTRACT;\nif(a===THREE.ZeroFactor)return j.ZERO;if(a===THREE.OneFactor)return j.ONE;if(a===THREE.SrcColorFactor)return j.SRC_COLOR;if(a===THREE.OneMinusSrcColorFactor)return j.ONE_MINUS_SRC_COLOR;if(a===THREE.SrcAlphaFactor)return j.SRC_ALPHA;if(a===THREE.OneMinusSrcAlphaFactor)return j.ONE_MINUS_SRC_ALPHA;if(a===THREE.DstAlphaFactor)return j.DST_ALPHA;if(a===THREE.OneMinusDstAlphaFactor)return j.ONE_MINUS_DST_ALPHA;if(a===THREE.DstColorFactor)return j.DST_COLOR;if(a===THREE.OneMinusDstColorFactor)return j.ONE_MINUS_DST_COLOR;\nif(a===THREE.SrcAlphaSaturateFactor)return j.SRC_ALPHA_SATURATE;if(void 0!==ta){if(a===THREE.RGB_S3TC_DXT1_Format)return ta.COMPRESSED_RGB_S3TC_DXT1_EXT;if(a===THREE.RGBA_S3TC_DXT1_Format)return ta.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(a===THREE.RGBA_S3TC_DXT3_Format)return ta.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(a===THREE.RGBA_S3TC_DXT5_Format)return ta.COMPRESSED_RGBA_S3TC_DXT5_EXT}return 0}console.log(\"THREE.WebGLRenderer\",THREE.REVISION);var a=a||{},H=void 0!==a.canvas?a.canvas:document.createElement(\"canvas\"),\nK=void 0!==a.precision?a.precision:\"highp\",A=void 0!==a.alpha?a.alpha:!1,da=void 0!==a.premultipliedAlpha?a.premultipliedAlpha:!0,ha=void 0!==a.antialias?a.antialias:!1,ua=void 0!==a.stencil?a.stencil:!0,O=void 0!==a.preserveDrawingBuffer?a.preserveDrawingBuffer:!1,T=new THREE.Color(0),ea=0;this.domElement=H;this.context=null;this.devicePixelRatio=void 0!==a.devicePixelRatio?a.devicePixelRatio:void 0!==self.devicePixelRatio?self.devicePixelRatio:1;this.autoUpdateObjects=this.sortObjects=this.autoClearStencil=\nthis.autoClearDepth=this.autoClearColor=this.autoClear=!0;this.shadowMapEnabled=this.gammaOutput=this.gammaInput=!1;this.shadowMapAutoUpdate=!0;this.shadowMapType=THREE.PCFShadowMap;this.shadowMapCullFace=THREE.CullFaceFront;this.shadowMapCascade=this.shadowMapDebug=!1;this.maxMorphTargets=8;this.maxMorphNormals=4;this.autoScaleCubemaps=!0;this.renderPluginsPre=[];this.renderPluginsPost=[];this.info={memory:{programs:0,geometries:0,textures:0},render:{calls:0,vertices:0,faces:0,points:0}};var I=this,\nP=[],Q=0,oa=null,va=null,Ea=-1,za=null,Ha=null,Ta=0,Ja=0,sa=-1,Aa=-1,ba=-1,W=-1,Ka=-1,U=-1,ca=-1,wa=-1,Ua=null,Oa=null,la=null,ia=null,Fa=0,Ga=0,Ba=H.width,xa=H.height,Va=0,La=0,Ma={},ya=new THREE.Frustum,V=new THREE.Matrix4,pa=new THREE.Matrix4,ja=new THREE.Vector3,fa=new THREE.Vector3,Za=!0,Na={ambient:[0,0,0],directional:{length:0,colors:[],positions:[]},point:{length:0,colors:[],positions:[],distances:[]},spot:{length:0,colors:[],positions:[],distances:[],directions:[],anglesCos:[],exponents:[]},\nhemi:{length:0,skyColors:[],groundColors:[],positions:[]}},j,Pa,Wa,qa,ta;try{var hb={alpha:A,premultipliedAlpha:da,antialias:ha,stencil:ua,preserveDrawingBuffer:O};j=H.getContext(\"webgl\",hb)||H.getContext(\"experimental-webgl\",hb);if(null===j)throw\"Error creating WebGL context.\";}catch(db){console.error(db)}Pa=j.getExtension(\"OES_texture_float\");j.getExtension(\"OES_texture_float_linear\");Wa=j.getExtension(\"OES_standard_derivatives\");qa=j.getExtension(\"EXT_texture_filter_anisotropic\")||j.getExtension(\"MOZ_EXT_texture_filter_anisotropic\")||\nj.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\");ta=j.getExtension(\"WEBGL_compressed_texture_s3tc\")||j.getExtension(\"MOZ_WEBGL_compressed_texture_s3tc\")||j.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\");Pa||console.log(\"THREE.WebGLRenderer: Float textures not supported.\");Wa||console.log(\"THREE.WebGLRenderer: Standard derivatives not supported.\");qa||console.log(\"THREE.WebGLRenderer: Anisotropic texture filtering not supported.\");ta||console.log(\"THREE.WebGLRenderer: S3TC compressed textures not supported.\");\nvoid 0===j.getShaderPrecisionFormat&&(j.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}});j.clearColor(0,0,0,1);j.clearDepth(1);j.clearStencil(0);j.enable(j.DEPTH_TEST);j.depthFunc(j.LEQUAL);j.frontFace(j.CCW);j.cullFace(j.BACK);j.enable(j.CULL_FACE);j.enable(j.BLEND);j.blendEquation(j.FUNC_ADD);j.blendFunc(j.SRC_ALPHA,j.ONE_MINUS_SRC_ALPHA);j.viewport(Fa,Ga,Ba,xa);j.clearColor(T.r,T.g,T.b,ea);this.context=j;var Ab=j.getParameter(j.MAX_TEXTURE_IMAGE_UNITS),Xb=j.getParameter(j.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\nj.getParameter(j.MAX_TEXTURE_SIZE);var Yb=j.getParameter(j.MAX_CUBE_MAP_TEXTURE_SIZE),Jb=qa?j.getParameter(qa.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0,xb=0<Xb,tb=xb&&Pa;ta&&j.getParameter(j.COMPRESSED_TEXTURE_FORMATS);var Zb=j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.HIGH_FLOAT),$b=j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.MEDIUM_FLOAT);j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.LOW_FLOAT);var ac=j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,j.HIGH_FLOAT),pc=j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,\nj.MEDIUM_FLOAT);j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,j.LOW_FLOAT);j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.HIGH_INT);j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.MEDIUM_INT);j.getShaderPrecisionFormat(j.VERTEX_SHADER,j.LOW_INT);j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,j.HIGH_INT);j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,j.MEDIUM_INT);j.getShaderPrecisionFormat(j.FRAGMENT_SHADER,j.LOW_INT);var qc=0<Zb.precision&&0<ac.precision,Kb=0<$b.precision&&0<pc.precision;\"highp\"===K&&!qc&&\n(Kb?(K=\"mediump\",console.warn(\"WebGLRenderer: highp not supported, using mediump\")):(K=\"lowp\",console.warn(\"WebGLRenderer: highp and mediump not supported, using lowp\")));\"mediump\"===K&&!Kb&&(K=\"lowp\",console.warn(\"WebGLRenderer: mediump not supported, using lowp\"));this.getContext=function(){return j};this.supportsVertexTextures=function(){return xb};this.supportsFloatTextures=function(){return Pa};this.supportsStandardDerivatives=function(){return Wa};this.supportsCompressedTextureS3TC=function(){return ta};\nthis.getMaxAnisotropy=function(){return Jb};this.getPrecision=function(){return K};this.setSize=function(a,b,c){H.width=a*this.devicePixelRatio;H.height=b*this.devicePixelRatio;1!==this.devicePixelRatio&&!1!==c&&(H.style.width=a+\"px\",H.style.height=b+\"px\");this.setViewport(0,0,H.width,H.height)};this.setViewport=function(a,b,c,d){Fa=void 0!==a?a:0;Ga=void 0!==b?b:0;Ba=void 0!==c?c:H.width;xa=void 0!==d?d:H.height;j.viewport(Fa,Ga,Ba,xa)};this.setScissor=function(a,b,c,d){j.scissor(a,b,c,d)};this.enableScissorTest=\nfunction(a){a?j.enable(j.SCISSOR_TEST):j.disable(j.SCISSOR_TEST)};this.setClearColor=function(a,b){T.set(a);ea=void 0!==b?b:1;j.clearColor(T.r,T.g,T.b,ea)};this.setClearColorHex=function(a,b){console.warn(\"DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.\");this.setClearColor(a,b)};this.getClearColor=function(){return T};this.getClearAlpha=function(){return ea};this.clear=function(a,b,c){var d=0;if(void 0===a||a)d|=j.COLOR_BUFFER_BIT;if(void 0===b||b)d|=j.DEPTH_BUFFER_BIT;\nif(void 0===c||c)d|=j.STENCIL_BUFFER_BIT;j.clear(d)};this.clearColor=function(){j.clear(j.COLOR_BUFFER_BIT)};this.clearDepth=function(){j.clear(j.DEPTH_BUFFER_BIT)};this.clearStencil=function(){j.clear(j.STENCIL_BUFFER_BIT)};this.clearTarget=function(a,b,c,d){this.setRenderTarget(a);this.clear(b,c,d)};this.addPostPlugin=function(a){a.init(this);this.renderPluginsPost.push(a)};this.addPrePlugin=function(a){a.init(this);this.renderPluginsPre.push(a)};this.updateShadowMap=function(a,b){oa=null;Ea=za=\nwa=ca=ba=-1;Za=!0;Aa=sa=-1;this.shadowMapPlugin.update(a,b)};var Lb=function(a){a=a.target;a.removeEventListener(\"dispose\",Lb);a.__webglInit=void 0;if(a instanceof THREE.BufferGeometry){var b=a.attributes,c;for(c in b)void 0!==b[c].buffer&&j.deleteBuffer(b[c].buffer);I.info.memory.geometries--}else if(void 0!==a.geometryGroups)for(b in a.geometryGroups){c=a.geometryGroups[b];if(void 0!==c.numMorphTargets)for(var d=0,e=c.numMorphTargets;d<e;d++)j.deleteBuffer(c.__webglMorphTargetsBuffers[d]);if(void 0!==\nc.numMorphNormals){d=0;for(e=c.numMorphNormals;d<e;d++)j.deleteBuffer(c.__webglMorphNormalsBuffers[d])}Db(c)}else Db(a)},Bb=function(a){a=a.target;a.removeEventListener(\"dispose\",Bb);a.image&&a.image.__webglTextureCube?j.deleteTexture(a.image.__webglTextureCube):a.__webglInit&&(a.__webglInit=!1,j.deleteTexture(a.__webglTexture));I.info.memory.textures--},Mb=function(a){a=a.target;a.removeEventListener(\"dispose\",Mb);if(a&&a.__webglTexture)if(j.deleteTexture(a.__webglTexture),a instanceof THREE.WebGLRenderTargetCube)for(var b=\n0;6>b;b++)j.deleteFramebuffer(a.__webglFramebuffer[b]),j.deleteRenderbuffer(a.__webglRenderbuffer[b]);else j.deleteFramebuffer(a.__webglFramebuffer),j.deleteRenderbuffer(a.__webglRenderbuffer);I.info.memory.textures--},Cb=function(a){a=a.target;a.removeEventListener(\"dispose\",Cb);Eb(a)},Db=function(a){void 0!==a.__webglVertexBuffer&&j.deleteBuffer(a.__webglVertexBuffer);void 0!==a.__webglNormalBuffer&&j.deleteBuffer(a.__webglNormalBuffer);void 0!==a.__webglTangentBuffer&&j.deleteBuffer(a.__webglTangentBuffer);\nvoid 0!==a.__webglColorBuffer&&j.deleteBuffer(a.__webglColorBuffer);void 0!==a.__webglUVBuffer&&j.deleteBuffer(a.__webglUVBuffer);void 0!==a.__webglUV2Buffer&&j.deleteBuffer(a.__webglUV2Buffer);void 0!==a.__webglSkinIndicesBuffer&&j.deleteBuffer(a.__webglSkinIndicesBuffer);void 0!==a.__webglSkinWeightsBuffer&&j.deleteBuffer(a.__webglSkinWeightsBuffer);void 0!==a.__webglFaceBuffer&&j.deleteBuffer(a.__webglFaceBuffer);void 0!==a.__webglLineBuffer&&j.deleteBuffer(a.__webglLineBuffer);void 0!==a.__webglLineDistanceBuffer&&\nj.deleteBuffer(a.__webglLineDistanceBuffer);if(void 0!==a.__webglCustomAttributesList)for(var b in a.__webglCustomAttributesList)j.deleteBuffer(a.__webglCustomAttributesList[b].buffer);I.info.memory.geometries--},Eb=function(a){var b=a.program;if(void 0!==b){a.program=void 0;var c,d,e=!1,a=0;for(c=P.length;a<c;a++)if(d=P[a],d.program===b){d.usedTimes--;0===d.usedTimes&&(e=!0);break}if(!0===e){e=[];a=0;for(c=P.length;a<c;a++)d=P[a],d.program!==b&&e.push(d);P=e;j.deleteProgram(b);I.info.memory.programs--}}};\nthis.renderBufferImmediate=function(a,b,c){a.hasPositions&&!a.__webglVertexBuffer&&(a.__webglVertexBuffer=j.createBuffer());a.hasNormals&&!a.__webglNormalBuffer&&(a.__webglNormalBuffer=j.createBuffer());a.hasUvs&&!a.__webglUvBuffer&&(a.__webglUvBuffer=j.createBuffer());a.hasColors&&!a.__webglColorBuffer&&(a.__webglColorBuffer=j.createBuffer());a.hasPositions&&(j.bindBuffer(j.ARRAY_BUFFER,a.__webglVertexBuffer),j.bufferData(j.ARRAY_BUFFER,a.positionArray,j.DYNAMIC_DRAW),j.enableVertexAttribArray(b.attributes.position),\nj.vertexAttribPointer(b.attributes.position,3,j.FLOAT,!1,0,0));if(a.hasNormals){j.bindBuffer(j.ARRAY_BUFFER,a.__webglNormalBuffer);if(c.shading===THREE.FlatShading){var d,e,f,g,h,i,k,l,m,n,p,q=3*a.count;for(p=0;p<q;p+=9)n=a.normalArray,d=n[p],e=n[p+1],f=n[p+2],g=n[p+3],i=n[p+4],l=n[p+5],h=n[p+6],k=n[p+7],m=n[p+8],d=(d+g+h)/3,e=(e+i+k)/3,f=(f+l+m)/3,n[p]=d,n[p+1]=e,n[p+2]=f,n[p+3]=d,n[p+4]=e,n[p+5]=f,n[p+6]=d,n[p+7]=e,n[p+8]=f}j.bufferData(j.ARRAY_BUFFER,a.normalArray,j.DYNAMIC_DRAW);j.enableVertexAttribArray(b.attributes.normal);\nj.vertexAttribPointer(b.attributes.normal,3,j.FLOAT,!1,0,0)}a.hasUvs&&c.map&&(j.bindBuffer(j.ARRAY_BUFFER,a.__webglUvBuffer),j.bufferData(j.ARRAY_BUFFER,a.uvArray,j.DYNAMIC_DRAW),j.enableVertexAttribArray(b.attributes.uv),j.vertexAttribPointer(b.attributes.uv,2,j.FLOAT,!1,0,0));a.hasColors&&c.vertexColors!==THREE.NoColors&&(j.bindBuffer(j.ARRAY_BUFFER,a.__webglColorBuffer),j.bufferData(j.ARRAY_BUFFER,a.colorArray,j.DYNAMIC_DRAW),j.enableVertexAttribArray(b.attributes.color),j.vertexAttribPointer(b.attributes.color,\n3,j.FLOAT,!1,0,0));j.drawArrays(j.TRIANGLES,0,a.count);a.count=0};this.renderBufferDirect=function(a,b,c,d,e,f){if(!1!==d.visible){var i,k,l,m;i=z(a,b,c,d,f);b=i.attributes;a=e.attributes;c=!1;i=16777215*e.id+2*i.id+(d.wireframe?1:0);i!==za&&(za=i,c=!0);c&&h();if(f instanceof THREE.Mesh)if(f=a.index){e=e.offsets;1<e.length&&(c=!0);for(var n=0,p=e.length;n<p;n++){var q=e[n].index;if(c){for(k in b)l=b[k],i=a[k],0<=l&&(i?(m=i.itemSize,j.bindBuffer(j.ARRAY_BUFFER,i.buffer),g(l),j.vertexAttribPointer(l,\nm,j.FLOAT,!1,0,4*q*m)):d.defaultAttributeValues&&(2===d.defaultAttributeValues[k].length?j.vertexAttrib2fv(l,d.defaultAttributeValues[k]):3===d.defaultAttributeValues[k].length&&j.vertexAttrib3fv(l,d.defaultAttributeValues[k])));j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,f.buffer)}j.drawElements(j.TRIANGLES,e[n].count,j.UNSIGNED_SHORT,2*e[n].start);I.info.render.calls++;I.info.render.vertices+=e[n].count;I.info.render.faces+=e[n].count/3}}else{if(c)for(k in b)\"index\"!==k&&(l=b[k],i=a[k],0<=l&&(i?(m=i.itemSize,\nj.bindBuffer(j.ARRAY_BUFFER,i.buffer),g(l),j.vertexAttribPointer(l,m,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&d.defaultAttributeValues[k]&&(2===d.defaultAttributeValues[k].length?j.vertexAttrib2fv(l,d.defaultAttributeValues[k]):3===d.defaultAttributeValues[k].length&&j.vertexAttrib3fv(l,d.defaultAttributeValues[k]))));d=e.attributes.position;j.drawArrays(j.TRIANGLES,0,d.numItems/3);I.info.render.calls++;I.info.render.vertices+=d.numItems/3;I.info.render.faces+=d.numItems/3/3}else if(f instanceof\nTHREE.ParticleSystem){if(c)for(k in b)l=b[k],i=a[k],0<=l&&(i?(m=i.itemSize,j.bindBuffer(j.ARRAY_BUFFER,i.buffer),g(l),j.vertexAttribPointer(l,m,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&d.defaultAttributeValues[k]&&(2===d.defaultAttributeValues[k].length?j.vertexAttrib2fv(l,d.defaultAttributeValues[k]):3===d.defaultAttributeValues[k].length&&j.vertexAttrib3fv(l,d.defaultAttributeValues[k])));d=a.position;j.drawArrays(j.POINTS,0,d.numItems/3);I.info.render.calls++;I.info.render.points+=d.numItems/\n3}else if(f instanceof THREE.Line){if(c)for(k in b)l=b[k],i=a[k],0<=l&&(i?(m=i.itemSize,j.bindBuffer(j.ARRAY_BUFFER,i.buffer),g(l),j.vertexAttribPointer(l,m,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&d.defaultAttributeValues[k]&&(2===d.defaultAttributeValues[k].length?j.vertexAttrib2fv(l,d.defaultAttributeValues[k]):3===d.defaultAttributeValues[k].length&&j.vertexAttrib3fv(l,d.defaultAttributeValues[k])));k=f.type===THREE.LineStrip?j.LINE_STRIP:j.LINES;B(d.linewidth);d=a.position;j.drawArrays(k,0,\nd.numItems/3);I.info.render.calls++;I.info.render.points+=d.numItems}}};this.renderBuffer=function(a,b,c,d,e,f){if(!1!==d.visible){var i,l,c=z(a,b,c,d,f),a=c.attributes,b=!1,c=16777215*e.id+2*c.id+(d.wireframe?1:0);c!==za&&(za=c,b=!0);b&&h();if(!d.morphTargets&&0<=a.position)b&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglVertexBuffer),g(a.position),j.vertexAttribPointer(a.position,3,j.FLOAT,!1,0,0));else if(f.morphTargetBase){c=d.program.attributes;-1!==f.morphTargetBase&&0<=c.position?(j.bindBuffer(j.ARRAY_BUFFER,\ne.__webglMorphTargetsBuffers[f.morphTargetBase]),g(c.position),j.vertexAttribPointer(c.position,3,j.FLOAT,!1,0,0)):0<=c.position&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglVertexBuffer),g(c.position),j.vertexAttribPointer(c.position,3,j.FLOAT,!1,0,0));if(f.morphTargetForcedOrder.length){var m=0;l=f.morphTargetForcedOrder;for(i=f.morphTargetInfluences;m<d.numSupportedMorphTargets&&m<l.length;)0<=c[\"morphTarget\"+m]&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglMorphTargetsBuffers[l[m]]),g(c[\"morphTarget\"+m]),\nj.vertexAttribPointer(c[\"morphTarget\"+m],3,j.FLOAT,!1,0,0)),0<=c[\"morphNormal\"+m]&&d.morphNormals&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglMorphNormalsBuffers[l[m]]),g(c[\"morphNormal\"+m]),j.vertexAttribPointer(c[\"morphNormal\"+m],3,j.FLOAT,!1,0,0)),f.__webglMorphTargetInfluences[m]=i[l[m]],m++}else{l=[];i=f.morphTargetInfluences;var n,p=i.length;for(n=0;n<p;n++)m=i[n],0<m&&l.push([m,n]);l.length>d.numSupportedMorphTargets?(l.sort(k),l.length=d.numSupportedMorphTargets):l.length>d.numSupportedMorphNormals?\nl.sort(k):0===l.length&&l.push([0,0]);for(m=0;m<d.numSupportedMorphTargets;)l[m]?(n=l[m][1],0<=c[\"morphTarget\"+m]&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglMorphTargetsBuffers[n]),g(c[\"morphTarget\"+m]),j.vertexAttribPointer(c[\"morphTarget\"+m],3,j.FLOAT,!1,0,0)),0<=c[\"morphNormal\"+m]&&d.morphNormals&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglMorphNormalsBuffers[n]),g(c[\"morphNormal\"+m]),j.vertexAttribPointer(c[\"morphNormal\"+m],3,j.FLOAT,!1,0,0)),f.__webglMorphTargetInfluences[m]=i[n]):f.__webglMorphTargetInfluences[m]=\n0,m++}null!==d.program.uniforms.morphTargetInfluences&&j.uniform1fv(d.program.uniforms.morphTargetInfluences,f.__webglMorphTargetInfluences)}if(b){if(e.__webglCustomAttributesList){i=0;for(l=e.__webglCustomAttributesList.length;i<l;i++)c=e.__webglCustomAttributesList[i],0<=a[c.buffer.belongsToAttribute]&&(j.bindBuffer(j.ARRAY_BUFFER,c.buffer),g(a[c.buffer.belongsToAttribute]),j.vertexAttribPointer(a[c.buffer.belongsToAttribute],c.size,j.FLOAT,!1,0,0))}0<=a.color&&(0<f.geometry.colors.length||0<f.geometry.faces.length?\n(j.bindBuffer(j.ARRAY_BUFFER,e.__webglColorBuffer),g(a.color),j.vertexAttribPointer(a.color,3,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&j.vertexAttrib3fv(a.color,d.defaultAttributeValues.color));0<=a.normal&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglNormalBuffer),g(a.normal),j.vertexAttribPointer(a.normal,3,j.FLOAT,!1,0,0));0<=a.tangent&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglTangentBuffer),g(a.tangent),j.vertexAttribPointer(a.tangent,4,j.FLOAT,!1,0,0));0<=a.uv&&(f.geometry.faceVertexUvs[0]?(j.bindBuffer(j.ARRAY_BUFFER,\ne.__webglUVBuffer),g(a.uv),j.vertexAttribPointer(a.uv,2,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&j.vertexAttrib2fv(a.uv,d.defaultAttributeValues.uv));0<=a.uv2&&(f.geometry.faceVertexUvs[1]?(j.bindBuffer(j.ARRAY_BUFFER,e.__webglUV2Buffer),g(a.uv2),j.vertexAttribPointer(a.uv2,2,j.FLOAT,!1,0,0)):d.defaultAttributeValues&&j.vertexAttrib2fv(a.uv2,d.defaultAttributeValues.uv2));d.skinning&&(0<=a.skinIndex&&0<=a.skinWeight)&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglSkinIndicesBuffer),g(a.skinIndex),j.vertexAttribPointer(a.skinIndex,\n4,j.FLOAT,!1,0,0),j.bindBuffer(j.ARRAY_BUFFER,e.__webglSkinWeightsBuffer),g(a.skinWeight),j.vertexAttribPointer(a.skinWeight,4,j.FLOAT,!1,0,0));0<=a.lineDistance&&(j.bindBuffer(j.ARRAY_BUFFER,e.__webglLineDistanceBuffer),g(a.lineDistance),j.vertexAttribPointer(a.lineDistance,1,j.FLOAT,!1,0,0))}f instanceof THREE.Mesh?(d.wireframe?(B(d.wireframeLinewidth),b&&j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,e.__webglLineBuffer),j.drawElements(j.LINES,e.__webglLineCount,j.UNSIGNED_SHORT,0)):(b&&j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,\ne.__webglFaceBuffer),j.drawElements(j.TRIANGLES,e.__webglFaceCount,j.UNSIGNED_SHORT,0)),I.info.render.calls++,I.info.render.vertices+=e.__webglFaceCount,I.info.render.faces+=e.__webglFaceCount/3):f instanceof THREE.Line?(f=f.type===THREE.LineStrip?j.LINE_STRIP:j.LINES,B(d.linewidth),j.drawArrays(f,0,e.__webglLineCount),I.info.render.calls++):f instanceof THREE.ParticleSystem&&(j.drawArrays(j.POINTS,0,e.__webglParticleCount),I.info.render.calls++,I.info.render.points+=e.__webglParticleCount)}};this.render=\nfunction(a,b,c,d){if(!1===b instanceof THREE.Camera)console.error(\"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.\");else{var e,f,g,h,k=a.__lights,m=a.fog;Ea=-1;Za=!0;!0===a.autoUpdate&&a.updateMatrixWorld();void 0===b.parent&&b.updateMatrixWorld();b.matrixWorldInverse.getInverse(b.matrixWorld);V.multiplyMatrices(b.projectionMatrix,b.matrixWorldInverse);ya.setFromMatrix(V);this.autoUpdateObjects&&this.initWebGLObjects(a);l(this.renderPluginsPre,a,b);I.info.render.calls=0;I.info.render.vertices=\n0;I.info.render.faces=0;I.info.render.points=0;this.setRenderTarget(c);(this.autoClear||d)&&this.clear(this.autoClearColor,this.autoClearDepth,this.autoClearStencil);h=a.__webglObjects;d=0;for(e=h.length;d<e;d++)if(f=h[d],g=f.object,f.id=d,f.render=!1,g.visible&&(!(g instanceof THREE.Mesh||g instanceof THREE.ParticleSystem)||!g.frustumCulled||ya.intersectsObject(g))){var q=g;q._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse,q.matrixWorld);q._normalMatrix.getNormalMatrix(q._modelViewMatrix);\nvar q=f,r=q.buffer,t=void 0,s=t=void 0,s=q.object.material;if(s instanceof THREE.MeshFaceMaterial)t=r.materialIndex,t=s.materials[t],t.transparent?(q.transparent=t,q.opaque=null):(q.opaque=t,q.transparent=null);else if(t=s)t.transparent?(q.transparent=t,q.opaque=null):(q.opaque=t,q.transparent=null);f.render=!0;!0===this.sortObjects&&(null!==g.renderDepth?f.z=g.renderDepth:(ja.setFromMatrixPosition(g.matrixWorld),ja.applyProjection(V),f.z=ja.z))}this.sortObjects&&h.sort(i);h=a.__webglObjectsImmediate;\nd=0;for(e=h.length;d<e;d++)f=h[d],g=f.object,g.visible&&(g._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse,g.matrixWorld),g._normalMatrix.getNormalMatrix(g._modelViewMatrix),g=f.object.material,g.transparent?(f.transparent=g,f.opaque=null):(f.opaque=g,f.transparent=null));a.overrideMaterial?(d=a.overrideMaterial,this.setBlending(d.blending,d.blendEquation,d.blendSrc,d.blendDst),this.setDepthTest(d.depthTest),this.setDepthWrite(d.depthWrite),x(d.polygonOffset,d.polygonOffsetFactor,d.polygonOffsetUnits),\nn(a.__webglObjects,!1,\"\",b,k,m,!0,d),p(a.__webglObjectsImmediate,\"\",b,k,m,!1,d)):(d=null,this.setBlending(THREE.NoBlending),n(a.__webglObjects,!0,\"opaque\",b,k,m,!1,d),p(a.__webglObjectsImmediate,\"opaque\",b,k,m,!1,d),n(a.__webglObjects,!1,\"transparent\",b,k,m,!0,d),p(a.__webglObjectsImmediate,\"transparent\",b,k,m,!0,d));l(this.renderPluginsPost,a,b);c&&(c.generateMipmaps&&c.minFilter!==THREE.NearestFilter&&c.minFilter!==THREE.LinearFilter)&&(c instanceof THREE.WebGLRenderTargetCube?(j.bindTexture(j.TEXTURE_CUBE_MAP,\nc.__webglTexture),j.generateMipmap(j.TEXTURE_CUBE_MAP),j.bindTexture(j.TEXTURE_CUBE_MAP,null)):(j.bindTexture(j.TEXTURE_2D,c.__webglTexture),j.generateMipmap(j.TEXTURE_2D),j.bindTexture(j.TEXTURE_2D,null)));this.setDepthTest(!0);this.setDepthWrite(!0)}};this.renderImmediateObject=function(a,b,c,d,e){var f=z(a,b,c,d,e);za=-1;I.setMaterialFaces(d);e.immediateRenderCallback?e.immediateRenderCallback(f,j,ya):e.render(function(a){I.renderBufferImmediate(a,f,d)})};this.initWebGLObjects=function(a){a.__webglObjects||\n(a.__webglObjects=[],a.__webglObjectsImmediate=[],a.__webglSprites=[],a.__webglFlares=[]);for(;a.__objectsAdded.length;)t(a.__objectsAdded[0],a),a.__objectsAdded.splice(0,1);for(;a.__objectsRemoved.length;)u(a.__objectsRemoved[0],a),a.__objectsRemoved.splice(0,1);for(var b=0,g=a.__webglObjects.length;b<g;b++){var h=a.__webglObjects[b].object;void 0===h.__webglInit&&(void 0!==h.__webglActive&&u(h,a),t(h,a));var i=h,l=i.geometry,n=void 0,p=void 0,r=void 0;if(l instanceof THREE.BufferGeometry){var s=\nj.DYNAMIC_DRAW,v=!l.dynamic,z=l.attributes,y=void 0,x=void 0;for(y in z)x=z[y],x.needsUpdate&&(\"index\"===y?(j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,x.buffer),j.bufferData(j.ELEMENT_ARRAY_BUFFER,x.array,s)):(j.bindBuffer(j.ARRAY_BUFFER,x.buffer),j.bufferData(j.ARRAY_BUFFER,x.array,s)),x.needsUpdate=!1),v&&!x.dynamic&&(x.array=null)}else if(i instanceof THREE.Mesh){for(var B=0,C=l.geometryGroupsList.length;B<C;B++)if(n=l.geometryGroupsList[B],r=d(i,n),l.buffersNeedUpdate&&c(n,i),p=r.attributes&&m(r),l.verticesNeedUpdate||\nl.morphTargetsNeedUpdate||l.elementsNeedUpdate||l.uvsNeedUpdate||l.normalsNeedUpdate||l.colorsNeedUpdate||l.tangentsNeedUpdate||p){var w=n,D=i,F=j.DYNAMIC_DRAW,E=!l.dynamic,G=r;if(w.__inittedArrays){var H=e(G),L=G.vertexColors?G.vertexColors:!1,N=f(G),O=H===THREE.SmoothShading,A=void 0,I=void 0,Q=void 0,K=void 0,P=void 0,U=void 0,T=void 0,W=void 0,oa=void 0,va=void 0,sa=void 0,Y=void 0,Z=void 0,X=void 0,Ea=void 0,Ta=void 0,ba=void 0,da=void 0,ca=void 0,za=void 0,Ja=void 0,ea=void 0,fa=void 0,ha=void 0,\nHa=void 0,la=void 0,Aa=void 0,qa=void 0,ua=void 0,Ia=void 0,Fa=void 0,Ba=void 0,Ka=void 0,Ga=void 0,ia=void 0,Na=void 0,ta=void 0,wa=void 0,Ma=void 0,Oa=void 0,xa=0,ya=0,Pa=0,Ua=0,Va=0,ib=0,Ya=0,La=0,eb=0,ra=0,Ca=0,M=0,Xa=void 0,jb=w.__vertexArray,Za=w.__uvArray,db=w.__uv2Array,Wa=w.__normalArray,$a=w.__tangentArray,kb=w.__colorArray,ab=w.__skinIndexArray,bb=w.__skinWeightArray,hb=w.__morphTargetsArrays,xb=w.__morphNormalsArrays,tb=w.__webglCustomAttributesList,J=void 0,Nb=w.__faceArray,ub=w.__lineArray,\nQa=D.geometry,Bb=Qa.elementsNeedUpdate,Ab=Qa.uvsNeedUpdate,Jb=Qa.normalsNeedUpdate,Kb=Qa.tangentsNeedUpdate,Lb=Qa.colorsNeedUpdate,Mb=Qa.morphTargetsNeedUpdate,bc=Qa.vertices,aa=w.faces3,lb=Qa.faces,Cb=Qa.faceVertexUvs[0],Db=Qa.faceVertexUvs[1],cc=Qa.skinIndices,Ob=Qa.skinWeights,Pb=Qa.morphTargets,Eb=Qa.morphNormals;if(Qa.verticesNeedUpdate){A=0;for(I=aa.length;A<I;A++)K=lb[aa[A]],Y=bc[K.a],Z=bc[K.b],X=bc[K.c],jb[ya]=Y.x,jb[ya+1]=Y.y,jb[ya+2]=Y.z,jb[ya+3]=Z.x,jb[ya+4]=Z.y,jb[ya+5]=Z.z,jb[ya+6]=X.x,\njb[ya+7]=X.y,jb[ya+8]=X.z,ya+=9;j.bindBuffer(j.ARRAY_BUFFER,w.__webglVertexBuffer);j.bufferData(j.ARRAY_BUFFER,jb,F)}if(Mb){ia=0;for(Na=Pb.length;ia<Na;ia++){A=Ca=0;for(I=aa.length;A<I;A++)Ma=aa[A],K=lb[Ma],Y=Pb[ia].vertices[K.a],Z=Pb[ia].vertices[K.b],X=Pb[ia].vertices[K.c],ta=hb[ia],ta[Ca]=Y.x,ta[Ca+1]=Y.y,ta[Ca+2]=Y.z,ta[Ca+3]=Z.x,ta[Ca+4]=Z.y,ta[Ca+5]=Z.z,ta[Ca+6]=X.x,ta[Ca+7]=X.y,ta[Ca+8]=X.z,G.morphNormals&&(O?(Oa=Eb[ia].vertexNormals[Ma],da=Oa.a,ca=Oa.b,za=Oa.c):za=ca=da=Eb[ia].faceNormals[Ma],\nwa=xb[ia],wa[Ca]=da.x,wa[Ca+1]=da.y,wa[Ca+2]=da.z,wa[Ca+3]=ca.x,wa[Ca+4]=ca.y,wa[Ca+5]=ca.z,wa[Ca+6]=za.x,wa[Ca+7]=za.y,wa[Ca+8]=za.z),Ca+=9;j.bindBuffer(j.ARRAY_BUFFER,w.__webglMorphTargetsBuffers[ia]);j.bufferData(j.ARRAY_BUFFER,hb[ia],F);G.morphNormals&&(j.bindBuffer(j.ARRAY_BUFFER,w.__webglMorphNormalsBuffers[ia]),j.bufferData(j.ARRAY_BUFFER,xb[ia],F))}}if(Ob.length){A=0;for(I=aa.length;A<I;A++)K=lb[aa[A]],ha=Ob[K.a],Ha=Ob[K.b],la=Ob[K.c],bb[ra]=ha.x,bb[ra+1]=ha.y,bb[ra+2]=ha.z,bb[ra+3]=ha.w,\nbb[ra+4]=Ha.x,bb[ra+5]=Ha.y,bb[ra+6]=Ha.z,bb[ra+7]=Ha.w,bb[ra+8]=la.x,bb[ra+9]=la.y,bb[ra+10]=la.z,bb[ra+11]=la.w,Aa=cc[K.a],qa=cc[K.b],ua=cc[K.c],ab[ra]=Aa.x,ab[ra+1]=Aa.y,ab[ra+2]=Aa.z,ab[ra+3]=Aa.w,ab[ra+4]=qa.x,ab[ra+5]=qa.y,ab[ra+6]=qa.z,ab[ra+7]=qa.w,ab[ra+8]=ua.x,ab[ra+9]=ua.y,ab[ra+10]=ua.z,ab[ra+11]=ua.w,ra+=12;0<ra&&(j.bindBuffer(j.ARRAY_BUFFER,w.__webglSkinIndicesBuffer),j.bufferData(j.ARRAY_BUFFER,ab,F),j.bindBuffer(j.ARRAY_BUFFER,w.__webglSkinWeightsBuffer),j.bufferData(j.ARRAY_BUFFER,\nbb,F))}if(Lb&&L){A=0;for(I=aa.length;A<I;A++)K=lb[aa[A]],T=K.vertexColors,W=K.color,3===T.length&&L===THREE.VertexColors?(Ja=T[0],ea=T[1],fa=T[2]):fa=ea=Ja=W,kb[eb]=Ja.r,kb[eb+1]=Ja.g,kb[eb+2]=Ja.b,kb[eb+3]=ea.r,kb[eb+4]=ea.g,kb[eb+5]=ea.b,kb[eb+6]=fa.r,kb[eb+7]=fa.g,kb[eb+8]=fa.b,eb+=9;0<eb&&(j.bindBuffer(j.ARRAY_BUFFER,w.__webglColorBuffer),j.bufferData(j.ARRAY_BUFFER,kb,F))}if(Kb&&Qa.hasTangents){A=0;for(I=aa.length;A<I;A++)K=lb[aa[A]],oa=K.vertexTangents,Ea=oa[0],Ta=oa[1],ba=oa[2],$a[Ya]=Ea.x,\n$a[Ya+1]=Ea.y,$a[Ya+2]=Ea.z,$a[Ya+3]=Ea.w,$a[Ya+4]=Ta.x,$a[Ya+5]=Ta.y,$a[Ya+6]=Ta.z,$a[Ya+7]=Ta.w,$a[Ya+8]=ba.x,$a[Ya+9]=ba.y,$a[Ya+10]=ba.z,$a[Ya+11]=ba.w,Ya+=12;j.bindBuffer(j.ARRAY_BUFFER,w.__webglTangentBuffer);j.bufferData(j.ARRAY_BUFFER,$a,F)}if(Jb&&H){A=0;for(I=aa.length;A<I;A++)if(K=lb[aa[A]],P=K.vertexNormals,U=K.normal,3===P.length&&O)for(Ia=0;3>Ia;Ia++)Ba=P[Ia],Wa[ib]=Ba.x,Wa[ib+1]=Ba.y,Wa[ib+2]=Ba.z,ib+=3;else for(Ia=0;3>Ia;Ia++)Wa[ib]=U.x,Wa[ib+1]=U.y,Wa[ib+2]=U.z,ib+=3;j.bindBuffer(j.ARRAY_BUFFER,\nw.__webglNormalBuffer);j.bufferData(j.ARRAY_BUFFER,Wa,F)}if(Ab&&Cb&&N){A=0;for(I=aa.length;A<I;A++)if(Q=aa[A],va=Cb[Q],void 0!==va)for(Ia=0;3>Ia;Ia++)Ka=va[Ia],Za[Pa]=Ka.x,Za[Pa+1]=Ka.y,Pa+=2;0<Pa&&(j.bindBuffer(j.ARRAY_BUFFER,w.__webglUVBuffer),j.bufferData(j.ARRAY_BUFFER,Za,F))}if(Ab&&Db&&N){A=0;for(I=aa.length;A<I;A++)if(Q=aa[A],sa=Db[Q],void 0!==sa)for(Ia=0;3>Ia;Ia++)Ga=sa[Ia],db[Ua]=Ga.x,db[Ua+1]=Ga.y,Ua+=2;0<Ua&&(j.bindBuffer(j.ARRAY_BUFFER,w.__webglUV2Buffer),j.bufferData(j.ARRAY_BUFFER,db,\nF))}if(Bb){A=0;for(I=aa.length;A<I;A++)Nb[Va]=xa,Nb[Va+1]=xa+1,Nb[Va+2]=xa+2,Va+=3,ub[La]=xa,ub[La+1]=xa+1,ub[La+2]=xa,ub[La+3]=xa+2,ub[La+4]=xa+1,ub[La+5]=xa+2,La+=6,xa+=3;j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,w.__webglFaceBuffer);j.bufferData(j.ELEMENT_ARRAY_BUFFER,Nb,F);j.bindBuffer(j.ELEMENT_ARRAY_BUFFER,w.__webglLineBuffer);j.bufferData(j.ELEMENT_ARRAY_BUFFER,ub,F)}if(tb){Ia=0;for(Fa=tb.length;Ia<Fa;Ia++)if(J=tb[Ia],J.__original.needsUpdate){M=0;if(1===J.size)if(void 0===J.boundTo||\"vertices\"===\nJ.boundTo){A=0;for(I=aa.length;A<I;A++)K=lb[aa[A]],J.array[M]=J.value[K.a],J.array[M+1]=J.value[K.b],J.array[M+2]=J.value[K.c],M+=3}else{if(\"faces\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)Xa=J.value[aa[A]],J.array[M]=Xa,J.array[M+1]=Xa,J.array[M+2]=Xa,M+=3}}else if(2===J.size)if(void 0===J.boundTo||\"vertices\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)K=lb[aa[A]],Y=J.value[K.a],Z=J.value[K.b],X=J.value[K.c],J.array[M]=Y.x,J.array[M+1]=Y.y,J.array[M+2]=Z.x,J.array[M+3]=Z.y,J.array[M+4]=X.x,J.array[M+\n5]=X.y,M+=6}else{if(\"faces\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)X=Z=Y=Xa=J.value[aa[A]],J.array[M]=Y.x,J.array[M+1]=Y.y,J.array[M+2]=Z.x,J.array[M+3]=Z.y,J.array[M+4]=X.x,J.array[M+5]=X.y,M+=6}}else if(3===J.size){var na;na=\"c\"===J.type?[\"r\",\"g\",\"b\"]:[\"x\",\"y\",\"z\"];if(void 0===J.boundTo||\"vertices\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)K=lb[aa[A]],Y=J.value[K.a],Z=J.value[K.b],X=J.value[K.c],J.array[M]=Y[na[0]],J.array[M+1]=Y[na[1]],J.array[M+2]=Y[na[2]],J.array[M+3]=Z[na[0]],J.array[M+4]=\nZ[na[1]],J.array[M+5]=Z[na[2]],J.array[M+6]=X[na[0]],J.array[M+7]=X[na[1]],J.array[M+8]=X[na[2]],M+=9}else if(\"faces\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)X=Z=Y=Xa=J.value[aa[A]],J.array[M]=Y[na[0]],J.array[M+1]=Y[na[1]],J.array[M+2]=Y[na[2]],J.array[M+3]=Z[na[0]],J.array[M+4]=Z[na[1]],J.array[M+5]=Z[na[2]],J.array[M+6]=X[na[0]],J.array[M+7]=X[na[1]],J.array[M+8]=X[na[2]],M+=9}else if(\"faceVertices\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)Xa=J.value[aa[A]],Y=Xa[0],Z=Xa[1],X=Xa[2],J.array[M]=\nY[na[0]],J.array[M+1]=Y[na[1]],J.array[M+2]=Y[na[2]],J.array[M+3]=Z[na[0]],J.array[M+4]=Z[na[1]],J.array[M+5]=Z[na[2]],J.array[M+6]=X[na[0]],J.array[M+7]=X[na[1]],J.array[M+8]=X[na[2]],M+=9}}else if(4===J.size)if(void 0===J.boundTo||\"vertices\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)K=lb[aa[A]],Y=J.value[K.a],Z=J.value[K.b],X=J.value[K.c],J.array[M]=Y.x,J.array[M+1]=Y.y,J.array[M+2]=Y.z,J.array[M+3]=Y.w,J.array[M+4]=Z.x,J.array[M+5]=Z.y,J.array[M+6]=Z.z,J.array[M+7]=Z.w,J.array[M+8]=X.x,J.array[M+\n9]=X.y,J.array[M+10]=X.z,J.array[M+11]=X.w,M+=12}else if(\"faces\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)X=Z=Y=Xa=J.value[aa[A]],J.array[M]=Y.x,J.array[M+1]=Y.y,J.array[M+2]=Y.z,J.array[M+3]=Y.w,J.array[M+4]=Z.x,J.array[M+5]=Z.y,J.array[M+6]=Z.z,J.array[M+7]=Z.w,J.array[M+8]=X.x,J.array[M+9]=X.y,J.array[M+10]=X.z,J.array[M+11]=X.w,M+=12}else if(\"faceVertices\"===J.boundTo){A=0;for(I=aa.length;A<I;A++)Xa=J.value[aa[A]],Y=Xa[0],Z=Xa[1],X=Xa[2],J.array[M]=Y.x,J.array[M+1]=Y.y,J.array[M+2]=Y.z,J.array[M+\n3]=Y.w,J.array[M+4]=Z.x,J.array[M+5]=Z.y,J.array[M+6]=Z.z,J.array[M+7]=Z.w,J.array[M+8]=X.x,J.array[M+9]=X.y,J.array[M+10]=X.z,J.array[M+11]=X.w,M+=12}j.bindBuffer(j.ARRAY_BUFFER,J.buffer);j.bufferData(j.ARRAY_BUFFER,J.array,F)}}E&&(delete w.__inittedArrays,delete w.__colorArray,delete w.__normalArray,delete w.__tangentArray,delete w.__uvArray,delete w.__uv2Array,delete w.__faceArray,delete w.__vertexArray,delete w.__lineArray,delete w.__skinIndexArray,delete w.__skinWeightArray)}}l.verticesNeedUpdate=\n!1;l.morphTargetsNeedUpdate=!1;l.elementsNeedUpdate=!1;l.uvsNeedUpdate=!1;l.normalsNeedUpdate=!1;l.colorsNeedUpdate=!1;l.tangentsNeedUpdate=!1;l.buffersNeedUpdate=!1;r.attributes&&q(r)}else if(i instanceof THREE.Line){r=d(i,l);p=r.attributes&&m(r);if(l.verticesNeedUpdate||l.colorsNeedUpdate||l.lineDistancesNeedUpdate||p){var cb=l,Qb=j.DYNAMIC_DRAW,Fb=void 0,Gb=void 0,Hb=void 0,Rb=void 0,ma=void 0,Sb=void 0,hc=cb.vertices,ic=cb.colors,jc=cb.lineDistances,Xb=hc.length,Yb=ic.length,Zb=jc.length,Tb=cb.__vertexArray,\nUb=cb.__colorArray,kc=cb.__lineDistanceArray,$b=cb.colorsNeedUpdate,ac=cb.lineDistancesNeedUpdate,dc=cb.__webglCustomAttributesList,Vb=void 0,lc=void 0,Da=void 0,yb=void 0,Ra=void 0,ka=void 0;if(cb.verticesNeedUpdate){for(Fb=0;Fb<Xb;Fb++)Rb=hc[Fb],ma=3*Fb,Tb[ma]=Rb.x,Tb[ma+1]=Rb.y,Tb[ma+2]=Rb.z;j.bindBuffer(j.ARRAY_BUFFER,cb.__webglVertexBuffer);j.bufferData(j.ARRAY_BUFFER,Tb,Qb)}if($b){for(Gb=0;Gb<Yb;Gb++)Sb=ic[Gb],ma=3*Gb,Ub[ma]=Sb.r,Ub[ma+1]=Sb.g,Ub[ma+2]=Sb.b;j.bindBuffer(j.ARRAY_BUFFER,cb.__webglColorBuffer);\nj.bufferData(j.ARRAY_BUFFER,Ub,Qb)}if(ac){for(Hb=0;Hb<Zb;Hb++)kc[Hb]=jc[Hb];j.bindBuffer(j.ARRAY_BUFFER,cb.__webglLineDistanceBuffer);j.bufferData(j.ARRAY_BUFFER,kc,Qb)}if(dc){Vb=0;for(lc=dc.length;Vb<lc;Vb++)if(ka=dc[Vb],ka.needsUpdate&&(void 0===ka.boundTo||\"vertices\"===ka.boundTo)){ma=0;yb=ka.value.length;if(1===ka.size)for(Da=0;Da<yb;Da++)ka.array[Da]=ka.value[Da];else if(2===ka.size)for(Da=0;Da<yb;Da++)Ra=ka.value[Da],ka.array[ma]=Ra.x,ka.array[ma+1]=Ra.y,ma+=2;else if(3===ka.size)if(\"c\"===ka.type)for(Da=\n0;Da<yb;Da++)Ra=ka.value[Da],ka.array[ma]=Ra.r,ka.array[ma+1]=Ra.g,ka.array[ma+2]=Ra.b,ma+=3;else for(Da=0;Da<yb;Da++)Ra=ka.value[Da],ka.array[ma]=Ra.x,ka.array[ma+1]=Ra.y,ka.array[ma+2]=Ra.z,ma+=3;else if(4===ka.size)for(Da=0;Da<yb;Da++)Ra=ka.value[Da],ka.array[ma]=Ra.x,ka.array[ma+1]=Ra.y,ka.array[ma+2]=Ra.z,ka.array[ma+3]=Ra.w,ma+=4;j.bindBuffer(j.ARRAY_BUFFER,ka.buffer);j.bufferData(j.ARRAY_BUFFER,ka.array,Qb)}}}l.verticesNeedUpdate=!1;l.colorsNeedUpdate=!1;l.lineDistancesNeedUpdate=!1;r.attributes&&\nq(r)}else if(i instanceof THREE.ParticleSystem){r=d(i,l);p=r.attributes&&m(r);if(l.verticesNeedUpdate||l.colorsNeedUpdate||i.sortParticles||p){var mb=l,ec=j.DYNAMIC_DRAW,Ib=i,Sa=void 0,nb=void 0,ob=void 0,S=void 0,pb=void 0,sb=void 0,Wb=mb.vertices,fc=Wb.length,gc=mb.colors,mc=gc.length,vb=mb.__vertexArray,wb=mb.__colorArray,qb=mb.__sortArray,nc=mb.verticesNeedUpdate,oc=mb.colorsNeedUpdate,rb=mb.__webglCustomAttributesList,fb=void 0,zb=void 0,$=void 0,gb=void 0,ga=void 0,R=void 0;if(Ib.sortParticles){pa.copy(V);\npa.multiply(Ib.matrixWorld);for(Sa=0;Sa<fc;Sa++)ob=Wb[Sa],ja.copy(ob),ja.applyProjection(pa),qb[Sa]=[ja.z,Sa];qb.sort(k);for(Sa=0;Sa<fc;Sa++)ob=Wb[qb[Sa][1]],S=3*Sa,vb[S]=ob.x,vb[S+1]=ob.y,vb[S+2]=ob.z;for(nb=0;nb<mc;nb++)S=3*nb,sb=gc[qb[nb][1]],wb[S]=sb.r,wb[S+1]=sb.g,wb[S+2]=sb.b;if(rb){fb=0;for(zb=rb.length;fb<zb;fb++)if(R=rb[fb],void 0===R.boundTo||\"vertices\"===R.boundTo)if(S=0,gb=R.value.length,1===R.size)for($=0;$<gb;$++)pb=qb[$][1],R.array[$]=R.value[pb];else if(2===R.size)for($=0;$<gb;$++)pb=\nqb[$][1],ga=R.value[pb],R.array[S]=ga.x,R.array[S+1]=ga.y,S+=2;else if(3===R.size)if(\"c\"===R.type)for($=0;$<gb;$++)pb=qb[$][1],ga=R.value[pb],R.array[S]=ga.r,R.array[S+1]=ga.g,R.array[S+2]=ga.b,S+=3;else for($=0;$<gb;$++)pb=qb[$][1],ga=R.value[pb],R.array[S]=ga.x,R.array[S+1]=ga.y,R.array[S+2]=ga.z,S+=3;else if(4===R.size)for($=0;$<gb;$++)pb=qb[$][1],ga=R.value[pb],R.array[S]=ga.x,R.array[S+1]=ga.y,R.array[S+2]=ga.z,R.array[S+3]=ga.w,S+=4}}else{if(nc)for(Sa=0;Sa<fc;Sa++)ob=Wb[Sa],S=3*Sa,vb[S]=ob.x,\nvb[S+1]=ob.y,vb[S+2]=ob.z;if(oc)for(nb=0;nb<mc;nb++)sb=gc[nb],S=3*nb,wb[S]=sb.r,wb[S+1]=sb.g,wb[S+2]=sb.b;if(rb){fb=0;for(zb=rb.length;fb<zb;fb++)if(R=rb[fb],R.needsUpdate&&(void 0===R.boundTo||\"vertices\"===R.boundTo))if(gb=R.value.length,S=0,1===R.size)for($=0;$<gb;$++)R.array[$]=R.value[$];else if(2===R.size)for($=0;$<gb;$++)ga=R.value[$],R.array[S]=ga.x,R.array[S+1]=ga.y,S+=2;else if(3===R.size)if(\"c\"===R.type)for($=0;$<gb;$++)ga=R.value[$],R.array[S]=ga.r,R.array[S+1]=ga.g,R.array[S+2]=ga.b,S+=\n3;else for($=0;$<gb;$++)ga=R.value[$],R.array[S]=ga.x,R.array[S+1]=ga.y,R.array[S+2]=ga.z,S+=3;else if(4===R.size)for($=0;$<gb;$++)ga=R.value[$],R.array[S]=ga.x,R.array[S+1]=ga.y,R.array[S+2]=ga.z,R.array[S+3]=ga.w,S+=4}}if(nc||Ib.sortParticles)j.bindBuffer(j.ARRAY_BUFFER,mb.__webglVertexBuffer),j.bufferData(j.ARRAY_BUFFER,vb,ec);if(oc||Ib.sortParticles)j.bindBuffer(j.ARRAY_BUFFER,mb.__webglColorBuffer),j.bufferData(j.ARRAY_BUFFER,wb,ec);if(rb){fb=0;for(zb=rb.length;fb<zb;fb++)if(R=rb[fb],R.needsUpdate||\nIb.sortParticles)j.bindBuffer(j.ARRAY_BUFFER,R.buffer),j.bufferData(j.ARRAY_BUFFER,R.array,ec)}}l.verticesNeedUpdate=!1;l.colorsNeedUpdate=!1;r.attributes&&q(r)}}};this.initMaterial=function(a,b,c,d){var e,f,g,h;a.addEventListener(\"dispose\",Cb);var i,k,l,m,n;a instanceof THREE.MeshDepthMaterial?n=\"depth\":a instanceof THREE.MeshNormalMaterial?n=\"normal\":a instanceof THREE.MeshBasicMaterial?n=\"basic\":a instanceof THREE.MeshLambertMaterial?n=\"lambert\":a instanceof THREE.MeshPhongMaterial?n=\"phong\":a instanceof\nTHREE.LineBasicMaterial?n=\"basic\":a instanceof THREE.LineDashedMaterial?n=\"dashed\":a instanceof THREE.ParticleSystemMaterial&&(n=\"particle_basic\");if(n){var p=THREE.ShaderLib[n];a.uniforms=THREE.UniformsUtils.clone(p.uniforms);a.vertexShader=p.vertexShader;a.fragmentShader=p.fragmentShader}var q=e=0,r=0,t=p=0;for(f=b.length;t<f;t++)g=b[t],g.onlyShadow||(g instanceof THREE.DirectionalLight&&e++,g instanceof THREE.PointLight&&q++,g instanceof THREE.SpotLight&&r++,g instanceof THREE.HemisphereLight&&\np++);f=q;g=r;h=p;r=p=0;for(q=b.length;r<q;r++)t=b[r],t.castShadow&&(t instanceof THREE.SpotLight&&p++,t instanceof THREE.DirectionalLight&&!t.shadowCascade&&p++);m=p;tb&&d&&d.useVertexTexture?l=1024:(b=j.getParameter(j.MAX_VERTEX_UNIFORM_VECTORS),b=Math.floor((b-20)/4),void 0!==d&&d instanceof THREE.SkinnedMesh&&(b=Math.min(d.bones.length,b),b<d.bones.length&&console.warn(\"WebGLRenderer: too many bones - \"+d.bones.length+\", this GPU supports just \"+b+\" (try OpenGL instead of ANGLE)\")),l=b);a:{var r=\na.fragmentShader,q=a.vertexShader,p=a.uniforms,b=a.attributes,t=a.defines,c={map:!!a.map,envMap:!!a.envMap,lightMap:!!a.lightMap,bumpMap:!!a.bumpMap,normalMap:!!a.normalMap,specularMap:!!a.specularMap,vertexColors:a.vertexColors,fog:c,useFog:a.fog,fogExp:c instanceof THREE.FogExp2,sizeAttenuation:a.sizeAttenuation,skinning:a.skinning,maxBones:l,useVertexTexture:tb&&d&&d.useVertexTexture,morphTargets:a.morphTargets,morphNormals:a.morphNormals,maxMorphTargets:this.maxMorphTargets,maxMorphNormals:this.maxMorphNormals,\nmaxDirLights:e,maxPointLights:f,maxSpotLights:g,maxHemiLights:h,maxShadows:m,shadowMapEnabled:this.shadowMapEnabled&&d.receiveShadow,shadowMapType:this.shadowMapType,shadowMapDebug:this.shadowMapDebug,shadowMapCascade:this.shadowMapCascade,alphaTest:a.alphaTest,metal:a.metal,perPixel:a.perPixel,wrapAround:a.wrapAround,doubleSided:a.side===THREE.DoubleSide,flipSided:a.side===THREE.BackSide},d=a.index0AttributeName,s,u,v;e=[];n?e.push(n):(e.push(r),e.push(q));for(u in t)e.push(u),e.push(t[u]);for(s in c)e.push(s),\ne.push(c[s]);n=e.join();s=0;for(u=P.length;s<u;s++)if(e=P[s],e.code===n){e.usedTimes++;k=e.program;break a}s=\"SHADOWMAP_TYPE_BASIC\";c.shadowMapType===THREE.PCFShadowMap?s=\"SHADOWMAP_TYPE_PCF\":c.shadowMapType===THREE.PCFSoftShadowMap&&(s=\"SHADOWMAP_TYPE_PCF_SOFT\");u=[];for(v in t)e=t[v],!1!==e&&(e=\"#define \"+v+\" \"+e,u.push(e));e=u.join(\"\\n\");v=j.createProgram();u=[\"precision \"+K+\" float;\",\"precision \"+K+\" int;\",e,xb?\"#define VERTEX_TEXTURES\":\"\",I.gammaInput?\"#define GAMMA_INPUT\":\"\",I.gammaOutput?\"#define GAMMA_OUTPUT\":\n\"\",\"#define MAX_DIR_LIGHTS \"+c.maxDirLights,\"#define MAX_POINT_LIGHTS \"+c.maxPointLights,\"#define MAX_SPOT_LIGHTS \"+c.maxSpotLights,\"#define MAX_HEMI_LIGHTS \"+c.maxHemiLights,\"#define MAX_SHADOWS \"+c.maxShadows,\"#define MAX_BONES \"+c.maxBones,c.map?\"#define USE_MAP\":\"\",c.envMap?\"#define USE_ENVMAP\":\"\",c.lightMap?\"#define USE_LIGHTMAP\":\"\",c.bumpMap?\"#define USE_BUMPMAP\":\"\",c.normalMap?\"#define USE_NORMALMAP\":\"\",c.specularMap?\"#define USE_SPECULARMAP\":\"\",c.vertexColors?\"#define USE_COLOR\":\"\",c.skinning?\n\"#define USE_SKINNING\":\"\",c.useVertexTexture?\"#define BONE_TEXTURE\":\"\",c.morphTargets?\"#define USE_MORPHTARGETS\":\"\",c.morphNormals?\"#define USE_MORPHNORMALS\":\"\",c.perPixel?\"#define PHONG_PER_PIXEL\":\"\",c.wrapAround?\"#define WRAP_AROUND\":\"\",c.doubleSided?\"#define DOUBLE_SIDED\":\"\",c.flipSided?\"#define FLIP_SIDED\":\"\",c.shadowMapEnabled?\"#define USE_SHADOWMAP\":\"\",c.shadowMapEnabled?\"#define \"+s:\"\",c.shadowMapDebug?\"#define SHADOWMAP_DEBUG\":\"\",c.shadowMapCascade?\"#define SHADOWMAP_CASCADE\":\"\",c.sizeAttenuation?\n\"#define USE_SIZEATTENUATION\":\"\",\"uniform mat4 modelMatrix;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\nuniform vec3 cameraPosition;\\nattribute vec3 position;\\nattribute vec3 normal;\\nattribute vec2 uv;\\nattribute vec2 uv2;\\n#ifdef USE_COLOR\\nattribute vec3 color;\\n#endif\\n#ifdef USE_MORPHTARGETS\\nattribute vec3 morphTarget0;\\nattribute vec3 morphTarget1;\\nattribute vec3 morphTarget2;\\nattribute vec3 morphTarget3;\\n#ifdef USE_MORPHNORMALS\\nattribute vec3 morphNormal0;\\nattribute vec3 morphNormal1;\\nattribute vec3 morphNormal2;\\nattribute vec3 morphNormal3;\\n#else\\nattribute vec3 morphTarget4;\\nattribute vec3 morphTarget5;\\nattribute vec3 morphTarget6;\\nattribute vec3 morphTarget7;\\n#endif\\n#endif\\n#ifdef USE_SKINNING\\nattribute vec4 skinIndex;\\nattribute vec4 skinWeight;\\n#endif\\n\"].join(\"\\n\");\ns=[\"precision \"+K+\" float;\",\"precision \"+K+\" int;\",c.bumpMap||c.normalMap?\"#extension GL_OES_standard_derivatives : enable\":\"\",e,\"#define MAX_DIR_LIGHTS \"+c.maxDirLights,\"#define MAX_POINT_LIGHTS \"+c.maxPointLights,\"#define MAX_SPOT_LIGHTS \"+c.maxSpotLights,\"#define MAX_HEMI_LIGHTS \"+c.maxHemiLights,\"#define MAX_SHADOWS \"+c.maxShadows,c.alphaTest?\"#define ALPHATEST \"+c.alphaTest:\"\",I.gammaInput?\"#define GAMMA_INPUT\":\"\",I.gammaOutput?\"#define GAMMA_OUTPUT\":\"\",c.useFog&&c.fog?\"#define USE_FOG\":\"\",c.useFog&&\nc.fogExp?\"#define FOG_EXP2\":\"\",c.map?\"#define USE_MAP\":\"\",c.envMap?\"#define USE_ENVMAP\":\"\",c.lightMap?\"#define USE_LIGHTMAP\":\"\",c.bumpMap?\"#define USE_BUMPMAP\":\"\",c.normalMap?\"#define USE_NORMALMAP\":\"\",c.specularMap?\"#define USE_SPECULARMAP\":\"\",c.vertexColors?\"#define USE_COLOR\":\"\",c.metal?\"#define METAL\":\"\",c.perPixel?\"#define PHONG_PER_PIXEL\":\"\",c.wrapAround?\"#define WRAP_AROUND\":\"\",c.doubleSided?\"#define DOUBLE_SIDED\":\"\",c.flipSided?\"#define FLIP_SIDED\":\"\",c.shadowMapEnabled?\"#define USE_SHADOWMAP\":\n\"\",c.shadowMapEnabled?\"#define \"+s:\"\",c.shadowMapDebug?\"#define SHADOWMAP_DEBUG\":\"\",c.shadowMapCascade?\"#define SHADOWMAP_CASCADE\":\"\",\"uniform mat4 viewMatrix;\\nuniform vec3 cameraPosition;\\n\"].join(\"\\n\");u=L(\"vertex\",u+q);s=L(\"fragment\",s+r);j.attachShader(v,u);j.attachShader(v,s);d&&j.bindAttribLocation(v,0,d);j.linkProgram(v);j.getProgramParameter(v,j.LINK_STATUS)||(console.error(\"Could not initialise shader\\nVALIDATE_STATUS: \"+j.getProgramParameter(v,j.VALIDATE_STATUS)+\", gl error [\"+j.getError()+\n\"]\"),console.error(\"Program Info Log: \"+j.getProgramInfoLog(v)));j.deleteShader(s);j.deleteShader(u);v.uniforms={};v.attributes={};var w;s=\"viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences\".split(\" \");c.useVertexTexture?(s.push(\"boneTexture\"),s.push(\"boneTextureWidth\"),s.push(\"boneTextureHeight\")):s.push(\"boneGlobalMatrices\");for(w in p)s.push(w);w=s;s=0;for(u=w.length;s<u;s++)p=w[s],v.uniforms[p]=j.getUniformLocation(v,p);s=\"position normal uv uv2 tangent color skinIndex skinWeight lineDistance\".split(\" \");\nfor(w=0;w<c.maxMorphTargets;w++)s.push(\"morphTarget\"+w);for(w=0;w<c.maxMorphNormals;w++)s.push(\"morphNormal\"+w);for(k in b)s.push(k);k=s;w=0;for(b=k.length;w<b;w++)s=k[w],v.attributes[s]=j.getAttribLocation(v,s);v.id=Q++;P.push({program:v,code:n,usedTimes:1});I.info.memory.programs=P.length;k=v}a.program=k;w=a.program.attributes;if(a.morphTargets){a.numSupportedMorphTargets=0;b=\"morphTarget\";for(k=0;k<this.maxMorphTargets;k++)v=b+k,0<=w[v]&&a.numSupportedMorphTargets++}if(a.morphNormals){a.numSupportedMorphNormals=\n0;b=\"morphNormal\";for(k=0;k<this.maxMorphNormals;k++)v=b+k,0<=w[v]&&a.numSupportedMorphNormals++}a.uniformsList=[];for(i in a.uniforms)a.uniformsList.push([a.uniforms[i],i])};this.setFaceCulling=function(a,b){a===THREE.CullFaceNone?j.disable(j.CULL_FACE):(b===THREE.FrontFaceDirectionCW?j.frontFace(j.CW):j.frontFace(j.CCW),a===THREE.CullFaceBack?j.cullFace(j.BACK):a===THREE.CullFaceFront?j.cullFace(j.FRONT):j.cullFace(j.FRONT_AND_BACK),j.enable(j.CULL_FACE))};this.setMaterialFaces=function(a){var b=\na.side===THREE.DoubleSide,a=a.side===THREE.BackSide;sa!==b&&(b?j.disable(j.CULL_FACE):j.enable(j.CULL_FACE),sa=b);Aa!==a&&(a?j.frontFace(j.CW):j.frontFace(j.CCW),Aa=a)};this.setDepthTest=function(a){ca!==a&&(a?j.enable(j.DEPTH_TEST):j.disable(j.DEPTH_TEST),ca=a)};this.setDepthWrite=function(a){wa!==a&&(j.depthMask(a),wa=a)};this.setBlending=function(a,b,c,d){a!==ba&&(a===THREE.NoBlending?j.disable(j.BLEND):a===THREE.AdditiveBlending?(j.enable(j.BLEND),j.blendEquation(j.FUNC_ADD),j.blendFunc(j.SRC_ALPHA,\nj.ONE)):a===THREE.SubtractiveBlending?(j.enable(j.BLEND),j.blendEquation(j.FUNC_ADD),j.blendFunc(j.ZERO,j.ONE_MINUS_SRC_COLOR)):a===THREE.MultiplyBlending?(j.enable(j.BLEND),j.blendEquation(j.FUNC_ADD),j.blendFunc(j.ZERO,j.SRC_COLOR)):a===THREE.CustomBlending?j.enable(j.BLEND):(j.enable(j.BLEND),j.blendEquationSeparate(j.FUNC_ADD,j.FUNC_ADD),j.blendFuncSeparate(j.SRC_ALPHA,j.ONE_MINUS_SRC_ALPHA,j.ONE,j.ONE_MINUS_SRC_ALPHA)),ba=a);if(a===THREE.CustomBlending){if(b!==W&&(j.blendEquation(D(b)),W=b),\nc!==Ka||d!==U)j.blendFunc(D(c),D(d)),Ka=c,U=d}else U=Ka=W=null};this.setTexture=function(a,b){if(a.needsUpdate){a.__webglInit||(a.__webglInit=!0,a.addEventListener(\"dispose\",Bb),a.__webglTexture=j.createTexture(),I.info.memory.textures++);j.activeTexture(j.TEXTURE0+b);j.bindTexture(j.TEXTURE_2D,a.__webglTexture);j.pixelStorei(j.UNPACK_FLIP_Y_WEBGL,a.flipY);j.pixelStorei(j.UNPACK_PREMULTIPLY_ALPHA_WEBGL,a.premultiplyAlpha);j.pixelStorei(j.UNPACK_ALIGNMENT,a.unpackAlignment);var c=a.image,d=0===(c.width&\nc.width-1)&&0===(c.height&c.height-1),e=D(a.format),f=D(a.type);w(j.TEXTURE_2D,a,d);var g=a.mipmaps;if(a instanceof THREE.DataTexture)if(0<g.length&&d){for(var h=0,i=g.length;h<i;h++)c=g[h],j.texImage2D(j.TEXTURE_2D,h,e,c.width,c.height,0,e,f,c.data);a.generateMipmaps=!1}else j.texImage2D(j.TEXTURE_2D,0,e,c.width,c.height,0,e,f,c.data);else if(a instanceof THREE.CompressedTexture){h=0;for(i=g.length;h<i;h++)c=g[h],a.format!==THREE.RGBAFormat?j.compressedTexImage2D(j.TEXTURE_2D,h,e,c.width,c.height,\n0,c.data):j.texImage2D(j.TEXTURE_2D,h,e,c.width,c.height,0,e,f,c.data)}else if(0<g.length&&d){h=0;for(i=g.length;h<i;h++)c=g[h],j.texImage2D(j.TEXTURE_2D,h,e,e,f,c);a.generateMipmaps=!1}else j.texImage2D(j.TEXTURE_2D,0,e,e,f,a.image);a.generateMipmaps&&d&&j.generateMipmap(j.TEXTURE_2D);a.needsUpdate=!1;if(a.onUpdate)a.onUpdate()}else j.activeTexture(j.TEXTURE0+b),j.bindTexture(j.TEXTURE_2D,a.__webglTexture)};this.setRenderTarget=function(a){var b=a instanceof THREE.WebGLRenderTargetCube;if(a&&!a.__webglFramebuffer){void 0===\na.depthBuffer&&(a.depthBuffer=!0);void 0===a.stencilBuffer&&(a.stencilBuffer=!0);a.addEventListener(\"dispose\",Mb);a.__webglTexture=j.createTexture();I.info.memory.textures++;var c=0===(a.width&a.width-1)&&0===(a.height&a.height-1),d=D(a.format),e=D(a.type);if(b){a.__webglFramebuffer=[];a.__webglRenderbuffer=[];j.bindTexture(j.TEXTURE_CUBE_MAP,a.__webglTexture);w(j.TEXTURE_CUBE_MAP,a,c);for(var f=0;6>f;f++){a.__webglFramebuffer[f]=j.createFramebuffer();a.__webglRenderbuffer[f]=j.createRenderbuffer();\nj.texImage2D(j.TEXTURE_CUBE_MAP_POSITIVE_X+f,0,d,a.width,a.height,0,d,e,null);var g=a,h=j.TEXTURE_CUBE_MAP_POSITIVE_X+f;j.bindFramebuffer(j.FRAMEBUFFER,a.__webglFramebuffer[f]);j.framebufferTexture2D(j.FRAMEBUFFER,j.COLOR_ATTACHMENT0,h,g.__webglTexture,0);E(a.__webglRenderbuffer[f],a)}c&&j.generateMipmap(j.TEXTURE_CUBE_MAP)}else a.__webglFramebuffer=j.createFramebuffer(),a.__webglRenderbuffer=a.shareDepthFrom?a.shareDepthFrom.__webglRenderbuffer:j.createRenderbuffer(),j.bindTexture(j.TEXTURE_2D,a.__webglTexture),\nw(j.TEXTURE_2D,a,c),j.texImage2D(j.TEXTURE_2D,0,d,a.width,a.height,0,d,e,null),d=j.TEXTURE_2D,j.bindFramebuffer(j.FRAMEBUFFER,a.__webglFramebuffer),j.framebufferTexture2D(j.FRAMEBUFFER,j.COLOR_ATTACHMENT0,d,a.__webglTexture,0),a.shareDepthFrom?a.depthBuffer&&!a.stencilBuffer?j.framebufferRenderbuffer(j.FRAMEBUFFER,j.DEPTH_ATTACHMENT,j.RENDERBUFFER,a.__webglRenderbuffer):a.depthBuffer&&a.stencilBuffer&&j.framebufferRenderbuffer(j.FRAMEBUFFER,j.DEPTH_STENCIL_ATTACHMENT,j.RENDERBUFFER,a.__webglRenderbuffer):\nE(a.__webglRenderbuffer,a),c&&j.generateMipmap(j.TEXTURE_2D);b?j.bindTexture(j.TEXTURE_CUBE_MAP,null):j.bindTexture(j.TEXTURE_2D,null);j.bindRenderbuffer(j.RENDERBUFFER,null);j.bindFramebuffer(j.FRAMEBUFFER,null)}a?(b=b?a.__webglFramebuffer[a.activeCubeFace]:a.__webglFramebuffer,c=a.width,a=a.height,e=d=0):(b=null,c=Ba,a=xa,d=Fa,e=Ga);b!==va&&(j.bindFramebuffer(j.FRAMEBUFFER,b),j.viewport(d,e,c,a),va=b);Va=c;La=a};this.shadowMapPlugin=new THREE.ShadowMapPlugin;this.addPrePlugin(this.shadowMapPlugin);\nthis.addPostPlugin(new THREE.SpritePlugin);this.addPostPlugin(new THREE.LensFlarePlugin)};THREE.WebGLRenderTarget=function(a,b,c){this.width=a;this.height=b;c=c||{};this.wrapS=void 0!==c.wrapS?c.wrapS:THREE.ClampToEdgeWrapping;this.wrapT=void 0!==c.wrapT?c.wrapT:THREE.ClampToEdgeWrapping;this.magFilter=void 0!==c.magFilter?c.magFilter:THREE.LinearFilter;this.minFilter=void 0!==c.minFilter?c.minFilter:THREE.LinearMipMapLinearFilter;this.anisotropy=void 0!==c.anisotropy?c.anisotropy:1;this.offset=new THREE.Vector2(0,0);this.repeat=new THREE.Vector2(1,1);this.format=void 0!==c.format?c.format:\nTHREE.RGBAFormat;this.type=void 0!==c.type?c.type:THREE.UnsignedByteType;this.depthBuffer=void 0!==c.depthBuffer?c.depthBuffer:!0;this.stencilBuffer=void 0!==c.stencilBuffer?c.stencilBuffer:!0;this.generateMipmaps=!0;this.shareDepthFrom=null};\nTHREE.WebGLRenderTarget.prototype={constructor:THREE.WebGLRenderTarget,clone:function(){var a=new THREE.WebGLRenderTarget(this.width,this.height);a.wrapS=this.wrapS;a.wrapT=this.wrapT;a.magFilter=this.magFilter;a.minFilter=this.minFilter;a.anisotropy=this.anisotropy;a.offset.copy(this.offset);a.repeat.copy(this.repeat);a.format=this.format;a.type=this.type;a.depthBuffer=this.depthBuffer;a.stencilBuffer=this.stencilBuffer;a.generateMipmaps=this.generateMipmaps;a.shareDepthFrom=this.shareDepthFrom;\nreturn a},dispose:function(){this.dispatchEvent({type:\"dispose\"})}};THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);THREE.WebGLRenderTargetCube=function(a,b,c){THREE.WebGLRenderTarget.call(this,a,b,c);this.activeCubeFace=0};THREE.WebGLRenderTargetCube.prototype=Object.create(THREE.WebGLRenderTarget.prototype);THREE.RenderableVertex=function(){this.position=new THREE.Vector3;this.positionWorld=new THREE.Vector3;this.positionScreen=new THREE.Vector4;this.visible=!0};THREE.RenderableVertex.prototype.copy=function(a){this.positionWorld.copy(a.positionWorld);this.positionScreen.copy(a.positionScreen)};THREE.RenderableFace3=function(){this.id=0;this.v1=new THREE.RenderableVertex;this.v2=new THREE.RenderableVertex;this.v3=new THREE.RenderableVertex;this.centroidModel=new THREE.Vector3;this.normalModel=new THREE.Vector3;this.normalModelView=new THREE.Vector3;this.vertexNormalsLength=0;this.vertexNormalsModel=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];this.vertexNormalsModelView=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];this.material=this.color=null;this.uvs=[[]];this.z=\n0};THREE.RenderableObject=function(){this.id=0;this.object=null;this.z=0};THREE.RenderableSprite=function(){this.id=0;this.object=null;this.rotation=this.z=this.y=this.x=0;this.scale=new THREE.Vector2;this.material=null};THREE.RenderableLine=function(){this.id=0;this.v1=new THREE.RenderableVertex;this.v2=new THREE.RenderableVertex;this.vertexColors=[new THREE.Color,new THREE.Color];this.material=null;this.z=0};THREE.GeometryUtils={merge:function(a,b,c){var d,e,f=a.vertices.length,g=b instanceof THREE.Mesh?b.geometry:b,h=a.vertices,i=g.vertices,k=a.faces,l=g.faces,a=a.faceVertexUvs[0],g=g.faceVertexUvs[0];void 0===c&&(c=0);b instanceof THREE.Mesh&&(b.matrixAutoUpdate&&b.updateMatrix(),d=b.matrix,e=(new THREE.Matrix3).getNormalMatrix(d));for(var b=0,n=i.length;b<n;b++){var p=i[b].clone();d&&p.applyMatrix4(d);h.push(p)}b=0;for(n=l.length;b<n;b++){var p=l[b],t,r,m=p.vertexNormals,q=p.vertexColors;t=new THREE.Face3(p.a+\nf,p.b+f,p.c+f);t.normal.copy(p.normal);e&&t.normal.applyMatrix3(e).normalize();h=0;for(i=m.length;h<i;h++)r=m[h].clone(),e&&r.applyMatrix3(e).normalize(),t.vertexNormals.push(r);t.color.copy(p.color);h=0;for(i=q.length;h<i;h++)r=q[h],t.vertexColors.push(r.clone());t.materialIndex=p.materialIndex+c;t.centroid.copy(p.centroid);d&&t.centroid.applyMatrix4(d);k.push(t)}b=0;for(n=g.length;b<n;b++){c=g[b];d=[];h=0;for(i=c.length;h<i;h++)d.push(new THREE.Vector2(c[h].x,c[h].y));a.push(d)}},randomPointInTriangle:function(){var a=\nnew THREE.Vector3;return function(b,c,d){var e=new THREE.Vector3,f=THREE.Math.random16(),g=THREE.Math.random16();1<f+g&&(f=1-f,g=1-g);var h=1-f-g;e.copy(b);e.multiplyScalar(f);a.copy(c);a.multiplyScalar(g);e.add(a);a.copy(d);a.multiplyScalar(h);e.add(a);return e}}(),randomPointInFace:function(a,b){return THREE.GeometryUtils.randomPointInTriangle(b.vertices[a.a],b.vertices[a.b],b.vertices[a.c])},randomPointsInGeometry:function(a,b){function c(a){function b(c,d){if(d<c)return c;var e=c+Math.floor((d-\nc)/2);return k[e]>a?b(c,e-1):k[e]<a?b(e+1,d):e}return b(0,k.length-1)}var d,e,f=a.faces,g=a.vertices,h=f.length,i=0,k=[],l,n,p;for(e=0;e<h;e++)d=f[e],l=g[d.a],n=g[d.b],p=g[d.c],d._area=THREE.GeometryUtils.triangleArea(l,n,p),i+=d._area,k[e]=i;d=[];for(e=0;e<b;e++)g=THREE.Math.random16()*i,g=c(g),d[e]=THREE.GeometryUtils.randomPointInFace(f[g],a,!0);return d},triangleArea:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d,e){a.subVectors(d,c);b.subVectors(e,c);a.cross(b);return 0.5*\na.length()}}(),center:function(a){a.computeBoundingBox();var b=a.boundingBox,c=new THREE.Vector3;c.addVectors(b.min,b.max);c.multiplyScalar(-0.5);a.applyMatrix((new THREE.Matrix4).makeTranslation(c.x,c.y,c.z));a.computeBoundingBox();return c},triangulateQuads:function(a){var b,c,d,e,f=[],g=[];b=0;for(c=a.faceVertexUvs.length;b<c;b++)g[b]=[];b=0;for(c=a.faces.length;b<c;b++){f.push(a.faces[b]);d=0;for(e=a.faceVertexUvs.length;d<e;d++)g[d].push(a.faceVertexUvs[d][b])}a.faces=f;a.faceVertexUvs=g;a.computeCentroids();\na.computeFaceNormals();a.computeVertexNormals();a.hasTangents&&a.computeTangents()}};THREE.ImageUtils={crossOrigin:void 0,loadTexture:function(a,b,c){var d=new THREE.ImageLoader;d.crossOrigin=this.crossOrigin;var e=new THREE.Texture(void 0,b),b=d.load(a,function(){e.needsUpdate=!0;c&&c(e)});e.image=b;e.sourceFile=a;return e},loadCompressedTexture:function(a,b,c,d){var e=new THREE.CompressedTexture;e.mapping=b;var f=new XMLHttpRequest;f.onload=function(){var a=THREE.ImageUtils.parseDDS(f.response,!0);e.format=a.format;e.mipmaps=a.mipmaps;e.image.width=a.width;e.image.height=a.height;\ne.generateMipmaps=!1;e.needsUpdate=!0;c&&c(e)};f.onerror=d;f.open(\"GET\",a,!0);f.responseType=\"arraybuffer\";f.send(null);return e},loadTextureCube:function(a,b,c,d){var e=[];e.loadCount=0;var f=new THREE.Texture;f.image=e;void 0!==b&&(f.mapping=b);f.flipY=!1;for(var b=0,g=a.length;b<g;++b){var h=new Image;e[b]=h;h.onload=function(){e.loadCount+=1;6===e.loadCount&&(f.needsUpdate=!0,c&&c(f))};h.onerror=d;h.crossOrigin=this.crossOrigin;h.src=a[b]}return f},loadCompressedTextureCube:function(a,b,c,d){var e=\n[];e.loadCount=0;var f=new THREE.CompressedTexture;f.image=e;void 0!==b&&(f.mapping=b);f.flipY=!1;f.generateMipmaps=!1;b=function(a,b){return function(){var d=THREE.ImageUtils.parseDDS(a.response,!0);b.format=d.format;b.mipmaps=d.mipmaps;b.width=d.width;b.height=d.height;e.loadCount+=1;6===e.loadCount&&(f.format=d.format,f.needsUpdate=!0,c&&c(f))}};if(a instanceof Array)for(var g=0,h=a.length;g<h;++g){var i={};e[g]=i;var k=new XMLHttpRequest;k.onload=b(k,i);k.onerror=d;i=a[g];k.open(\"GET\",i,!0);k.responseType=\n\"arraybuffer\";k.send(null)}else k=new XMLHttpRequest,k.onload=function(){var a=THREE.ImageUtils.parseDDS(k.response,!0);if(a.isCubemap){for(var b=a.mipmaps.length/a.mipmapCount,d=0;d<b;d++){e[d]={mipmaps:[]};for(var g=0;g<a.mipmapCount;g++)e[d].mipmaps.push(a.mipmaps[d*a.mipmapCount+g]),e[d].format=a.format,e[d].width=a.width,e[d].height=a.height}f.format=a.format;f.needsUpdate=!0;c&&c(f)}},k.onerror=d,k.open(\"GET\",a,!0),k.responseType=\"arraybuffer\",k.send(null);return f},loadDDSTexture:function(a,\nb,c,d){var e=[];e.loadCount=0;var f=new THREE.CompressedTexture;f.image=e;void 0!==b&&(f.mapping=b);f.flipY=!1;f.generateMipmaps=!1;var g=new XMLHttpRequest;g.onload=function(){var a=THREE.ImageUtils.parseDDS(g.response,!0);if(a.isCubemap)for(var b=a.mipmaps.length/a.mipmapCount,d=0;d<b;d++){e[d]={mipmaps:[]};for(var l=0;l<a.mipmapCount;l++)e[d].mipmaps.push(a.mipmaps[d*a.mipmapCount+l]),e[d].format=a.format,e[d].width=a.width,e[d].height=a.height}else f.image.width=a.width,f.image.height=a.height,\nf.mipmaps=a.mipmaps;f.format=a.format;f.needsUpdate=!0;c&&c(f)};g.onerror=d;g.open(\"GET\",a,!0);g.responseType=\"arraybuffer\";g.send(null);return f},parseDDS:function(a,b){function c(a){return a.charCodeAt(0)+(a.charCodeAt(1)<<8)+(a.charCodeAt(2)<<16)+(a.charCodeAt(3)<<24)}var d={mipmaps:[],width:0,height:0,format:null,mipmapCount:1},e=c(\"DXT1\"),f=c(\"DXT3\"),g=c(\"DXT5\"),h=new Int32Array(a,0,31);if(542327876!==h[0])return console.error(\"ImageUtils.parseDDS(): Invalid magic number in DDS header\"),d;if(!h[20]&\n4)return console.error(\"ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code\"),d;var i=h[21],k=!1;switch(i){case e:e=8;d.format=THREE.RGB_S3TC_DXT1_Format;break;case f:e=16;d.format=THREE.RGBA_S3TC_DXT3_Format;break;case g:e=16;d.format=THREE.RGBA_S3TC_DXT5_Format;break;default:if(32==h[22]&&h[23]&16711680&&h[24]&65280&&h[25]&255&&h[26]&4278190080)k=!0,e=64,d.format=THREE.RGBAFormat;else return console.error(\"ImageUtils.parseDDS(): Unsupported FourCC code: \",String.fromCharCode(i&\n255,i>>8&255,i>>16&255,i>>24&255)),d}d.mipmapCount=1;h[2]&131072&&!1!==b&&(d.mipmapCount=Math.max(1,h[7]));d.isCubemap=h[28]&512?!0:!1;d.width=h[4];d.height=h[3];for(var h=h[1]+4,f=d.width,g=d.height,i=d.isCubemap?6:1,l=0;l<i;l++){for(var n=0;n<d.mipmapCount;n++){if(k){var p;p=f;for(var t=g,r=4*p*t,m=new Uint8Array(a,h,r),r=new Uint8Array(r),q=0,u=0,s=0;s<t;s++)for(var v=0;v<p;v++){var z=m[u];u++;var G=m[u];u++;var N=m[u];u++;var C=m[u];u++;r[q]=N;q++;r[q]=G;q++;r[q]=z;q++;r[q]=C;q++}p=r;t=p.length}else t=\nMath.max(4,f)/4*Math.max(4,g)/4*e,p=new Uint8Array(a,h,t);d.mipmaps.push({data:p,width:f,height:g});h+=t;f=Math.max(0.5*f,1);g=Math.max(0.5*g,1)}f=d.width;g=d.height}return d},getNormalMap:function(a,b){var c=function(a){var b=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);return[a[0]/b,a[1]/b,a[2]/b]},b=b|1,d=a.width,e=a.height,f=document.createElement(\"canvas\");f.width=d;f.height=e;var g=f.getContext(\"2d\");g.drawImage(a,0,0);for(var h=g.getImageData(0,0,d,e).data,i=g.createImageData(d,e),k=i.data,l=0;l<\nd;l++)for(var n=0;n<e;n++){var p=0>n-1?0:n-1,t=n+1>e-1?e-1:n+1,r=0>l-1?0:l-1,m=l+1>d-1?d-1:l+1,q=[],u=[0,0,h[4*(n*d+l)]/255*b];q.push([-1,0,h[4*(n*d+r)]/255*b]);q.push([-1,-1,h[4*(p*d+r)]/255*b]);q.push([0,-1,h[4*(p*d+l)]/255*b]);q.push([1,-1,h[4*(p*d+m)]/255*b]);q.push([1,0,h[4*(n*d+m)]/255*b]);q.push([1,1,h[4*(t*d+m)]/255*b]);q.push([0,1,h[4*(t*d+l)]/255*b]);q.push([-1,1,h[4*(t*d+r)]/255*b]);p=[];r=q.length;for(t=0;t<r;t++){var m=q[t],s=q[(t+1)%r],m=[m[0]-u[0],m[1]-u[1],m[2]-u[2]],s=[s[0]-u[0],\ns[1]-u[1],s[2]-u[2]];p.push(c([m[1]*s[2]-m[2]*s[1],m[2]*s[0]-m[0]*s[2],m[0]*s[1]-m[1]*s[0]]))}q=[0,0,0];for(t=0;t<p.length;t++)q[0]+=p[t][0],q[1]+=p[t][1],q[2]+=p[t][2];q[0]/=p.length;q[1]/=p.length;q[2]/=p.length;u=4*(n*d+l);k[u]=255*((q[0]+1)/2)|0;k[u+1]=255*((q[1]+1)/2)|0;k[u+2]=255*q[2]|0;k[u+3]=255}g.putImageData(i,0,0);return f},generateDataTexture:function(a,b,c){for(var d=a*b,e=new Uint8Array(3*d),f=Math.floor(255*c.r),g=Math.floor(255*c.g),c=Math.floor(255*c.b),h=0;h<d;h++)e[3*h]=f,e[3*h+\n1]=g,e[3*h+2]=c;a=new THREE.DataTexture(e,a,b,THREE.RGBFormat);a.needsUpdate=!0;return a}};THREE.SceneUtils={createMultiMaterialObject:function(a,b){for(var c=new THREE.Object3D,d=0,e=b.length;d<e;d++)c.add(new THREE.Mesh(a,b[d]));return c},detach:function(a,b,c){a.applyMatrix(b.matrixWorld);b.remove(a);c.add(a)},attach:function(a,b,c){var d=new THREE.Matrix4;d.getInverse(c.matrixWorld);a.applyMatrix(d);b.remove(a);c.add(a)}};THREE.FontUtils={faces:{},face:\"helvetiker\",weight:\"normal\",style:\"normal\",size:150,divisions:10,getFace:function(){return this.faces[this.face][this.weight][this.style]},loadFace:function(a){var b=a.familyName.toLowerCase();this.faces[b]=this.faces[b]||{};this.faces[b][a.cssFontWeight]=this.faces[b][a.cssFontWeight]||{};this.faces[b][a.cssFontWeight][a.cssFontStyle]=a;return this.faces[b][a.cssFontWeight][a.cssFontStyle]=a},drawText:function(a){for(var b=this.getFace(),c=this.size/b.resolution,d=\n0,e=String(a).split(\"\"),f=e.length,g=[],a=0;a<f;a++){var h=new THREE.Path,h=this.extractGlyphPoints(e[a],b,c,d,h),d=d+h.offset;g.push(h.path)}return{paths:g,offset:d/2}},extractGlyphPoints:function(a,b,c,d,e){var f=[],g,h,i,k,l,n,p,t,r,m,q,u=b.glyphs[a]||b.glyphs[\"?\"];if(u){if(u.o){b=u._cachedOutline||(u._cachedOutline=u.o.split(\" \"));k=b.length;for(a=0;a<k;)switch(i=b[a++],i){case \"m\":i=b[a++]*c+d;l=b[a++]*c;e.moveTo(i,l);break;case \"l\":i=b[a++]*c+d;l=b[a++]*c;e.lineTo(i,l);break;case \"q\":i=b[a++]*\nc+d;l=b[a++]*c;t=b[a++]*c+d;r=b[a++]*c;e.quadraticCurveTo(t,r,i,l);if(g=f[f.length-1]){n=g.x;p=g.y;g=1;for(h=this.divisions;g<=h;g++){var s=g/h;THREE.Shape.Utils.b2(s,n,t,i);THREE.Shape.Utils.b2(s,p,r,l)}}break;case \"b\":if(i=b[a++]*c+d,l=b[a++]*c,t=b[a++]*c+d,r=b[a++]*-c,m=b[a++]*c+d,q=b[a++]*-c,e.bezierCurveTo(i,l,t,r,m,q),g=f[f.length-1]){n=g.x;p=g.y;g=1;for(h=this.divisions;g<=h;g++)s=g/h,THREE.Shape.Utils.b3(s,n,t,m,i),THREE.Shape.Utils.b3(s,p,r,q,l)}}}return{offset:u.ha*c,path:e}}}};\nTHREE.FontUtils.generateShapes=function(a,b){var b=b||{},c=void 0!==b.curveSegments?b.curveSegments:4,d=void 0!==b.font?b.font:\"helvetiker\",e=void 0!==b.weight?b.weight:\"normal\",f=void 0!==b.style?b.style:\"normal\";THREE.FontUtils.size=void 0!==b.size?b.size:100;THREE.FontUtils.divisions=c;THREE.FontUtils.face=d;THREE.FontUtils.weight=e;THREE.FontUtils.style=f;c=THREE.FontUtils.drawText(a).paths;d=[];e=0;for(f=c.length;e<f;e++)Array.prototype.push.apply(d,c[e].toShapes());return d};\n(function(a){var b=function(a){for(var b=a.length,e=0,f=b-1,g=0;g<b;f=g++)e+=a[f].x*a[g].y-a[g].x*a[f].y;return 0.5*e};a.Triangulate=function(a,d){var e=a.length;if(3>e)return null;var f=[],g=[],h=[],i,k,l;if(0<b(a))for(k=0;k<e;k++)g[k]=k;else for(k=0;k<e;k++)g[k]=e-1-k;var n=2*e;for(k=e-1;2<e;){if(0>=n--){console.log(\"Warning, unable to triangulate polygon!\");break}i=k;e<=i&&(i=0);k=i+1;e<=k&&(k=0);l=k+1;e<=l&&(l=0);var p;a:{var t=p=void 0,r=void 0,m=void 0,q=void 0,u=void 0,s=void 0,v=void 0,z=\nvoid 0,t=a[g[i]].x,r=a[g[i]].y,m=a[g[k]].x,q=a[g[k]].y,u=a[g[l]].x,s=a[g[l]].y;if(1E-10>(m-t)*(s-r)-(q-r)*(u-t))p=!1;else{var G=void 0,N=void 0,C=void 0,B=void 0,x=void 0,F=void 0,L=void 0,w=void 0,E=void 0,y=void 0,E=w=L=z=v=void 0,G=u-m,N=s-q,C=t-u,B=r-s,x=m-t,F=q-r;for(p=0;p<e;p++)if(!(p===i||p===k||p===l))if(v=a[g[p]].x,z=a[g[p]].y,L=v-t,w=z-r,E=v-m,y=z-q,v-=u,z-=s,E=G*y-N*E,L=x*w-F*L,w=C*z-B*v,-1E-10<=E&&-1E-10<=w&&-1E-10<=L){p=!1;break a}p=!0}}if(p){f.push([a[g[i]],a[g[k]],a[g[l]]]);h.push([g[i],\ng[k],g[l]]);i=k;for(l=k+1;l<e;i++,l++)g[i]=g[l];e--;n=2*e}}return d?h:f};a.Triangulate.area=b;return a})(THREE.FontUtils);self._typeface_js={faces:THREE.FontUtils.faces,loadFace:THREE.FontUtils.loadFace};THREE.typeface_js=self._typeface_js;THREE.Curve=function(){};THREE.Curve.prototype.getPoint=function(){console.log(\"Warning, getPoint() not implemented!\");return null};THREE.Curve.prototype.getPointAt=function(a){a=this.getUtoTmapping(a);return this.getPoint(a)};THREE.Curve.prototype.getPoints=function(a){a||(a=5);var b,c=[];for(b=0;b<=a;b++)c.push(this.getPoint(b/a));return c};THREE.Curve.prototype.getSpacedPoints=function(a){a||(a=5);var b,c=[];for(b=0;b<=a;b++)c.push(this.getPointAt(b/a));return c};\nTHREE.Curve.prototype.getLength=function(){var a=this.getLengths();return a[a.length-1]};THREE.Curve.prototype.getLengths=function(a){a||(a=this.__arcLengthDivisions?this.__arcLengthDivisions:200);if(this.cacheArcLengths&&this.cacheArcLengths.length==a+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;var b=[],c,d=this.getPoint(0),e,f=0;b.push(0);for(e=1;e<=a;e++)c=this.getPoint(e/a),f+=c.distanceTo(d),b.push(f),d=c;return this.cacheArcLengths=b};\nTHREE.Curve.prototype.updateArcLengths=function(){this.needsUpdate=!0;this.getLengths()};THREE.Curve.prototype.getUtoTmapping=function(a,b){var c=this.getLengths(),d=0,e=c.length,f;f=b?b:a*c[e-1];for(var g=0,h=e-1,i;g<=h;)if(d=Math.floor(g+(h-g)/2),i=c[d]-f,0>i)g=d+1;else if(0<i)h=d-1;else{h=d;break}d=h;if(c[d]==f)return d/(e-1);g=c[d];return c=(d+(f-g)/(c[d+1]-g))/(e-1)};THREE.Curve.prototype.getTangent=function(a){var b=a-1E-4,a=a+1E-4;0>b&&(b=0);1<a&&(a=1);b=this.getPoint(b);return this.getPoint(a).clone().sub(b).normalize()};\nTHREE.Curve.prototype.getTangentAt=function(a){a=this.getUtoTmapping(a);return this.getTangent(a)};\nTHREE.Curve.Utils={tangentQuadraticBezier:function(a,b,c,d){return 2*(1-a)*(c-b)+2*a*(d-c)},tangentCubicBezier:function(a,b,c,d,e){return-3*b*(1-a)*(1-a)+3*c*(1-a)*(1-a)-6*a*c*(1-a)+6*a*d*(1-a)-3*a*a*d+3*a*a*e},tangentSpline:function(a){return 6*a*a-6*a+(3*a*a-4*a+1)+(-6*a*a+6*a)+(3*a*a-2*a)},interpolate:function(a,b,c,d,e){var a=0.5*(c-a),d=0.5*(d-b),f=e*e;return(2*b-2*c+a+d)*e*f+(-3*b+3*c-2*a-d)*f+a*e+b}};\nTHREE.Curve.create=function(a,b){a.prototype=Object.create(THREE.Curve.prototype);a.prototype.getPoint=b;return a};THREE.CurvePath=function(){this.curves=[];this.bends=[];this.autoClose=!1};THREE.CurvePath.prototype=Object.create(THREE.Curve.prototype);THREE.CurvePath.prototype.add=function(a){this.curves.push(a)};THREE.CurvePath.prototype.checkConnection=function(){};THREE.CurvePath.prototype.closePath=function(){var a=this.curves[0].getPoint(0),b=this.curves[this.curves.length-1].getPoint(1);a.equals(b)||this.curves.push(new THREE.LineCurve(b,a))};\nTHREE.CurvePath.prototype.getPoint=function(a){for(var b=a*this.getLength(),c=this.getCurveLengths(),a=0;a<c.length;){if(c[a]>=b)return b=c[a]-b,a=this.curves[a],b=1-b/a.getLength(),a.getPointAt(b);a++}return null};THREE.CurvePath.prototype.getLength=function(){var a=this.getCurveLengths();return a[a.length-1]};\nTHREE.CurvePath.prototype.getCurveLengths=function(){if(this.cacheLengths&&this.cacheLengths.length==this.curves.length)return this.cacheLengths;var a=[],b=0,c,d=this.curves.length;for(c=0;c<d;c++)b+=this.curves[c].getLength(),a.push(b);return this.cacheLengths=a};\nTHREE.CurvePath.prototype.getBoundingBox=function(){var a=this.getPoints(),b,c,d,e,f,g;b=c=Number.NEGATIVE_INFINITY;e=f=Number.POSITIVE_INFINITY;var h,i,k,l,n=a[0]instanceof THREE.Vector3;l=n?new THREE.Vector3:new THREE.Vector2;i=0;for(k=a.length;i<k;i++)h=a[i],h.x>b?b=h.x:h.x<e&&(e=h.x),h.y>c?c=h.y:h.y<f&&(f=h.y),n&&(h.z>d?d=h.z:h.z<g&&(g=h.z)),l.add(h);a={minX:e,minY:f,maxX:b,maxY:c,centroid:l.divideScalar(k)};n&&(a.maxZ=d,a.minZ=g);return a};\nTHREE.CurvePath.prototype.createPointsGeometry=function(a){a=this.getPoints(a,!0);return this.createGeometry(a)};THREE.CurvePath.prototype.createSpacedPointsGeometry=function(a){a=this.getSpacedPoints(a,!0);return this.createGeometry(a)};THREE.CurvePath.prototype.createGeometry=function(a){for(var b=new THREE.Geometry,c=0;c<a.length;c++)b.vertices.push(new THREE.Vector3(a[c].x,a[c].y,a[c].z||0));return b};THREE.CurvePath.prototype.addWrapPath=function(a){this.bends.push(a)};\nTHREE.CurvePath.prototype.getTransformedPoints=function(a,b){var c=this.getPoints(a),d,e;b||(b=this.bends);d=0;for(e=b.length;d<e;d++)c=this.getWrapPoints(c,b[d]);return c};THREE.CurvePath.prototype.getTransformedSpacedPoints=function(a,b){var c=this.getSpacedPoints(a),d,e;b||(b=this.bends);d=0;for(e=b.length;d<e;d++)c=this.getWrapPoints(c,b[d]);return c};\nTHREE.CurvePath.prototype.getWrapPoints=function(a,b){var c=this.getBoundingBox(),d,e,f,g,h,i;d=0;for(e=a.length;d<e;d++)f=a[d],g=f.x,h=f.y,i=g/c.maxX,i=b.getUtoTmapping(i,g),g=b.getPoint(i),i=b.getTangent(i),i.set(-i.y,i.x).multiplyScalar(h),f.x=g.x+i.x,f.y=g.y+i.y;return a};THREE.Gyroscope=function(){THREE.Object3D.call(this)};THREE.Gyroscope.prototype=Object.create(THREE.Object3D.prototype);\nTHREE.Gyroscope.prototype.updateMatrixWorld=function(a){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||a)this.parent?(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorld.decompose(this.translationWorld,this.quaternionWorld,this.scaleWorld),this.matrix.decompose(this.translationObject,this.quaternionObject,this.scaleObject),this.matrixWorld.compose(this.translationWorld,this.quaternionObject,this.scaleWorld)):this.matrixWorld.copy(this.matrix),\nthis.matrixWorldNeedsUpdate=!1,a=!0;for(var b=0,c=this.children.length;b<c;b++)this.children[b].updateMatrixWorld(a)};THREE.Gyroscope.prototype.translationWorld=new THREE.Vector3;THREE.Gyroscope.prototype.translationObject=new THREE.Vector3;THREE.Gyroscope.prototype.quaternionWorld=new THREE.Quaternion;THREE.Gyroscope.prototype.quaternionObject=new THREE.Quaternion;THREE.Gyroscope.prototype.scaleWorld=new THREE.Vector3;THREE.Gyroscope.prototype.scaleObject=new THREE.Vector3;THREE.Path=function(a){THREE.CurvePath.call(this);this.actions=[];a&&this.fromPoints(a)};THREE.Path.prototype=Object.create(THREE.CurvePath.prototype);THREE.PathActions={MOVE_TO:\"moveTo\",LINE_TO:\"lineTo\",QUADRATIC_CURVE_TO:\"quadraticCurveTo\",BEZIER_CURVE_TO:\"bezierCurveTo\",CSPLINE_THRU:\"splineThru\",ARC:\"arc\",ELLIPSE:\"ellipse\"};THREE.Path.prototype.fromPoints=function(a){this.moveTo(a[0].x,a[0].y);for(var b=1,c=a.length;b<c;b++)this.lineTo(a[b].x,a[b].y)};\nTHREE.Path.prototype.moveTo=function(a,b){var c=Array.prototype.slice.call(arguments);this.actions.push({action:THREE.PathActions.MOVE_TO,args:c})};THREE.Path.prototype.lineTo=function(a,b){var c=Array.prototype.slice.call(arguments),d=this.actions[this.actions.length-1].args,d=new THREE.LineCurve(new THREE.Vector2(d[d.length-2],d[d.length-1]),new THREE.Vector2(a,b));this.curves.push(d);this.actions.push({action:THREE.PathActions.LINE_TO,args:c})};\nTHREE.Path.prototype.quadraticCurveTo=function(a,b,c,d){var e=Array.prototype.slice.call(arguments),f=this.actions[this.actions.length-1].args,f=new THREE.QuadraticBezierCurve(new THREE.Vector2(f[f.length-2],f[f.length-1]),new THREE.Vector2(a,b),new THREE.Vector2(c,d));this.curves.push(f);this.actions.push({action:THREE.PathActions.QUADRATIC_CURVE_TO,args:e})};\nTHREE.Path.prototype.bezierCurveTo=function(a,b,c,d,e,f){var g=Array.prototype.slice.call(arguments),h=this.actions[this.actions.length-1].args,h=new THREE.CubicBezierCurve(new THREE.Vector2(h[h.length-2],h[h.length-1]),new THREE.Vector2(a,b),new THREE.Vector2(c,d),new THREE.Vector2(e,f));this.curves.push(h);this.actions.push({action:THREE.PathActions.BEZIER_CURVE_TO,args:g})};\nTHREE.Path.prototype.splineThru=function(a){var b=Array.prototype.slice.call(arguments),c=this.actions[this.actions.length-1].args,c=[new THREE.Vector2(c[c.length-2],c[c.length-1])];Array.prototype.push.apply(c,a);c=new THREE.SplineCurve(c);this.curves.push(c);this.actions.push({action:THREE.PathActions.CSPLINE_THRU,args:b})};THREE.Path.prototype.arc=function(a,b,c,d,e,f){var g=this.actions[this.actions.length-1].args;this.absarc(a+g[g.length-2],b+g[g.length-1],c,d,e,f)};\nTHREE.Path.prototype.absarc=function(a,b,c,d,e,f){this.absellipse(a,b,c,c,d,e,f)};THREE.Path.prototype.ellipse=function(a,b,c,d,e,f,g){var h=this.actions[this.actions.length-1].args;this.absellipse(a+h[h.length-2],b+h[h.length-1],c,d,e,f,g)};THREE.Path.prototype.absellipse=function(a,b,c,d,e,f,g){var h=Array.prototype.slice.call(arguments),i=new THREE.EllipseCurve(a,b,c,d,e,f,g);this.curves.push(i);i=i.getPoint(1);h.push(i.x);h.push(i.y);this.actions.push({action:THREE.PathActions.ELLIPSE,args:h})};\nTHREE.Path.prototype.getSpacedPoints=function(a){a||(a=40);for(var b=[],c=0;c<a;c++)b.push(this.getPoint(c/a));return b};\nTHREE.Path.prototype.getPoints=function(a,b){if(this.useSpacedPoints)return console.log(\"tata\"),this.getSpacedPoints(a,b);var a=a||12,c=[],d,e,f,g,h,i,k,l,n,p,t,r,m;d=0;for(e=this.actions.length;d<e;d++)switch(f=this.actions[d],g=f.action,f=f.args,g){case THREE.PathActions.MOVE_TO:c.push(new THREE.Vector2(f[0],f[1]));break;case THREE.PathActions.LINE_TO:c.push(new THREE.Vector2(f[0],f[1]));break;case THREE.PathActions.QUADRATIC_CURVE_TO:h=f[2];i=f[3];n=f[0];p=f[1];0<c.length?(g=c[c.length-1],t=g.x,\nr=g.y):(g=this.actions[d-1].args,t=g[g.length-2],r=g[g.length-1]);for(f=1;f<=a;f++)m=f/a,g=THREE.Shape.Utils.b2(m,t,n,h),m=THREE.Shape.Utils.b2(m,r,p,i),c.push(new THREE.Vector2(g,m));break;case THREE.PathActions.BEZIER_CURVE_TO:h=f[4];i=f[5];n=f[0];p=f[1];k=f[2];l=f[3];0<c.length?(g=c[c.length-1],t=g.x,r=g.y):(g=this.actions[d-1].args,t=g[g.length-2],r=g[g.length-1]);for(f=1;f<=a;f++)m=f/a,g=THREE.Shape.Utils.b3(m,t,n,k,h),m=THREE.Shape.Utils.b3(m,r,p,l,i),c.push(new THREE.Vector2(g,m));break;case THREE.PathActions.CSPLINE_THRU:g=\nthis.actions[d-1].args;m=[new THREE.Vector2(g[g.length-2],g[g.length-1])];g=a*f[0].length;m=m.concat(f[0]);m=new THREE.SplineCurve(m);for(f=1;f<=g;f++)c.push(m.getPointAt(f/g));break;case THREE.PathActions.ARC:h=f[0];i=f[1];p=f[2];k=f[3];g=f[4];n=!!f[5];t=g-k;r=2*a;for(f=1;f<=r;f++)m=f/r,n||(m=1-m),m=k+m*t,g=h+p*Math.cos(m),m=i+p*Math.sin(m),c.push(new THREE.Vector2(g,m));break;case THREE.PathActions.ELLIPSE:h=f[0];i=f[1];p=f[2];l=f[3];k=f[4];g=f[5];n=!!f[6];t=g-k;r=2*a;for(f=1;f<=r;f++)m=f/r,n||\n(m=1-m),m=k+m*t,g=h+p*Math.cos(m),m=i+l*Math.sin(m),c.push(new THREE.Vector2(g,m))}d=c[c.length-1];1E-10>Math.abs(d.x-c[0].x)&&1E-10>Math.abs(d.y-c[0].y)&&c.splice(c.length-1,1);b&&c.push(c[0]);return c};\nTHREE.Path.prototype.toShapes=function(a){var b,c,d,e,f=[],g=new THREE.Path;b=0;for(c=this.actions.length;b<c;b++)d=this.actions[b],e=d.args,d=d.action,d==THREE.PathActions.MOVE_TO&&0!=g.actions.length&&(f.push(g),g=new THREE.Path),g[d].apply(g,e);0!=g.actions.length&&f.push(g);if(0==f.length)return[];var h;e=[];if(1==f.length)return d=f[0],h=new THREE.Shape,h.actions=d.actions,h.curves=d.curves,e.push(h),e;b=!THREE.Shape.Utils.isClockWise(f[0].getPoints());if(a?!b:b){h=new THREE.Shape;b=0;for(c=\nf.length;b<c;b++)d=f[b],g=THREE.Shape.Utils.isClockWise(d.getPoints()),(g=a?!g:g)?(h.actions=d.actions,h.curves=d.curves,e.push(h),h=new THREE.Shape):h.holes.push(d)}else{h=void 0;b=0;for(c=f.length;b<c;b++)d=f[b],g=THREE.Shape.Utils.isClockWise(d.getPoints()),(g=a?!g:g)?(h&&e.push(h),h=new THREE.Shape,h.actions=d.actions,h.curves=d.curves):h.holes.push(d);e.push(h)}return e};THREE.Shape=function(){THREE.Path.apply(this,arguments);this.holes=[]};THREE.Shape.prototype=Object.create(THREE.Path.prototype);THREE.Shape.prototype.extrude=function(a){return new THREE.ExtrudeGeometry(this,a)};THREE.Shape.prototype.makeGeometry=function(a){return new THREE.ShapeGeometry(this,a)};THREE.Shape.prototype.getPointsHoles=function(a){var b,c=this.holes.length,d=[];for(b=0;b<c;b++)d[b]=this.holes[b].getTransformedPoints(a,this.bends);return d};\nTHREE.Shape.prototype.getSpacedPointsHoles=function(a){var b,c=this.holes.length,d=[];for(b=0;b<c;b++)d[b]=this.holes[b].getTransformedSpacedPoints(a,this.bends);return d};THREE.Shape.prototype.extractAllPoints=function(a){return{shape:this.getTransformedPoints(a),holes:this.getPointsHoles(a)}};THREE.Shape.prototype.extractPoints=function(a){return this.useSpacedPoints?this.extractAllSpacedPoints(a):this.extractAllPoints(a)};\nTHREE.Shape.prototype.extractAllSpacedPoints=function(a){return{shape:this.getTransformedSpacedPoints(a),holes:this.getSpacedPointsHoles(a)}};\nTHREE.Shape.Utils={removeHoles:function(a,b){var c=a.concat(),d=c.concat(),e,f,g,h,i,k,l,n,p,t,r=[];for(i=0;i<b.length;i++){k=b[i];Array.prototype.push.apply(d,k);f=Number.POSITIVE_INFINITY;for(e=0;e<k.length;e++){p=k[e];t=[];for(n=0;n<c.length;n++)l=c[n],l=p.distanceToSquared(l),t.push(l),l<f&&(f=l,g=e,h=n)}e=0<=h-1?h-1:c.length-1;f=0<=g-1?g-1:k.length-1;var m=[k[g],c[h],c[e]];n=THREE.FontUtils.Triangulate.area(m);var q=[k[g],k[f],c[h]];p=THREE.FontUtils.Triangulate.area(q);t=h;l=g;h+=1;g+=-1;0>\nh&&(h+=c.length);h%=c.length;0>g&&(g+=k.length);g%=k.length;e=0<=h-1?h-1:c.length-1;f=0<=g-1?g-1:k.length-1;m=[k[g],c[h],c[e]];m=THREE.FontUtils.Triangulate.area(m);q=[k[g],k[f],c[h]];q=THREE.FontUtils.Triangulate.area(q);n+p>m+q&&(h=t,g=l,0>h&&(h+=c.length),h%=c.length,0>g&&(g+=k.length),g%=k.length,e=0<=h-1?h-1:c.length-1,f=0<=g-1?g-1:k.length-1);n=c.slice(0,h);p=c.slice(h);t=k.slice(g);l=k.slice(0,g);f=[k[g],k[f],c[h]];r.push([k[g],c[h],c[e]]);r.push(f);c=n.concat(t).concat(l).concat(p)}return{shape:c,\nisolatedPts:r,allpoints:d}},triangulateShape:function(a,b){var c=THREE.Shape.Utils.removeHoles(a,b),d=c.allpoints,e=c.isolatedPts,c=THREE.FontUtils.Triangulate(c.shape,!1),f,g,h,i,k={};f=0;for(g=d.length;f<g;f++)i=d[f].x+\":\"+d[f].y,void 0!==k[i]&&console.log(\"Duplicate point\",i),k[i]=f;f=0;for(g=c.length;f<g;f++){h=c[f];for(d=0;3>d;d++)i=h[d].x+\":\"+h[d].y,i=k[i],void 0!==i&&(h[d]=i)}f=0;for(g=e.length;f<g;f++){h=e[f];for(d=0;3>d;d++)i=h[d].x+\":\"+h[d].y,i=k[i],void 0!==i&&(h[d]=i)}return c.concat(e)},\nisClockWise:function(a){return 0>THREE.FontUtils.Triangulate.area(a)},b2p0:function(a,b){var c=1-a;return c*c*b},b2p1:function(a,b){return 2*(1-a)*a*b},b2p2:function(a,b){return a*a*b},b2:function(a,b,c,d){return this.b2p0(a,b)+this.b2p1(a,c)+this.b2p2(a,d)},b3p0:function(a,b){var c=1-a;return c*c*c*b},b3p1:function(a,b){var c=1-a;return 3*c*c*a*b},b3p2:function(a,b){return 3*(1-a)*a*a*b},b3p3:function(a,b){return a*a*a*b},b3:function(a,b,c,d,e){return this.b3p0(a,b)+this.b3p1(a,c)+this.b3p2(a,d)+\nthis.b3p3(a,e)}};THREE.LineCurve=function(a,b){this.v1=a;this.v2=b};THREE.LineCurve.prototype=Object.create(THREE.Curve.prototype);THREE.LineCurve.prototype.getPoint=function(a){var b=this.v2.clone().sub(this.v1);b.multiplyScalar(a).add(this.v1);return b};THREE.LineCurve.prototype.getPointAt=function(a){return this.getPoint(a)};THREE.LineCurve.prototype.getTangent=function(){return this.v2.clone().sub(this.v1).normalize()};THREE.QuadraticBezierCurve=function(a,b,c){this.v0=a;this.v1=b;this.v2=c};THREE.QuadraticBezierCurve.prototype=Object.create(THREE.Curve.prototype);THREE.QuadraticBezierCurve.prototype.getPoint=function(a){var b;b=THREE.Shape.Utils.b2(a,this.v0.x,this.v1.x,this.v2.x);a=THREE.Shape.Utils.b2(a,this.v0.y,this.v1.y,this.v2.y);return new THREE.Vector2(b,a)};\nTHREE.QuadraticBezierCurve.prototype.getTangent=function(a){var b;b=THREE.Curve.Utils.tangentQuadraticBezier(a,this.v0.x,this.v1.x,this.v2.x);a=THREE.Curve.Utils.tangentQuadraticBezier(a,this.v0.y,this.v1.y,this.v2.y);b=new THREE.Vector2(b,a);b.normalize();return b};THREE.CubicBezierCurve=function(a,b,c,d){this.v0=a;this.v1=b;this.v2=c;this.v3=d};THREE.CubicBezierCurve.prototype=Object.create(THREE.Curve.prototype);THREE.CubicBezierCurve.prototype.getPoint=function(a){var b;b=THREE.Shape.Utils.b3(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);a=THREE.Shape.Utils.b3(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);return new THREE.Vector2(b,a)};\nTHREE.CubicBezierCurve.prototype.getTangent=function(a){var b;b=THREE.Curve.Utils.tangentCubicBezier(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);a=THREE.Curve.Utils.tangentCubicBezier(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);b=new THREE.Vector2(b,a);b.normalize();return b};THREE.SplineCurve=function(a){this.points=void 0==a?[]:a};THREE.SplineCurve.prototype=Object.create(THREE.Curve.prototype);THREE.SplineCurve.prototype.getPoint=function(a){var b=new THREE.Vector2,c=[],d=this.points,e;e=(d.length-1)*a;a=Math.floor(e);e-=a;c[0]=0==a?a:a-1;c[1]=a;c[2]=a>d.length-2?d.length-1:a+1;c[3]=a>d.length-3?d.length-1:a+2;b.x=THREE.Curve.Utils.interpolate(d[c[0]].x,d[c[1]].x,d[c[2]].x,d[c[3]].x,e);b.y=THREE.Curve.Utils.interpolate(d[c[0]].y,d[c[1]].y,d[c[2]].y,d[c[3]].y,e);return b};THREE.EllipseCurve=function(a,b,c,d,e,f,g){this.aX=a;this.aY=b;this.xRadius=c;this.yRadius=d;this.aStartAngle=e;this.aEndAngle=f;this.aClockwise=g};THREE.EllipseCurve.prototype=Object.create(THREE.Curve.prototype);\nTHREE.EllipseCurve.prototype.getPoint=function(a){var b;b=this.aEndAngle-this.aStartAngle;0>b&&(b+=2*Math.PI);b>2*Math.PI&&(b-=2*Math.PI);b=!0===this.aClockwise?this.aEndAngle+(1-a)*(2*Math.PI-b):this.aStartAngle+a*b;a=this.aX+this.xRadius*Math.cos(b);b=this.aY+this.yRadius*Math.sin(b);return new THREE.Vector2(a,b)};THREE.ArcCurve=function(a,b,c,d,e,f){THREE.EllipseCurve.call(this,a,b,c,c,d,e,f)};THREE.ArcCurve.prototype=Object.create(THREE.EllipseCurve.prototype);THREE.LineCurve3=THREE.Curve.create(function(a,b){this.v1=a;this.v2=b},function(a){var b=new THREE.Vector3;b.subVectors(this.v2,this.v1);b.multiplyScalar(a);b.add(this.v1);return b});THREE.QuadraticBezierCurve3=THREE.Curve.create(function(a,b,c){this.v0=a;this.v1=b;this.v2=c},function(a){var b,c;b=THREE.Shape.Utils.b2(a,this.v0.x,this.v1.x,this.v2.x);c=THREE.Shape.Utils.b2(a,this.v0.y,this.v1.y,this.v2.y);a=THREE.Shape.Utils.b2(a,this.v0.z,this.v1.z,this.v2.z);return new THREE.Vector3(b,c,a)});THREE.CubicBezierCurve3=THREE.Curve.create(function(a,b,c,d){this.v0=a;this.v1=b;this.v2=c;this.v3=d},function(a){var b,c;b=THREE.Shape.Utils.b3(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x);c=THREE.Shape.Utils.b3(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y);a=THREE.Shape.Utils.b3(a,this.v0.z,this.v1.z,this.v2.z,this.v3.z);return new THREE.Vector3(b,c,a)});THREE.SplineCurve3=THREE.Curve.create(function(a){this.points=void 0==a?[]:a},function(a){var b=new THREE.Vector3,c=[],d=this.points,e,a=(d.length-1)*a;e=Math.floor(a);a-=e;c[0]=0==e?e:e-1;c[1]=e;c[2]=e>d.length-2?d.length-1:e+1;c[3]=e>d.length-3?d.length-1:e+2;e=d[c[0]];var f=d[c[1]],g=d[c[2]],c=d[c[3]];b.x=THREE.Curve.Utils.interpolate(e.x,f.x,g.x,c.x,a);b.y=THREE.Curve.Utils.interpolate(e.y,f.y,g.y,c.y,a);b.z=THREE.Curve.Utils.interpolate(e.z,f.z,g.z,c.z,a);return b});THREE.ClosedSplineCurve3=THREE.Curve.create(function(a){this.points=void 0==a?[]:a},function(a){var b=new THREE.Vector3,c=[],d=this.points,e;e=(d.length-0)*a;a=Math.floor(e);e-=a;a+=0<a?0:(Math.floor(Math.abs(a)/d.length)+1)*d.length;c[0]=(a-1)%d.length;c[1]=a%d.length;c[2]=(a+1)%d.length;c[3]=(a+2)%d.length;b.x=THREE.Curve.Utils.interpolate(d[c[0]].x,d[c[1]].x,d[c[2]].x,d[c[3]].x,e);b.y=THREE.Curve.Utils.interpolate(d[c[0]].y,d[c[1]].y,d[c[2]].y,d[c[3]].y,e);b.z=THREE.Curve.Utils.interpolate(d[c[0]].z,\nd[c[1]].z,d[c[2]].z,d[c[3]].z,e);return b});THREE.AnimationHandler=function(){var a=[],b={},c={update:function(b){for(var c=0;c<a.length;c++)a[c].update(b)},addToUpdate:function(b){-1===a.indexOf(b)&&a.push(b)},removeFromUpdate:function(b){b=a.indexOf(b);-1!==b&&a.splice(b,1)},add:function(a){void 0!==b[a.name]&&console.log(\"THREE.AnimationHandler.add: Warning! \"+a.name+\" already exists in library. Overwriting.\");b[a.name]=a;if(!0!==a.initialized){for(var c=0;c<a.hierarchy.length;c++){for(var d=0;d<a.hierarchy[c].keys.length;d++)if(0>a.hierarchy[c].keys[d].time&&\n(a.hierarchy[c].keys[d].time=0),void 0!==a.hierarchy[c].keys[d].rot&&!(a.hierarchy[c].keys[d].rot instanceof THREE.Quaternion)){var h=a.hierarchy[c].keys[d].rot;a.hierarchy[c].keys[d].rot=new THREE.Quaternion(h[0],h[1],h[2],h[3])}if(a.hierarchy[c].keys.length&&void 0!==a.hierarchy[c].keys[0].morphTargets){h={};for(d=0;d<a.hierarchy[c].keys.length;d++)for(var i=0;i<a.hierarchy[c].keys[d].morphTargets.length;i++){var k=a.hierarchy[c].keys[d].morphTargets[i];h[k]=-1}a.hierarchy[c].usedMorphTargets=h;\nfor(d=0;d<a.hierarchy[c].keys.length;d++){var l={};for(k in h){for(i=0;i<a.hierarchy[c].keys[d].morphTargets.length;i++)if(a.hierarchy[c].keys[d].morphTargets[i]===k){l[k]=a.hierarchy[c].keys[d].morphTargetsInfluences[i];break}i===a.hierarchy[c].keys[d].morphTargets.length&&(l[k]=0)}a.hierarchy[c].keys[d].morphTargetsInfluences=l}}for(d=1;d<a.hierarchy[c].keys.length;d++)a.hierarchy[c].keys[d].time===a.hierarchy[c].keys[d-1].time&&(a.hierarchy[c].keys.splice(d,1),d--);for(d=0;d<a.hierarchy[c].keys.length;d++)a.hierarchy[c].keys[d].index=\nd}d=parseInt(a.length*a.fps,10);a.JIT={};a.JIT.hierarchy=[];for(c=0;c<a.hierarchy.length;c++)a.JIT.hierarchy.push(Array(d));a.initialized=!0}},get:function(a){if(\"string\"===typeof a){if(b[a])return b[a];console.log(\"THREE.AnimationHandler.get: Couldn't find animation \"+a);return null}},parse:function(a){var b=[];if(a instanceof THREE.SkinnedMesh)for(var c=0;c<a.bones.length;c++)b.push(a.bones[c]);else d(a,b);return b}},d=function(a,b){b.push(a);for(var c=0;c<a.children.length;c++)d(a.children[c],\nb)};c.LINEAR=0;c.CATMULLROM=1;c.CATMULLROM_FORWARD=2;return c}();THREE.Animation=function(a,b,c){this.root=a;this.data=THREE.AnimationHandler.get(b);this.hierarchy=THREE.AnimationHandler.parse(a);this.currentTime=0;this.timeScale=1;this.isPlaying=!1;this.loop=this.isPaused=!0;this.interpolationType=void 0!==c?c:THREE.AnimationHandler.LINEAR;this.points=[];this.target=new THREE.Vector3};\nTHREE.Animation.prototype.play=function(a,b){if(!1===this.isPlaying){this.isPlaying=!0;this.loop=void 0!==a?a:!0;this.currentTime=void 0!==b?b:0;var c,d=this.hierarchy.length,e;for(c=0;c<d;c++){e=this.hierarchy[c];e.matrixAutoUpdate=!0;void 0===e.animationCache&&(e.animationCache={},e.animationCache.prevKey={pos:0,rot:0,scl:0},e.animationCache.nextKey={pos:0,rot:0,scl:0},e.animationCache.originalMatrix=e instanceof THREE.Bone?e.skinMatrix:e.matrix);var f=e.animationCache.prevKey;e=e.animationCache.nextKey;\nf.pos=this.data.hierarchy[c].keys[0];f.rot=this.data.hierarchy[c].keys[0];f.scl=this.data.hierarchy[c].keys[0];e.pos=this.getNextKeyWith(\"pos\",c,1);e.rot=this.getNextKeyWith(\"rot\",c,1);e.scl=this.getNextKeyWith(\"scl\",c,1)}this.update(0)}this.isPaused=!1;THREE.AnimationHandler.addToUpdate(this)};THREE.Animation.prototype.pause=function(){!0===this.isPaused?THREE.AnimationHandler.addToUpdate(this):THREE.AnimationHandler.removeFromUpdate(this);this.isPaused=!this.isPaused};\nTHREE.Animation.prototype.stop=function(){this.isPaused=this.isPlaying=!1;THREE.AnimationHandler.removeFromUpdate(this)};\nTHREE.Animation.prototype.update=function(a){if(!1!==this.isPlaying){var b=[\"pos\",\"rot\",\"scl\"],c,d,e,f,g,h,i,k,l;for(l=this.currentTime+=a*this.timeScale;this.currentTime>this.data.length;)this.currentTime-=this.data.length;k=this.currentTime%=this.data.length;parseInt(Math.min(k*this.data.fps,this.data.length*this.data.fps),10);for(var n=0,p=this.hierarchy.length;n<p;n++){a=this.hierarchy[n];i=a.animationCache;for(var t=0;3>t;t++){c=b[t];g=i.prevKey[c];h=i.nextKey[c];if(h.time<=l){if(k<=l)if(this.loop){g=\nthis.data.hierarchy[n].keys[0];for(h=this.getNextKeyWith(c,n,1);null!==h&&h.time<k&&h.index>g.index;)g=h,h=this.getNextKeyWith(c,n,h.index+1)}else{this.stop();return}else{do g=h,h=this.getNextKeyWith(c,n,h.index+1);while(null!==h&&h.time<k&&h.index>g.index)}i.prevKey[c]=g;i.nextKey[c]=h}a.matrixAutoUpdate=!0;a.matrixWorldNeedsUpdate=!0;d=(k-g.time)/(h.time-g.time);e=g[c];f=h[c];if(0>d||1<d)console.log(\"THREE.Animation.update: Warning! Scale out of bounds:\"+d+\" on bone \"+n),d=0>d?0:1;if(\"pos\"===c)if(c=\na.position,this.interpolationType===THREE.AnimationHandler.LINEAR)c.x=e[0]+(f[0]-e[0])*d,c.y=e[1]+(f[1]-e[1])*d,c.z=e[2]+(f[2]-e[2])*d;else{if(this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD)this.points[0]=this.getPrevKeyWith(\"pos\",n,g.index-1).pos,this.points[1]=e,this.points[2]=f,this.points[3]=this.getNextKeyWith(\"pos\",n,h.index+1).pos,d=0.33*d+0.33,e=this.interpolateCatmullRom(this.points,d),c.x=e[0],c.y=e[1],c.z=e[2],\nthis.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD&&(d=this.interpolateCatmullRom(this.points,1.01*d),this.target.set(d[0],d[1],d[2]),this.target.sub(c),this.target.y=0,this.target.normalize(),d=Math.atan2(this.target.x,this.target.z),a.rotation.set(0,d,0))}else\"rot\"===c?THREE.Quaternion.slerp(e,f,a.quaternion,d):\"scl\"===c&&(c=a.scale,c.x=e[0]+(f[0]-e[0])*d,c.y=e[1]+(f[1]-e[1])*d,c.z=e[2]+(f[2]-e[2])*d)}}}};\nTHREE.Animation.prototype.interpolateCatmullRom=function(a,b){var c=[],d=[],e,f,g,h,i,k;e=(a.length-1)*b;f=Math.floor(e);e-=f;c[0]=0===f?f:f-1;c[1]=f;c[2]=f>a.length-2?f:f+1;c[3]=f>a.length-3?f:f+2;f=a[c[0]];h=a[c[1]];i=a[c[2]];k=a[c[3]];c=e*e;g=e*c;d[0]=this.interpolate(f[0],h[0],i[0],k[0],e,c,g);d[1]=this.interpolate(f[1],h[1],i[1],k[1],e,c,g);d[2]=this.interpolate(f[2],h[2],i[2],k[2],e,c,g);return d};\nTHREE.Animation.prototype.interpolate=function(a,b,c,d,e,f,g){a=0.5*(c-a);d=0.5*(d-b);return(2*(b-c)+a+d)*g+(-3*(b-c)-2*a-d)*f+a*e+b};THREE.Animation.prototype.getNextKeyWith=function(a,b,c){for(var d=this.data.hierarchy[b].keys,c=this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD?c<d.length-1?c:d.length-1:c%d.length;c<d.length;c++)if(void 0!==d[c][a])return d[c];return this.data.hierarchy[b].keys[0]};\nTHREE.Animation.prototype.getPrevKeyWith=function(a,b,c){for(var d=this.data.hierarchy[b].keys,c=this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD?0<c?c:0:0<=c?c:c+d.length;0<=c;c--)if(void 0!==d[c][a])return d[c];return this.data.hierarchy[b].keys[d.length-1]};THREE.KeyFrameAnimation=function(a,b,c){this.root=a;this.data=THREE.AnimationHandler.get(b);this.hierarchy=THREE.AnimationHandler.parse(a);this.currentTime=0;this.timeScale=0.001;this.isPlaying=!1;this.loop=this.isPaused=!0;this.JITCompile=void 0!==c?c:!0;a=0;for(b=this.hierarchy.length;a<b;a++){var c=this.data.hierarchy[a].sids,d=this.hierarchy[a];if(this.data.hierarchy[a].keys.length&&c){for(var e=0;e<c.length;e++){var f=c[e],g=this.getNextKeyWith(f,a,0);g&&g.apply(f)}d.matrixAutoUpdate=!1;this.data.hierarchy[a].node.updateMatrix();\nd.matrixWorldNeedsUpdate=!0}}};\nTHREE.KeyFrameAnimation.prototype.play=function(a,b){if(!this.isPlaying){this.isPlaying=!0;this.loop=void 0!==a?a:!0;this.currentTime=void 0!==b?b:0;this.startTimeMs=b;this.startTime=1E7;this.endTime=-this.startTime;var c,d=this.hierarchy.length,e,f;for(c=0;c<d;c++)e=this.hierarchy[c],f=this.data.hierarchy[c],void 0===f.animationCache&&(f.animationCache={},f.animationCache.prevKey=null,f.animationCache.nextKey=null,f.animationCache.originalMatrix=e instanceof THREE.Bone?e.skinMatrix:e.matrix),e=this.data.hierarchy[c].keys,\ne.length&&(f.animationCache.prevKey=e[0],f.animationCache.nextKey=e[1],this.startTime=Math.min(e[0].time,this.startTime),this.endTime=Math.max(e[e.length-1].time,this.endTime));this.update(0)}this.isPaused=!1;THREE.AnimationHandler.addToUpdate(this)};THREE.KeyFrameAnimation.prototype.pause=function(){this.isPaused?THREE.AnimationHandler.addToUpdate(this):THREE.AnimationHandler.removeFromUpdate(this);this.isPaused=!this.isPaused};\nTHREE.KeyFrameAnimation.prototype.stop=function(){this.isPaused=this.isPlaying=!1;THREE.AnimationHandler.removeFromUpdate(this);for(var a=0;a<this.data.hierarchy.length;a++){var b=this.hierarchy[a],c=this.data.hierarchy[a];if(void 0!==c.animationCache){var d=c.animationCache.originalMatrix;b instanceof THREE.Bone?(d.copy(b.skinMatrix),b.skinMatrix=d):(d.copy(b.matrix),b.matrix=d);delete c.animationCache}}};\nTHREE.KeyFrameAnimation.prototype.update=function(a){if(this.isPlaying){var b,c,d,e,f=this.data.JIT.hierarchy,g,h,i;h=this.currentTime+=a*this.timeScale;g=this.currentTime%=this.data.length;g<this.startTimeMs&&(g=this.currentTime=this.startTimeMs+g);e=parseInt(Math.min(g*this.data.fps,this.data.length*this.data.fps),10);if((i=g<h)&&!this.loop){for(var a=0,k=this.hierarchy.length;a<k;a++){var l=this.data.hierarchy[a].keys,f=this.data.hierarchy[a].sids;d=l.length-1;e=this.hierarchy[a];if(l.length){for(l=\n0;l<f.length;l++)g=f[l],(h=this.getPrevKeyWith(g,a,d))&&h.apply(g);this.data.hierarchy[a].node.updateMatrix();e.matrixWorldNeedsUpdate=!0}}this.stop()}else if(!(g<this.startTime)){a=0;for(k=this.hierarchy.length;a<k;a++){d=this.hierarchy[a];b=this.data.hierarchy[a];var l=b.keys,n=b.animationCache;if(this.JITCompile&&void 0!==f[a][e])d instanceof THREE.Bone?(d.skinMatrix=f[a][e],d.matrixWorldNeedsUpdate=!1):(d.matrix=f[a][e],d.matrixWorldNeedsUpdate=!0);else if(l.length){this.JITCompile&&n&&(d instanceof\nTHREE.Bone?d.skinMatrix=n.originalMatrix:d.matrix=n.originalMatrix);b=n.prevKey;c=n.nextKey;if(b&&c){if(c.time<=h){if(i&&this.loop){b=l[0];for(c=l[1];c.time<g;)b=c,c=l[b.index+1]}else if(!i)for(var p=l.length-1;c.time<g&&c.index!==p;)b=c,c=l[b.index+1];n.prevKey=b;n.nextKey=c}c.time>=g?b.interpolate(c,g):b.interpolate(c,c.time)}this.data.hierarchy[a].node.updateMatrix();d.matrixWorldNeedsUpdate=!0}}if(this.JITCompile&&void 0===f[0][e]){this.hierarchy[0].updateMatrixWorld(!0);for(a=0;a<this.hierarchy.length;a++)f[a][e]=\nthis.hierarchy[a]instanceof THREE.Bone?this.hierarchy[a].skinMatrix.clone():this.hierarchy[a].matrix.clone()}}}};THREE.KeyFrameAnimation.prototype.getNextKeyWith=function(a,b,c){b=this.data.hierarchy[b].keys;for(c%=b.length;c<b.length;c++)if(b[c].hasTarget(a))return b[c];return b[0]};THREE.KeyFrameAnimation.prototype.getPrevKeyWith=function(a,b,c){b=this.data.hierarchy[b].keys;for(c=0<=c?c:c+b.length;0<=c;c--)if(b[c].hasTarget(a))return b[c];return b[b.length-1]};THREE.CubeCamera=function(a,b,c){THREE.Object3D.call(this);var d=new THREE.PerspectiveCamera(90,1,a,b);d.up.set(0,-1,0);d.lookAt(new THREE.Vector3(1,0,0));this.add(d);var e=new THREE.PerspectiveCamera(90,1,a,b);e.up.set(0,-1,0);e.lookAt(new THREE.Vector3(-1,0,0));this.add(e);var f=new THREE.PerspectiveCamera(90,1,a,b);f.up.set(0,0,1);f.lookAt(new THREE.Vector3(0,1,0));this.add(f);var g=new THREE.PerspectiveCamera(90,1,a,b);g.up.set(0,0,-1);g.lookAt(new THREE.Vector3(0,-1,0));this.add(g);var h=new THREE.PerspectiveCamera(90,\n1,a,b);h.up.set(0,-1,0);h.lookAt(new THREE.Vector3(0,0,1));this.add(h);var i=new THREE.PerspectiveCamera(90,1,a,b);i.up.set(0,-1,0);i.lookAt(new THREE.Vector3(0,0,-1));this.add(i);this.renderTarget=new THREE.WebGLRenderTargetCube(c,c,{format:THREE.RGBFormat,magFilter:THREE.LinearFilter,minFilter:THREE.LinearFilter});this.updateCubeMap=function(a,b){var c=this.renderTarget,p=c.generateMipmaps;c.generateMipmaps=!1;c.activeCubeFace=0;a.render(b,d,c);c.activeCubeFace=1;a.render(b,e,c);c.activeCubeFace=\n2;a.render(b,f,c);c.activeCubeFace=3;a.render(b,g,c);c.activeCubeFace=4;a.render(b,h,c);c.generateMipmaps=p;c.activeCubeFace=5;a.render(b,i,c)}};THREE.CubeCamera.prototype=Object.create(THREE.Object3D.prototype);THREE.CombinedCamera=function(a,b,c,d,e,f,g){THREE.Camera.call(this);this.fov=c;this.left=-a/2;this.right=a/2;this.top=b/2;this.bottom=-b/2;this.cameraO=new THREE.OrthographicCamera(a/-2,a/2,b/2,b/-2,f,g);this.cameraP=new THREE.PerspectiveCamera(c,a/b,d,e);this.zoom=1;this.toPerspective()};THREE.CombinedCamera.prototype=Object.create(THREE.Camera.prototype);\nTHREE.CombinedCamera.prototype.toPerspective=function(){this.near=this.cameraP.near;this.far=this.cameraP.far;this.cameraP.fov=this.fov/this.zoom;this.cameraP.updateProjectionMatrix();this.projectionMatrix=this.cameraP.projectionMatrix;this.inPerspectiveMode=!0;this.inOrthographicMode=!1};\nTHREE.CombinedCamera.prototype.toOrthographic=function(){var a=this.cameraP.aspect,b=(this.cameraP.near+this.cameraP.far)/2,b=Math.tan(this.fov/2)*b,a=2*b*a/2,b=b/this.zoom,a=a/this.zoom;this.cameraO.left=-a;this.cameraO.right=a;this.cameraO.top=b;this.cameraO.bottom=-b;this.cameraO.updateProjectionMatrix();this.near=this.cameraO.near;this.far=this.cameraO.far;this.projectionMatrix=this.cameraO.projectionMatrix;this.inPerspectiveMode=!1;this.inOrthographicMode=!0};\nTHREE.CombinedCamera.prototype.setSize=function(a,b){this.cameraP.aspect=a/b;this.left=-a/2;this.right=a/2;this.top=b/2;this.bottom=-b/2};THREE.CombinedCamera.prototype.setFov=function(a){this.fov=a;this.inPerspectiveMode?this.toPerspective():this.toOrthographic()};THREE.CombinedCamera.prototype.updateProjectionMatrix=function(){this.inPerspectiveMode?this.toPerspective():(this.toPerspective(),this.toOrthographic())};\nTHREE.CombinedCamera.prototype.setLens=function(a,b){void 0===b&&(b=24);var c=2*THREE.Math.radToDeg(Math.atan(b/(2*a)));this.setFov(c);return c};THREE.CombinedCamera.prototype.setZoom=function(a){this.zoom=a;this.inPerspectiveMode?this.toPerspective():this.toOrthographic()};THREE.CombinedCamera.prototype.toFrontView=function(){this.rotation.x=0;this.rotation.y=0;this.rotation.z=0;this.rotationAutoUpdate=!1};\nTHREE.CombinedCamera.prototype.toBackView=function(){this.rotation.x=0;this.rotation.y=Math.PI;this.rotation.z=0;this.rotationAutoUpdate=!1};THREE.CombinedCamera.prototype.toLeftView=function(){this.rotation.x=0;this.rotation.y=-Math.PI/2;this.rotation.z=0;this.rotationAutoUpdate=!1};THREE.CombinedCamera.prototype.toRightView=function(){this.rotation.x=0;this.rotation.y=Math.PI/2;this.rotation.z=0;this.rotationAutoUpdate=!1};\nTHREE.CombinedCamera.prototype.toTopView=function(){this.rotation.x=-Math.PI/2;this.rotation.y=0;this.rotation.z=0;this.rotationAutoUpdate=!1};THREE.CombinedCamera.prototype.toBottomView=function(){this.rotation.x=Math.PI/2;this.rotation.y=0;this.rotation.z=0;this.rotationAutoUpdate=!1};THREE.CircleGeometry=function(a,b,c,d){THREE.Geometry.call(this);this.radius=a=a||50;this.segments=b=void 0!==b?Math.max(3,b):8;this.thetaStart=c=void 0!==c?c:0;this.thetaLength=d=void 0!==d?d:2*Math.PI;var e,f=[];e=new THREE.Vector3;var g=new THREE.Vector2(0.5,0.5);this.vertices.push(e);f.push(g);for(e=0;e<=b;e++){var h=new THREE.Vector3,i=c+e/b*d;h.x=a*Math.cos(i);h.y=a*Math.sin(i);this.vertices.push(h);f.push(new THREE.Vector2((h.x/a+1)/2,(h.y/a+1)/2))}c=new THREE.Vector3(0,0,1);for(e=1;e<=b;e++)this.faces.push(new THREE.Face3(e,\ne+1,0,[c.clone(),c.clone(),c.clone()])),this.faceVertexUvs[0].push([f[e].clone(),f[e+1].clone(),g.clone()]);this.computeCentroids();this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,a)};THREE.CircleGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.CubeGeometry=function(a,b,c,d,e,f){function g(a,b,c,d,e,f,g,m){var q,u=h.widthSegments,s=h.heightSegments,v=e/2,z=f/2,G=h.vertices.length;if(\"x\"===a&&\"y\"===b||\"y\"===a&&\"x\"===b)q=\"z\";else if(\"x\"===a&&\"z\"===b||\"z\"===a&&\"x\"===b)q=\"y\",s=h.depthSegments;else if(\"z\"===a&&\"y\"===b||\"y\"===a&&\"z\"===b)q=\"x\",u=h.depthSegments;var N=u+1,C=s+1,B=e/u,x=f/s,F=new THREE.Vector3;F[q]=0<g?1:-1;for(e=0;e<C;e++)for(f=0;f<N;f++){var L=new THREE.Vector3;L[a]=(f*B-v)*c;L[b]=(e*x-z)*d;L[q]=g;h.vertices.push(L)}for(e=\n0;e<s;e++)for(f=0;f<u;f++)z=f+N*e,a=f+N*(e+1),b=f+1+N*(e+1),c=f+1+N*e,d=new THREE.Vector2(f/u,1-e/s),g=new THREE.Vector2(f/u,1-(e+1)/s),q=new THREE.Vector2((f+1)/u,1-(e+1)/s),v=new THREE.Vector2((f+1)/u,1-e/s),z=new THREE.Face3(z+G,a+G,c+G),z.normal.copy(F),z.vertexNormals.push(F.clone(),F.clone(),F.clone()),z.materialIndex=m,h.faces.push(z),h.faceVertexUvs[0].push([d,g,v]),z=new THREE.Face3(a+G,b+G,c+G),z.normal.copy(F),z.vertexNormals.push(F.clone(),F.clone(),F.clone()),z.materialIndex=m,h.faces.push(z),\nh.faceVertexUvs[0].push([g.clone(),q,v.clone()])}THREE.Geometry.call(this);var h=this;this.width=a;this.height=b;this.depth=c;this.widthSegments=d||1;this.heightSegments=e||1;this.depthSegments=f||1;a=this.width/2;b=this.height/2;c=this.depth/2;g(\"z\",\"y\",-1,-1,this.depth,this.height,a,0);g(\"z\",\"y\",1,-1,this.depth,this.height,-a,1);g(\"x\",\"z\",1,1,this.width,this.depth,b,2);g(\"x\",\"z\",1,-1,this.width,this.depth,-b,3);g(\"x\",\"y\",1,-1,this.width,this.height,c,4);g(\"x\",\"y\",-1,-1,this.width,this.height,-c,\n5);this.computeCentroids();this.mergeVertices()};THREE.CubeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.CylinderGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);this.radiusTop=a=void 0!==a?a:20;this.radiusBottom=b=void 0!==b?b:20;this.height=c=void 0!==c?c:100;this.radialSegments=d=d||8;this.heightSegments=e=e||1;this.openEnded=f=void 0!==f?f:!1;var g=c/2,h,i,k=[],l=[];for(i=0;i<=e;i++){var n=[],p=[],t=i/e,r=t*(b-a)+a;for(h=0;h<=d;h++){var m=h/d,q=new THREE.Vector3;q.x=r*Math.sin(2*m*Math.PI);q.y=-t*c+g;q.z=r*Math.cos(2*m*Math.PI);this.vertices.push(q);n.push(this.vertices.length-1);p.push(new THREE.Vector2(m,\n1-t))}k.push(n);l.push(p)}c=(b-a)/c;for(h=0;h<d;h++){0!==a?(n=this.vertices[k[0][h]].clone(),p=this.vertices[k[0][h+1]].clone()):(n=this.vertices[k[1][h]].clone(),p=this.vertices[k[1][h+1]].clone());n.setY(Math.sqrt(n.x*n.x+n.z*n.z)*c).normalize();p.setY(Math.sqrt(p.x*p.x+p.z*p.z)*c).normalize();for(i=0;i<e;i++){var t=k[i][h],r=k[i+1][h],m=k[i+1][h+1],q=k[i][h+1],u=n.clone(),s=n.clone(),v=p.clone(),z=p.clone(),G=l[i][h].clone(),N=l[i+1][h].clone(),C=l[i+1][h+1].clone(),B=l[i][h+1].clone();this.faces.push(new THREE.Face3(t,\nr,q,[u,s,z]));this.faceVertexUvs[0].push([G,N,B]);this.faces.push(new THREE.Face3(r,m,q,[s.clone(),v,z.clone()]));this.faceVertexUvs[0].push([N.clone(),C,B.clone()])}}if(!1===f&&0<a){this.vertices.push(new THREE.Vector3(0,g,0));for(h=0;h<d;h++)t=k[0][h],r=k[0][h+1],m=this.vertices.length-1,u=new THREE.Vector3(0,1,0),s=new THREE.Vector3(0,1,0),v=new THREE.Vector3(0,1,0),G=l[0][h].clone(),N=l[0][h+1].clone(),C=new THREE.Vector2(N.x,0),this.faces.push(new THREE.Face3(t,r,m,[u,s,v])),this.faceVertexUvs[0].push([G,\nN,C])}if(!1===f&&0<b){this.vertices.push(new THREE.Vector3(0,-g,0));for(h=0;h<d;h++)t=k[i][h+1],r=k[i][h],m=this.vertices.length-1,u=new THREE.Vector3(0,-1,0),s=new THREE.Vector3(0,-1,0),v=new THREE.Vector3(0,-1,0),G=l[i][h+1].clone(),N=l[i][h].clone(),C=new THREE.Vector2(N.x,1),this.faces.push(new THREE.Face3(t,r,m,[u,s,v])),this.faceVertexUvs[0].push([G,N,C])}this.computeCentroids();this.computeFaceNormals()};THREE.CylinderGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ExtrudeGeometry=function(a,b){\"undefined\"!==typeof a&&(THREE.Geometry.call(this),a=a instanceof Array?a:[a],this.shapebb=a[a.length-1].getBoundingBox(),this.addShapeList(a,b),this.computeCentroids(),this.computeFaceNormals())};THREE.ExtrudeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ExtrudeGeometry.prototype.addShapeList=function(a,b){for(var c=a.length,d=0;d<c;d++)this.addShape(a[d],b)};\nTHREE.ExtrudeGeometry.prototype.addShape=function(a,b){function c(a,b,c){b||console.log(\"die\");return b.clone().multiplyScalar(c).add(a)}function d(a,b,c){var d=THREE.ExtrudeGeometry.__v1,e=THREE.ExtrudeGeometry.__v2,f=THREE.ExtrudeGeometry.__v3,g=THREE.ExtrudeGeometry.__v4,h=THREE.ExtrudeGeometry.__v5,i=THREE.ExtrudeGeometry.__v6;d.set(a.x-b.x,a.y-b.y);e.set(a.x-c.x,a.y-c.y);d=d.normalize();e=e.normalize();f.set(-d.y,d.x);g.set(e.y,-e.x);h.copy(a).add(f);i.copy(a).add(g);if(h.equals(i))return g.clone();\nh.copy(b).add(f);i.copy(c).add(g);f=d.dot(g);g=i.sub(h).dot(g);0===f&&(console.log(\"Either infinite or no solutions!\"),0===g?console.log(\"Its finite solutions.\"):console.log(\"Too bad, no solutions.\"));g/=f;return 0>g?(b=Math.atan2(b.y-a.y,b.x-a.x),a=Math.atan2(c.y-a.y,c.x-a.x),b>a&&(a+=2*Math.PI),c=(b+a)/2,a=-Math.cos(c),c=-Math.sin(c),new THREE.Vector2(a,c)):d.multiplyScalar(g).add(h).sub(a).clone()}function e(c,d){var e,f;for(O=c.length;0<=--O;){e=O;f=O-1;0>f&&(f=c.length-1);for(var g=0,h=t+2*l,\ng=0;g<h;g++){var i=da*g,k=da*(g+1),m=d+e+i,i=d+f+i,n=d+f+k,k=d+e+k,p=c,q=g,r=h,u=e,z=f,m=m+w,i=i+w,n=n+w,k=k+w;L.faces.push(new THREE.Face3(m,i,k,null,null,s));L.faces.push(new THREE.Face3(i,n,k,null,null,s));m=v.generateSideWallUV(L,a,p,b,m,i,n,k,q,r,u,z);L.faceVertexUvs[0].push([m[0],m[1],m[3]]);L.faceVertexUvs[0].push([m[1],m[2],m[3]])}}}function f(a,b,c){L.vertices.push(new THREE.Vector3(a,b,c))}function g(c,d,e,f){c+=w;d+=w;e+=w;L.faces.push(new THREE.Face3(c,d,e,null,null,u));c=f?v.generateBottomUV(L,\na,b,c,d,e):v.generateTopUV(L,a,b,c,d,e);L.faceVertexUvs[0].push(c)}var h=void 0!==b.amount?b.amount:100,i=void 0!==b.bevelThickness?b.bevelThickness:6,k=void 0!==b.bevelSize?b.bevelSize:i-2,l=void 0!==b.bevelSegments?b.bevelSegments:3,n=void 0!==b.bevelEnabled?b.bevelEnabled:!0,p=void 0!==b.curveSegments?b.curveSegments:12,t=void 0!==b.steps?b.steps:1,r=b.extrudePath,m,q=!1,u=b.material,s=b.extrudeMaterial,v=void 0!==b.UVGenerator?b.UVGenerator:THREE.ExtrudeGeometry.WorldUVGenerator,z,G,N,C;r&&(m=\nr.getSpacedPoints(t),q=!0,n=!1,z=void 0!==b.frames?b.frames:new THREE.TubeGeometry.FrenetFrames(r,t,!1),G=new THREE.Vector3,N=new THREE.Vector3,C=new THREE.Vector3);n||(k=i=l=0);var B,x,F,L=this,w=this.vertices.length,p=a.extractPoints(p),E=p.shape,p=p.holes;if(r=!THREE.Shape.Utils.isClockWise(E)){E=E.reverse();x=0;for(F=p.length;x<F;x++)B=p[x],THREE.Shape.Utils.isClockWise(B)&&(p[x]=B.reverse());r=!1}var y=THREE.Shape.Utils.triangulateShape(E,p),r=E;x=0;for(F=p.length;x<F;x++)B=p[x],E=E.concat(B);\nvar D,H,K,A,da=E.length,ha=y.length,ua=[],O=0,T=r.length;D=T-1;for(H=O+1;O<T;O++,D++,H++)D===T&&(D=0),H===T&&(H=0),ua[O]=d(r[O],r[D],r[H]);var ea=[],I,P=ua.concat();x=0;for(F=p.length;x<F;x++){B=p[x];I=[];O=0;T=B.length;D=T-1;for(H=O+1;O<T;O++,D++,H++)D===T&&(D=0),H===T&&(H=0),I[O]=d(B[O],B[D],B[H]);ea.push(I);P=P.concat(I)}for(D=0;D<l;D++){B=D/l;K=i*(1-B);H=k*Math.sin(B*Math.PI/2);O=0;for(T=r.length;O<T;O++)A=c(r[O],ua[O],H),f(A.x,A.y,-K);x=0;for(F=p.length;x<F;x++){B=p[x];I=ea[x];O=0;for(T=B.length;O<\nT;O++)A=c(B[O],I[O],H),f(A.x,A.y,-K)}}H=k;for(O=0;O<da;O++)A=n?c(E[O],P[O],H):E[O],q?(N.copy(z.normals[0]).multiplyScalar(A.x),G.copy(z.binormals[0]).multiplyScalar(A.y),C.copy(m[0]).add(N).add(G),f(C.x,C.y,C.z)):f(A.x,A.y,0);for(B=1;B<=t;B++)for(O=0;O<da;O++)A=n?c(E[O],P[O],H):E[O],q?(N.copy(z.normals[B]).multiplyScalar(A.x),G.copy(z.binormals[B]).multiplyScalar(A.y),C.copy(m[B]).add(N).add(G),f(C.x,C.y,C.z)):f(A.x,A.y,h/t*B);for(D=l-1;0<=D;D--){B=D/l;K=i*(1-B);H=k*Math.sin(B*Math.PI/2);O=0;for(T=\nr.length;O<T;O++)A=c(r[O],ua[O],H),f(A.x,A.y,h+K);x=0;for(F=p.length;x<F;x++){B=p[x];I=ea[x];O=0;for(T=B.length;O<T;O++)A=c(B[O],I[O],H),q?f(A.x,A.y+m[t-1].y,m[t-1].x+K):f(A.x,A.y,h+K)}}if(n){i=0*da;for(O=0;O<ha;O++)h=y[O],g(h[2]+i,h[1]+i,h[0]+i,!0);i=da*(t+2*l);for(O=0;O<ha;O++)h=y[O],g(h[0]+i,h[1]+i,h[2]+i,!1)}else{for(O=0;O<ha;O++)h=y[O],g(h[2],h[1],h[0],!0);for(O=0;O<ha;O++)h=y[O],g(h[0]+da*t,h[1]+da*t,h[2]+da*t,!1)}h=0;e(r,h);h+=r.length;x=0;for(F=p.length;x<F;x++)B=p[x],e(B,h),h+=B.length};\nTHREE.ExtrudeGeometry.WorldUVGenerator={generateTopUV:function(a,b,c,d,e,f){b=a.vertices[e].x;e=a.vertices[e].y;c=a.vertices[f].x;f=a.vertices[f].y;return[new THREE.Vector2(a.vertices[d].x,a.vertices[d].y),new THREE.Vector2(b,e),new THREE.Vector2(c,f)]},generateBottomUV:function(a,b,c,d,e,f){return this.generateTopUV(a,b,c,d,e,f)},generateSideWallUV:function(a,b,c,d,e,f,g,h){var b=a.vertices[e].x,c=a.vertices[e].y,e=a.vertices[e].z,d=a.vertices[f].x,i=a.vertices[f].y,f=a.vertices[f].z,k=a.vertices[g].x,\nl=a.vertices[g].y,g=a.vertices[g].z,n=a.vertices[h].x,p=a.vertices[h].y,a=a.vertices[h].z;return 0.01>Math.abs(c-i)?[new THREE.Vector2(b,1-e),new THREE.Vector2(d,1-f),new THREE.Vector2(k,1-g),new THREE.Vector2(n,1-a)]:[new THREE.Vector2(c,1-e),new THREE.Vector2(i,1-f),new THREE.Vector2(l,1-g),new THREE.Vector2(p,1-a)]}};THREE.ExtrudeGeometry.__v1=new THREE.Vector2;THREE.ExtrudeGeometry.__v2=new THREE.Vector2;THREE.ExtrudeGeometry.__v3=new THREE.Vector2;THREE.ExtrudeGeometry.__v4=new THREE.Vector2;\nTHREE.ExtrudeGeometry.__v5=new THREE.Vector2;THREE.ExtrudeGeometry.__v6=new THREE.Vector2;THREE.ShapeGeometry=function(a,b){THREE.Geometry.call(this);!1===a instanceof Array&&(a=[a]);this.shapebb=a[a.length-1].getBoundingBox();this.addShapeList(a,b);this.computeCentroids();this.computeFaceNormals()};THREE.ShapeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ShapeGeometry.prototype.addShapeList=function(a,b){for(var c=0,d=a.length;c<d;c++)this.addShape(a[c],b);return this};\nTHREE.ShapeGeometry.prototype.addShape=function(a,b){void 0===b&&(b={});var c=b.material,d=void 0===b.UVGenerator?THREE.ExtrudeGeometry.WorldUVGenerator:b.UVGenerator,e,f,g,h=this.vertices.length;e=a.extractPoints(void 0!==b.curveSegments?b.curveSegments:12);var i=e.shape,k=e.holes;if(!THREE.Shape.Utils.isClockWise(i)){i=i.reverse();e=0;for(f=k.length;e<f;e++)g=k[e],THREE.Shape.Utils.isClockWise(g)&&(k[e]=g.reverse())}var l=THREE.Shape.Utils.triangulateShape(i,k);e=0;for(f=k.length;e<f;e++)g=k[e],\ni=i.concat(g);k=i.length;f=l.length;for(e=0;e<k;e++)g=i[e],this.vertices.push(new THREE.Vector3(g.x,g.y,0));for(e=0;e<f;e++)k=l[e],i=k[0]+h,g=k[1]+h,k=k[2]+h,this.faces.push(new THREE.Face3(i,g,k,null,null,c)),this.faceVertexUvs[0].push(d.generateBottomUV(this,a,b,i,g,k))};THREE.LatheGeometry=function(a,b,c,d){THREE.Geometry.call(this);for(var b=b||12,c=c||0,d=d||2*Math.PI,e=1/(a.length-1),f=1/b,g=0,h=b;g<=h;g++)for(var i=c+g*f*d,k=Math.cos(i),l=Math.sin(i),i=0,n=a.length;i<n;i++){var p=a[i],t=new THREE.Vector3;t.x=k*p.x-l*p.y;t.y=l*p.x+k*p.y;t.z=p.z;this.vertices.push(t)}c=a.length;g=0;for(h=b;g<h;g++){i=0;for(n=a.length-1;i<n;i++){var b=l=i+c*g,d=l+c,k=l+1+c,l=l+1,p=g*f,t=i*e,r=p+f,m=t+e;this.faces.push(new THREE.Face3(b,d,l));this.faceVertexUvs[0].push([new THREE.Vector2(p,\nt),new THREE.Vector2(r,t),new THREE.Vector2(p,m)]);this.faces.push(new THREE.Face3(d,k,l));this.faceVertexUvs[0].push([new THREE.Vector2(r,t),new THREE.Vector2(r,m),new THREE.Vector2(p,m)])}}this.mergeVertices();this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.LatheGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.PlaneGeometry=function(a,b,c,d){THREE.Geometry.call(this);this.width=a;this.height=b;this.widthSegments=c||1;this.heightSegments=d||1;for(var e=a/2,f=b/2,c=this.widthSegments,d=this.heightSegments,g=c+1,h=d+1,i=this.width/c,k=this.height/d,l=new THREE.Vector3(0,0,1),a=0;a<h;a++)for(b=0;b<g;b++)this.vertices.push(new THREE.Vector3(b*i-e,-(a*k-f),0));for(a=0;a<d;a++)for(b=0;b<c;b++){var n=b+g*a,e=b+g*(a+1),f=b+1+g*(a+1),h=b+1+g*a,i=new THREE.Vector2(b/c,1-a/d),k=new THREE.Vector2(b/c,1-(a+1)/\nd),p=new THREE.Vector2((b+1)/c,1-(a+1)/d),t=new THREE.Vector2((b+1)/c,1-a/d),n=new THREE.Face3(n,e,h);n.normal.copy(l);n.vertexNormals.push(l.clone(),l.clone(),l.clone());this.faces.push(n);this.faceVertexUvs[0].push([i,k,t]);n=new THREE.Face3(e,f,h);n.normal.copy(l);n.vertexNormals.push(l.clone(),l.clone(),l.clone());this.faces.push(n);this.faceVertexUvs[0].push([k.clone(),p,t.clone()])}this.computeCentroids()};THREE.PlaneGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.RingGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);for(var a=a||0,b=b||50,e=void 0!==e?e:0,f=void 0!==f?f:2*Math.PI,c=void 0!==c?Math.max(3,c):8,d=void 0!==d?Math.max(3,d):8,g,h=[],i=a,k=(b-a)/d,a=0;a<=d;a++){for(g=0;g<=c;g++){var l=new THREE.Vector3,n=e+g/c*f;l.x=i*Math.cos(n);l.y=i*Math.sin(n);this.vertices.push(l);h.push(new THREE.Vector2((l.x/b+1)/2,(l.y/b+1)/2))}i+=k}b=new THREE.Vector3(0,0,1);for(a=0;a<d;a++){e=a*c;for(g=0;g<=c;g++)n=g+e,f=n+a,k=n+c+a,l=n+c+1+a,this.faces.push(new THREE.Face3(f,\nk,l,[b.clone(),b.clone(),b.clone()])),this.faceVertexUvs[0].push([h[f].clone(),h[k].clone(),h[l].clone()]),f=n+a,k=n+c+1+a,l=n+1+a,this.faces.push(new THREE.Face3(f,k,l,[b.clone(),b.clone(),b.clone()])),this.faceVertexUvs[0].push([h[f].clone(),h[k].clone(),h[l].clone()])}this.computeCentroids();this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,i)};THREE.RingGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.SphereGeometry=function(a,b,c,d,e,f,g){THREE.Geometry.call(this);this.radius=a=a||50;this.widthSegments=b=Math.max(3,Math.floor(b)||8);this.heightSegments=c=Math.max(2,Math.floor(c)||6);this.phiStart=d=void 0!==d?d:0;this.phiLength=e=void 0!==e?e:2*Math.PI;this.thetaStart=f=void 0!==f?f:0;this.thetaLength=g=void 0!==g?g:Math.PI;var h,i,k=[],l=[];for(i=0;i<=c;i++){var n=[],p=[];for(h=0;h<=b;h++){var t=h/b,r=i/c,m=new THREE.Vector3;m.x=-a*Math.cos(d+t*e)*Math.sin(f+r*g);m.y=a*Math.cos(f+r*g);\nm.z=a*Math.sin(d+t*e)*Math.sin(f+r*g);this.vertices.push(m);n.push(this.vertices.length-1);p.push(new THREE.Vector2(t,1-r))}k.push(n);l.push(p)}for(i=0;i<this.heightSegments;i++)for(h=0;h<this.widthSegments;h++){var b=k[i][h+1],c=k[i][h],d=k[i+1][h],e=k[i+1][h+1],f=this.vertices[b].clone().normalize(),g=this.vertices[c].clone().normalize(),n=this.vertices[d].clone().normalize(),p=this.vertices[e].clone().normalize(),t=l[i][h+1].clone(),r=l[i][h].clone(),m=l[i+1][h].clone(),q=l[i+1][h+1].clone();Math.abs(this.vertices[b].y)===\nthis.radius?(t.x=(t.x+r.x)/2,this.faces.push(new THREE.Face3(b,d,e,[f,n,p])),this.faceVertexUvs[0].push([t,m,q])):Math.abs(this.vertices[d].y)===this.radius?(m.x=(m.x+q.x)/2,this.faces.push(new THREE.Face3(b,c,d,[f,g,n])),this.faceVertexUvs[0].push([t,r,m])):(this.faces.push(new THREE.Face3(b,c,e,[f,g,p])),this.faceVertexUvs[0].push([t,r,q]),this.faces.push(new THREE.Face3(c,d,e,[g.clone(),n,p.clone()])),this.faceVertexUvs[0].push([r.clone(),m,q.clone()]))}this.computeCentroids();this.computeFaceNormals();\nthis.boundingSphere=new THREE.Sphere(new THREE.Vector3,a)};THREE.SphereGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TextGeometry=function(a,b){var b=b||{},c=THREE.FontUtils.generateShapes(a,b);b.amount=void 0!==b.height?b.height:50;void 0===b.bevelThickness&&(b.bevelThickness=10);void 0===b.bevelSize&&(b.bevelSize=8);void 0===b.bevelEnabled&&(b.bevelEnabled=!1);THREE.ExtrudeGeometry.call(this,c,b)};THREE.TextGeometry.prototype=Object.create(THREE.ExtrudeGeometry.prototype);THREE.TorusGeometry=function(a,b,c,d,e){THREE.Geometry.call(this);this.radius=a||100;this.tube=b||40;this.radialSegments=c||8;this.tubularSegments=d||6;this.arc=e||2*Math.PI;e=new THREE.Vector3;a=[];b=[];for(c=0;c<=this.radialSegments;c++)for(d=0;d<=this.tubularSegments;d++){var f=d/this.tubularSegments*this.arc,g=2*c/this.radialSegments*Math.PI;e.x=this.radius*Math.cos(f);e.y=this.radius*Math.sin(f);var h=new THREE.Vector3;h.x=(this.radius+this.tube*Math.cos(g))*Math.cos(f);h.y=(this.radius+this.tube*\nMath.cos(g))*Math.sin(f);h.z=this.tube*Math.sin(g);this.vertices.push(h);a.push(new THREE.Vector2(d/this.tubularSegments,c/this.radialSegments));b.push(h.clone().sub(e).normalize())}for(c=1;c<=this.radialSegments;c++)for(d=1;d<=this.tubularSegments;d++){var e=(this.tubularSegments+1)*c+d-1,f=(this.tubularSegments+1)*(c-1)+d-1,g=(this.tubularSegments+1)*(c-1)+d,h=(this.tubularSegments+1)*c+d,i=new THREE.Face3(e,f,h,[b[e].clone(),b[f].clone(),b[h].clone()]);this.faces.push(i);this.faceVertexUvs[0].push([a[e].clone(),\na[f].clone(),a[h].clone()]);i=new THREE.Face3(f,g,h,[b[f].clone(),b[g].clone(),b[h].clone()]);this.faces.push(i);this.faceVertexUvs[0].push([a[f].clone(),a[g].clone(),a[h].clone()])}this.computeCentroids();this.computeFaceNormals()};THREE.TorusGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TorusKnotGeometry=function(a,b,c,d,e,f,g){function h(a,b,c,d,e){var f=Math.cos(a),g=Math.sin(a),a=b/c*a,b=Math.cos(a),f=0.5*(d*(2+b))*f,g=0.5*d*(2+b)*g,d=0.5*e*d*Math.sin(a);return new THREE.Vector3(f,g,d)}THREE.Geometry.call(this);this.radius=a||100;this.tube=b||40;this.radialSegments=c||64;this.tubularSegments=d||8;this.p=e||2;this.q=f||3;this.heightScale=g||1;this.grid=Array(this.radialSegments);c=new THREE.Vector3;d=new THREE.Vector3;e=new THREE.Vector3;for(a=0;a<this.radialSegments;++a){this.grid[a]=\nArray(this.tubularSegments);b=2*(a/this.radialSegments)*this.p*Math.PI;f=h(b,this.q,this.p,this.radius,this.heightScale);b=h(b+0.01,this.q,this.p,this.radius,this.heightScale);c.subVectors(b,f);d.addVectors(b,f);e.crossVectors(c,d);d.crossVectors(e,c);e.normalize();d.normalize();for(b=0;b<this.tubularSegments;++b){var i=2*(b/this.tubularSegments)*Math.PI,g=-this.tube*Math.cos(i),i=this.tube*Math.sin(i),k=new THREE.Vector3;k.x=f.x+g*d.x+i*e.x;k.y=f.y+g*d.y+i*e.y;k.z=f.z+g*d.z+i*e.z;this.grid[a][b]=\nthis.vertices.push(k)-1}}for(a=0;a<this.radialSegments;++a)for(b=0;b<this.tubularSegments;++b){var e=(a+1)%this.radialSegments,f=(b+1)%this.tubularSegments,c=this.grid[a][b],d=this.grid[e][b],e=this.grid[e][f],f=this.grid[a][f],g=new THREE.Vector2(a/this.radialSegments,b/this.tubularSegments),i=new THREE.Vector2((a+1)/this.radialSegments,b/this.tubularSegments),k=new THREE.Vector2((a+1)/this.radialSegments,(b+1)/this.tubularSegments),l=new THREE.Vector2(a/this.radialSegments,(b+1)/this.tubularSegments);\nthis.faces.push(new THREE.Face3(c,d,f));this.faceVertexUvs[0].push([g,i,l]);this.faces.push(new THREE.Face3(d,e,f));this.faceVertexUvs[0].push([i.clone(),k,l.clone()])}this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.TorusKnotGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TubeGeometry=function(a,b,c,d,e){THREE.Geometry.call(this);this.path=a;this.segments=b||64;this.radius=c||1;this.radialSegments=d||8;this.closed=e||!1;this.grid=[];var f,g,d=this.segments+1,h,i,k,e=new THREE.Vector3,l,n,b=new THREE.TubeGeometry.FrenetFrames(this.path,this.segments,this.closed);l=b.normals;n=b.binormals;this.tangents=b.tangents;this.normals=l;this.binormals=n;for(b=0;b<d;b++){this.grid[b]=[];c=b/(d-1);k=a.getPointAt(c);f=l[b];g=n[b];for(c=0;c<this.radialSegments;c++)h=2*(c/this.radialSegments)*\nMath.PI,i=-this.radius*Math.cos(h),h=this.radius*Math.sin(h),e.copy(k),e.x+=i*f.x+h*g.x,e.y+=i*f.y+h*g.y,e.z+=i*f.z+h*g.z,this.grid[b][c]=this.vertices.push(new THREE.Vector3(e.x,e.y,e.z))-1}for(b=0;b<this.segments;b++)for(c=0;c<this.radialSegments;c++)e=this.closed?(b+1)%this.segments:b+1,l=(c+1)%this.radialSegments,a=this.grid[b][c],d=this.grid[e][c],e=this.grid[e][l],l=this.grid[b][l],n=new THREE.Vector2(b/this.segments,c/this.radialSegments),f=new THREE.Vector2((b+1)/this.segments,c/this.radialSegments),\ng=new THREE.Vector2((b+1)/this.segments,(c+1)/this.radialSegments),i=new THREE.Vector2(b/this.segments,(c+1)/this.radialSegments),this.faces.push(new THREE.Face3(a,d,l)),this.faceVertexUvs[0].push([n,f,i]),this.faces.push(new THREE.Face3(d,e,l)),this.faceVertexUvs[0].push([f.clone(),g,i.clone()]);this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.TubeGeometry.prototype=Object.create(THREE.Geometry.prototype);\nTHREE.TubeGeometry.FrenetFrames=function(a,b,c){new THREE.Vector3;var d=new THREE.Vector3;new THREE.Vector3;var e=[],f=[],g=[],h=new THREE.Vector3,i=new THREE.Matrix4,b=b+1,k,l,n;this.tangents=e;this.normals=f;this.binormals=g;for(k=0;k<b;k++)l=k/(b-1),e[k]=a.getTangentAt(l),e[k].normalize();f[0]=new THREE.Vector3;g[0]=new THREE.Vector3;a=Number.MAX_VALUE;k=Math.abs(e[0].x);l=Math.abs(e[0].y);n=Math.abs(e[0].z);k<=a&&(a=k,d.set(1,0,0));l<=a&&(a=l,d.set(0,1,0));n<=a&&d.set(0,0,1);h.crossVectors(e[0],\nd).normalize();f[0].crossVectors(e[0],h);g[0].crossVectors(e[0],f[0]);for(k=1;k<b;k++)f[k]=f[k-1].clone(),g[k]=g[k-1].clone(),h.crossVectors(e[k-1],e[k]),1E-4<h.length()&&(h.normalize(),d=Math.acos(THREE.Math.clamp(e[k-1].dot(e[k]),-1,1)),f[k].applyMatrix4(i.makeRotationAxis(h,d))),g[k].crossVectors(e[k],f[k]);if(c){d=Math.acos(THREE.Math.clamp(f[0].dot(f[b-1]),-1,1));d/=b-1;0<e[0].dot(h.crossVectors(f[0],f[b-1]))&&(d=-d);for(k=1;k<b;k++)f[k].applyMatrix4(i.makeRotationAxis(e[k],d*k)),g[k].crossVectors(e[k],\nf[k])}};THREE.PolyhedronGeometry=function(a,b,c,d){function e(a){var b=a.normalize().clone();b.index=h.vertices.push(b)-1;var c=Math.atan2(a.z,-a.x)/2/Math.PI+0.5,a=Math.atan2(-a.y,Math.sqrt(a.x*a.x+a.z*a.z))/Math.PI+0.5;b.uv=new THREE.Vector2(c,1-a);return b}function f(a,b,c){var d=new THREE.Face3(a.index,b.index,c.index,[a.clone(),b.clone(),c.clone()]);d.centroid.add(a).add(b).add(c).divideScalar(3);h.faces.push(d);d=Math.atan2(d.centroid.z,-d.centroid.x);h.faceVertexUvs[0].push([g(a.uv,a,d),g(b.uv,b,d),\ng(c.uv,c,d)])}function g(a,b,c){0>c&&1===a.x&&(a=new THREE.Vector2(a.x-1,a.y));0===b.x&&0===b.z&&(a=new THREE.Vector2(c/2/Math.PI+0.5,a.y));return a.clone()}THREE.Geometry.call(this);for(var c=c||1,d=d||0,h=this,i=0,k=a.length;i<k;i++)e(new THREE.Vector3(a[i][0],a[i][1],a[i][2]));for(var l=this.vertices,a=[],i=0,k=b.length;i<k;i++){var n=l[b[i][0]],p=l[b[i][1]],t=l[b[i][2]];a[i]=new THREE.Face3(n.index,p.index,t.index,[n.clone(),p.clone(),t.clone()])}i=0;for(k=a.length;i<k;i++){p=a[i];l=d;b=Math.pow(2,\nl);Math.pow(4,l);for(var l=e(h.vertices[p.a]),n=e(h.vertices[p.b]),r=e(h.vertices[p.c]),p=[],t=0;t<=b;t++){p[t]=[];for(var m=e(l.clone().lerp(r,t/b)),q=e(n.clone().lerp(r,t/b)),u=b-t,s=0;s<=u;s++)p[t][s]=0==s&&t==b?m:e(m.clone().lerp(q,s/u))}for(t=0;t<b;t++)for(s=0;s<2*(b-t)-1;s++)l=Math.floor(s/2),0==s%2?f(p[t][l+1],p[t+1][l],p[t][l]):f(p[t][l+1],p[t+1][l+1],p[t+1][l])}i=0;for(k=this.faceVertexUvs[0].length;i<k;i++)d=this.faceVertexUvs[0][i],a=d[0].x,b=d[1].x,l=d[2].x,n=Math.max(a,Math.max(b,l)),\np=Math.min(a,Math.min(b,l)),0.9<n&&0.1>p&&(0.2>a&&(d[0].x+=1),0.2>b&&(d[1].x+=1),0.2>l&&(d[2].x+=1));i=0;for(k=this.vertices.length;i<k;i++)this.vertices[i].multiplyScalar(c);this.mergeVertices();this.computeCentroids();this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,c)};THREE.PolyhedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.IcosahedronGeometry=function(a,b){this.radius=a;this.detail=b;var c=(1+Math.sqrt(5))/2;THREE.PolyhedronGeometry.call(this,[[-1,c,0],[1,c,0],[-1,-c,0],[1,-c,0],[0,-1,c],[0,1,c],[0,-1,-c],[0,1,-c],[c,0,-1],[c,0,1],[-c,0,-1],[-c,0,1]],[[0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],[1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],[3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],[4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]],a,b)};THREE.IcosahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.OctahedronGeometry=function(a,b){THREE.PolyhedronGeometry.call(this,[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]],[[0,2,4],[0,4,3],[0,3,5],[0,5,2],[1,2,5],[1,5,3],[1,3,4],[1,4,2]],a,b)};THREE.OctahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TetrahedronGeometry=function(a,b){THREE.PolyhedronGeometry.call(this,[[1,1,1],[-1,-1,1],[-1,1,-1],[1,-1,-1]],[[2,1,0],[0,3,2],[1,3,0],[2,3,1]],a,b)};THREE.TetrahedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ParametricGeometry=function(a,b,c){THREE.Geometry.call(this);var d=this.vertices,e=this.faces,f=this.faceVertexUvs[0],g,h,i,k,l=b+1;for(g=0;g<=c;g++){k=g/c;for(h=0;h<=b;h++)i=h/b,i=a(i,k),d.push(i)}var n,p,t,r;for(g=0;g<c;g++)for(h=0;h<b;h++)a=g*l+h,d=g*l+h+1,k=(g+1)*l+h+1,i=(g+1)*l+h,n=new THREE.Vector2(h/b,g/c),p=new THREE.Vector2((h+1)/b,g/c),t=new THREE.Vector2((h+1)/b,(g+1)/c),r=new THREE.Vector2(h/b,(g+1)/c),e.push(new THREE.Face3(a,d,i)),f.push([n,p,r]),e.push(new THREE.Face3(d,k,i)),\nf.push([p.clone(),t,r.clone()]);this.computeCentroids();this.computeFaceNormals();this.computeVertexNormals()};THREE.ParametricGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.AxisHelper=function(a){var a=a||1,b=new THREE.Geometry;b.vertices.push(new THREE.Vector3,new THREE.Vector3(a,0,0),new THREE.Vector3,new THREE.Vector3(0,a,0),new THREE.Vector3,new THREE.Vector3(0,0,a));b.colors.push(new THREE.Color(16711680),new THREE.Color(16755200),new THREE.Color(65280),new THREE.Color(11206400),new THREE.Color(255),new THREE.Color(43775));a=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});THREE.Line.call(this,b,a,THREE.LinePieces)};\nTHREE.AxisHelper.prototype=Object.create(THREE.Line.prototype);THREE.ArrowHelper=function(a,b,c,d,e,f){THREE.Object3D.call(this);void 0===d&&(d=16776960);void 0===c&&(c=1);void 0===e&&(e=0.2*c);void 0===f&&(f=0.2*e);this.position=b;b=new THREE.Geometry;b.vertices.push(new THREE.Vector3(0,0,0));b.vertices.push(new THREE.Vector3(0,1,0));this.line=new THREE.Line(b,new THREE.LineBasicMaterial({color:d}));this.line.matrixAutoUpdate=!1;this.add(this.line);b=new THREE.CylinderGeometry(0,0.5,1,5,1);b.applyMatrix((new THREE.Matrix4).makeTranslation(0,-0.5,0));this.cone=\nnew THREE.Mesh(b,new THREE.MeshBasicMaterial({color:d}));this.cone.matrixAutoUpdate=!1;this.add(this.cone);this.setDirection(a);this.setLength(c,e,f)};THREE.ArrowHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.ArrowHelper.prototype.setDirection=function(){var a=new THREE.Vector3,b;return function(c){0.99999<c.y?this.quaternion.set(0,0,0,1):-0.99999>c.y?this.quaternion.set(1,0,0,0):(a.set(c.z,0,-c.x).normalize(),b=Math.acos(c.y),this.quaternion.setFromAxisAngle(a,b))}}();\nTHREE.ArrowHelper.prototype.setLength=function(a,b,c){void 0===b&&(b=0.2*a);void 0===c&&(c=0.2*b);this.line.scale.set(1,a,1);this.line.updateMatrix();this.cone.scale.set(c,b,c);this.cone.position.y=a;this.cone.updateMatrix()};THREE.ArrowHelper.prototype.setColor=function(a){this.line.material.color.setHex(a);this.cone.material.color.setHex(a)};THREE.BoxHelper=function(a){var b=[new THREE.Vector3(1,1,1),new THREE.Vector3(-1,1,1),new THREE.Vector3(-1,-1,1),new THREE.Vector3(1,-1,1),new THREE.Vector3(1,1,-1),new THREE.Vector3(-1,1,-1),new THREE.Vector3(-1,-1,-1),new THREE.Vector3(1,-1,-1)];this.vertices=b;var c=new THREE.Geometry;c.vertices.push(b[0],b[1],b[1],b[2],b[2],b[3],b[3],b[0],b[4],b[5],b[5],b[6],b[6],b[7],b[7],b[4],b[0],b[4],b[1],b[5],b[2],b[6],b[3],b[7]);THREE.Line.call(this,c,new THREE.LineBasicMaterial({color:16776960}),THREE.LinePieces);\nvoid 0!==a&&this.update(a)};THREE.BoxHelper.prototype=Object.create(THREE.Line.prototype);\nTHREE.BoxHelper.prototype.update=function(a){var b=a.geometry;null===b.boundingBox&&b.computeBoundingBox();var c=b.boundingBox.min,b=b.boundingBox.max,d=this.vertices;d[0].set(b.x,b.y,b.z);d[1].set(c.x,b.y,b.z);d[2].set(c.x,c.y,b.z);d[3].set(b.x,c.y,b.z);d[4].set(b.x,b.y,c.z);d[5].set(c.x,b.y,c.z);d[6].set(c.x,c.y,c.z);d[7].set(b.x,c.y,c.z);this.geometry.computeBoundingSphere();this.geometry.verticesNeedUpdate=!0;this.matrixAutoUpdate=!1;this.matrixWorld=a.matrixWorld};THREE.BoundingBoxHelper=function(a,b){var c=void 0!==b?b:8947848;this.object=a;this.box=new THREE.Box3;THREE.Mesh.call(this,new THREE.CubeGeometry(1,1,1),new THREE.MeshBasicMaterial({color:c,wireframe:!0}))};THREE.BoundingBoxHelper.prototype=Object.create(THREE.Mesh.prototype);THREE.BoundingBoxHelper.prototype.update=function(){this.box.setFromObject(this.object);this.box.size(this.scale);this.box.center(this.position)};THREE.CameraHelper=function(a){function b(a,b,d){c(a,d);c(b,d)}function c(a,b){d.vertices.push(new THREE.Vector3);d.colors.push(new THREE.Color(b));void 0===f[a]&&(f[a]=[]);f[a].push(d.vertices.length-1)}var d=new THREE.Geometry,e=new THREE.LineBasicMaterial({color:16777215,vertexColors:THREE.FaceColors}),f={};b(\"n1\",\"n2\",16755200);b(\"n2\",\"n4\",16755200);b(\"n4\",\"n3\",16755200);b(\"n3\",\"n1\",16755200);b(\"f1\",\"f2\",16755200);b(\"f2\",\"f4\",16755200);b(\"f4\",\"f3\",16755200);b(\"f3\",\"f1\",16755200);b(\"n1\",\"f1\",16755200);\nb(\"n2\",\"f2\",16755200);b(\"n3\",\"f3\",16755200);b(\"n4\",\"f4\",16755200);b(\"p\",\"n1\",16711680);b(\"p\",\"n2\",16711680);b(\"p\",\"n3\",16711680);b(\"p\",\"n4\",16711680);b(\"u1\",\"u2\",43775);b(\"u2\",\"u3\",43775);b(\"u3\",\"u1\",43775);b(\"c\",\"t\",16777215);b(\"p\",\"c\",3355443);b(\"cn1\",\"cn2\",3355443);b(\"cn3\",\"cn4\",3355443);b(\"cf1\",\"cf2\",3355443);b(\"cf3\",\"cf4\",3355443);THREE.Line.call(this,d,e,THREE.LinePieces);this.camera=a;this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;this.pointMap=f;this.update()};\nTHREE.CameraHelper.prototype=Object.create(THREE.Line.prototype);\nTHREE.CameraHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Camera,c=new THREE.Projector;return function(){function d(d,g,h,i){a.set(g,h,i);c.unprojectVector(a,b);d=e.pointMap[d];if(void 0!==d){g=0;for(h=d.length;g<h;g++)e.geometry.vertices[d[g]].copy(a)}}var e=this;b.projectionMatrix.copy(this.camera.projectionMatrix);d(\"c\",0,0,-1);d(\"t\",0,0,1);d(\"n1\",-1,-1,-1);d(\"n2\",1,-1,-1);d(\"n3\",-1,1,-1);d(\"n4\",1,1,-1);d(\"f1\",-1,-1,1);d(\"f2\",1,-1,1);d(\"f3\",-1,1,1);d(\"f4\",1,1,1);d(\"u1\",\n0.7,1.1,-1);d(\"u2\",-0.7,1.1,-1);d(\"u3\",0,2,-1);d(\"cf1\",-1,0,1);d(\"cf2\",1,0,1);d(\"cf3\",0,-1,1);d(\"cf4\",0,1,1);d(\"cn1\",-1,0,-1);d(\"cn2\",1,0,-1);d(\"cn3\",0,-1,-1);d(\"cn4\",0,1,-1);this.geometry.verticesNeedUpdate=!0}}();THREE.DirectionalLightHelper=function(a,b){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;var b=b||1,c=new THREE.PlaneGeometry(b,b),d=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});d.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.lightPlane=new THREE.Mesh(c,d);this.add(this.lightPlane);c=new THREE.Geometry;c.vertices.push(new THREE.Vector3);c.vertices.push(new THREE.Vector3);d=new THREE.LineBasicMaterial({fog:!1});\nd.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.targetLine=new THREE.Line(c,d);this.add(this.targetLine);this.update()};THREE.DirectionalLightHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.DirectionalLightHelper.prototype.dispose=function(){this.lightPlane.geometry.dispose();this.lightPlane.material.dispose();this.targetLine.geometry.dispose();this.targetLine.material.dispose()};\nTHREE.DirectionalLightHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(){a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);c.subVectors(b,a);this.lightPlane.lookAt(c);this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.targetLine.geometry.vertices[1].copy(c);this.targetLine.geometry.verticesNeedUpdate=!0;this.targetLine.material.color.copy(this.lightPlane.material.color)}}();THREE.EdgesHelper=function(a,b){var c=void 0!==b?b:16777215,d=[0,0],e={},f=function(a,b){return a-b},g=[\"a\",\"b\",\"c\"],h=new THREE.BufferGeometry,i=a.geometry.clone();i.mergeVertices();i.computeFaceNormals();for(var k=i.vertices,i=i.faces,l=0,n=0,p=i.length;n<p;n++)for(var t=i[n],r=0;3>r;r++){d[0]=t[g[r]];d[1]=t[g[(r+1)%3]];d.sort(f);var m=d.toString();void 0===e[m]?(e[m]={vert1:d[0],vert2:d[1],face1:n,face2:void 0},l++):e[m].face2=n}h.addAttribute(\"position\",Float32Array,2*l,3);d=h.attributes.position.array;\nf=0;for(m in e)if(g=e[m],void 0===g.face2||0.9999>i[g.face1].normal.dot(i[g.face2].normal))l=k[g.vert1],d[f++]=l.x,d[f++]=l.y,d[f++]=l.z,l=k[g.vert2],d[f++]=l.x,d[f++]=l.y,d[f++]=l.z;THREE.Line.call(this,h,new THREE.LineBasicMaterial({color:c}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.matrixWorld=a.matrixWorld};THREE.EdgesHelper.prototype=Object.create(THREE.Line.prototype);THREE.FaceNormalsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;for(var a=void 0!==c?c:16776960,d=void 0!==d?d:1,b=new THREE.Geometry,c=0,e=this.object.geometry.faces.length;c<e;c++)b.vertices.push(new THREE.Vector3),b.vertices.push(new THREE.Vector3);THREE.Line.call(this,b,new THREE.LineBasicMaterial({color:a,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.normalMatrix=new THREE.Matrix3;this.update()};THREE.FaceNormalsHelper.prototype=Object.create(THREE.Line.prototype);\nTHREE.FaceNormalsHelper.prototype.update=function(){var a=new THREE.Vector3;return function(){this.object.updateMatrixWorld(!0);this.normalMatrix.getNormalMatrix(this.object.matrixWorld);for(var b=this.geometry.vertices,c=this.object.geometry.faces,d=this.object.matrixWorld,e=0,f=c.length;e<f;e++){var g=c[e];a.copy(g.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);var h=2*e;b[h].copy(g.centroid).applyMatrix4(d);b[h+1].addVectors(b[h],a)}this.geometry.verticesNeedUpdate=\n!0;return this}}();THREE.GridHelper=function(a,b){var c=new THREE.Geometry,d=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});this.color1=new THREE.Color(4473924);this.color2=new THREE.Color(8947848);for(var e=-a;e<=a;e+=b){c.vertices.push(new THREE.Vector3(-a,0,e),new THREE.Vector3(a,0,e),new THREE.Vector3(e,0,-a),new THREE.Vector3(e,0,a));var f=0===e?this.color1:this.color2;c.colors.push(f,f,f,f)}THREE.Line.call(this,c,d,THREE.LinePieces)};THREE.GridHelper.prototype=Object.create(THREE.Line.prototype);\nTHREE.GridHelper.prototype.setColors=function(a,b){this.color1.set(a);this.color2.set(b);this.geometry.colorsNeedUpdate=!0};THREE.HemisphereLightHelper=function(a,b){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;this.colors=[new THREE.Color,new THREE.Color];var c=new THREE.SphereGeometry(b,4,2);c.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI/2));for(var d=0;8>d;d++)c.faces[d].color=this.colors[4>d?0:1];d=new THREE.MeshBasicMaterial({vertexColors:THREE.FaceColors,wireframe:!0});this.lightSphere=new THREE.Mesh(c,d);this.add(this.lightSphere);\nthis.update()};THREE.HemisphereLightHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.HemisphereLightHelper.prototype.dispose=function(){this.lightSphere.geometry.dispose();this.lightSphere.material.dispose()};\nTHREE.HemisphereLightHelper.prototype.update=function(){var a=new THREE.Vector3;return function(){this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());this.lightSphere.geometry.colorsNeedUpdate=!0}}();THREE.PointLightHelper=function(a,b){this.light=a;this.light.updateMatrixWorld();var c=new THREE.SphereGeometry(b,4,2),d=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});d.color.copy(this.light.color).multiplyScalar(this.light.intensity);THREE.Mesh.call(this,c,d);this.matrixWorld=this.light.matrixWorld;this.matrixAutoUpdate=!1};THREE.PointLightHelper.prototype=Object.create(THREE.Mesh.prototype);THREE.PointLightHelper.prototype.dispose=function(){this.geometry.dispose();this.material.dispose()};\nTHREE.PointLightHelper.prototype.update=function(){this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)};THREE.SpotLightHelper=function(a){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;a=new THREE.CylinderGeometry(0,1,1,8,1,!0);a.applyMatrix((new THREE.Matrix4).makeTranslation(0,-0.5,0));a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI/2));var b=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});this.cone=new THREE.Mesh(a,b);this.add(this.cone);this.update()};THREE.SpotLightHelper.prototype=Object.create(THREE.Object3D.prototype);\nTHREE.SpotLightHelper.prototype.dispose=function(){this.cone.geometry.dispose();this.cone.material.dispose()};THREE.SpotLightHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(){var c=this.light.distance?this.light.distance:1E4,d=c*Math.tan(this.light.angle);this.cone.scale.set(d,d,c);a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(b.sub(a));this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)}}();THREE.VertexNormalsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;for(var b=void 0!==c?c:16711680,d=void 0!==d?d:1,c=new THREE.Geometry,a=a.geometry.faces,e=0,f=a.length;e<f;e++)for(var g=0,h=a[e].vertexNormals.length;g<h;g++)c.vertices.push(new THREE.Vector3),c.vertices.push(new THREE.Vector3);THREE.Line.call(this,c,new THREE.LineBasicMaterial({color:b,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.normalMatrix=new THREE.Matrix3;this.update()};\nTHREE.VertexNormalsHelper.prototype=Object.create(THREE.Line.prototype);\nTHREE.VertexNormalsHelper.prototype.update=function(){var a=new THREE.Vector3;return function(){var b=[\"a\",\"b\",\"c\",\"d\"];this.object.updateMatrixWorld(!0);this.normalMatrix.getNormalMatrix(this.object.matrixWorld);for(var c=this.geometry.vertices,d=this.object.geometry.vertices,e=this.object.geometry.faces,f=this.object.matrixWorld,g=0,h=0,i=e.length;h<i;h++)for(var k=e[h],l=0,n=k.vertexNormals.length;l<n;l++){var p=k.vertexNormals[l];c[g].copy(d[k[b[l]]]).applyMatrix4(f);a.copy(p).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);\na.add(c[g]);g+=1;c[g].copy(a);g+=1}this.geometry.verticesNeedUpdate=!0;return this}}();THREE.VertexTangentsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;for(var b=void 0!==c?c:255,d=void 0!==d?d:1,c=new THREE.Geometry,a=a.geometry.faces,e=0,f=a.length;e<f;e++)for(var g=0,h=a[e].vertexTangents.length;g<h;g++)c.vertices.push(new THREE.Vector3),c.vertices.push(new THREE.Vector3);THREE.Line.call(this,c,new THREE.LineBasicMaterial({color:b,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.update()};THREE.VertexTangentsHelper.prototype=Object.create(THREE.Line.prototype);\nTHREE.VertexTangentsHelper.prototype.update=function(){var a=new THREE.Vector3;return function(){var b=[\"a\",\"b\",\"c\",\"d\"];this.object.updateMatrixWorld(!0);for(var c=this.geometry.vertices,d=this.object.geometry.vertices,e=this.object.geometry.faces,f=this.object.matrixWorld,g=0,h=0,i=e.length;h<i;h++)for(var k=e[h],l=0,n=k.vertexTangents.length;l<n;l++){var p=k.vertexTangents[l];c[g].copy(d[k[b[l]]]).applyMatrix4(f);a.copy(p).transformDirection(f).multiplyScalar(this.size);a.add(c[g]);g+=1;c[g].copy(a);\ng+=1}this.geometry.verticesNeedUpdate=!0;return this}}();THREE.WireframeHelper=function(a,b){var c=void 0!==b?b:16777215,d=[0,0],e={},f=function(a,b){return a-b},g=[\"a\",\"b\",\"c\"],h=new THREE.BufferGeometry;if(a.geometry instanceof THREE.Geometry){for(var i=a.geometry.vertices,k=a.geometry.faces,l=0,n=new Uint32Array(6*k.length),p=0,t=k.length;p<t;p++)for(var r=k[p],m=0;3>m;m++){d[0]=r[g[m]];d[1]=r[g[(m+1)%3]];d.sort(f);var q=d.toString();void 0===e[q]&&(n[2*l]=d[0],n[2*l+1]=d[1],e[q]=!0,l++)}h.addAttribute(\"position\",Float32Array,2*l,3);d=h.attributes.position.array;\np=0;for(t=l;p<t;p++)for(m=0;2>m;m++)l=i[n[2*p+m]],g=6*p+3*m,d[g+0]=l.x,d[g+1]=l.y,d[g+2]=l.z}else if(a.geometry instanceof THREE.BufferGeometry&&void 0!==a.geometry.attributes.index){for(var i=a.geometry.attributes.position.array,t=a.geometry.attributes.index.array,k=a.geometry.offsets,l=0,n=new Uint32Array(2*t.length),r=0,u=k.length;r<u;++r)for(var m=k[r].start,q=k[r].count,g=k[r].index,p=m,s=m+q;p<s;p+=3)for(m=0;3>m;m++)d[0]=g+t[p+m],d[1]=g+t[p+(m+1)%3],d.sort(f),q=d.toString(),void 0===e[q]&&(n[2*\nl]=d[0],n[2*l+1]=d[1],e[q]=!0,l++);h.addAttribute(\"position\",Float32Array,2*l,3);d=h.attributes.position.array;p=0;for(t=l;p<t;p++)for(m=0;2>m;m++)g=6*p+3*m,l=3*n[2*p+m],d[g+0]=i[l],d[g+1]=i[l+1],d[g+2]=i[l+2]}else if(a.geometry instanceof THREE.BufferGeometry){i=a.geometry.attributes.position.array;l=i.length/3;n=l/3;h.addAttribute(\"position\",Float32Array,2*l,3);d=h.attributes.position.array;p=0;for(t=n;p<t;p++)for(m=0;3>m;m++)g=18*p+6*m,n=9*p+3*m,d[g+0]=i[n],d[g+1]=i[n+1],d[g+2]=i[n+2],l=9*p+3*\n((m+1)%3),d[g+3]=i[l],d[g+4]=i[l+1],d[g+5]=i[l+2]}THREE.Line.call(this,h,new THREE.LineBasicMaterial({color:c}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.matrixWorld=a.matrixWorld};THREE.WireframeHelper.prototype=Object.create(THREE.Line.prototype);THREE.ImmediateRenderObject=function(){THREE.Object3D.call(this);this.render=function(){}};THREE.ImmediateRenderObject.prototype=Object.create(THREE.Object3D.prototype);THREE.LensFlare=function(a,b,c,d,e){THREE.Object3D.call(this);this.lensFlares=[];this.positionScreen=new THREE.Vector3;this.customUpdateCallback=void 0;void 0!==a&&this.add(a,b,c,d,e)};THREE.LensFlare.prototype=Object.create(THREE.Object3D.prototype);\nTHREE.LensFlare.prototype.add=function(a,b,c,d,e,f){void 0===b&&(b=-1);void 0===c&&(c=0);void 0===f&&(f=1);void 0===e&&(e=new THREE.Color(16777215));void 0===d&&(d=THREE.NormalBlending);c=Math.min(c,Math.max(0,c));this.lensFlares.push({texture:a,size:b,distance:c,x:0,y:0,z:0,scale:1,rotation:1,opacity:f,color:e,blending:d})};\nTHREE.LensFlare.prototype.updateLensFlares=function(){var a,b=this.lensFlares.length,c,d=2*-this.positionScreen.x,e=2*-this.positionScreen.y;for(a=0;a<b;a++)c=this.lensFlares[a],c.x=this.positionScreen.x+d*c.distance,c.y=this.positionScreen.y+e*c.distance,c.wantedRotation=0.25*c.x*Math.PI,c.rotation+=0.25*(c.wantedRotation-c.rotation)};THREE.MorphBlendMesh=function(a,b){THREE.Mesh.call(this,a,b);this.animationsMap={};this.animationsList=[];var c=this.geometry.morphTargets.length;this.createAnimation(\"__default\",0,c-1,c/1);this.setAnimationWeight(\"__default\",1)};THREE.MorphBlendMesh.prototype=Object.create(THREE.Mesh.prototype);\nTHREE.MorphBlendMesh.prototype.createAnimation=function(a,b,c,d){b={startFrame:b,endFrame:c,length:c-b+1,fps:d,duration:(c-b)/d,lastFrame:0,currentFrame:0,active:!1,time:0,direction:1,weight:1,directionBackwards:!1,mirroredLoop:!1};this.animationsMap[a]=b;this.animationsList.push(b)};\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations=function(a){for(var b=/([a-z]+)(\\d+)/,c,d={},e=this.geometry,f=0,g=e.morphTargets.length;f<g;f++){var h=e.morphTargets[f].name.match(b);if(h&&1<h.length){var i=h[1];d[i]||(d[i]={start:Infinity,end:-Infinity});h=d[i];f<h.start&&(h.start=f);f>h.end&&(h.end=f);c||(c=i)}}for(i in d)h=d[i],this.createAnimation(i,h.start,h.end,a);this.firstAnimation=c};\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward=function(a){if(a=this.animationsMap[a])a.direction=1,a.directionBackwards=!1};THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward=function(a){if(a=this.animationsMap[a])a.direction=-1,a.directionBackwards=!0};THREE.MorphBlendMesh.prototype.setAnimationFPS=function(a,b){var c=this.animationsMap[a];c&&(c.fps=b,c.duration=(c.end-c.start)/c.fps)};\nTHREE.MorphBlendMesh.prototype.setAnimationDuration=function(a,b){var c=this.animationsMap[a];c&&(c.duration=b,c.fps=(c.end-c.start)/c.duration)};THREE.MorphBlendMesh.prototype.setAnimationWeight=function(a,b){var c=this.animationsMap[a];c&&(c.weight=b)};THREE.MorphBlendMesh.prototype.setAnimationTime=function(a,b){var c=this.animationsMap[a];c&&(c.time=b)};THREE.MorphBlendMesh.prototype.getAnimationTime=function(a){var b=0;if(a=this.animationsMap[a])b=a.time;return b};\nTHREE.MorphBlendMesh.prototype.getAnimationDuration=function(a){var b=-1;if(a=this.animationsMap[a])b=a.duration;return b};THREE.MorphBlendMesh.prototype.playAnimation=function(a){var b=this.animationsMap[a];b?(b.time=0,b.active=!0):console.warn(\"animation[\"+a+\"] undefined\")};THREE.MorphBlendMesh.prototype.stopAnimation=function(a){if(a=this.animationsMap[a])a.active=!1};\nTHREE.MorphBlendMesh.prototype.update=function(a){for(var b=0,c=this.animationsList.length;b<c;b++){var d=this.animationsList[b];if(d.active){var e=d.duration/d.length;d.time+=d.direction*a;if(d.mirroredLoop){if(d.time>d.duration||0>d.time)d.direction*=-1,d.time>d.duration&&(d.time=d.duration,d.directionBackwards=!0),0>d.time&&(d.time=0,d.directionBackwards=!1)}else d.time%=d.duration,0>d.time&&(d.time+=d.duration);var f=d.startFrame+THREE.Math.clamp(Math.floor(d.time/e),0,d.length-1),g=d.weight;\nf!==d.currentFrame&&(this.morphTargetInfluences[d.lastFrame]=0,this.morphTargetInfluences[d.currentFrame]=1*g,this.morphTargetInfluences[f]=0,d.lastFrame=d.currentFrame,d.currentFrame=f);e=d.time%e/e;d.directionBackwards&&(e=1-e);this.morphTargetInfluences[d.currentFrame]=e*g;this.morphTargetInfluences[d.lastFrame]=(1-e)*g}}};THREE.LensFlarePlugin=function(){function a(a,c){var d=b.createProgram(),e=b.createShader(b.FRAGMENT_SHADER),f=b.createShader(b.VERTEX_SHADER),g=\"precision \"+c+\" float;\\n\";b.shaderSource(e,g+a.fragmentShader);b.shaderSource(f,g+a.vertexShader);b.compileShader(e);b.compileShader(f);b.attachShader(d,e);b.attachShader(d,f);b.linkProgram(d);return d}var b,c,d,e,f,g,h,i,k,l,n,p,t;this.init=function(r){b=r.context;c=r;d=r.getPrecision();e=new Float32Array(16);f=new Uint16Array(6);r=0;e[r++]=-1;e[r++]=-1;\ne[r++]=0;e[r++]=0;e[r++]=1;e[r++]=-1;e[r++]=1;e[r++]=0;e[r++]=1;e[r++]=1;e[r++]=1;e[r++]=1;e[r++]=-1;e[r++]=1;e[r++]=0;e[r++]=1;r=0;f[r++]=0;f[r++]=1;f[r++]=2;f[r++]=0;f[r++]=2;f[r++]=3;g=b.createBuffer();h=b.createBuffer();b.bindBuffer(b.ARRAY_BUFFER,g);b.bufferData(b.ARRAY_BUFFER,e,b.STATIC_DRAW);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,h);b.bufferData(b.ELEMENT_ARRAY_BUFFER,f,b.STATIC_DRAW);i=b.createTexture();k=b.createTexture();b.bindTexture(b.TEXTURE_2D,i);b.texImage2D(b.TEXTURE_2D,0,b.RGB,16,16,\n0,b.RGB,b.UNSIGNED_BYTE,null);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.NEAREST);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.NEAREST);b.bindTexture(b.TEXTURE_2D,k);b.texImage2D(b.TEXTURE_2D,0,b.RGBA,16,16,0,b.RGBA,b.UNSIGNED_BYTE,null);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_S,b.CLAMP_TO_EDGE);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_WRAP_T,b.CLAMP_TO_EDGE);\nb.texParameteri(b.TEXTURE_2D,b.TEXTURE_MAG_FILTER,b.NEAREST);b.texParameteri(b.TEXTURE_2D,b.TEXTURE_MIN_FILTER,b.NEAREST);0>=b.getParameter(b.MAX_VERTEX_TEXTURE_IMAGE_UNITS)?(l=!1,n=a(THREE.ShaderFlares.lensFlare,d)):(l=!0,n=a(THREE.ShaderFlares.lensFlareVertexTexture,d));p={};t={};p.vertex=b.getAttribLocation(n,\"position\");p.uv=b.getAttribLocation(n,\"uv\");t.renderType=b.getUniformLocation(n,\"renderType\");t.map=b.getUniformLocation(n,\"map\");t.occlusionMap=b.getUniformLocation(n,\"occlusionMap\");t.opacity=\nb.getUniformLocation(n,\"opacity\");t.color=b.getUniformLocation(n,\"color\");t.scale=b.getUniformLocation(n,\"scale\");t.rotation=b.getUniformLocation(n,\"rotation\");t.screenPosition=b.getUniformLocation(n,\"screenPosition\")};this.render=function(a,d,e,f){var a=a.__webglFlares,s=a.length;if(s){var v=new THREE.Vector3,z=f/e,G=0.5*e,N=0.5*f,C=16/f,B=new THREE.Vector2(C*z,C),x=new THREE.Vector3(1,1,0),F=new THREE.Vector2(1,1),L=t,C=p;b.useProgram(n);b.enableVertexAttribArray(p.vertex);b.enableVertexAttribArray(p.uv);\nb.uniform1i(L.occlusionMap,0);b.uniform1i(L.map,1);b.bindBuffer(b.ARRAY_BUFFER,g);b.vertexAttribPointer(C.vertex,2,b.FLOAT,!1,16,0);b.vertexAttribPointer(C.uv,2,b.FLOAT,!1,16,8);b.bindBuffer(b.ELEMENT_ARRAY_BUFFER,h);b.disable(b.CULL_FACE);b.depthMask(!1);var w,E,y,D,H;for(w=0;w<s;w++)if(C=16/f,B.set(C*z,C),D=a[w],v.set(D.matrixWorld.elements[12],D.matrixWorld.elements[13],D.matrixWorld.elements[14]),v.applyMatrix4(d.matrixWorldInverse),v.applyProjection(d.projectionMatrix),x.copy(v),F.x=x.x*G+G,\nF.y=x.y*N+N,l||0<F.x&&F.x<e&&0<F.y&&F.y<f){b.activeTexture(b.TEXTURE1);b.bindTexture(b.TEXTURE_2D,i);b.copyTexImage2D(b.TEXTURE_2D,0,b.RGB,F.x-8,F.y-8,16,16,0);b.uniform1i(L.renderType,0);b.uniform2f(L.scale,B.x,B.y);b.uniform3f(L.screenPosition,x.x,x.y,x.z);b.disable(b.BLEND);b.enable(b.DEPTH_TEST);b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0);b.activeTexture(b.TEXTURE0);b.bindTexture(b.TEXTURE_2D,k);b.copyTexImage2D(b.TEXTURE_2D,0,b.RGBA,F.x-8,F.y-8,16,16,0);b.uniform1i(L.renderType,1);b.disable(b.DEPTH_TEST);\nb.activeTexture(b.TEXTURE1);b.bindTexture(b.TEXTURE_2D,i);b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0);D.positionScreen.copy(x);D.customUpdateCallback?D.customUpdateCallback(D):D.updateLensFlares();b.uniform1i(L.renderType,2);b.enable(b.BLEND);E=0;for(y=D.lensFlares.length;E<y;E++)H=D.lensFlares[E],0.001<H.opacity&&0.001<H.scale&&(x.x=H.x,x.y=H.y,x.z=H.z,C=H.size*H.scale/f,B.x=C*z,B.y=C,b.uniform3f(L.screenPosition,x.x,x.y,x.z),b.uniform2f(L.scale,B.x,B.y),b.uniform1f(L.rotation,H.rotation),b.uniform1f(L.opacity,\nH.opacity),b.uniform3f(L.color,H.color.r,H.color.g,H.color.b),c.setBlending(H.blending,H.blendEquation,H.blendSrc,H.blendDst),c.setTexture(H.texture,1),b.drawElements(b.TRIANGLES,6,b.UNSIGNED_SHORT,0))}b.enable(b.CULL_FACE);b.enable(b.DEPTH_TEST);b.depthMask(!0)}}};THREE.ShadowMapPlugin=function(){var a,b,c,d,e,f,g=new THREE.Frustum,h=new THREE.Matrix4,i=new THREE.Vector3,k=new THREE.Vector3,l=new THREE.Vector3;this.init=function(g){a=g.context;b=g;var g=THREE.ShaderLib.depthRGBA,h=THREE.UniformsUtils.clone(g.uniforms);c=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h});d=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:!0});e=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,\nvertexShader:g.vertexShader,uniforms:h,skinning:!0});f=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:!0,skinning:!0});c._shadowPass=!0;d._shadowPass=!0;e._shadowPass=!0;f._shadowPass=!0};this.render=function(a,c){b.shadowMapEnabled&&b.shadowMapAutoUpdate&&this.update(a,c)};this.update=function(n,p){var t,r,m,q,u,s,v,z,G,N=[];q=0;a.clearColor(1,1,1,1);a.disable(a.BLEND);a.enable(a.CULL_FACE);a.frontFace(a.CCW);b.shadowMapCullFace===THREE.CullFaceFront?\na.cullFace(a.FRONT):a.cullFace(a.BACK);b.setDepthTest(!0);t=0;for(r=n.__lights.length;t<r;t++)if(m=n.__lights[t],m.castShadow)if(m instanceof THREE.DirectionalLight&&m.shadowCascade)for(u=0;u<m.shadowCascadeCount;u++){var C;if(m.shadowCascadeArray[u])C=m.shadowCascadeArray[u];else{G=m;v=u;C=new THREE.DirectionalLight;C.isVirtual=!0;C.onlyShadow=!0;C.castShadow=!0;C.shadowCameraNear=G.shadowCameraNear;C.shadowCameraFar=G.shadowCameraFar;C.shadowCameraLeft=G.shadowCameraLeft;C.shadowCameraRight=G.shadowCameraRight;\nC.shadowCameraBottom=G.shadowCameraBottom;C.shadowCameraTop=G.shadowCameraTop;C.shadowCameraVisible=G.shadowCameraVisible;C.shadowDarkness=G.shadowDarkness;C.shadowBias=G.shadowCascadeBias[v];C.shadowMapWidth=G.shadowCascadeWidth[v];C.shadowMapHeight=G.shadowCascadeHeight[v];C.pointsWorld=[];C.pointsFrustum=[];z=C.pointsWorld;s=C.pointsFrustum;for(var B=0;8>B;B++)z[B]=new THREE.Vector3,s[B]=new THREE.Vector3;z=G.shadowCascadeNearZ[v];G=G.shadowCascadeFarZ[v];s[0].set(-1,-1,z);s[1].set(1,-1,z);s[2].set(-1,\n1,z);s[3].set(1,1,z);s[4].set(-1,-1,G);s[5].set(1,-1,G);s[6].set(-1,1,G);s[7].set(1,1,G);C.originalCamera=p;s=new THREE.Gyroscope;s.position=m.shadowCascadeOffset;s.add(C);s.add(C.target);p.add(s);m.shadowCascadeArray[u]=C;console.log(\"Created virtualLight\",C)}v=m;z=u;G=v.shadowCascadeArray[z];G.position.copy(v.position);G.target.position.copy(v.target.position);G.lookAt(G.target);G.shadowCameraVisible=v.shadowCameraVisible;G.shadowDarkness=v.shadowDarkness;G.shadowBias=v.shadowCascadeBias[z];s=v.shadowCascadeNearZ[z];\nv=v.shadowCascadeFarZ[z];G=G.pointsFrustum;G[0].z=s;G[1].z=s;G[2].z=s;G[3].z=s;G[4].z=v;G[5].z=v;G[6].z=v;G[7].z=v;N[q]=C;q++}else N[q]=m,q++;t=0;for(r=N.length;t<r;t++){m=N[t];m.shadowMap||(u=THREE.LinearFilter,b.shadowMapType===THREE.PCFSoftShadowMap&&(u=THREE.NearestFilter),m.shadowMap=new THREE.WebGLRenderTarget(m.shadowMapWidth,m.shadowMapHeight,{minFilter:u,magFilter:u,format:THREE.RGBAFormat}),m.shadowMapSize=new THREE.Vector2(m.shadowMapWidth,m.shadowMapHeight),m.shadowMatrix=new THREE.Matrix4);\nif(!m.shadowCamera){if(m instanceof THREE.SpotLight)m.shadowCamera=new THREE.PerspectiveCamera(m.shadowCameraFov,m.shadowMapWidth/m.shadowMapHeight,m.shadowCameraNear,m.shadowCameraFar);else if(m instanceof THREE.DirectionalLight)m.shadowCamera=new THREE.OrthographicCamera(m.shadowCameraLeft,m.shadowCameraRight,m.shadowCameraTop,m.shadowCameraBottom,m.shadowCameraNear,m.shadowCameraFar);else{console.error(\"Unsupported light type for shadow\");continue}n.add(m.shadowCamera);!0===n.autoUpdate&&n.updateMatrixWorld()}m.shadowCameraVisible&&\n!m.cameraHelper&&(m.cameraHelper=new THREE.CameraHelper(m.shadowCamera),m.shadowCamera.add(m.cameraHelper));if(m.isVirtual&&C.originalCamera==p){u=p;q=m.shadowCamera;s=m.pointsFrustum;G=m.pointsWorld;i.set(Infinity,Infinity,Infinity);k.set(-Infinity,-Infinity,-Infinity);for(v=0;8>v;v++)z=G[v],z.copy(s[v]),THREE.ShadowMapPlugin.__projector.unprojectVector(z,u),z.applyMatrix4(q.matrixWorldInverse),z.x<i.x&&(i.x=z.x),z.x>k.x&&(k.x=z.x),z.y<i.y&&(i.y=z.y),z.y>k.y&&(k.y=z.y),z.z<i.z&&(i.z=z.z),z.z>k.z&&\n(k.z=z.z);q.left=i.x;q.right=k.x;q.top=k.y;q.bottom=i.y;q.updateProjectionMatrix()}q=m.shadowMap;s=m.shadowMatrix;u=m.shadowCamera;u.position.setFromMatrixPosition(m.matrixWorld);l.setFromMatrixPosition(m.target.matrixWorld);u.lookAt(l);u.updateMatrixWorld();u.matrixWorldInverse.getInverse(u.matrixWorld);m.cameraHelper&&(m.cameraHelper.visible=m.shadowCameraVisible);m.shadowCameraVisible&&m.cameraHelper.update();s.set(0.5,0,0,0.5,0,0.5,0,0.5,0,0,0.5,0.5,0,0,0,1);s.multiply(u.projectionMatrix);s.multiply(u.matrixWorldInverse);\nh.multiplyMatrices(u.projectionMatrix,u.matrixWorldInverse);g.setFromMatrix(h);b.setRenderTarget(q);b.clear();G=n.__webglObjects;m=0;for(q=G.length;m<q;m++)if(v=G[m],s=v.object,v.render=!1,s.visible&&s.castShadow&&(!(s instanceof THREE.Mesh||s instanceof THREE.ParticleSystem)||!s.frustumCulled||g.intersectsObject(s)))s._modelViewMatrix.multiplyMatrices(u.matrixWorldInverse,s.matrixWorld),v.render=!0;m=0;for(q=G.length;m<q;m++)v=G[m],v.render&&(s=v.object,v=v.buffer,B=s.material instanceof THREE.MeshFaceMaterial?\ns.material.materials[0]:s.material,z=0<s.geometry.morphTargets.length&&B.morphTargets,B=s instanceof THREE.SkinnedMesh&&B.skinning,z=s.customDepthMaterial?s.customDepthMaterial:B?z?f:e:z?d:c,v instanceof THREE.BufferGeometry?b.renderBufferDirect(u,n.__lights,null,z,v,s):b.renderBuffer(u,n.__lights,null,z,v,s));G=n.__webglObjectsImmediate;m=0;for(q=G.length;m<q;m++)v=G[m],s=v.object,s.visible&&s.castShadow&&(s._modelViewMatrix.multiplyMatrices(u.matrixWorldInverse,s.matrixWorld),b.renderImmediateObject(u,\nn.__lights,null,c,s))}t=b.getClearColor();r=b.getClearAlpha();a.clearColor(t.r,t.g,t.b,r);a.enable(a.BLEND);b.shadowMapCullFace===THREE.CullFaceFront&&a.cullFace(a.BACK)}};THREE.ShadowMapPlugin.__projector=new THREE.Projector;THREE.SpritePlugin=function(){var a,b,c,d,e,f,g,h,i,k,l,n,p,t,r,m,q;function u(a,b){return a.z!==b.z?b.z-a.z:b.id-a.id}var s,v,z,G,N,C,B,x;this.init=function(u){s=u.context;v=u;G=new Float32Array([-0.5,-0.5,0,0,0.5,-0.5,1,0,0.5,0.5,1,1,-0.5,0.5,0,1]);N=new Uint16Array([0,1,2,0,2,3]);C=s.createBuffer();B=s.createBuffer();s.bindBuffer(s.ARRAY_BUFFER,C);s.bufferData(s.ARRAY_BUFFER,G,s.STATIC_DRAW);s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,B);s.bufferData(s.ELEMENT_ARRAY_BUFFER,N,s.STATIC_DRAW);var u=s.createProgram(),\nL=s.createShader(s.VERTEX_SHADER),w=s.createShader(s.FRAGMENT_SHADER);s.shaderSource(L,[\"precision \"+v.getPrecision()+\" float;\",\"uniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform float rotation;\\nuniform vec2 scale;\\nuniform vec2 uvOffset;\\nuniform vec2 uvScale;\\nattribute vec2 position;\\nattribute vec2 uv;\\nvarying vec2 vUV;\\nvoid main() {\\nvUV = uvOffset + uv * uvScale;\\nvec2 alignedPosition = position * scale;\\nvec2 rotatedPosition;\\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\nvec4 finalPosition;\\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\nfinalPosition.xy += rotatedPosition;\\nfinalPosition = projectionMatrix * finalPosition;\\ngl_Position = finalPosition;\\n}\"].join(\"\\n\"));\ns.shaderSource(w,[\"precision \"+v.getPrecision()+\" float;\",\"uniform vec3 color;\\nuniform sampler2D map;\\nuniform float opacity;\\nuniform int fogType;\\nuniform vec3 fogColor;\\nuniform float fogDensity;\\nuniform float fogNear;\\nuniform float fogFar;\\nuniform float alphaTest;\\nvarying vec2 vUV;\\nvoid main() {\\nvec4 texture = texture2D( map, vUV );\\nif ( texture.a < alphaTest ) discard;\\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\\nif ( fogType > 0 ) {\\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\nfloat fogFactor = 0.0;\\nif ( fogType == 1 ) {\\nfogFactor = smoothstep( fogNear, fogFar, depth );\\n} else {\\nconst float LOG2 = 1.442695;\\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\\n}\\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n}\\n}\"].join(\"\\n\"));\ns.compileShader(L);s.compileShader(w);s.attachShader(u,L);s.attachShader(u,w);s.linkProgram(u);x=u;m=s.getAttribLocation(x,\"position\");q=s.getAttribLocation(x,\"uv\");a=s.getUniformLocation(x,\"uvOffset\");b=s.getUniformLocation(x,\"uvScale\");c=s.getUniformLocation(x,\"rotation\");d=s.getUniformLocation(x,\"scale\");e=s.getUniformLocation(x,\"color\");f=s.getUniformLocation(x,\"map\");g=s.getUniformLocation(x,\"opacity\");h=s.getUniformLocation(x,\"modelViewMatrix\");i=s.getUniformLocation(x,\"projectionMatrix\");k=\ns.getUniformLocation(x,\"fogType\");l=s.getUniformLocation(x,\"fogDensity\");n=s.getUniformLocation(x,\"fogNear\");p=s.getUniformLocation(x,\"fogFar\");t=s.getUniformLocation(x,\"fogColor\");r=s.getUniformLocation(x,\"alphaTest\");u=document.createElement(\"canvas\");u.width=8;u.height=8;L=u.getContext(\"2d\");L.fillStyle=\"#ffffff\";L.fillRect(0,0,u.width,u.height);z=new THREE.Texture(u);z.needsUpdate=!0};this.render=function(F,G){var w=F.__webglSprites,E=w.length;if(E){s.useProgram(x);s.enableVertexAttribArray(m);\ns.enableVertexAttribArray(q);s.disable(s.CULL_FACE);s.enable(s.BLEND);s.bindBuffer(s.ARRAY_BUFFER,C);s.vertexAttribPointer(m,2,s.FLOAT,!1,16,0);s.vertexAttribPointer(q,2,s.FLOAT,!1,16,8);s.bindBuffer(s.ELEMENT_ARRAY_BUFFER,B);s.uniformMatrix4fv(i,!1,G.projectionMatrix.elements);s.activeTexture(s.TEXTURE0);s.uniform1i(f,0);var y=0,D=0,H=F.fog;H?(s.uniform3f(t,H.color.r,H.color.g,H.color.b),H instanceof THREE.Fog?(s.uniform1f(n,H.near),s.uniform1f(p,H.far),s.uniform1i(k,1),D=y=1):H instanceof THREE.FogExp2&&\n(s.uniform1f(l,H.density),s.uniform1i(k,2),D=y=2)):(s.uniform1i(k,0),D=y=0);for(var K,A,N=[],H=0;H<E;H++)K=w[H],!1!==K.visible&&(K._modelViewMatrix.multiplyMatrices(G.matrixWorldInverse,K.matrixWorld),K.z=-K._modelViewMatrix.elements[14]);w.sort(u);for(H=0;H<E;H++)K=w[H],!1!==K.visible&&(A=K.material,s.uniform1f(r,A.alphaTest),s.uniformMatrix4fv(h,!1,K._modelViewMatrix.elements),N[0]=K.scale.x,N[1]=K.scale.y,K=F.fog&&A.fog?D:0,y!==K&&(s.uniform1i(k,K),y=K),null!==A.map?(s.uniform2f(a,A.map.offset.x,\nA.map.offset.y),s.uniform2f(b,A.map.repeat.x,A.map.repeat.y)):(s.uniform2f(a,0,0),s.uniform2f(b,1,1)),s.uniform1f(g,A.opacity),s.uniform3f(e,A.color.r,A.color.g,A.color.b),s.uniform1f(c,A.rotation),s.uniform2fv(d,N),v.setBlending(A.blending,A.blendEquation,A.blendSrc,A.blendDst),v.setDepthTest(A.depthTest),v.setDepthWrite(A.depthWrite),A.map&&A.map.image&&A.map.image.width?v.setTexture(A.map,0):v.setTexture(z,0),s.drawElements(s.TRIANGLES,6,s.UNSIGNED_SHORT,0));s.enable(s.CULL_FACE)}}};THREE.DepthPassPlugin=function(){this.enabled=!1;this.renderTarget=null;var a,b,c,d,e,f,g=new THREE.Frustum,h=new THREE.Matrix4;this.init=function(g){a=g.context;b=g;var g=THREE.ShaderLib.depthRGBA,h=THREE.UniformsUtils.clone(g.uniforms);c=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h});d=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:!0});e=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,\nvertexShader:g.vertexShader,uniforms:h,skinning:!0});f=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:h,morphTargets:!0,skinning:!0});c._shadowPass=!0;d._shadowPass=!0;e._shadowPass=!0;f._shadowPass=!0};this.render=function(a,b){this.enabled&&this.update(a,b)};this.update=function(i,k){var l,n,p,t,r,m;a.clearColor(1,1,1,1);a.disable(a.BLEND);b.setDepthTest(!0);!0===i.autoUpdate&&i.updateMatrixWorld();k.matrixWorldInverse.getInverse(k.matrixWorld);h.multiplyMatrices(k.projectionMatrix,\nk.matrixWorldInverse);g.setFromMatrix(h);b.setRenderTarget(this.renderTarget);b.clear();m=i.__webglObjects;l=0;for(n=m.length;l<n;l++)if(p=m[l],r=p.object,p.render=!1,r.visible&&(!(r instanceof THREE.Mesh||r instanceof THREE.ParticleSystem)||!r.frustumCulled||g.intersectsObject(r)))r._modelViewMatrix.multiplyMatrices(k.matrixWorldInverse,r.matrixWorld),p.render=!0;var q;l=0;for(n=m.length;l<n;l++)if(p=m[l],p.render&&(r=p.object,p=p.buffer,!(r instanceof THREE.ParticleSystem)||r.customDepthMaterial))(q=\nr.material instanceof THREE.MeshFaceMaterial?r.material.materials[0]:r.material)&&b.setMaterialFaces(r.material),t=0<r.geometry.morphTargets.length&&q.morphTargets,q=r instanceof THREE.SkinnedMesh&&q.skinning,t=r.customDepthMaterial?r.customDepthMaterial:q?t?f:e:t?d:c,p instanceof THREE.BufferGeometry?b.renderBufferDirect(k,i.__lights,null,t,p,r):b.renderBuffer(k,i.__lights,null,t,p,r);m=i.__webglObjectsImmediate;l=0;for(n=m.length;l<n;l++)p=m[l],r=p.object,r.visible&&(r._modelViewMatrix.multiplyMatrices(k.matrixWorldInverse,\nr.matrixWorld),b.renderImmediateObject(k,i.__lights,null,c,r));l=b.getClearColor();n=b.getClearAlpha();a.clearColor(l.r,l.g,l.b,n);a.enable(a.BLEND)}};THREE.ShaderFlares={lensFlareVertexTexture:{vertexShader:\"uniform lowp int renderType;\\nuniform vec3 screenPosition;\\nuniform vec2 scale;\\nuniform float rotation;\\nuniform sampler2D occlusionMap;\\nattribute vec2 position;\\nattribute vec2 uv;\\nvarying vec2 vUV;\\nvarying float vVisibility;\\nvoid main() {\\nvUV = uv;\\nvec2 pos = position;\\nif( renderType == 2 ) {\\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\\nvVisibility =        visibility.r / 9.0;\\nvVisibility *= 1.0 - visibility.g / 9.0;\\nvVisibility *=       visibility.b / 9.0;\\nvVisibility *= 1.0 - visibility.a / 9.0;\\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\\n}\\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\\n}\",\nfragmentShader:\"uniform lowp int renderType;\\nuniform sampler2D map;\\nuniform float opacity;\\nuniform vec3 color;\\nvarying vec2 vUV;\\nvarying float vVisibility;\\nvoid main() {\\nif( renderType == 0 ) {\\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\\n} else if( renderType == 1 ) {\\ngl_FragColor = texture2D( map, vUV );\\n} else {\\nvec4 texture = texture2D( map, vUV );\\ntexture.a *= opacity * vVisibility;\\ngl_FragColor = texture;\\ngl_FragColor.rgb *= color;\\n}\\n}\"},lensFlare:{vertexShader:\"uniform lowp int renderType;\\nuniform vec3 screenPosition;\\nuniform vec2 scale;\\nuniform float rotation;\\nattribute vec2 position;\\nattribute vec2 uv;\\nvarying vec2 vUV;\\nvoid main() {\\nvUV = uv;\\nvec2 pos = position;\\nif( renderType == 2 ) {\\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\\n}\\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\\n}\",\nfragmentShader:\"precision mediump float;\\nuniform lowp int renderType;\\nuniform sampler2D map;\\nuniform sampler2D occlusionMap;\\nuniform float opacity;\\nuniform vec3 color;\\nvarying vec2 vUV;\\nvoid main() {\\nif( renderType == 0 ) {\\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\\n} else if( renderType == 1 ) {\\ngl_FragColor = texture2D( map, vUV );\\n} else {\\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\\nvisibility = ( 1.0 - visibility / 4.0 );\\nvec4 texture = texture2D( map, vUV );\\ntexture.a *= opacity * visibility;\\ngl_FragColor = texture;\\ngl_FragColor.rgb *= color;\\n}\\n}\"}};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "three.min.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-three",
      "url": "/js/three.min.js",
      "urls": [
        "/js/three.min.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/effects/AnaglyphEffect.js",
      "relativePath": "js/effects/AnaglyphEffect.js",
      "basename": "AnaglyphEffect",
      "outBasename": "AnaglyphEffect",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "AnaglyphEffect.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/effects",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/effects/AnaglyphEffect.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/effects",
      "outFilename": "AnaglyphEffect.js",
      "relativeOutPath": "js/effects/AnaglyphEffect.js",
      "relativeDirPath": "js/effects",
      "relativeOutDirPath": "js/effects",
      "relativeBase": "js/effects/AnaglyphEffect",
      "relativeOutBase": "js/effects/AnaglyphEffect",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.555Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author mrdoob / http://mrdoob.com/\n * @author marklundin / http://mark-lundin.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.AnaglyphEffect = function ( renderer, width, height ) {\n\n\tvar eyeRight = new THREE.Matrix4();\n\tvar eyeLeft = new THREE.Matrix4();\n\tvar focalLength = 125;\n\tvar _aspect, _near, _far, _fov;\n\n\tvar _cameraL = new THREE.PerspectiveCamera();\n\t_cameraL.matrixAutoUpdate = false;\n\n\tvar _cameraR = new THREE.PerspectiveCamera();\n\t_cameraR.matrixAutoUpdate = false;\n\n\tvar _camera = new THREE.OrthographicCamera( -1, 1, 1, - 1, 0, 1 );\n\n\tvar _scene = new THREE.Scene();\n\n\tvar _params = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\n\n\tif ( width === undefined ) width = 512;\n\tif ( height === undefined ) height = 512;\n\n\tvar _renderTargetL = new THREE.WebGLRenderTarget( width, height, _params );\n\tvar _renderTargetR = new THREE.WebGLRenderTarget( width, height, _params );\n\n\tvar _material = new THREE.ShaderMaterial( {\n\n\t\tuniforms: {\n\n\t\t\t\"mapLeft\": { type: \"t\", value: _renderTargetL },\n\t\t\t\"mapRight\": { type: \"t\", value: _renderTargetR }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = vec2( uv.x, uv.y );\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D mapLeft;\",\n\t\t\t\"uniform sampler2D mapRight;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 colorL, colorR;\",\n\t\t\t\"\tvec2 uv = vUv;\",\n\n\t\t\t\"\tcolorL = texture2D( mapLeft, uv );\",\n\t\t\t\"\tcolorR = texture2D( mapRight, uv );\",\n\n\t\t\t\t// http://3dtv.at/Knowhow/AnaglyphComparison_en.aspx\n\n\t\t\t\"\tgl_FragColor = vec4( colorL.g * 0.7 + colorL.b * 0.3, colorR.g, colorR.b, colorL.a + colorR.a ) * 1.1;\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t} );\n\n\tvar mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), _material );\n\t_scene.add( mesh );\n\n\tthis.setSize = function ( width, height ) {\n\n\t\tif ( _renderTargetL ) _renderTargetL.dispose();\n\t\tif ( _renderTargetR ) _renderTargetR.dispose();\n\t\t_renderTargetL = new THREE.WebGLRenderTarget( width, height, _params );\n\t\t_renderTargetR = new THREE.WebGLRenderTarget( width, height, _params );\n\n\t\t_material.uniforms[ \"mapLeft\" ].value = _renderTargetL;\n\t\t_material.uniforms[ \"mapRight\" ].value = _renderTargetR;\n\n\t\trenderer.setSize( width, height );\n\n\t};\n\n\t/*\n\t * Renderer now uses an asymmetric perspective projection\n\t * (http://paulbourke.net/miscellaneous/stereographics/stereorender/).\n\t *\n\t * Each camera is offset by the eye seperation and its projection matrix is\n\t * also skewed asymetrically back to converge on the same projection plane.\n\t * Added a focal length parameter to, this is where the parallax is equal to 0.\n\t */\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tscene.updateMatrixWorld();\n\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\n\t\tvar hasCameraChanged = ( _aspect !== camera.aspect ) || ( _near !== camera.near ) || ( _far !== camera.far ) || ( _fov !== camera.fov );\n\n\t\tif ( hasCameraChanged ) {\n\n\t\t\t_aspect = camera.aspect;\n\t\t\t_near = camera.near;\n\t\t\t_far = camera.far;\n\t\t\t_fov = camera.fov;\n\n\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\tvar eyeSep = focalLength / 30 * 0.5;\n\t\t\tvar eyeSepOnProjection = eyeSep * _near / focalLength;\n\t\t\tvar ymax = _near * Math.tan( THREE.Math.degToRad( _fov * 0.5 ) );\n\t\t\tvar xmin, xmax;\n\n\t\t\t// translate xOffset\n\n\t\t\teyeRight.elements[12] = eyeSep;\n\t\t\teyeLeft.elements[12] = -eyeSep;\n\n\t\t\t// for left eye\n\n\t\t\txmin = -ymax * _aspect + eyeSepOnProjection;\n\t\t\txmax = ymax * _aspect + eyeSepOnProjection;\n\n\t\t\tprojectionMatrix.elements[0] = 2 * _near / ( xmax - xmin );\n\t\t\tprojectionMatrix.elements[8] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t_cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t// for right eye\n\n\t\t\txmin = -ymax * _aspect - eyeSepOnProjection;\n\t\t\txmax = ymax * _aspect - eyeSepOnProjection;\n\n\t\t\tprojectionMatrix.elements[0] = 2 * _near / ( xmax - xmin );\n\t\t\tprojectionMatrix.elements[8] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t_cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t}\n\n\t\t_cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t_cameraL.position.copy( camera.position );\n\t\t_cameraL.near = camera.near;\n\t\t_cameraL.far = camera.far;\n\n\t\trenderer.render( scene, _cameraL, _renderTargetL, true );\n\n\t\t_cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\t\t_cameraR.position.copy( camera.position );\n\t\t_cameraR.near = camera.near;\n\t\t_cameraR.far = camera.far;\n\n\t\trenderer.render( scene, _cameraR, _renderTargetR, true );\n\n\t\trenderer.render( _scene, _camera );\n\n\t};\n\n\tthis.dispose = function() {\n\t\tif ( _renderTargetL ) _renderTargetL.dispose();\n\t\tif ( _renderTargetR ) _renderTargetR.dispose();\n\t}\n\n};\n",
      "content": "/**\n * @author mrdoob / http://mrdoob.com/\n * @author marklundin / http://mark-lundin.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.AnaglyphEffect = function ( renderer, width, height ) {\n\n\tvar eyeRight = new THREE.Matrix4();\n\tvar eyeLeft = new THREE.Matrix4();\n\tvar focalLength = 125;\n\tvar _aspect, _near, _far, _fov;\n\n\tvar _cameraL = new THREE.PerspectiveCamera();\n\t_cameraL.matrixAutoUpdate = false;\n\n\tvar _cameraR = new THREE.PerspectiveCamera();\n\t_cameraR.matrixAutoUpdate = false;\n\n\tvar _camera = new THREE.OrthographicCamera( -1, 1, 1, - 1, 0, 1 );\n\n\tvar _scene = new THREE.Scene();\n\n\tvar _params = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\n\n\tif ( width === undefined ) width = 512;\n\tif ( height === undefined ) height = 512;\n\n\tvar _renderTargetL = new THREE.WebGLRenderTarget( width, height, _params );\n\tvar _renderTargetR = new THREE.WebGLRenderTarget( width, height, _params );\n\n\tvar _material = new THREE.ShaderMaterial( {\n\n\t\tuniforms: {\n\n\t\t\t\"mapLeft\": { type: \"t\", value: _renderTargetL },\n\t\t\t\"mapRight\": { type: \"t\", value: _renderTargetR }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = vec2( uv.x, uv.y );\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D mapLeft;\",\n\t\t\t\"uniform sampler2D mapRight;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec4 colorL, colorR;\",\n\t\t\t\"\tvec2 uv = vUv;\",\n\n\t\t\t\"\tcolorL = texture2D( mapLeft, uv );\",\n\t\t\t\"\tcolorR = texture2D( mapRight, uv );\",\n\n\t\t\t\t// http://3dtv.at/Knowhow/AnaglyphComparison_en.aspx\n\n\t\t\t\"\tgl_FragColor = vec4( colorL.g * 0.7 + colorL.b * 0.3, colorR.g, colorR.b, colorL.a + colorR.a ) * 1.1;\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t} );\n\n\tvar mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), _material );\n\t_scene.add( mesh );\n\n\tthis.setSize = function ( width, height ) {\n\n\t\tif ( _renderTargetL ) _renderTargetL.dispose();\n\t\tif ( _renderTargetR ) _renderTargetR.dispose();\n\t\t_renderTargetL = new THREE.WebGLRenderTarget( width, height, _params );\n\t\t_renderTargetR = new THREE.WebGLRenderTarget( width, height, _params );\n\n\t\t_material.uniforms[ \"mapLeft\" ].value = _renderTargetL;\n\t\t_material.uniforms[ \"mapRight\" ].value = _renderTargetR;\n\n\t\trenderer.setSize( width, height );\n\n\t};\n\n\t/*\n\t * Renderer now uses an asymmetric perspective projection\n\t * (http://paulbourke.net/miscellaneous/stereographics/stereorender/).\n\t *\n\t * Each camera is offset by the eye seperation and its projection matrix is\n\t * also skewed asymetrically back to converge on the same projection plane.\n\t * Added a focal length parameter to, this is where the parallax is equal to 0.\n\t */\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tscene.updateMatrixWorld();\n\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\n\t\tvar hasCameraChanged = ( _aspect !== camera.aspect ) || ( _near !== camera.near ) || ( _far !== camera.far ) || ( _fov !== camera.fov );\n\n\t\tif ( hasCameraChanged ) {\n\n\t\t\t_aspect = camera.aspect;\n\t\t\t_near = camera.near;\n\t\t\t_far = camera.far;\n\t\t\t_fov = camera.fov;\n\n\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\tvar eyeSep = focalLength / 30 * 0.5;\n\t\t\tvar eyeSepOnProjection = eyeSep * _near / focalLength;\n\t\t\tvar ymax = _near * Math.tan( THREE.Math.degToRad( _fov * 0.5 ) );\n\t\t\tvar xmin, xmax;\n\n\t\t\t// translate xOffset\n\n\t\t\teyeRight.elements[12] = eyeSep;\n\t\t\teyeLeft.elements[12] = -eyeSep;\n\n\t\t\t// for left eye\n\n\t\t\txmin = -ymax * _aspect + eyeSepOnProjection;\n\t\t\txmax = ymax * _aspect + eyeSepOnProjection;\n\n\t\t\tprojectionMatrix.elements[0] = 2 * _near / ( xmax - xmin );\n\t\t\tprojectionMatrix.elements[8] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t_cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t// for right eye\n\n\t\t\txmin = -ymax * _aspect - eyeSepOnProjection;\n\t\t\txmax = ymax * _aspect - eyeSepOnProjection;\n\n\t\t\tprojectionMatrix.elements[0] = 2 * _near / ( xmax - xmin );\n\t\t\tprojectionMatrix.elements[8] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t_cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t}\n\n\t\t_cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t_cameraL.position.copy( camera.position );\n\t\t_cameraL.near = camera.near;\n\t\t_cameraL.far = camera.far;\n\n\t\trenderer.render( scene, _cameraL, _renderTargetL, true );\n\n\t\t_cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\t\t_cameraR.position.copy( camera.position );\n\t\t_cameraR.near = camera.near;\n\t\t_cameraR.far = camera.far;\n\n\t\trenderer.render( scene, _cameraR, _renderTargetR, true );\n\n\t\trenderer.render( _scene, _camera );\n\n\t};\n\n\tthis.dispose = function() {\n\t\tif ( _renderTargetL ) _renderTargetL.dispose();\n\t\tif ( _renderTargetR ) _renderTargetR.dispose();\n\t}\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "AnaglyphEffect.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-effects-AnaglyphEffect",
      "url": "/js/effects/AnaglyphEffect.js",
      "urls": [
        "/js/effects/AnaglyphEffect.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/effects/AsciiEffect.js",
      "relativePath": "js/effects/AsciiEffect.js",
      "basename": "AsciiEffect",
      "outBasename": "AsciiEffect",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "AsciiEffect.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/effects",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/effects/AsciiEffect.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/effects",
      "outFilename": "AsciiEffect.js",
      "relativeOutPath": "js/effects/AsciiEffect.js",
      "relativeDirPath": "js/effects",
      "relativeOutDirPath": "js/effects",
      "relativeBase": "js/effects/AsciiEffect",
      "relativeOutBase": "js/effects/AsciiEffect",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.561Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/*\n * @author zz85 / https://github.com/zz85\n *\n * Ascii generation is based on http://www.nihilogic.dk/labs/jsascii/\n * Maybe more about this later with a blog post at http://lab4games.net/zz85/blog\n *\n * 16 April 2012 - @blurspline\n */\n\nTHREE.AsciiEffect = function ( renderer, charSet, options ) {\n\n\t// its fun to create one your own!\n\n\tcharSet = ( charSet === undefined ) ? ' .:-=+*#%@' : charSet;\n\n\t// ' .,:;=|iI+hHOE#`$';\n\t// darker bolder character set from https://github.com/saw/Canvas-ASCII-Art/\n\t// ' .\\'`^\",:;Il!i~+_-?][}{1)(|/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$'.split('');\n\n\tif ( !options ) options = {};\n\n\t// Some ASCII settings\n\n\tvar bResolution = !options['resolution'] ? 0.15 : options['resolution']; // Higher for more details\n\tvar iScale = !options['scale'] ? 1 : options['scale'];\n\tvar bColor = !options['color'] ? false : options['color']; // nice but slows down rendering!\n\tvar bAlpha = !options['alpha'] ? false : options['alpha']; // Transparency\n\tvar bBlock = !options['block'] ? false : options['block']; // blocked characters. like good O dos\n\tvar bInvert = !options['invert'] ? false : options['invert']; // black is white, white is black\n\n\tvar strResolution = 'low';\n\n\tvar width, height;\n\n\tvar domElement = document.createElement('div');\n\tdomElement.style.cursor = 'default';\n\n\tvar oAscii = document.createElement(\"table\");\n\tdomElement.appendChild( oAscii );\n\n\tvar iWidth, iHeight;\n\tvar oImg;\n\n\tthis.setSize = function ( w, h ) {\n\n\t\twidth = w;\n\t\theight = h;\n\n\t\trenderer.setSize( w, h );\n\n\t\tinitAsciiSize();\n\n\t};\n\n\n\tthis.render = function ( scene, camera ) {\n\n\t\trenderer.render( scene, camera );\n\t\tasciifyImage( renderer, oAscii );\n\n\t};\n\n\tthis.domElement = domElement;\n\n\n\t// Throw in ascii library from http://www.nihilogic.dk/labs/jsascii/jsascii.js\n\n\t/*\n\t* jsAscii 0.1\n\t* Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/\n\t* MIT License [http://www.nihilogic.dk/licenses/mit-license.txt]\n\t*/\n\n\tfunction initAsciiSize() {\n\n\t\tiWidth = Math.round( width * fResolution );\n\t\tiHeight = Math.round( height * fResolution );\n\n\t\toCanvas.width = iWidth;\n\t\toCanvas.height = iHeight;\n\t\t// oCanvas.style.display = \"none\";\n\t\t// oCanvas.style.width = iWidth;\n\t\t// oCanvas.style.height = iHeight;\n\n\t\toImg = renderer.domElement;\n\n\t\tif ( oImg.style.backgroundColor ) {\n\n\t\t\toAscii.rows[0].cells[0].style.backgroundColor = oImg.style.backgroundColor;\n\t\t\toAscii.rows[0].cells[0].style.color = oImg.style.color;\n\n\t\t}\n\n\t\toAscii.cellSpacing = 0;\n\t\toAscii.cellPadding = 0;\n\n\t\tvar oStyle = oAscii.style;\n\t\toStyle.display = \"inline\";\n\t\toStyle.width = Math.round(iWidth/fResolution*iScale) + \"px\";\n\t\toStyle.height = Math.round(iHeight/fResolution*iScale) + \"px\";\n\t\toStyle.whiteSpace = \"pre\";\n\t\toStyle.margin = \"0px\";\n\t\toStyle.padding = \"0px\";\n\t\toStyle.letterSpacing = fLetterSpacing + \"px\";\n\t\toStyle.fontFamily = strFont;\n\t\toStyle.fontSize = fFontSize + \"px\";\n\t\toStyle.lineHeight = fLineHeight + \"px\";\n\t\toStyle.textAlign = \"left\";\n\t\toStyle.textDecoration = \"none\";\n\t}\n\n\n\tvar aDefaultCharList = (\" .,:;i1tfLCG08@\").split(\"\");\n\tvar aDefaultColorCharList = (\" CGO08@\").split(\"\");\n\tvar strFont = \"courier new, monospace\";\n\n\tvar oCanvasImg = renderer.domElement;\n\n\tvar oCanvas = document.createElement(\"canvas\");\n\tif (!oCanvas.getContext) {\n\t\treturn;\n\t}\n\n\tvar oCtx = oCanvas.getContext(\"2d\");\n\tif (!oCtx.getImageData) {\n\t\treturn;\n\t}\n\n\tvar aCharList = (bColor ? aDefaultColorCharList : aDefaultCharList);\n\n\tif (charSet) aCharList = charSet;\n\n\tvar fResolution = 0.5;\n\n\tswitch ( strResolution ) {\n\n\t\tcase \"low\" : \tfResolution = 0.25; break;\n\t\tcase \"medium\" : fResolution = 0.5; break;\n\t\tcase \"high\" : \tfResolution = 1; break;\n\n\t}\n\n\tif ( bResolution ) fResolution = bResolution;\n\n\t// Setup dom\n\n\tvar fFontSize = (2/fResolution)*iScale;\n\tvar fLineHeight = (2/fResolution)*iScale;\n\n\t// adjust letter-spacing for all combinations of scale and resolution to get it to fit the image width.\n\n\tvar fLetterSpacing = 0;\n\n\tif ( strResolution == \"low\" ) {\n\n\t\tswitch (iScale) {\n\t\t\tcase 1 : fLetterSpacing = -1; break;\n\t\t\tcase 2 :\n\t\t\tcase 3 : fLetterSpacing = -2.1; break;\n\t\t\tcase 4 : fLetterSpacing = -3.1; break;\n\t\t\tcase 5 : fLetterSpacing = -4.15; break;\n\t\t}\n\n\t}\n\n\tif ( strResolution == \"medium\" ) {\n\n\t\tswitch (iScale) {\n\t\t\tcase 1 : fLetterSpacing = 0; break;\n\t\t\tcase 2 : fLetterSpacing = -1; break;\n\t\t\tcase 3 : fLetterSpacing = -1.04; break;\n\t\t\tcase 4 :\n\t\t\tcase 5 : fLetterSpacing = -2.1; break;\n\t\t}\n\n\t}\n\n\tif ( strResolution == \"high\" ) {\n\n\t\tswitch (iScale) {\n\t\t\tcase 1 :\n\t\t\tcase 2 : fLetterSpacing = 0; break;\n\t\t\tcase 3 :\n\t\t\tcase 4 :\n\t\t\tcase 5 : fLetterSpacing = -1; break;\n\t\t}\n\n\t}\n\n\n\t// can't get a span or div to flow like an img element, but a table works?\n\n\n\t// convert img element to ascii\n\n\tfunction asciifyImage( canvasRenderer, oAscii ) {\n\n\t\toCtx.clearRect( 0, 0, iWidth, iHeight );\n\t\toCtx.drawImage( oCanvasImg, 0, 0, iWidth, iHeight );\n\t\tvar oImgData = oCtx.getImageData(0, 0, iWidth, iHeight).data;\n\n\t\t// Coloring loop starts now\n\t\tvar strChars = \"\";\n\n\t\t// console.time('rendering');\n\n\t\tfor (var y=0;y<iHeight;y+=2) {\n\t\t\tfor (var x=0;x<iWidth;x++) {\n\t\t\t\tvar iOffset = (y*iWidth + x) * 4;\n\n\t\t\t\tvar iRed = oImgData[iOffset];\n\t\t\t\tvar iGreen = oImgData[iOffset + 1];\n\t\t\t\tvar iBlue = oImgData[iOffset + 2];\n\t\t\t\tvar iAlpha = oImgData[iOffset + 3];\n\t\t\t\tvar iCharIdx;\n\n\t\t\t\tvar fBrightness;\n\n\t\t\t\tfBrightness = (0.3*iRed + 0.59*iGreen + 0.11*iBlue) / 255;\n\t\t\t\t// fBrightness = (0.3*iRed + 0.5*iGreen + 0.3*iBlue) / 255;\n\n\t\t\t\tif (iAlpha == 0) {\n\t\t\t\t\t// should calculate alpha instead, but quick hack :)\n\t\t\t\t\t//fBrightness *= (iAlpha / 255);\n\t\t\t\t\tfBrightness = 1;\n\n\t\t\t\t}\n\n\t\t\t\tiCharIdx = Math.floor((1-fBrightness) * (aCharList.length-1));\n\n\t\t\t\tif (bInvert) {\n\t\t\t\t\tiCharIdx = aCharList.length - iCharIdx - 1;\n\t\t\t\t}\n\n\t\t\t\t// good for debugging\n\t\t\t\t//fBrightness = Math.floor(fBrightness * 10);\n\t\t\t\t//strThisChar = fBrightness;\n\n\t\t\t\tvar strThisChar = aCharList[iCharIdx];\n\n\t\t\t\tif (strThisChar===undefined || strThisChar == \" \")\n\t\t\t\t\tstrThisChar = \"&nbsp;\";\n\n\t\t\t\tif (bColor) {\n\t\t\t\t\tstrChars += \"<span style='\"\n\t\t\t\t\t\t+ \"color:rgb(\"+iRed+\",\"+iGreen+\",\"+iBlue+\");\"\n\t\t\t\t\t\t+ (bBlock ? \"background-color:rgb(\"+iRed+\",\"+iGreen+\",\"+iBlue+\");\" : \"\")\n\t\t\t\t\t\t+ (bAlpha ? \"opacity:\" + (iAlpha/255) + \";\" : \"\")\n\t\t\t\t\t\t+ \"'>\" + strThisChar + \"</span>\";\n\t\t\t\t} else {\n\t\t\t\t\tstrChars += strThisChar;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrChars += \"<br/>\";\n\t\t}\n\n\t\toAscii.innerHTML = \"<tr><td>\" + strChars + \"</td></tr>\";\n\n\t\t// console.timeEnd('rendering');\n\n\t\t// return oAscii;\n\t}\n\n\t// end modified asciifyImage block\n\n};\n",
      "content": "/*\n * @author zz85 / https://github.com/zz85\n *\n * Ascii generation is based on http://www.nihilogic.dk/labs/jsascii/\n * Maybe more about this later with a blog post at http://lab4games.net/zz85/blog\n *\n * 16 April 2012 - @blurspline\n */\n\nTHREE.AsciiEffect = function ( renderer, charSet, options ) {\n\n\t// its fun to create one your own!\n\n\tcharSet = ( charSet === undefined ) ? ' .:-=+*#%@' : charSet;\n\n\t// ' .,:;=|iI+hHOE#`$';\n\t// darker bolder character set from https://github.com/saw/Canvas-ASCII-Art/\n\t// ' .\\'`^\",:;Il!i~+_-?][}{1)(|/tfjrxnuvczXYUJCLQ0OZmwqpdbkhao*#MW&8%B@$'.split('');\n\n\tif ( !options ) options = {};\n\n\t// Some ASCII settings\n\n\tvar bResolution = !options['resolution'] ? 0.15 : options['resolution']; // Higher for more details\n\tvar iScale = !options['scale'] ? 1 : options['scale'];\n\tvar bColor = !options['color'] ? false : options['color']; // nice but slows down rendering!\n\tvar bAlpha = !options['alpha'] ? false : options['alpha']; // Transparency\n\tvar bBlock = !options['block'] ? false : options['block']; // blocked characters. like good O dos\n\tvar bInvert = !options['invert'] ? false : options['invert']; // black is white, white is black\n\n\tvar strResolution = 'low';\n\n\tvar width, height;\n\n\tvar domElement = document.createElement('div');\n\tdomElement.style.cursor = 'default';\n\n\tvar oAscii = document.createElement(\"table\");\n\tdomElement.appendChild( oAscii );\n\n\tvar iWidth, iHeight;\n\tvar oImg;\n\n\tthis.setSize = function ( w, h ) {\n\n\t\twidth = w;\n\t\theight = h;\n\n\t\trenderer.setSize( w, h );\n\n\t\tinitAsciiSize();\n\n\t};\n\n\n\tthis.render = function ( scene, camera ) {\n\n\t\trenderer.render( scene, camera );\n\t\tasciifyImage( renderer, oAscii );\n\n\t};\n\n\tthis.domElement = domElement;\n\n\n\t// Throw in ascii library from http://www.nihilogic.dk/labs/jsascii/jsascii.js\n\n\t/*\n\t* jsAscii 0.1\n\t* Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/\n\t* MIT License [http://www.nihilogic.dk/licenses/mit-license.txt]\n\t*/\n\n\tfunction initAsciiSize() {\n\n\t\tiWidth = Math.round( width * fResolution );\n\t\tiHeight = Math.round( height * fResolution );\n\n\t\toCanvas.width = iWidth;\n\t\toCanvas.height = iHeight;\n\t\t// oCanvas.style.display = \"none\";\n\t\t// oCanvas.style.width = iWidth;\n\t\t// oCanvas.style.height = iHeight;\n\n\t\toImg = renderer.domElement;\n\n\t\tif ( oImg.style.backgroundColor ) {\n\n\t\t\toAscii.rows[0].cells[0].style.backgroundColor = oImg.style.backgroundColor;\n\t\t\toAscii.rows[0].cells[0].style.color = oImg.style.color;\n\n\t\t}\n\n\t\toAscii.cellSpacing = 0;\n\t\toAscii.cellPadding = 0;\n\n\t\tvar oStyle = oAscii.style;\n\t\toStyle.display = \"inline\";\n\t\toStyle.width = Math.round(iWidth/fResolution*iScale) + \"px\";\n\t\toStyle.height = Math.round(iHeight/fResolution*iScale) + \"px\";\n\t\toStyle.whiteSpace = \"pre\";\n\t\toStyle.margin = \"0px\";\n\t\toStyle.padding = \"0px\";\n\t\toStyle.letterSpacing = fLetterSpacing + \"px\";\n\t\toStyle.fontFamily = strFont;\n\t\toStyle.fontSize = fFontSize + \"px\";\n\t\toStyle.lineHeight = fLineHeight + \"px\";\n\t\toStyle.textAlign = \"left\";\n\t\toStyle.textDecoration = \"none\";\n\t}\n\n\n\tvar aDefaultCharList = (\" .,:;i1tfLCG08@\").split(\"\");\n\tvar aDefaultColorCharList = (\" CGO08@\").split(\"\");\n\tvar strFont = \"courier new, monospace\";\n\n\tvar oCanvasImg = renderer.domElement;\n\n\tvar oCanvas = document.createElement(\"canvas\");\n\tif (!oCanvas.getContext) {\n\t\treturn;\n\t}\n\n\tvar oCtx = oCanvas.getContext(\"2d\");\n\tif (!oCtx.getImageData) {\n\t\treturn;\n\t}\n\n\tvar aCharList = (bColor ? aDefaultColorCharList : aDefaultCharList);\n\n\tif (charSet) aCharList = charSet;\n\n\tvar fResolution = 0.5;\n\n\tswitch ( strResolution ) {\n\n\t\tcase \"low\" : \tfResolution = 0.25; break;\n\t\tcase \"medium\" : fResolution = 0.5; break;\n\t\tcase \"high\" : \tfResolution = 1; break;\n\n\t}\n\n\tif ( bResolution ) fResolution = bResolution;\n\n\t// Setup dom\n\n\tvar fFontSize = (2/fResolution)*iScale;\n\tvar fLineHeight = (2/fResolution)*iScale;\n\n\t// adjust letter-spacing for all combinations of scale and resolution to get it to fit the image width.\n\n\tvar fLetterSpacing = 0;\n\n\tif ( strResolution == \"low\" ) {\n\n\t\tswitch (iScale) {\n\t\t\tcase 1 : fLetterSpacing = -1; break;\n\t\t\tcase 2 :\n\t\t\tcase 3 : fLetterSpacing = -2.1; break;\n\t\t\tcase 4 : fLetterSpacing = -3.1; break;\n\t\t\tcase 5 : fLetterSpacing = -4.15; break;\n\t\t}\n\n\t}\n\n\tif ( strResolution == \"medium\" ) {\n\n\t\tswitch (iScale) {\n\t\t\tcase 1 : fLetterSpacing = 0; break;\n\t\t\tcase 2 : fLetterSpacing = -1; break;\n\t\t\tcase 3 : fLetterSpacing = -1.04; break;\n\t\t\tcase 4 :\n\t\t\tcase 5 : fLetterSpacing = -2.1; break;\n\t\t}\n\n\t}\n\n\tif ( strResolution == \"high\" ) {\n\n\t\tswitch (iScale) {\n\t\t\tcase 1 :\n\t\t\tcase 2 : fLetterSpacing = 0; break;\n\t\t\tcase 3 :\n\t\t\tcase 4 :\n\t\t\tcase 5 : fLetterSpacing = -1; break;\n\t\t}\n\n\t}\n\n\n\t// can't get a span or div to flow like an img element, but a table works?\n\n\n\t// convert img element to ascii\n\n\tfunction asciifyImage( canvasRenderer, oAscii ) {\n\n\t\toCtx.clearRect( 0, 0, iWidth, iHeight );\n\t\toCtx.drawImage( oCanvasImg, 0, 0, iWidth, iHeight );\n\t\tvar oImgData = oCtx.getImageData(0, 0, iWidth, iHeight).data;\n\n\t\t// Coloring loop starts now\n\t\tvar strChars = \"\";\n\n\t\t// console.time('rendering');\n\n\t\tfor (var y=0;y<iHeight;y+=2) {\n\t\t\tfor (var x=0;x<iWidth;x++) {\n\t\t\t\tvar iOffset = (y*iWidth + x) * 4;\n\n\t\t\t\tvar iRed = oImgData[iOffset];\n\t\t\t\tvar iGreen = oImgData[iOffset + 1];\n\t\t\t\tvar iBlue = oImgData[iOffset + 2];\n\t\t\t\tvar iAlpha = oImgData[iOffset + 3];\n\t\t\t\tvar iCharIdx;\n\n\t\t\t\tvar fBrightness;\n\n\t\t\t\tfBrightness = (0.3*iRed + 0.59*iGreen + 0.11*iBlue) / 255;\n\t\t\t\t// fBrightness = (0.3*iRed + 0.5*iGreen + 0.3*iBlue) / 255;\n\n\t\t\t\tif (iAlpha == 0) {\n\t\t\t\t\t// should calculate alpha instead, but quick hack :)\n\t\t\t\t\t//fBrightness *= (iAlpha / 255);\n\t\t\t\t\tfBrightness = 1;\n\n\t\t\t\t}\n\n\t\t\t\tiCharIdx = Math.floor((1-fBrightness) * (aCharList.length-1));\n\n\t\t\t\tif (bInvert) {\n\t\t\t\t\tiCharIdx = aCharList.length - iCharIdx - 1;\n\t\t\t\t}\n\n\t\t\t\t// good for debugging\n\t\t\t\t//fBrightness = Math.floor(fBrightness * 10);\n\t\t\t\t//strThisChar = fBrightness;\n\n\t\t\t\tvar strThisChar = aCharList[iCharIdx];\n\n\t\t\t\tif (strThisChar===undefined || strThisChar == \" \")\n\t\t\t\t\tstrThisChar = \"&nbsp;\";\n\n\t\t\t\tif (bColor) {\n\t\t\t\t\tstrChars += \"<span style='\"\n\t\t\t\t\t\t+ \"color:rgb(\"+iRed+\",\"+iGreen+\",\"+iBlue+\");\"\n\t\t\t\t\t\t+ (bBlock ? \"background-color:rgb(\"+iRed+\",\"+iGreen+\",\"+iBlue+\");\" : \"\")\n\t\t\t\t\t\t+ (bAlpha ? \"opacity:\" + (iAlpha/255) + \";\" : \"\")\n\t\t\t\t\t\t+ \"'>\" + strThisChar + \"</span>\";\n\t\t\t\t} else {\n\t\t\t\t\tstrChars += strThisChar;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstrChars += \"<br/>\";\n\t\t}\n\n\t\toAscii.innerHTML = \"<tr><td>\" + strChars + \"</td></tr>\";\n\n\t\t// console.timeEnd('rendering');\n\n\t\t// return oAscii;\n\t}\n\n\t// end modified asciifyImage block\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "AsciiEffect.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-effects-AsciiEffect",
      "url": "/js/effects/AsciiEffect.js",
      "urls": [
        "/js/effects/AsciiEffect.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/effects/CrosseyedEffect.js",
      "relativePath": "js/effects/CrosseyedEffect.js",
      "basename": "CrosseyedEffect",
      "outBasename": "CrosseyedEffect",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "CrosseyedEffect.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/effects",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/effects/CrosseyedEffect.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/effects",
      "outFilename": "CrosseyedEffect.js",
      "relativeOutPath": "js/effects/CrosseyedEffect.js",
      "relativeDirPath": "js/effects",
      "relativeOutDirPath": "js/effects",
      "relativeBase": "js/effects/CrosseyedEffect",
      "relativeOutBase": "js/effects/CrosseyedEffect",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.565Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CrosseyedEffect = function ( renderer ) {\n\n\t// API\n\n\tthis.separation = 10;\n\n\t// internals\n\n\tvar _width, _height;\n\n\tvar _cameraL = new THREE.PerspectiveCamera();\n\t_cameraL.target = new THREE.Vector3();\n\n\tvar _cameraR = new THREE.PerspectiveCamera();\n\t_cameraR.target = new THREE.Vector3();\n\n\t// initialization\n\n\trenderer.autoClear = false;\n\n\tthis.setSize = function ( width, height ) {\n\n\t\t_width = width / 2;\n\t\t_height = height;\n\n\t\trenderer.setSize( width, height );\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\t// left\n\n\t\t_cameraL.fov = camera.fov;\n\t\t_cameraL.aspect = 0.5 * camera.aspect;\n\t\t_cameraL.near = camera.near;\n\t\t_cameraL.far = camera.far;\n\t\t_cameraL.updateProjectionMatrix();\n\n\t\t_cameraL.position.copy( camera.position );\n\t\t_cameraL.target.copy( camera.target );\n\t\t_cameraL.translateX( this.separation );\n\t\t_cameraL.lookAt( _cameraL.target );\n\n\t\t// right\n\n\t\t_cameraR.near = camera.near;\n\t\t_cameraR.far = camera.far;\n\n\t\t_cameraR.projectionMatrix = _cameraL.projectionMatrix;\n\n\t\t_cameraR.position.copy( camera.position );\n\t\t_cameraR.target.copy( camera.target );\n\t\t_cameraR.translateX( - this.separation );\n\t\t_cameraR.lookAt( _cameraR.target );\n\n\t\t//\n\n\t\trenderer.clear();\n\n\t\trenderer.setViewport( 0, 0, _width, _height );\n\t\trenderer.render( scene, _cameraL );\n\n\t\trenderer.setViewport( _width, 0, _width, _height );\n\t\trenderer.render( scene, _cameraR, false );\n\n\t};\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.CrosseyedEffect = function ( renderer ) {\n\n\t// API\n\n\tthis.separation = 10;\n\n\t// internals\n\n\tvar _width, _height;\n\n\tvar _cameraL = new THREE.PerspectiveCamera();\n\t_cameraL.target = new THREE.Vector3();\n\n\tvar _cameraR = new THREE.PerspectiveCamera();\n\t_cameraR.target = new THREE.Vector3();\n\n\t// initialization\n\n\trenderer.autoClear = false;\n\n\tthis.setSize = function ( width, height ) {\n\n\t\t_width = width / 2;\n\t\t_height = height;\n\n\t\trenderer.setSize( width, height );\n\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\n\t\t// left\n\n\t\t_cameraL.fov = camera.fov;\n\t\t_cameraL.aspect = 0.5 * camera.aspect;\n\t\t_cameraL.near = camera.near;\n\t\t_cameraL.far = camera.far;\n\t\t_cameraL.updateProjectionMatrix();\n\n\t\t_cameraL.position.copy( camera.position );\n\t\t_cameraL.target.copy( camera.target );\n\t\t_cameraL.translateX( this.separation );\n\t\t_cameraL.lookAt( _cameraL.target );\n\n\t\t// right\n\n\t\t_cameraR.near = camera.near;\n\t\t_cameraR.far = camera.far;\n\n\t\t_cameraR.projectionMatrix = _cameraL.projectionMatrix;\n\n\t\t_cameraR.position.copy( camera.position );\n\t\t_cameraR.target.copy( camera.target );\n\t\t_cameraR.translateX( - this.separation );\n\t\t_cameraR.lookAt( _cameraR.target );\n\n\t\t//\n\n\t\trenderer.clear();\n\n\t\trenderer.setViewport( 0, 0, _width, _height );\n\t\trenderer.render( scene, _cameraL );\n\n\t\trenderer.setViewport( _width, 0, _width, _height );\n\t\trenderer.render( scene, _cameraR, false );\n\n\t};\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "CrosseyedEffect.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-effects-CrosseyedEffect",
      "url": "/js/effects/CrosseyedEffect.js",
      "urls": [
        "/js/effects/CrosseyedEffect.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/effects/OculusRiftEffect.js",
      "relativePath": "js/effects/OculusRiftEffect.js",
      "basename": "OculusRiftEffect",
      "outBasename": "OculusRiftEffect",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "OculusRiftEffect.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/effects",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/effects/OculusRiftEffect.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/effects",
      "outFilename": "OculusRiftEffect.js",
      "relativeOutPath": "js/effects/OculusRiftEffect.js",
      "relativeDirPath": "js/effects",
      "relativeOutDirPath": "js/effects",
      "relativeBase": "js/effects/OculusRiftEffect",
      "relativeOutBase": "js/effects/OculusRiftEffect",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.571Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author troffmo5 / http://github.com/troffmo5\n *\n * Effect to render the scene in stereo 3d side by side with lens distortion.\n * It is written to be used with the Oculus Rift (http://www.oculusvr.com/) but\n * it works also with other HMD using the same technology\n */\n\nTHREE.OculusRiftEffect = function ( renderer, options ) {\n\t// worldFactor indicates how many units is 1 meter\n\tvar worldFactor = (options && options.worldFactor) ? options.worldFactor: 1.0;\n\n\t// Specific HMD parameters\n\tvar HMD = (options && options.HMD) ? options.HMD: {\n\t\t// Parameters from the Oculus Rift DK1\n\t\thResolution: 1280,\n\t\tvResolution: 800,\n\t\thScreenSize: 0.14976,\n\t\tvScreenSize: 0.0936,\n\t\tinterpupillaryDistance: 0.064,\n\t\tlensSeparationDistance: 0.064,\n\t\teyeToScreenDistance: 0.041,\n\t\tdistortionK : [1.0, 0.22, 0.24, 0.0],\n\t\tchromaAbParameter: [ 0.996, -0.004, 1.014, 0.0]\n\t};\n\n\t// Perspective camera\n\tvar pCamera = new THREE.PerspectiveCamera();\n\tpCamera.matrixAutoUpdate = false;\n\tpCamera.target = new THREE.Vector3();\n\n\t// Orthographic camera\n\tvar oCamera = new THREE.OrthographicCamera( -1, 1, 1, -1, 1, 1000 );\n\toCamera.position.z = 1;\n\n\t// pre-render hooks\n\tthis.preLeftRender = function() {};\n\tthis.preRightRender = function() {};\n\n\trenderer.autoClear = false;\n\tvar emptyColor = new THREE.Color(\"black\");\n\n\t// Render target\n\tvar RTParams = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\n\tvar renderTarget = new THREE.WebGLRenderTarget( 640, 800, RTParams );\n\tvar RTMaterial = new THREE.ShaderMaterial( {\n\t\tuniforms: {\n\t\t\t\"texid\": { type: \"t\", value: renderTarget },\n\t\t\t\"scale\": { type: \"v2\", value: new THREE.Vector2(1.0,1.0) },\n\t\t\t\"scaleIn\": { type: \"v2\", value: new THREE.Vector2(1.0,1.0) },\n\t\t\t\"lensCenter\": { type: \"v2\", value: new THREE.Vector2(0.0,0.0) },\n\t\t\t\"hmdWarpParam\": { type: \"v4\", value: new THREE.Vector4(1.0,0.0,0.0,0.0) },\n\t\t\t\"chromAbParam\": { type: \"v4\", value: new THREE.Vector4(1.0,0.0,0.0,0.0) }\n\t\t},\n\t\tvertexShader: [\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"void main() {\",\n\t\t\t\" vUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\"}\"\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\t\t\t\"uniform vec2 scale;\",\n\t\t\t\"uniform vec2 scaleIn;\",\n\t\t\t\"uniform vec2 lensCenter;\",\n\t\t\t\"uniform vec4 hmdWarpParam;\",\n\t\t\t'uniform vec4 chromAbParam;',\n\t\t\t\"uniform sampler2D texid;\",\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"void main()\",\n\t\t\t\"{\",\n\t\t\t\"  vec2 uv = (vUv*2.0)-1.0;\", // range from [0,1] to [-1,1]\n\t\t\t\"  vec2 theta = (uv-lensCenter)*scaleIn;\",\n\t\t\t\"  float rSq = theta.x*theta.x + theta.y*theta.y;\",\n\t\t\t\"  vec2 rvector = theta*(hmdWarpParam.x + hmdWarpParam.y*rSq + hmdWarpParam.z*rSq*rSq + hmdWarpParam.w*rSq*rSq*rSq);\",\n\t\t\t'  vec2 rBlue = rvector * (chromAbParam.z + chromAbParam.w * rSq);',\n\t\t\t\"  vec2 tcBlue = (lensCenter + scale * rBlue);\",\n\t\t\t\"  tcBlue = (tcBlue+1.0)/2.0;\", // range from [-1,1] to [0,1]\n\t\t\t\"  if (any(bvec2(clamp(tcBlue, vec2(0.0,0.0), vec2(1.0,1.0))-tcBlue))) {\",\n\t\t\t\"    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\",\n\t\t\t\"    return;}\",\n\t\t\t\"  vec2 tcGreen = lensCenter + scale * rvector;\",\n\t\t\t\"  tcGreen = (tcGreen+1.0)/2.0;\", // range from [-1,1] to [0,1]\n\t\t\t\"  vec2 rRed = rvector * (chromAbParam.x + chromAbParam.y * rSq);\",\n\t\t\t\"  vec2 tcRed = lensCenter + scale * rRed;\",\n\t\t\t\"  tcRed = (tcRed+1.0)/2.0;\", // range from [-1,1] to [0,1]\n\t\t\t\"  gl_FragColor = vec4(texture2D(texid, tcRed).r, texture2D(texid, tcGreen).g, texture2D(texid, tcBlue).b, 1);\",\n\t\t\t\"}\"\n\t\t].join(\"\\n\")\n\t} );\n\n\tvar mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), RTMaterial );\n\n\t// Final scene\n\tvar finalScene = new THREE.Scene();\n\tfinalScene.add( oCamera );\n\tfinalScene.add( mesh );\n\n    var left = {}, right = {};\n    var distScale = 1.0;\n\tthis.setHMD = function(v) {\n\t\tHMD = v;\n\t\t// Compute aspect ratio and FOV\n\t\tvar aspect = HMD.hResolution / (2*HMD.vResolution);\n\n\t\t// Fov is normally computed with:\n\t\t//   THREE.Math.radToDeg( 2*Math.atan2(HMD.vScreenSize,2*HMD.eyeToScreenDistance) );\n\t\t// But with lens distortion it is increased (see Oculus SDK Documentation)\n\t\tvar r = -1.0 - (4 * (HMD.hScreenSize/4 - HMD.lensSeparationDistance/2) / HMD.hScreenSize);\n\t\tdistScale = (HMD.distortionK[0] + HMD.distortionK[1] * Math.pow(r,2) + HMD.distortionK[2] * Math.pow(r,4) + HMD.distortionK[3] * Math.pow(r,6));\n\t\tvar fov = THREE.Math.radToDeg(2*Math.atan2(HMD.vScreenSize*distScale, 2*HMD.eyeToScreenDistance));\n\n\t\t// Compute camera projection matrices\n\t\tvar proj = (new THREE.Matrix4()).makePerspective( fov, aspect, 0.3, 10000 );\n\t\tvar h = 4 * (HMD.hScreenSize/4 - HMD.interpupillaryDistance/2) / HMD.hScreenSize;\n\t\tleft.proj = ((new THREE.Matrix4()).makeTranslation( h, 0.0, 0.0 )).multiply(proj);\n\t\tright.proj = ((new THREE.Matrix4()).makeTranslation( -h, 0.0, 0.0 )).multiply(proj);\n\n\t\t// Compute camera transformation matrices\n\t\tleft.tranform = (new THREE.Matrix4()).makeTranslation( -worldFactor * HMD.interpupillaryDistance/2, 0.0, 0.0 );\n\t\tright.tranform = (new THREE.Matrix4()).makeTranslation( worldFactor * HMD.interpupillaryDistance/2, 0.0, 0.0 );\n\n\t\t// Compute Viewport\n\t\tleft.viewport = [0, 0, HMD.hResolution/2, HMD.vResolution];\n\t\tright.viewport = [HMD.hResolution/2, 0, HMD.hResolution/2, HMD.vResolution];\n\n\t\t// Distortion shader parameters\n\t\tvar lensShift = 4 * (HMD.hScreenSize/4 - HMD.lensSeparationDistance/2) / HMD.hScreenSize;\n\t\tleft.lensCenter = new THREE.Vector2(lensShift, 0.0);\n\t\tright.lensCenter = new THREE.Vector2(-lensShift, 0.0);\n\n\t\tRTMaterial.uniforms['hmdWarpParam'].value = new THREE.Vector4(HMD.distortionK[0], HMD.distortionK[1], HMD.distortionK[2], HMD.distortionK[3]);\n\t\tRTMaterial.uniforms['chromAbParam'].value = new THREE.Vector4(HMD.chromaAbParameter[0], HMD.chromaAbParameter[1], HMD.chromaAbParameter[2], HMD.chromaAbParameter[3]);\n\t\tRTMaterial.uniforms['scaleIn'].value = new THREE.Vector2(1.0,1.0/aspect);\n\t\tRTMaterial.uniforms['scale'].value = new THREE.Vector2(1.0/distScale, 1.0*aspect/distScale);\n\n\t\t// Create render target\n\t\tif ( renderTarget ) renderTarget.dispose();\n\t\trenderTarget = new THREE.WebGLRenderTarget( HMD.hResolution*distScale/2, HMD.vResolution*distScale, RTParams );\n\t\tRTMaterial.uniforms[ \"texid\" ].value = renderTarget;\n\n\t}\t\n\tthis.getHMD = function() {return HMD};\n\n\tthis.setHMD(HMD);\t\n\n\tthis.setSize = function ( width, height ) {\n\t\tleft.viewport = [width/2 - HMD.hResolution/2, height/2 - HMD.vResolution/2, HMD.hResolution/2, HMD.vResolution];\n\t\tright.viewport = [width/2, height/2 - HMD.vResolution/2, HMD.hResolution/2, HMD.vResolution];\n\n\t\trenderer.setSize( width, height );\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\t\tvar cc = renderer.getClearColor().clone();\n\n\t\t// Clear\n\t\trenderer.setClearColor(emptyColor);\n\t\trenderer.clear();\n\t\trenderer.setClearColor(cc);\n\n\t\t// camera parameters\n\t\tif (camera.matrixAutoUpdate) camera.updateMatrix();\n\n\t\t// Render left\n\t\tthis.preLeftRender();\n\n\t\tpCamera.projectionMatrix.copy(left.proj);\n\n\t\tpCamera.matrix.copy(camera.matrix).multiply(left.tranform);\n\t\tpCamera.matrixWorldNeedsUpdate = true;\n\n\t\trenderer.setViewport(left.viewport[0], left.viewport[1], left.viewport[2], left.viewport[3]);\n\n\t\tRTMaterial.uniforms['lensCenter'].value = left.lensCenter;\n\t\trenderer.render( scene, pCamera, renderTarget, true );\n\n\t\trenderer.render( finalScene, oCamera );\n\n\t\t// Render right\n\t\tthis.preRightRender();\n\n\t\tpCamera.projectionMatrix.copy(right.proj);\n\n\t\tpCamera.matrix.copy(camera.matrix).multiply(right.tranform);\n\t\tpCamera.matrixWorldNeedsUpdate = true;\n\n\t\trenderer.setViewport(right.viewport[0], right.viewport[1], right.viewport[2], right.viewport[3]);\n\n\t\tRTMaterial.uniforms['lensCenter'].value = right.lensCenter;\n\n\t\trenderer.render( scene, pCamera, renderTarget, true );\n\t\trenderer.render( finalScene, oCamera );\n\n\t};\n\n\tthis.dispose = function() {\n\t\tif ( RTMaterial ) {\n\t\t\tRTMaterial.dispose();\n\t\t}\n\t\tif ( renderTarget ) {\n\t\t\trenderTarget.dispose();\n\t\t}\n\t};\n\n};\n",
      "content": "/**\n * @author troffmo5 / http://github.com/troffmo5\n *\n * Effect to render the scene in stereo 3d side by side with lens distortion.\n * It is written to be used with the Oculus Rift (http://www.oculusvr.com/) but\n * it works also with other HMD using the same technology\n */\n\nTHREE.OculusRiftEffect = function ( renderer, options ) {\n\t// worldFactor indicates how many units is 1 meter\n\tvar worldFactor = (options && options.worldFactor) ? options.worldFactor: 1.0;\n\n\t// Specific HMD parameters\n\tvar HMD = (options && options.HMD) ? options.HMD: {\n\t\t// Parameters from the Oculus Rift DK1\n\t\thResolution: 1280,\n\t\tvResolution: 800,\n\t\thScreenSize: 0.14976,\n\t\tvScreenSize: 0.0936,\n\t\tinterpupillaryDistance: 0.064,\n\t\tlensSeparationDistance: 0.064,\n\t\teyeToScreenDistance: 0.041,\n\t\tdistortionK : [1.0, 0.22, 0.24, 0.0],\n\t\tchromaAbParameter: [ 0.996, -0.004, 1.014, 0.0]\n\t};\n\n\t// Perspective camera\n\tvar pCamera = new THREE.PerspectiveCamera();\n\tpCamera.matrixAutoUpdate = false;\n\tpCamera.target = new THREE.Vector3();\n\n\t// Orthographic camera\n\tvar oCamera = new THREE.OrthographicCamera( -1, 1, 1, -1, 1, 1000 );\n\toCamera.position.z = 1;\n\n\t// pre-render hooks\n\tthis.preLeftRender = function() {};\n\tthis.preRightRender = function() {};\n\n\trenderer.autoClear = false;\n\tvar emptyColor = new THREE.Color(\"black\");\n\n\t// Render target\n\tvar RTParams = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\n\tvar renderTarget = new THREE.WebGLRenderTarget( 640, 800, RTParams );\n\tvar RTMaterial = new THREE.ShaderMaterial( {\n\t\tuniforms: {\n\t\t\t\"texid\": { type: \"t\", value: renderTarget },\n\t\t\t\"scale\": { type: \"v2\", value: new THREE.Vector2(1.0,1.0) },\n\t\t\t\"scaleIn\": { type: \"v2\", value: new THREE.Vector2(1.0,1.0) },\n\t\t\t\"lensCenter\": { type: \"v2\", value: new THREE.Vector2(0.0,0.0) },\n\t\t\t\"hmdWarpParam\": { type: \"v4\", value: new THREE.Vector4(1.0,0.0,0.0,0.0) },\n\t\t\t\"chromAbParam\": { type: \"v4\", value: new THREE.Vector4(1.0,0.0,0.0,0.0) }\n\t\t},\n\t\tvertexShader: [\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"void main() {\",\n\t\t\t\" vUv = uv;\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\"}\"\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\t\t\t\"uniform vec2 scale;\",\n\t\t\t\"uniform vec2 scaleIn;\",\n\t\t\t\"uniform vec2 lensCenter;\",\n\t\t\t\"uniform vec4 hmdWarpParam;\",\n\t\t\t'uniform vec4 chromAbParam;',\n\t\t\t\"uniform sampler2D texid;\",\n\t\t\t\"varying vec2 vUv;\",\n\t\t\t\"void main()\",\n\t\t\t\"{\",\n\t\t\t\"  vec2 uv = (vUv*2.0)-1.0;\", // range from [0,1] to [-1,1]\n\t\t\t\"  vec2 theta = (uv-lensCenter)*scaleIn;\",\n\t\t\t\"  float rSq = theta.x*theta.x + theta.y*theta.y;\",\n\t\t\t\"  vec2 rvector = theta*(hmdWarpParam.x + hmdWarpParam.y*rSq + hmdWarpParam.z*rSq*rSq + hmdWarpParam.w*rSq*rSq*rSq);\",\n\t\t\t'  vec2 rBlue = rvector * (chromAbParam.z + chromAbParam.w * rSq);',\n\t\t\t\"  vec2 tcBlue = (lensCenter + scale * rBlue);\",\n\t\t\t\"  tcBlue = (tcBlue+1.0)/2.0;\", // range from [-1,1] to [0,1]\n\t\t\t\"  if (any(bvec2(clamp(tcBlue, vec2(0.0,0.0), vec2(1.0,1.0))-tcBlue))) {\",\n\t\t\t\"    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\",\n\t\t\t\"    return;}\",\n\t\t\t\"  vec2 tcGreen = lensCenter + scale * rvector;\",\n\t\t\t\"  tcGreen = (tcGreen+1.0)/2.0;\", // range from [-1,1] to [0,1]\n\t\t\t\"  vec2 rRed = rvector * (chromAbParam.x + chromAbParam.y * rSq);\",\n\t\t\t\"  vec2 tcRed = lensCenter + scale * rRed;\",\n\t\t\t\"  tcRed = (tcRed+1.0)/2.0;\", // range from [-1,1] to [0,1]\n\t\t\t\"  gl_FragColor = vec4(texture2D(texid, tcRed).r, texture2D(texid, tcGreen).g, texture2D(texid, tcBlue).b, 1);\",\n\t\t\t\"}\"\n\t\t].join(\"\\n\")\n\t} );\n\n\tvar mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), RTMaterial );\n\n\t// Final scene\n\tvar finalScene = new THREE.Scene();\n\tfinalScene.add( oCamera );\n\tfinalScene.add( mesh );\n\n    var left = {}, right = {};\n    var distScale = 1.0;\n\tthis.setHMD = function(v) {\n\t\tHMD = v;\n\t\t// Compute aspect ratio and FOV\n\t\tvar aspect = HMD.hResolution / (2*HMD.vResolution);\n\n\t\t// Fov is normally computed with:\n\t\t//   THREE.Math.radToDeg( 2*Math.atan2(HMD.vScreenSize,2*HMD.eyeToScreenDistance) );\n\t\t// But with lens distortion it is increased (see Oculus SDK Documentation)\n\t\tvar r = -1.0 - (4 * (HMD.hScreenSize/4 - HMD.lensSeparationDistance/2) / HMD.hScreenSize);\n\t\tdistScale = (HMD.distortionK[0] + HMD.distortionK[1] * Math.pow(r,2) + HMD.distortionK[2] * Math.pow(r,4) + HMD.distortionK[3] * Math.pow(r,6));\n\t\tvar fov = THREE.Math.radToDeg(2*Math.atan2(HMD.vScreenSize*distScale, 2*HMD.eyeToScreenDistance));\n\n\t\t// Compute camera projection matrices\n\t\tvar proj = (new THREE.Matrix4()).makePerspective( fov, aspect, 0.3, 10000 );\n\t\tvar h = 4 * (HMD.hScreenSize/4 - HMD.interpupillaryDistance/2) / HMD.hScreenSize;\n\t\tleft.proj = ((new THREE.Matrix4()).makeTranslation( h, 0.0, 0.0 )).multiply(proj);\n\t\tright.proj = ((new THREE.Matrix4()).makeTranslation( -h, 0.0, 0.0 )).multiply(proj);\n\n\t\t// Compute camera transformation matrices\n\t\tleft.tranform = (new THREE.Matrix4()).makeTranslation( -worldFactor * HMD.interpupillaryDistance/2, 0.0, 0.0 );\n\t\tright.tranform = (new THREE.Matrix4()).makeTranslation( worldFactor * HMD.interpupillaryDistance/2, 0.0, 0.0 );\n\n\t\t// Compute Viewport\n\t\tleft.viewport = [0, 0, HMD.hResolution/2, HMD.vResolution];\n\t\tright.viewport = [HMD.hResolution/2, 0, HMD.hResolution/2, HMD.vResolution];\n\n\t\t// Distortion shader parameters\n\t\tvar lensShift = 4 * (HMD.hScreenSize/4 - HMD.lensSeparationDistance/2) / HMD.hScreenSize;\n\t\tleft.lensCenter = new THREE.Vector2(lensShift, 0.0);\n\t\tright.lensCenter = new THREE.Vector2(-lensShift, 0.0);\n\n\t\tRTMaterial.uniforms['hmdWarpParam'].value = new THREE.Vector4(HMD.distortionK[0], HMD.distortionK[1], HMD.distortionK[2], HMD.distortionK[3]);\n\t\tRTMaterial.uniforms['chromAbParam'].value = new THREE.Vector4(HMD.chromaAbParameter[0], HMD.chromaAbParameter[1], HMD.chromaAbParameter[2], HMD.chromaAbParameter[3]);\n\t\tRTMaterial.uniforms['scaleIn'].value = new THREE.Vector2(1.0,1.0/aspect);\n\t\tRTMaterial.uniforms['scale'].value = new THREE.Vector2(1.0/distScale, 1.0*aspect/distScale);\n\n\t\t// Create render target\n\t\tif ( renderTarget ) renderTarget.dispose();\n\t\trenderTarget = new THREE.WebGLRenderTarget( HMD.hResolution*distScale/2, HMD.vResolution*distScale, RTParams );\n\t\tRTMaterial.uniforms[ \"texid\" ].value = renderTarget;\n\n\t}\t\n\tthis.getHMD = function() {return HMD};\n\n\tthis.setHMD(HMD);\t\n\n\tthis.setSize = function ( width, height ) {\n\t\tleft.viewport = [width/2 - HMD.hResolution/2, height/2 - HMD.vResolution/2, HMD.hResolution/2, HMD.vResolution];\n\t\tright.viewport = [width/2, height/2 - HMD.vResolution/2, HMD.hResolution/2, HMD.vResolution];\n\n\t\trenderer.setSize( width, height );\n\t};\n\n\tthis.render = function ( scene, camera ) {\n\t\tvar cc = renderer.getClearColor().clone();\n\n\t\t// Clear\n\t\trenderer.setClearColor(emptyColor);\n\t\trenderer.clear();\n\t\trenderer.setClearColor(cc);\n\n\t\t// camera parameters\n\t\tif (camera.matrixAutoUpdate) camera.updateMatrix();\n\n\t\t// Render left\n\t\tthis.preLeftRender();\n\n\t\tpCamera.projectionMatrix.copy(left.proj);\n\n\t\tpCamera.matrix.copy(camera.matrix).multiply(left.tranform);\n\t\tpCamera.matrixWorldNeedsUpdate = true;\n\n\t\trenderer.setViewport(left.viewport[0], left.viewport[1], left.viewport[2], left.viewport[3]);\n\n\t\tRTMaterial.uniforms['lensCenter'].value = left.lensCenter;\n\t\trenderer.render( scene, pCamera, renderTarget, true );\n\n\t\trenderer.render( finalScene, oCamera );\n\n\t\t// Render right\n\t\tthis.preRightRender();\n\n\t\tpCamera.projectionMatrix.copy(right.proj);\n\n\t\tpCamera.matrix.copy(camera.matrix).multiply(right.tranform);\n\t\tpCamera.matrixWorldNeedsUpdate = true;\n\n\t\trenderer.setViewport(right.viewport[0], right.viewport[1], right.viewport[2], right.viewport[3]);\n\n\t\tRTMaterial.uniforms['lensCenter'].value = right.lensCenter;\n\n\t\trenderer.render( scene, pCamera, renderTarget, true );\n\t\trenderer.render( finalScene, oCamera );\n\n\t};\n\n\tthis.dispose = function() {\n\t\tif ( RTMaterial ) {\n\t\t\tRTMaterial.dispose();\n\t\t}\n\t\tif ( renderTarget ) {\n\t\t\trenderTarget.dispose();\n\t\t}\n\t};\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "OculusRiftEffect.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-effects-OculusRiftEffect",
      "url": "/js/effects/OculusRiftEffect.js",
      "urls": [
        "/js/effects/OculusRiftEffect.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/effects/ParallaxBarrierEffect.js",
      "relativePath": "js/effects/ParallaxBarrierEffect.js",
      "basename": "ParallaxBarrierEffect",
      "outBasename": "ParallaxBarrierEffect",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "ParallaxBarrierEffect.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/effects",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/effects/ParallaxBarrierEffect.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/effects",
      "outFilename": "ParallaxBarrierEffect.js",
      "relativeOutPath": "js/effects/ParallaxBarrierEffect.js",
      "relativeDirPath": "js/effects",
      "relativeOutDirPath": "js/effects",
      "relativeBase": "js/effects/ParallaxBarrierEffect",
      "relativeOutBase": "js/effects/ParallaxBarrierEffect",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.576Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author mrdoob / http://mrdoob.com/\n * @author marklundin / http://mark-lundin.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ParallaxBarrierEffect = function ( renderer ) {\n\n\tvar eyeRight = new THREE.Matrix4();\n\tvar eyeLeft = new THREE.Matrix4();\n\tvar focalLength = 125;\n\tvar _aspect, _near, _far, _fov;\n\n\tvar _cameraL = new THREE.PerspectiveCamera();\n\t_cameraL.matrixAutoUpdate = false;\n\n\tvar _cameraR = new THREE.PerspectiveCamera();\n\t_cameraR.matrixAutoUpdate = false;\n\n\tvar _scene = new THREE.Scene();\n\n\tvar _camera = new THREE.PerspectiveCamera( 53, 1, 1, 10000 );\n\t_camera.position.z = 2;\n\t_scene.add( _camera );\n\n\tvar _params = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\n\n\tvar _renderTargetL = new THREE.WebGLRenderTarget( 512, 512, _params );\n\tvar _renderTargetR = new THREE.WebGLRenderTarget( 512, 512, _params );\n\n\tvar _material = new THREE.ShaderMaterial( {\n\n\t\tuniforms: {\n\n\t\t\t\"mapLeft\": { type: \"t\", value: _renderTargetL },\n\t\t\t\"mapRight\": { type: \"t\", value: _renderTargetR }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = vec2( uv.x, uv.y );\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D mapLeft;\",\n\t\t\t\"uniform sampler2D mapRight;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec2 uv = vUv;\",\n\n\t\t\t\"\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {\",\n\n\t\t\t\"\t\tgl_FragColor = texture2D( mapLeft, uv );\",\n\n\t\t\t\"\t} else {\",\n\n\t\t\t\"\t\tgl_FragColor = texture2D( mapRight, uv );\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t} );\n\n\tvar mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), _material );\n\t_scene.add( mesh );\n\n\tthis.setSize = function ( width, height ) {\n\n\t\t_renderTargetL = new THREE.WebGLRenderTarget( width, height, _params );\n\t\t_renderTargetR = new THREE.WebGLRenderTarget( width, height, _params );\n\n\t\t_material.uniforms[ \"mapLeft\" ].value = _renderTargetL;\n\t\t_material.uniforms[ \"mapRight\" ].value = _renderTargetR;\n\n\t\trenderer.setSize( width, height );\n\n\t};\n\n\t/*\n\t * Renderer now uses an asymmetric perspective projection\n\t * (http://paulbourke.net/miscellaneous/stereographics/stereorender/).\n\t *\n\t * Each camera is offset by the eye seperation and its projection matrix is\n\t * also skewed asymetrically back to converge on the same projection plane.\n\t * Added a focal length parameter to, this is where the parallax is equal to 0.\n\t */\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tscene.updateMatrixWorld();\n\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\n\t\tvar hasCameraChanged = ( _aspect !== camera.aspect ) || ( _near !== camera.near ) || ( _far !== camera.far ) || ( _fov !== camera.fov );\n\n\t\tif ( hasCameraChanged ) {\n\n\t\t\t_aspect = camera.aspect;\n\t\t\t_near = camera.near;\n\t\t\t_far = camera.far;\n\t\t\t_fov = camera.fov;\n\n\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\tvar eyeSep = focalLength / 30 * 0.5;\n\t\t\tvar eyeSepOnProjection = eyeSep * _near / focalLength;\n\t\t\tvar ymax = _near * Math.tan( THREE.Math.degToRad( _fov * 0.5 ) );\n\t\t\tvar xmin, xmax;\n\n\t\t\t// translate xOffset\n\n\t\t\teyeRight.elements[12] = eyeSep;\n\t\t\teyeLeft.elements[12] = -eyeSep;\n\n\t\t\t// for left eye\n\n\t\t\txmin = -ymax * _aspect + eyeSepOnProjection;\n\t\t\txmax = ymax * _aspect + eyeSepOnProjection;\n\n\t\t\tprojectionMatrix.elements[0] = 2 * _near / ( xmax - xmin );\n\t\t\tprojectionMatrix.elements[8] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t_cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t// for right eye\n\n\t\t\txmin = -ymax * _aspect - eyeSepOnProjection;\n\t\t\txmax = ymax * _aspect - eyeSepOnProjection;\n\n\t\t\tprojectionMatrix.elements[0] = 2 * _near / ( xmax - xmin );\n\t\t\tprojectionMatrix.elements[8] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t_cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t}\n\n\t\t_cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t_cameraL.position.copy( camera.position );\n\t\t_cameraL.near = camera.near;\n\t\t_cameraL.far = camera.far;\n\n\t\trenderer.render( scene, _cameraL, _renderTargetL, true );\n\n\t\t_cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\t\t_cameraR.position.copy( camera.position );\n\t\t_cameraR.near = camera.near;\n\t\t_cameraR.far = camera.far;\n\n\t\trenderer.render( scene, _cameraR, _renderTargetR, true );\n\n\t\t_scene.updateMatrixWorld();\n\n\t\trenderer.render( _scene, _camera );\n\n\t};\n\n};\n",
      "content": "/**\n * @author mrdoob / http://mrdoob.com/\n * @author marklundin / http://mark-lundin.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ParallaxBarrierEffect = function ( renderer ) {\n\n\tvar eyeRight = new THREE.Matrix4();\n\tvar eyeLeft = new THREE.Matrix4();\n\tvar focalLength = 125;\n\tvar _aspect, _near, _far, _fov;\n\n\tvar _cameraL = new THREE.PerspectiveCamera();\n\t_cameraL.matrixAutoUpdate = false;\n\n\tvar _cameraR = new THREE.PerspectiveCamera();\n\t_cameraR.matrixAutoUpdate = false;\n\n\tvar _scene = new THREE.Scene();\n\n\tvar _camera = new THREE.PerspectiveCamera( 53, 1, 1, 10000 );\n\t_camera.position.z = 2;\n\t_scene.add( _camera );\n\n\tvar _params = { minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\n\n\tvar _renderTargetL = new THREE.WebGLRenderTarget( 512, 512, _params );\n\tvar _renderTargetR = new THREE.WebGLRenderTarget( 512, 512, _params );\n\n\tvar _material = new THREE.ShaderMaterial( {\n\n\t\tuniforms: {\n\n\t\t\t\"mapLeft\": { type: \"t\", value: _renderTargetL },\n\t\t\t\"mapRight\": { type: \"t\", value: _renderTargetR }\n\n\t\t},\n\n\t\tvertexShader: [\n\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvUv = vec2( uv.x, uv.y );\",\n\t\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\"),\n\n\t\tfragmentShader: [\n\n\t\t\t\"uniform sampler2D mapLeft;\",\n\t\t\t\"uniform sampler2D mapRight;\",\n\t\t\t\"varying vec2 vUv;\",\n\n\t\t\t\"void main() {\",\n\n\t\t\t\"\tvec2 uv = vUv;\",\n\n\t\t\t\"\tif ( ( mod( gl_FragCoord.y, 2.0 ) ) > 1.00 ) {\",\n\n\t\t\t\"\t\tgl_FragColor = texture2D( mapLeft, uv );\",\n\n\t\t\t\"\t} else {\",\n\n\t\t\t\"\t\tgl_FragColor = texture2D( mapRight, uv );\",\n\n\t\t\t\"\t}\",\n\n\t\t\t\"}\"\n\n\t\t].join(\"\\n\")\n\n\t} );\n\n\tvar mesh = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), _material );\n\t_scene.add( mesh );\n\n\tthis.setSize = function ( width, height ) {\n\n\t\t_renderTargetL = new THREE.WebGLRenderTarget( width, height, _params );\n\t\t_renderTargetR = new THREE.WebGLRenderTarget( width, height, _params );\n\n\t\t_material.uniforms[ \"mapLeft\" ].value = _renderTargetL;\n\t\t_material.uniforms[ \"mapRight\" ].value = _renderTargetR;\n\n\t\trenderer.setSize( width, height );\n\n\t};\n\n\t/*\n\t * Renderer now uses an asymmetric perspective projection\n\t * (http://paulbourke.net/miscellaneous/stereographics/stereorender/).\n\t *\n\t * Each camera is offset by the eye seperation and its projection matrix is\n\t * also skewed asymetrically back to converge on the same projection plane.\n\t * Added a focal length parameter to, this is where the parallax is equal to 0.\n\t */\n\n\tthis.render = function ( scene, camera ) {\n\n\t\tscene.updateMatrixWorld();\n\n\t\tif ( camera.parent === undefined ) camera.updateMatrixWorld();\n\n\t\tvar hasCameraChanged = ( _aspect !== camera.aspect ) || ( _near !== camera.near ) || ( _far !== camera.far ) || ( _fov !== camera.fov );\n\n\t\tif ( hasCameraChanged ) {\n\n\t\t\t_aspect = camera.aspect;\n\t\t\t_near = camera.near;\n\t\t\t_far = camera.far;\n\t\t\t_fov = camera.fov;\n\n\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\n\t\t\tvar eyeSep = focalLength / 30 * 0.5;\n\t\t\tvar eyeSepOnProjection = eyeSep * _near / focalLength;\n\t\t\tvar ymax = _near * Math.tan( THREE.Math.degToRad( _fov * 0.5 ) );\n\t\t\tvar xmin, xmax;\n\n\t\t\t// translate xOffset\n\n\t\t\teyeRight.elements[12] = eyeSep;\n\t\t\teyeLeft.elements[12] = -eyeSep;\n\n\t\t\t// for left eye\n\n\t\t\txmin = -ymax * _aspect + eyeSepOnProjection;\n\t\t\txmax = ymax * _aspect + eyeSepOnProjection;\n\n\t\t\tprojectionMatrix.elements[0] = 2 * _near / ( xmax - xmin );\n\t\t\tprojectionMatrix.elements[8] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t_cameraL.projectionMatrix.copy( projectionMatrix );\n\n\t\t\t// for right eye\n\n\t\t\txmin = -ymax * _aspect - eyeSepOnProjection;\n\t\t\txmax = ymax * _aspect - eyeSepOnProjection;\n\n\t\t\tprojectionMatrix.elements[0] = 2 * _near / ( xmax - xmin );\n\t\t\tprojectionMatrix.elements[8] = ( xmax + xmin ) / ( xmax - xmin );\n\n\t\t\t_cameraR.projectionMatrix.copy( projectionMatrix );\n\n\t\t}\n\n\t\t_cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\n\t\t_cameraL.position.copy( camera.position );\n\t\t_cameraL.near = camera.near;\n\t\t_cameraL.far = camera.far;\n\n\t\trenderer.render( scene, _cameraL, _renderTargetL, true );\n\n\t\t_cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\n\t\t_cameraR.position.copy( camera.position );\n\t\t_cameraR.near = camera.near;\n\t\t_cameraR.far = camera.far;\n\n\t\trenderer.render( scene, _cameraR, _renderTargetR, true );\n\n\t\t_scene.updateMatrixWorld();\n\n\t\trenderer.render( _scene, _camera );\n\n\t};\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "ParallaxBarrierEffect.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-effects-ParallaxBarrierEffect",
      "url": "/js/effects/ParallaxBarrierEffect.js",
      "urls": [
        "/js/effects/ParallaxBarrierEffect.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post/BloomPass.js",
      "relativePath": "js/post/BloomPass.js",
      "basename": "BloomPass",
      "outBasename": "BloomPass",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "BloomPass.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post/BloomPass.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post",
      "outFilename": "BloomPass.js",
      "relativeOutPath": "js/post/BloomPass.js",
      "relativeDirPath": "js/post",
      "relativeOutDirPath": "js/post",
      "relativeBase": "js/post/BloomPass",
      "relativeOutBase": "js/post/BloomPass",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.580Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.BloomPass = function ( strength, kernelSize, sigma, resolution ) {\n\n\tstrength = ( strength !== undefined ) ? strength : 1;\n\tkernelSize = ( kernelSize !== undefined ) ? kernelSize : 25;\n\tsigma = ( sigma !== undefined ) ? sigma : 4.0;\n\tresolution = ( resolution !== undefined ) ? resolution : 256;\n\n\t// render targets\n\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };\n\n\tthis.renderTargetX = new THREE.WebGLRenderTarget( resolution, resolution, pars );\n\tthis.renderTargetY = new THREE.WebGLRenderTarget( resolution, resolution, pars );\n\n\t// copy material\n\n\tif ( THREE.CopyShader === undefined )\n\t\tconsole.error( \"THREE.BloomPass relies on THREE.CopyShader\" );\n\n\tvar copyShader = THREE.CopyShader;\n\n\tthis.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );\n\n\tthis.copyUniforms[ \"opacity\" ].value = strength;\n\n\tthis.materialCopy = new THREE.ShaderMaterial( {\n\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: THREE.AdditiveBlending,\n\t\ttransparent: true\n\n\t} );\n\n\t// convolution material\n\n\tif ( THREE.ConvolutionShader === undefined )\n\t\tconsole.error( \"THREE.BloomPass relies on THREE.ConvolutionShader\" );\n\n\tvar convolutionShader = THREE.ConvolutionShader;\n\n\tthis.convolutionUniforms = THREE.UniformsUtils.clone( convolutionShader.uniforms );\n\n\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurx;\n\tthis.convolutionUniforms[ \"cKernel\" ].value = THREE.ConvolutionShader.buildKernel( sigma );\n\n\tthis.materialConvolution = new THREE.ShaderMaterial( {\n\n\t\tuniforms: this.convolutionUniforms,\n\t\tvertexShader:  convolutionShader.vertexShader,\n\t\tfragmentShader: convolutionShader.fragmentShader,\n\t\tdefines: {\n\t\t\t\"KERNEL_SIZE_FLOAT\": kernelSize.toFixed( 1 ),\n\t\t\t\"KERNEL_SIZE_INT\": kernelSize.toFixed( 0 )\n\t\t}\n\n\t} );\n\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\tthis.clear = false;\n\n};\n\nTHREE.BloomPass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\n\n\t\tif ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );\n\n\t\t// Render quad with blured scene into texture (convolution pass 1)\n\n\t\tTHREE.EffectComposer.quad.material = this.materialConvolution;\n\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = readBuffer;\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurX;\n\n\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTargetX, true );\n\n\n\t\t// Render quad with blured scene into texture (convolution pass 2)\n\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = this.renderTargetX;\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurY;\n\n\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTargetY, true );\n\n\t\t// Render original scene with superimposed blur to texture\n\n\t\tTHREE.EffectComposer.quad.material = this.materialCopy;\n\n\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.renderTargetY;\n\n\t\tif ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );\n\n\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, readBuffer, this.clear );\n\n\t}\n\n};\n\nTHREE.BloomPass.blurX = new THREE.Vector2( 0.001953125, 0.0 );\nTHREE.BloomPass.blurY = new THREE.Vector2( 0.0, 0.001953125 );\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.BloomPass = function ( strength, kernelSize, sigma, resolution ) {\n\n\tstrength = ( strength !== undefined ) ? strength : 1;\n\tkernelSize = ( kernelSize !== undefined ) ? kernelSize : 25;\n\tsigma = ( sigma !== undefined ) ? sigma : 4.0;\n\tresolution = ( resolution !== undefined ) ? resolution : 256;\n\n\t// render targets\n\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };\n\n\tthis.renderTargetX = new THREE.WebGLRenderTarget( resolution, resolution, pars );\n\tthis.renderTargetY = new THREE.WebGLRenderTarget( resolution, resolution, pars );\n\n\t// copy material\n\n\tif ( THREE.CopyShader === undefined )\n\t\tconsole.error( \"THREE.BloomPass relies on THREE.CopyShader\" );\n\n\tvar copyShader = THREE.CopyShader;\n\n\tthis.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );\n\n\tthis.copyUniforms[ \"opacity\" ].value = strength;\n\n\tthis.materialCopy = new THREE.ShaderMaterial( {\n\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: THREE.AdditiveBlending,\n\t\ttransparent: true\n\n\t} );\n\n\t// convolution material\n\n\tif ( THREE.ConvolutionShader === undefined )\n\t\tconsole.error( \"THREE.BloomPass relies on THREE.ConvolutionShader\" );\n\n\tvar convolutionShader = THREE.ConvolutionShader;\n\n\tthis.convolutionUniforms = THREE.UniformsUtils.clone( convolutionShader.uniforms );\n\n\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurx;\n\tthis.convolutionUniforms[ \"cKernel\" ].value = THREE.ConvolutionShader.buildKernel( sigma );\n\n\tthis.materialConvolution = new THREE.ShaderMaterial( {\n\n\t\tuniforms: this.convolutionUniforms,\n\t\tvertexShader:  convolutionShader.vertexShader,\n\t\tfragmentShader: convolutionShader.fragmentShader,\n\t\tdefines: {\n\t\t\t\"KERNEL_SIZE_FLOAT\": kernelSize.toFixed( 1 ),\n\t\t\t\"KERNEL_SIZE_INT\": kernelSize.toFixed( 0 )\n\t\t}\n\n\t} );\n\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\tthis.clear = false;\n\n};\n\nTHREE.BloomPass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\n\n\t\tif ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );\n\n\t\t// Render quad with blured scene into texture (convolution pass 1)\n\n\t\tTHREE.EffectComposer.quad.material = this.materialConvolution;\n\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = readBuffer;\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurX;\n\n\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTargetX, true );\n\n\n\t\t// Render quad with blured scene into texture (convolution pass 2)\n\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = this.renderTargetX;\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurY;\n\n\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTargetY, true );\n\n\t\t// Render original scene with superimposed blur to texture\n\n\t\tTHREE.EffectComposer.quad.material = this.materialCopy;\n\n\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.renderTargetY;\n\n\t\tif ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );\n\n\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, readBuffer, this.clear );\n\n\t}\n\n};\n\nTHREE.BloomPass.blurX = new THREE.Vector2( 0.001953125, 0.0 );\nTHREE.BloomPass.blurY = new THREE.Vector2( 0.0, 0.001953125 );\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "BloomPass.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-post-BloomPass",
      "url": "/js/post/BloomPass.js",
      "urls": [
        "/js/post/BloomPass.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post/BokehPass.js",
      "relativePath": "js/post/BokehPass.js",
      "basename": "BokehPass",
      "outBasename": "BokehPass",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "BokehPass.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post/BokehPass.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post",
      "outFilename": "BokehPass.js",
      "relativeOutPath": "js/post/BokehPass.js",
      "relativeDirPath": "js/post",
      "relativeOutDirPath": "js/post",
      "relativeBase": "js/post/BokehPass",
      "relativeOutBase": "js/post/BokehPass",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.587Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * Depth-of-field post-process with bokeh shader\n */\n\n\nTHREE.BokehPass = function ( scene, camera, params ) {\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tvar focus = ( params.focus !== undefined ) ? params.focus : 1.0;\n\tvar aspect = ( params.aspect !== undefined ) ? params.aspect : camera.aspect;\n\tvar aperture = ( params.aperture !== undefined ) ? params.aperture : 0.025;\n\tvar maxblur = ( params.maxblur !== undefined ) ? params.maxblur : 1.0;\n\n\t// render targets\n\n\tvar width = params.width || window.innerWidth || 1;\n\tvar height = params.height || window.innerHeight || 1;\n\n\tthis.renderTargetColor = new THREE.WebGLRenderTarget( width, height, {\n\t\tminFilter: THREE.LinearFilter,\n\t\tmagFilter: THREE.LinearFilter,\n\t\tformat: THREE.RGBFormat\n\t} );\n\n\tthis.renderTargetDepth = this.renderTargetColor.clone();\n\n\t// depth material\n\n\tthis.materialDepth = new THREE.MeshDepthMaterial();\n\n\t// bokeh material\n\n\tif ( THREE.BokehShader === undefined ) {\n\t\tconsole.error( \"THREE.BokehPass relies on THREE.BokehShader\" );\n\t}\n\t\n\tvar bokehShader = THREE.BokehShader;\n\tvar bokehUniforms = THREE.UniformsUtils.clone( bokehShader.uniforms );\n\n\tbokehUniforms[ \"tDepth\" ].value = this.renderTargetDepth;\n\n\tbokehUniforms[ \"focus\" ].value = focus;\n\tbokehUniforms[ \"aspect\" ].value = aspect;\n\tbokehUniforms[ \"aperture\" ].value = aperture;\n\tbokehUniforms[ \"maxblur\" ].value = maxblur;\n\n\tthis.materialBokeh = new THREE.ShaderMaterial({\n\t\tuniforms: bokehUniforms,\n\t\tvertexShader: bokehShader.vertexShader,\n\t\tfragmentShader: bokehShader.fragmentShader\n\t});\n\n\tthis.uniforms = bokehUniforms;\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\tthis.renderToScreen = false;\n\tthis.clear = false;\n\n};\n\nTHREE.BokehPass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\n\n\t\tvar composer = THREE.EffectComposer;\n\n\t\tcomposer.quad.material = this.materialBokeh;\n\n\t\t// Render depth into texture\n\n\t\tthis.scene.overrideMaterial = this.materialDepth;\n\n\t\trenderer.render( this.scene, this.camera, this.renderTargetDepth, true );\n\n\t\t// Render bokeh composite\n\n\t\tthis.uniforms[ \"tColor\" ].value = readBuffer;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.render( composer.scene, composer.camera );\n\n\t\t} else {\n\n\t\t\trenderer.render( composer.scene, composer.camera, writeBuffer, this.clear );\n\n\t\t}\n\n\t\tthis.scene.overrideMaterial = null;\n\n\t}\n\n};\n\n",
      "content": "/**\n * Depth-of-field post-process with bokeh shader\n */\n\n\nTHREE.BokehPass = function ( scene, camera, params ) {\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tvar focus = ( params.focus !== undefined ) ? params.focus : 1.0;\n\tvar aspect = ( params.aspect !== undefined ) ? params.aspect : camera.aspect;\n\tvar aperture = ( params.aperture !== undefined ) ? params.aperture : 0.025;\n\tvar maxblur = ( params.maxblur !== undefined ) ? params.maxblur : 1.0;\n\n\t// render targets\n\n\tvar width = params.width || window.innerWidth || 1;\n\tvar height = params.height || window.innerHeight || 1;\n\n\tthis.renderTargetColor = new THREE.WebGLRenderTarget( width, height, {\n\t\tminFilter: THREE.LinearFilter,\n\t\tmagFilter: THREE.LinearFilter,\n\t\tformat: THREE.RGBFormat\n\t} );\n\n\tthis.renderTargetDepth = this.renderTargetColor.clone();\n\n\t// depth material\n\n\tthis.materialDepth = new THREE.MeshDepthMaterial();\n\n\t// bokeh material\n\n\tif ( THREE.BokehShader === undefined ) {\n\t\tconsole.error( \"THREE.BokehPass relies on THREE.BokehShader\" );\n\t}\n\t\n\tvar bokehShader = THREE.BokehShader;\n\tvar bokehUniforms = THREE.UniformsUtils.clone( bokehShader.uniforms );\n\n\tbokehUniforms[ \"tDepth\" ].value = this.renderTargetDepth;\n\n\tbokehUniforms[ \"focus\" ].value = focus;\n\tbokehUniforms[ \"aspect\" ].value = aspect;\n\tbokehUniforms[ \"aperture\" ].value = aperture;\n\tbokehUniforms[ \"maxblur\" ].value = maxblur;\n\n\tthis.materialBokeh = new THREE.ShaderMaterial({\n\t\tuniforms: bokehUniforms,\n\t\tvertexShader: bokehShader.vertexShader,\n\t\tfragmentShader: bokehShader.fragmentShader\n\t});\n\n\tthis.uniforms = bokehUniforms;\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\tthis.renderToScreen = false;\n\tthis.clear = false;\n\n};\n\nTHREE.BokehPass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\n\n\t\tvar composer = THREE.EffectComposer;\n\n\t\tcomposer.quad.material = this.materialBokeh;\n\n\t\t// Render depth into texture\n\n\t\tthis.scene.overrideMaterial = this.materialDepth;\n\n\t\trenderer.render( this.scene, this.camera, this.renderTargetDepth, true );\n\n\t\t// Render bokeh composite\n\n\t\tthis.uniforms[ \"tColor\" ].value = readBuffer;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.render( composer.scene, composer.camera );\n\n\t\t} else {\n\n\t\t\trenderer.render( composer.scene, composer.camera, writeBuffer, this.clear );\n\n\t\t}\n\n\t\tthis.scene.overrideMaterial = null;\n\n\t}\n\n};\n\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "BokehPass.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-post-BokehPass",
      "url": "/js/post/BokehPass.js",
      "urls": [
        "/js/post/BokehPass.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post/DotScreenPass.js",
      "relativePath": "js/post/DotScreenPass.js",
      "basename": "DotScreenPass",
      "outBasename": "DotScreenPass",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "DotScreenPass.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post/DotScreenPass.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post",
      "outFilename": "DotScreenPass.js",
      "relativeOutPath": "js/post/DotScreenPass.js",
      "relativeDirPath": "js/post",
      "relativeOutDirPath": "js/post",
      "relativeBase": "js/post/DotScreenPass",
      "relativeOutBase": "js/post/DotScreenPass",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.595Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DotScreenPass = function ( center, angle, scale ) {\n\n\tif ( THREE.DotScreenShader === undefined )\n\t\tconsole.error( \"THREE.DotScreenPass relies on THREE.DotScreenShader\" );\n\n\tvar shader = THREE.DotScreenShader;\n\n\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\tif ( center !== undefined ) this.uniforms[ \"center\" ].value.copy( center );\n\tif ( angle !== undefined ) this.uniforms[ \"angle\"].value = angle;\n\tif ( scale !== undefined ) this.uniforms[ \"scale\"].value = scale;\n\n\tthis.material = new THREE.ShaderMaterial( {\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\n\t} );\n\n\tthis.enabled = true;\n\tthis.renderToScreen = false;\n\tthis.needsSwap = true;\n\n};\n\nTHREE.DotScreenPass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\tthis.uniforms[ \"tDiffuse\" ].value = readBuffer;\n\t\tthis.uniforms[ \"tSize\" ].value.set( readBuffer.width, readBuffer.height );\n\n\t\tTHREE.EffectComposer.quad.material = this.material;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera );\n\n\t\t} else {\n\n\t\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, writeBuffer, false );\n\n\t\t}\n\n\t}\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.DotScreenPass = function ( center, angle, scale ) {\n\n\tif ( THREE.DotScreenShader === undefined )\n\t\tconsole.error( \"THREE.DotScreenPass relies on THREE.DotScreenShader\" );\n\n\tvar shader = THREE.DotScreenShader;\n\n\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\tif ( center !== undefined ) this.uniforms[ \"center\" ].value.copy( center );\n\tif ( angle !== undefined ) this.uniforms[ \"angle\"].value = angle;\n\tif ( scale !== undefined ) this.uniforms[ \"scale\"].value = scale;\n\n\tthis.material = new THREE.ShaderMaterial( {\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\n\t} );\n\n\tthis.enabled = true;\n\tthis.renderToScreen = false;\n\tthis.needsSwap = true;\n\n};\n\nTHREE.DotScreenPass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\tthis.uniforms[ \"tDiffuse\" ].value = readBuffer;\n\t\tthis.uniforms[ \"tSize\" ].value.set( readBuffer.width, readBuffer.height );\n\n\t\tTHREE.EffectComposer.quad.material = this.material;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera );\n\n\t\t} else {\n\n\t\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, writeBuffer, false );\n\n\t\t}\n\n\t}\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "DotScreenPass.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-post-DotScreenPass",
      "url": "/js/post/DotScreenPass.js",
      "urls": [
        "/js/post/DotScreenPass.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post/EffectComposer.js",
      "relativePath": "js/post/EffectComposer.js",
      "basename": "EffectComposer",
      "outBasename": "EffectComposer",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "EffectComposer.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post/EffectComposer.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post",
      "outFilename": "EffectComposer.js",
      "relativeOutPath": "js/post/EffectComposer.js",
      "relativeDirPath": "js/post",
      "relativeOutDirPath": "js/post",
      "relativeBase": "js/post/EffectComposer",
      "relativeOutBase": "js/post/EffectComposer",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.599Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.EffectComposer = function ( renderer, renderTarget ) {\n\n\tthis.renderer = renderer;\n\n\tif ( renderTarget === undefined ) {\n\n\t\tvar width = window.innerWidth || 1;\n\t\tvar height = window.innerHeight || 1;\n\t\tvar parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };\n\n\t\trenderTarget = new THREE.WebGLRenderTarget( width, height, parameters );\n\n\t}\n\n\tthis.renderTarget1 = renderTarget;\n\tthis.renderTarget2 = renderTarget.clone();\n\n\tthis.writeBuffer = this.renderTarget1;\n\tthis.readBuffer = this.renderTarget2;\n\n\tthis.passes = [];\n\n\tif ( THREE.CopyShader === undefined )\n\t\tconsole.error( \"THREE.EffectComposer relies on THREE.CopyShader\" );\n\n\tthis.copyPass = new THREE.ShaderPass( THREE.CopyShader );\n\n};\n\nTHREE.EffectComposer.prototype = {\n\n\tswapBuffers: function() {\n\n\t\tvar tmp = this.readBuffer;\n\t\tthis.readBuffer = this.writeBuffer;\n\t\tthis.writeBuffer = tmp;\n\n\t},\n\n\taddPass: function ( pass ) {\n\n\t\tthis.passes.push( pass );\n\n\t},\n\n\tinsertPass: function ( pass, index ) {\n\n\t\tthis.passes.splice( index, 0, pass );\n\n\t},\n\n\trender: function ( delta ) {\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t\tvar maskActive = false;\n\n\t\tvar pass, i, il = this.passes.length;\n\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tpass = this.passes[ i ];\n\n\t\t\tif ( !pass.enabled ) continue;\n\n\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );\n\n\t\t\tif ( pass.needsSwap ) {\n\n\t\t\t\tif ( maskActive ) {\n\n\t\t\t\t\tvar context = this.renderer.context;\n\n\t\t\t\t\tcontext.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\n\n\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );\n\n\t\t\t\t\tcontext.stencilFunc( context.EQUAL, 1, 0xffffffff );\n\n\t\t\t\t}\n\n\t\t\t\tthis.swapBuffers();\n\n\t\t\t}\n\n\t\t\tif ( pass instanceof THREE.MaskPass ) {\n\n\t\t\t\tmaskActive = true;\n\n\t\t\t} else if ( pass instanceof THREE.ClearMaskPass ) {\n\n\t\t\t\tmaskActive = false;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\treset: function ( renderTarget ) {\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = this.renderTarget1.clone();\n\n\t\t\trenderTarget.width = window.innerWidth;\n\t\t\trenderTarget.height = window.innerHeight;\n\n\t\t}\n\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t},\n\n\tsetSize: function ( width, height ) {\n\n\t\tvar renderTarget = this.renderTarget1.clone();\n\n\t\trenderTarget.width = width;\n\t\trenderTarget.height = height;\n\n\t\tthis.reset( renderTarget );\n\n\t}\n\n};\n\n// shared ortho camera\n\nTHREE.EffectComposer.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );\n\nTHREE.EffectComposer.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );\n\nTHREE.EffectComposer.scene = new THREE.Scene();\nTHREE.EffectComposer.scene.add( THREE.EffectComposer.quad );\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.EffectComposer = function ( renderer, renderTarget ) {\n\n\tthis.renderer = renderer;\n\n\tif ( renderTarget === undefined ) {\n\n\t\tvar width = window.innerWidth || 1;\n\t\tvar height = window.innerHeight || 1;\n\t\tvar parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };\n\n\t\trenderTarget = new THREE.WebGLRenderTarget( width, height, parameters );\n\n\t}\n\n\tthis.renderTarget1 = renderTarget;\n\tthis.renderTarget2 = renderTarget.clone();\n\n\tthis.writeBuffer = this.renderTarget1;\n\tthis.readBuffer = this.renderTarget2;\n\n\tthis.passes = [];\n\n\tif ( THREE.CopyShader === undefined )\n\t\tconsole.error( \"THREE.EffectComposer relies on THREE.CopyShader\" );\n\n\tthis.copyPass = new THREE.ShaderPass( THREE.CopyShader );\n\n};\n\nTHREE.EffectComposer.prototype = {\n\n\tswapBuffers: function() {\n\n\t\tvar tmp = this.readBuffer;\n\t\tthis.readBuffer = this.writeBuffer;\n\t\tthis.writeBuffer = tmp;\n\n\t},\n\n\taddPass: function ( pass ) {\n\n\t\tthis.passes.push( pass );\n\n\t},\n\n\tinsertPass: function ( pass, index ) {\n\n\t\tthis.passes.splice( index, 0, pass );\n\n\t},\n\n\trender: function ( delta ) {\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t\tvar maskActive = false;\n\n\t\tvar pass, i, il = this.passes.length;\n\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tpass = this.passes[ i ];\n\n\t\t\tif ( !pass.enabled ) continue;\n\n\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );\n\n\t\t\tif ( pass.needsSwap ) {\n\n\t\t\t\tif ( maskActive ) {\n\n\t\t\t\t\tvar context = this.renderer.context;\n\n\t\t\t\t\tcontext.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\n\n\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );\n\n\t\t\t\t\tcontext.stencilFunc( context.EQUAL, 1, 0xffffffff );\n\n\t\t\t\t}\n\n\t\t\t\tthis.swapBuffers();\n\n\t\t\t}\n\n\t\t\tif ( pass instanceof THREE.MaskPass ) {\n\n\t\t\t\tmaskActive = true;\n\n\t\t\t} else if ( pass instanceof THREE.ClearMaskPass ) {\n\n\t\t\t\tmaskActive = false;\n\n\t\t\t}\n\n\t\t}\n\n\t},\n\n\treset: function ( renderTarget ) {\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\trenderTarget = this.renderTarget1.clone();\n\n\t\t\trenderTarget.width = window.innerWidth;\n\t\t\trenderTarget.height = window.innerHeight;\n\n\t\t}\n\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t},\n\n\tsetSize: function ( width, height ) {\n\n\t\tvar renderTarget = this.renderTarget1.clone();\n\n\t\trenderTarget.width = width;\n\t\trenderTarget.height = height;\n\n\t\tthis.reset( renderTarget );\n\n\t}\n\n};\n\n// shared ortho camera\n\nTHREE.EffectComposer.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );\n\nTHREE.EffectComposer.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );\n\nTHREE.EffectComposer.scene = new THREE.Scene();\nTHREE.EffectComposer.scene.add( THREE.EffectComposer.quad );\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "EffectComposer.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-post-EffectComposer",
      "url": "/js/post/EffectComposer.js",
      "urls": [
        "/js/post/EffectComposer.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post/FilmPass.js",
      "relativePath": "js/post/FilmPass.js",
      "basename": "FilmPass",
      "outBasename": "FilmPass",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "FilmPass.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post/FilmPass.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post",
      "outFilename": "FilmPass.js",
      "relativeOutPath": "js/post/FilmPass.js",
      "relativeDirPath": "js/post",
      "relativeOutDirPath": "js/post",
      "relativeBase": "js/post/FilmPass",
      "relativeOutBase": "js/post/FilmPass",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.611Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.FilmPass = function ( noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale ) {\n\n\tif ( THREE.FilmShader === undefined )\n\t\tconsole.error( \"THREE.FilmPass relies on THREE.FilmShader\" );\n\n\tvar shader = THREE.FilmShader;\n\n\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\tthis.material = new THREE.ShaderMaterial( {\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\n\t} );\n\n\tif ( grayscale !== undefined )\tthis.uniforms.grayscale.value = grayscale;\n\tif ( noiseIntensity !== undefined ) this.uniforms.nIntensity.value = noiseIntensity;\n\tif ( scanlinesIntensity !== undefined ) this.uniforms.sIntensity.value = scanlinesIntensity;\n\tif ( scanlinesCount !== undefined ) this.uniforms.sCount.value = scanlinesCount;\n\n\tthis.enabled = true;\n\tthis.renderToScreen = false;\n\tthis.needsSwap = true;\n\n};\n\nTHREE.FilmPass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\tthis.uniforms[ \"tDiffuse\" ].value = readBuffer;\n\t\tthis.uniforms[ \"time\" ].value += delta;\n\n\t\tTHREE.EffectComposer.quad.material = this.material;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera );\n\n\t\t} else {\n\n\t\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, writeBuffer, false );\n\n\t\t}\n\n\t}\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.FilmPass = function ( noiseIntensity, scanlinesIntensity, scanlinesCount, grayscale ) {\n\n\tif ( THREE.FilmShader === undefined )\n\t\tconsole.error( \"THREE.FilmPass relies on THREE.FilmShader\" );\n\n\tvar shader = THREE.FilmShader;\n\n\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\tthis.material = new THREE.ShaderMaterial( {\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\n\t} );\n\n\tif ( grayscale !== undefined )\tthis.uniforms.grayscale.value = grayscale;\n\tif ( noiseIntensity !== undefined ) this.uniforms.nIntensity.value = noiseIntensity;\n\tif ( scanlinesIntensity !== undefined ) this.uniforms.sIntensity.value = scanlinesIntensity;\n\tif ( scanlinesCount !== undefined ) this.uniforms.sCount.value = scanlinesCount;\n\n\tthis.enabled = true;\n\tthis.renderToScreen = false;\n\tthis.needsSwap = true;\n\n};\n\nTHREE.FilmPass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\tthis.uniforms[ \"tDiffuse\" ].value = readBuffer;\n\t\tthis.uniforms[ \"time\" ].value += delta;\n\n\t\tTHREE.EffectComposer.quad.material = this.material;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera );\n\n\t\t} else {\n\n\t\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, writeBuffer, false );\n\n\t\t}\n\n\t}\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "FilmPass.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-post-FilmPass",
      "url": "/js/post/FilmPass.js",
      "urls": [
        "/js/post/FilmPass.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post/MaskPass.js",
      "relativePath": "js/post/MaskPass.js",
      "basename": "MaskPass",
      "outBasename": "MaskPass",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "MaskPass.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post/MaskPass.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post",
      "outFilename": "MaskPass.js",
      "relativeOutPath": "js/post/MaskPass.js",
      "relativeDirPath": "js/post",
      "relativeOutDirPath": "js/post",
      "relativeBase": "js/post/MaskPass",
      "relativeOutBase": "js/post/MaskPass",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.608Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.MaskPass = function ( scene, camera ) {\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.enabled = true;\n\tthis.clear = true;\n\tthis.needsSwap = false;\n\n\tthis.inverse = false;\n\n};\n\nTHREE.MaskPass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\tvar context = renderer.context;\n\n\t\t// don't update color or depth\n\n\t\tcontext.colorMask( false, false, false, false );\n\t\tcontext.depthMask( false );\n\n\t\t// set up stencil\n\n\t\tvar writeValue, clearValue;\n\n\t\tif ( this.inverse ) {\n\n\t\t\twriteValue = 0;\n\t\t\tclearValue = 1;\n\n\t\t} else {\n\n\t\t\twriteValue = 1;\n\t\t\tclearValue = 0;\n\n\t\t}\n\n\t\tcontext.enable( context.STENCIL_TEST );\n\t\tcontext.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );\n\t\tcontext.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );\n\t\tcontext.clearStencil( clearValue );\n\n\t\t// draw into the stencil buffer\n\n\t\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\n\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\n\n\t\t// re-enable update of color and depth\n\n\t\tcontext.colorMask( true, true, true, true );\n\t\tcontext.depthMask( true );\n\n\t\t// only render where stencil is set to 1\n\n\t\tcontext.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1\n\t\tcontext.stencilOp( context.KEEP, context.KEEP, context.KEEP );\n\n\t}\n\n};\n\n\nTHREE.ClearMaskPass = function () {\n\n\tthis.enabled = true;\n\n};\n\nTHREE.ClearMaskPass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\tvar context = renderer.context;\n\n\t\tcontext.disable( context.STENCIL_TEST );\n\n\t}\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.MaskPass = function ( scene, camera ) {\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.enabled = true;\n\tthis.clear = true;\n\tthis.needsSwap = false;\n\n\tthis.inverse = false;\n\n};\n\nTHREE.MaskPass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\tvar context = renderer.context;\n\n\t\t// don't update color or depth\n\n\t\tcontext.colorMask( false, false, false, false );\n\t\tcontext.depthMask( false );\n\n\t\t// set up stencil\n\n\t\tvar writeValue, clearValue;\n\n\t\tif ( this.inverse ) {\n\n\t\t\twriteValue = 0;\n\t\t\tclearValue = 1;\n\n\t\t} else {\n\n\t\t\twriteValue = 1;\n\t\t\tclearValue = 0;\n\n\t\t}\n\n\t\tcontext.enable( context.STENCIL_TEST );\n\t\tcontext.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );\n\t\tcontext.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );\n\t\tcontext.clearStencil( clearValue );\n\n\t\t// draw into the stencil buffer\n\n\t\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\n\t\trenderer.render( this.scene, this.camera, writeBuffer, this.clear );\n\n\t\t// re-enable update of color and depth\n\n\t\tcontext.colorMask( true, true, true, true );\n\t\tcontext.depthMask( true );\n\n\t\t// only render where stencil is set to 1\n\n\t\tcontext.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1\n\t\tcontext.stencilOp( context.KEEP, context.KEEP, context.KEEP );\n\n\t}\n\n};\n\n\nTHREE.ClearMaskPass = function () {\n\n\tthis.enabled = true;\n\n};\n\nTHREE.ClearMaskPass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\tvar context = renderer.context;\n\n\t\tcontext.disable( context.STENCIL_TEST );\n\n\t}\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "MaskPass.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-post-MaskPass",
      "url": "/js/post/MaskPass.js",
      "urls": [
        "/js/post/MaskPass.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post/RenderPass.js",
      "relativePath": "js/post/RenderPass.js",
      "basename": "RenderPass",
      "outBasename": "RenderPass",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "RenderPass.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post/RenderPass.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post",
      "outFilename": "RenderPass.js",
      "relativeOutPath": "js/post/RenderPass.js",
      "relativeDirPath": "js/post",
      "relativeOutDirPath": "js/post",
      "relativeBase": "js/post/RenderPass",
      "relativeOutBase": "js/post/RenderPass",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.616Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.overrideMaterial = overrideMaterial;\n\n\tthis.clearColor = clearColor;\n\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;\n\n\tthis.oldClearColor = new THREE.Color();\n\tthis.oldClearAlpha = 1;\n\n\tthis.enabled = true;\n\tthis.clear = true;\n\tthis.needsSwap = false;\n\n};\n\nTHREE.RenderPass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\tif ( this.clearColor ) {\n\n\t\t\tthis.oldClearColor.copy( renderer.getClearColor() );\n\t\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\n\n\t\t}\n\n\t\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\n\n\t\tif ( this.clearColor ) {\n\n\t\t\trenderer.setClearColor( this.oldClearColor, this.oldClearAlpha );\n\n\t\t}\n\n\t\tthis.scene.overrideMaterial = null;\n\n\t}\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.overrideMaterial = overrideMaterial;\n\n\tthis.clearColor = clearColor;\n\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;\n\n\tthis.oldClearColor = new THREE.Color();\n\tthis.oldClearAlpha = 1;\n\n\tthis.enabled = true;\n\tthis.clear = true;\n\tthis.needsSwap = false;\n\n};\n\nTHREE.RenderPass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\tif ( this.clearColor ) {\n\n\t\t\tthis.oldClearColor.copy( renderer.getClearColor() );\n\t\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\n\n\t\t}\n\n\t\trenderer.render( this.scene, this.camera, readBuffer, this.clear );\n\n\t\tif ( this.clearColor ) {\n\n\t\t\trenderer.setClearColor( this.oldClearColor, this.oldClearAlpha );\n\n\t\t}\n\n\t\tthis.scene.overrideMaterial = null;\n\n\t}\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "RenderPass.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-post-RenderPass",
      "url": "/js/post/RenderPass.js",
      "urls": [
        "/js/post/RenderPass.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post/SavePass.js",
      "relativePath": "js/post/SavePass.js",
      "basename": "SavePass",
      "outBasename": "SavePass",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "SavePass.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post/SavePass.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post",
      "outFilename": "SavePass.js",
      "relativeOutPath": "js/post/SavePass.js",
      "relativeDirPath": "js/post",
      "relativeOutDirPath": "js/post",
      "relativeBase": "js/post/SavePass",
      "relativeOutBase": "js/post/SavePass",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.621Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SavePass = function ( renderTarget ) {\n\n\tif ( THREE.CopyShader === undefined )\n\t\tconsole.error( \"THREE.SavePass relies on THREE.CopyShader\" );\n\n\tvar shader = THREE.CopyShader;\n\n\tthis.textureID = \"tDiffuse\";\n\n\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\tthis.material = new THREE.ShaderMaterial( {\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\n\t} );\n\n\tthis.renderTarget = renderTarget;\n\n\tif ( this.renderTarget === undefined ) {\n\n\t\tthis.renderTargetParameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };\n\t\tthis.renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, this.renderTargetParameters );\n\n\t}\n\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\tthis.clear = false;\n\n};\n\nTHREE.SavePass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\tif ( this.uniforms[ this.textureID ] ) {\n\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer;\n\n\t\t}\n\n\t\tTHREE.EffectComposer.quad.material = this.material;\n\n\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTarget, this.clear );\n\n\t}\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.SavePass = function ( renderTarget ) {\n\n\tif ( THREE.CopyShader === undefined )\n\t\tconsole.error( \"THREE.SavePass relies on THREE.CopyShader\" );\n\n\tvar shader = THREE.CopyShader;\n\n\tthis.textureID = \"tDiffuse\";\n\n\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\tthis.material = new THREE.ShaderMaterial( {\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\n\t} );\n\n\tthis.renderTarget = renderTarget;\n\n\tif ( this.renderTarget === undefined ) {\n\n\t\tthis.renderTargetParameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };\n\t\tthis.renderTarget = new THREE.WebGLRenderTarget( window.innerWidth, window.innerHeight, this.renderTargetParameters );\n\n\t}\n\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\tthis.clear = false;\n\n};\n\nTHREE.SavePass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\tif ( this.uniforms[ this.textureID ] ) {\n\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer;\n\n\t\t}\n\n\t\tTHREE.EffectComposer.quad.material = this.material;\n\n\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTarget, this.clear );\n\n\t}\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "SavePass.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-post-SavePass",
      "url": "/js/post/SavePass.js",
      "urls": [
        "/js/post/SavePass.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post/ShaderPass.js",
      "relativePath": "js/post/ShaderPass.js",
      "basename": "ShaderPass",
      "outBasename": "ShaderPass",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "ShaderPass.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post/ShaderPass.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post",
      "outFilename": "ShaderPass.js",
      "relativeOutPath": "js/post/ShaderPass.js",
      "relativeDirPath": "js/post",
      "relativeOutDirPath": "js/post",
      "relativeBase": "js/post/ShaderPass",
      "relativeOutBase": "js/post/ShaderPass",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.635Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ShaderPass = function ( shader, textureID ) {\n\n\tthis.textureID = ( textureID !== undefined ) ? textureID : \"tDiffuse\";\n\n\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\tthis.material = new THREE.ShaderMaterial( {\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\n\t} );\n\n\tthis.renderToScreen = false;\n\n\tthis.enabled = true;\n\tthis.needsSwap = true;\n\tthis.clear = false;\n\n};\n\nTHREE.ShaderPass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\tif ( this.uniforms[ this.textureID ] ) {\n\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer;\n\n\t\t}\n\n\t\tTHREE.EffectComposer.quad.material = this.material;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera );\n\n\t\t} else {\n\n\t\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, writeBuffer, this.clear );\n\n\t\t}\n\n\t}\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ShaderPass = function ( shader, textureID ) {\n\n\tthis.textureID = ( textureID !== undefined ) ? textureID : \"tDiffuse\";\n\n\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\tthis.material = new THREE.ShaderMaterial( {\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\n\t} );\n\n\tthis.renderToScreen = false;\n\n\tthis.enabled = true;\n\tthis.needsSwap = true;\n\tthis.clear = false;\n\n};\n\nTHREE.ShaderPass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\tif ( this.uniforms[ this.textureID ] ) {\n\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer;\n\n\t\t}\n\n\t\tTHREE.EffectComposer.quad.material = this.material;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera );\n\n\t\t} else {\n\n\t\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, writeBuffer, this.clear );\n\n\t\t}\n\n\t}\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "ShaderPass.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-post-ShaderPass",
      "url": "/js/post/ShaderPass.js",
      "urls": [
        "/js/post/ShaderPass.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post/TexturePass.js",
      "relativePath": "js/post/TexturePass.js",
      "basename": "TexturePass",
      "outBasename": "TexturePass",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "TexturePass.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/post",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post/TexturePass.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/post",
      "outFilename": "TexturePass.js",
      "relativeOutPath": "js/post/TexturePass.js",
      "relativeDirPath": "js/post",
      "relativeOutDirPath": "js/post",
      "relativeBase": "js/post/TexturePass",
      "relativeOutBase": "js/post/TexturePass",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.639Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.TexturePass = function ( texture, opacity ) {\n\n\tif ( THREE.CopyShader === undefined )\n\t\tconsole.error( \"THREE.TexturePass relies on THREE.CopyShader\" );\n\n\tvar shader = THREE.CopyShader;\n\n\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\tthis.uniforms[ \"opacity\" ].value = ( opacity !== undefined ) ? opacity : 1.0;\n\tthis.uniforms[ \"tDiffuse\" ].value = texture;\n\n\tthis.material = new THREE.ShaderMaterial( {\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\n\t} );\n\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\n};\n\nTHREE.TexturePass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\tTHREE.EffectComposer.quad.material = this.material;\n\n\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, readBuffer );\n\n\t}\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.TexturePass = function ( texture, opacity ) {\n\n\tif ( THREE.CopyShader === undefined )\n\t\tconsole.error( \"THREE.TexturePass relies on THREE.CopyShader\" );\n\n\tvar shader = THREE.CopyShader;\n\n\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\tthis.uniforms[ \"opacity\" ].value = ( opacity !== undefined ) ? opacity : 1.0;\n\tthis.uniforms[ \"tDiffuse\" ].value = texture;\n\n\tthis.material = new THREE.ShaderMaterial( {\n\n\t\tuniforms: this.uniforms,\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader\n\n\t} );\n\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\n};\n\nTHREE.TexturePass.prototype = {\n\n\trender: function ( renderer, writeBuffer, readBuffer, delta ) {\n\n\t\tTHREE.EffectComposer.quad.material = this.material;\n\n\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, readBuffer );\n\n\t}\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "TexturePass.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-post-TexturePass",
      "url": "/js/post/TexturePass.js",
      "urls": [
        "/js/post/TexturePass.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/BasicShader.js",
      "relativePath": "js/shaders/BasicShader.js",
      "basename": "BasicShader",
      "outBasename": "BasicShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "BasicShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/BasicShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "BasicShader.js",
      "relativeOutPath": "js/shaders/BasicShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/BasicShader",
      "relativeOutBase": "js/shaders/BasicShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.648Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author mrdoob / http://www.mrdoob.com\n *\n * Simple test shader\n */\n\nTHREE.BasicShader = {\n\n\tuniforms: {},\n\n\tvertexShader: [\n\n\t\t\"void main() {\",\n\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"void main() {\",\n\n\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author mrdoob / http://www.mrdoob.com\n *\n * Simple test shader\n */\n\nTHREE.BasicShader = {\n\n\tuniforms: {},\n\n\tvertexShader: [\n\n\t\t\"void main() {\",\n\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"void main() {\",\n\n\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "BasicShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-BasicShader",
      "url": "/js/shaders/BasicShader.js",
      "urls": [
        "/js/shaders/BasicShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/BleachBypassShader.js",
      "relativePath": "js/shaders/BleachBypassShader.js",
      "basename": "BleachBypassShader",
      "outBasename": "BleachBypassShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "BleachBypassShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/BleachBypassShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "BleachBypassShader.js",
      "relativeOutPath": "js/shaders/BleachBypassShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/BleachBypassShader",
      "relativeOutBase": "js/shaders/BleachBypassShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.655Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass]\n * - based on Nvidia example\n * http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass\n */\n\nTHREE.BleachBypassShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"opacity\":  { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float opacity;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 base = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );\",\n\t\t\t\"float lum = dot( lumCoeff, base.rgb );\",\n\t\t\t\"vec3 blend = vec3( lum );\",\n\n\t\t\t\"float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );\",\n\n\t\t\t\"vec3 result1 = 2.0 * base.rgb * blend;\",\n\t\t\t\"vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );\",\n\n\t\t\t\"vec3 newColor = mix( result1, result2, L );\",\n\n\t\t\t\"float A2 = opacity * base.a;\",\n\t\t\t\"vec3 mixRGB = A2 * newColor.rgb;\",\n\t\t\t\"mixRGB += ( ( 1.0 - A2 ) * base.rgb );\",\n\n\t\t\t\"gl_FragColor = vec4( mixRGB, base.a );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Bleach bypass shader [http://en.wikipedia.org/wiki/Bleach_bypass]\n * - based on Nvidia example\n * http://developer.download.nvidia.com/shaderlibrary/webpages/shader_library.html#post_bleach_bypass\n */\n\nTHREE.BleachBypassShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"opacity\":  { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float opacity;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 base = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"vec3 lumCoeff = vec3( 0.25, 0.65, 0.1 );\",\n\t\t\t\"float lum = dot( lumCoeff, base.rgb );\",\n\t\t\t\"vec3 blend = vec3( lum );\",\n\n\t\t\t\"float L = min( 1.0, max( 0.0, 10.0 * ( lum - 0.45 ) ) );\",\n\n\t\t\t\"vec3 result1 = 2.0 * base.rgb * blend;\",\n\t\t\t\"vec3 result2 = 1.0 - 2.0 * ( 1.0 - blend ) * ( 1.0 - base.rgb );\",\n\n\t\t\t\"vec3 newColor = mix( result1, result2, L );\",\n\n\t\t\t\"float A2 = opacity * base.a;\",\n\t\t\t\"vec3 mixRGB = A2 * newColor.rgb;\",\n\t\t\t\"mixRGB += ( ( 1.0 - A2 ) * base.rgb );\",\n\n\t\t\t\"gl_FragColor = vec4( mixRGB, base.a );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "BleachBypassShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-BleachBypassShader",
      "url": "/js/shaders/BleachBypassShader.js",
      "urls": [
        "/js/shaders/BleachBypassShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/BlendShader.js",
      "relativePath": "js/shaders/BlendShader.js",
      "basename": "BlendShader",
      "outBasename": "BlendShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "BlendShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/BlendShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "BlendShader.js",
      "relativeOutPath": "js/shaders/BlendShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/BlendShader",
      "relativeOutBase": "js/shaders/BlendShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.671Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Blend two textures\n */\n\nTHREE.BlendShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse1\": { type: \"t\", value: null },\n\t\t\"tDiffuse2\": { type: \"t\", value: null },\n\t\t\"mixRatio\":  { type: \"f\", value: 0.5 },\n\t\t\"opacity\":   { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float opacity;\",\n\t\t\"uniform float mixRatio;\",\n\n\t\t\"uniform sampler2D tDiffuse1;\",\n\t\t\"uniform sampler2D tDiffuse2;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 texel1 = texture2D( tDiffuse1, vUv );\",\n\t\t\t\"vec4 texel2 = texture2D( tDiffuse2, vUv );\",\n\t\t\t\"gl_FragColor = opacity * mix( texel1, texel2, mixRatio );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Blend two textures\n */\n\nTHREE.BlendShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse1\": { type: \"t\", value: null },\n\t\t\"tDiffuse2\": { type: \"t\", value: null },\n\t\t\"mixRatio\":  { type: \"f\", value: 0.5 },\n\t\t\"opacity\":   { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float opacity;\",\n\t\t\"uniform float mixRatio;\",\n\n\t\t\"uniform sampler2D tDiffuse1;\",\n\t\t\"uniform sampler2D tDiffuse2;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 texel1 = texture2D( tDiffuse1, vUv );\",\n\t\t\t\"vec4 texel2 = texture2D( tDiffuse2, vUv );\",\n\t\t\t\"gl_FragColor = opacity * mix( texel1, texel2, mixRatio );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "BlendShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-BlendShader",
      "url": "/js/shaders/BlendShader.js",
      "urls": [
        "/js/shaders/BlendShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/BokehShader.js",
      "relativePath": "js/shaders/BokehShader.js",
      "basename": "BokehShader",
      "outBasename": "BokehShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "BokehShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/BokehShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "BokehShader.js",
      "relativeOutPath": "js/shaders/BokehShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/BokehShader",
      "relativeOutBase": "js/shaders/BokehShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.676Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html\n */\n\nTHREE.BokehShader = {\n\n\tuniforms: {\n\n\t\t\"tColor\":   { type: \"t\", value: null },\n\t\t\"tDepth\":   { type: \"t\", value: null },\n\t\t\"focus\":    { type: \"f\", value: 1.0 },\n\t\t\"aspect\":   { type: \"f\", value: 1.0 },\n\t\t\"aperture\": { type: \"f\", value: 0.025 },\n\t\t\"maxblur\":  { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"uniform sampler2D tColor;\",\n\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\"uniform float maxblur;\",  // max blur amount\n\t\t\"uniform float aperture;\", // aperture - bigger values for shallower depth of field\n\n\t\t\"uniform float focus;\",\n\t\t\"uniform float aspect;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec2 aspectcorrect = vec2( 1.0, aspect );\",\n\n\t\t\t\"vec4 depth1 = texture2D( tDepth, vUv );\",\n\n\t\t\t\"float factor = depth1.x - focus;\",\n\n\t\t\t\"vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\",\n\n\t\t\t\"vec2 dofblur9 = dofblur * 0.9;\",\n\t\t\t\"vec2 dofblur7 = dofblur * 0.7;\",\n\t\t\t\"vec2 dofblur4 = dofblur * 0.4;\",\n\n\t\t\t\"vec4 col = vec4( 0.0 );\",\n\n\t\t\t\"col += texture2D( tColor, vUv.xy );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\",\n\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\",\n\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\",\n\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\",\n\n\t\t\t\"gl_FragColor = col / 41.0;\",\n\t\t\t\"gl_FragColor.a = 1.0;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html\n */\n\nTHREE.BokehShader = {\n\n\tuniforms: {\n\n\t\t\"tColor\":   { type: \"t\", value: null },\n\t\t\"tDepth\":   { type: \"t\", value: null },\n\t\t\"focus\":    { type: \"f\", value: 1.0 },\n\t\t\"aspect\":   { type: \"f\", value: 1.0 },\n\t\t\"aperture\": { type: \"f\", value: 0.025 },\n\t\t\"maxblur\":  { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"uniform sampler2D tColor;\",\n\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\"uniform float maxblur;\",  // max blur amount\n\t\t\"uniform float aperture;\", // aperture - bigger values for shallower depth of field\n\n\t\t\"uniform float focus;\",\n\t\t\"uniform float aspect;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec2 aspectcorrect = vec2( 1.0, aspect );\",\n\n\t\t\t\"vec4 depth1 = texture2D( tDepth, vUv );\",\n\n\t\t\t\"float factor = depth1.x - focus;\",\n\n\t\t\t\"vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );\",\n\n\t\t\t\"vec2 dofblur9 = dofblur * 0.9;\",\n\t\t\t\"vec2 dofblur7 = dofblur * 0.7;\",\n\t\t\t\"vec2 dofblur4 = dofblur * 0.4;\",\n\n\t\t\t\"vec4 col = vec4( 0.0 );\",\n\n\t\t\t\"col += texture2D( tColor, vUv.xy );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );\",\n\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );\",\n\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );\",\n\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );\",\n\t\t\t\"col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );\",\n\n\t\t\t\"gl_FragColor = col / 41.0;\",\n\t\t\t\"gl_FragColor.a = 1.0;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "BokehShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-BokehShader",
      "url": "/js/shaders/BokehShader.js",
      "urls": [
        "/js/shaders/BokehShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/BokehShader2.js",
      "relativePath": "js/shaders/BokehShader2.js",
      "basename": "BokehShader2",
      "outBasename": "BokehShader2",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "BokehShader2.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/BokehShader2.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "BokehShader2.js",
      "relativeOutPath": "js/shaders/BokehShader2.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/BokehShader2",
      "relativeOutBase": "js/shaders/BokehShader2",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.682Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author zz85 / https://github.com/zz85 | twitter.com/blurspline\n *\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n *\n * Requires #define RINGS and SAMPLES integers\n */\n\n\n\nTHREE.BokehShader = {\n\n\tuniforms: {\n\n\t\t\"textureWidth\":  { type: \"f\", value: 1.0 },\n\t\t\"textureHeight\":  { type: \"f\", value: 1.0 },\n\n\t\t\"focalDepth\":   { type: \"f\", value: 1.0 },\n\t\t\"focalLength\":   { type: \"f\", value: 24.0 },\n\t\t\"fstop\": { type: \"f\", value: 0.9 },\n\n\t\t\"tColor\":   { type: \"t\", value: null },\n\t\t\"tDepth\":   { type: \"t\", value: null },\n\n\t\t\"maxblur\":  { type: \"f\", value: 1.0 },\n\n\t\t\"showFocus\":   { type: \"i\", value: 0 },\n\t\t\"manualdof\":   { type: \"i\", value: 0 },\n\t\t\"vignetting\":   { type: \"i\", value: 0 },\n\t\t\"depthblur\":   { type: \"i\", value: 0 },\n\n\t\t\"threshold\":  { type: \"f\", value: 0.5 },\n\t\t\"gain\":  { type: \"f\", value: 2.0 },\n\t\t\"bias\":  { type: \"f\", value: 0.5 },\n\t\t\"fringe\":  { type: \"f\", value: 0.7 },\n\n\t\t\"znear\":  { type: \"f\", value: 0.1 },\n\t\t\"zfar\":  { type: \"f\", value: 100 },\n\n\t\t\"noise\":  { type: \"i\", value: 1 },\n\t\t\"dithering\":  { type: \"f\", value: 0.0001 },\n\t\t\"pentagon\": { type: \"i\", value: 0 },\n\n\t\t\"shaderFocus\":  { type: \"i\", value: 1 },\n\t\t\"focusCoords\":  { type: \"v2\", value: new THREE.Vector2()},\n\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"uniform sampler2D tColor;\",\n\t\t\"uniform sampler2D tDepth;\",\n\t\t\"uniform float textureWidth;\",\n\t\t\"uniform float textureHeight;\",\n\n\t\t\"const float PI = 3.14159265;\",\n\n\t\t\"float width = textureWidth; //texture width\",\n\t\t\"float height = textureHeight; //texture height\",\n\n\t\t\"vec2 texel = vec2(1.0/width,1.0/height);\",\n\n\t\t\"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\",\n\t\t\"uniform float focalLength; //focal length in mm\",\n\t\t\"uniform float fstop; //f-stop value\",\n\t\t\"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\",\n\n\t\t\"/*\",\n\t\t\"make sure that these two values are the same for your camera, otherwise distances will be wrong.\",\n\t\t\"*/\",\n\n\t\t\"uniform float znear; // camera clipping start\",\n\t\t\"uniform float zfar; // camera clipping end\",\n\n\t\t\"//------------------------------------------\",\n\t\t\"//user variables\",\n\n\t\t\"const int samples = SAMPLES; //samples on the first ring\",\n\t\t\"const int rings = RINGS; //ring count\",\n\n\t\t\"const int maxringsamples = rings * samples;\",\n\n\t\t\"uniform bool manualdof; // manual dof calculation\",\n\t\t\"float ndofstart = 1.0; // near dof blur start\",\n\t\t\"float ndofdist = 2.0; // near dof blur falloff distance\",\n\t\t\"float fdofstart = 1.0; // far dof blur start\",\n\t\t\"float fdofdist = 3.0; // far dof blur falloff distance\",\n\n\t\t\"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\",\n\n\t\t\"uniform bool vignetting; // use optical lens vignetting\",\n\n\t\t\"float vignout = 1.3; // vignetting outer border\",\n\t\t\"float vignin = 0.0; // vignetting inner border\",\n\t\t\"float vignfade = 22.0; // f-stops till vignete fades\",\n\n\t\t\"uniform bool shaderFocus;\",\n\n\t\t\"bool autofocus = shaderFocus;\",\n\t\t\"//use autofocus in shader - use with focusCoords\",\n\t\t\"// disable if you use external focalDepth value\",\n\n\t\t\"uniform vec2 focusCoords;\",\n\t\t\"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\",\n\t\t\"// if center of screen use vec2(0.5, 0.5);\",\n\n\t\t\"uniform float maxblur;\",\n\t\t\"//clamp value of max blur (0.0 = no blur, 1.0 default)\",\n\n\t\t\"uniform float threshold; // highlight threshold;\",\n\t\t\"uniform float gain; // highlight gain;\",\n\n\t\t\"uniform float bias; // bokeh edge bias\",\n\t\t\"uniform float fringe; // bokeh chromatic aberration / fringing\",\n\n\t\t\"uniform bool noise; //use noise instead of pattern for sample dithering\",\n\n\t\t\"uniform float dithering;\",\n\t\t\"float namount = dithering; //dither amount\",\n\n\t\t\"uniform bool depthblur; // blur the depth buffer\",\n\t\t\"float dbsize = 1.25; // depth blur size\",\n\n\t\t\"/*\",\n\t\t\"next part is experimental\",\n\t\t\"not looking good with small sample and ring count\",\n\t\t\"looks okay starting from samples = 4, rings = 4\",\n\t\t\"*/\",\n\n\t\t\"uniform bool pentagon; //use pentagon as bokeh shape?\",\n\t\t\"float feather = 0.4; //pentagon shape feather\",\n\n\t\t\"//------------------------------------------\",\n\n\t\t\"float penta(vec2 coords) {\",\n\t\t\t\"//pentagonal shape\",\n\t\t\t\"float scale = float(rings) - 1.3;\",\n\t\t\t\"vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\",\n\t\t\t\"vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\",\n\t\t\t\"vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\",\n\t\t\t\"vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\",\n\t\t\t\"vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\",\n\t\t\t\"vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\",\n\n\t\t\t\"vec4  one = vec4( 1.0 );\",\n\n\t\t\t\"vec4 P = vec4((coords),vec2(scale, scale));\",\n\n\t\t\t\"vec4 dist = vec4(0.0);\",\n\t\t\t\"float inorout = -4.0;\",\n\n\t\t\t\"dist.x = dot( P, HS0 );\",\n\t\t\t\"dist.y = dot( P, HS1 );\",\n\t\t\t\"dist.z = dot( P, HS2 );\",\n\t\t\t\"dist.w = dot( P, HS3 );\",\n\n\t\t\t\"dist = smoothstep( -feather, feather, dist );\",\n\n\t\t\t\"inorout += dot( dist, one );\",\n\n\t\t\t\"dist.x = dot( P, HS4 );\",\n\t\t\t\"dist.y = HS5.w - abs( P.z );\",\n\n\t\t\t\"dist = smoothstep( -feather, feather, dist );\",\n\t\t\t\"inorout += dist.x;\",\n\n\t\t\t\"return clamp( inorout, 0.0, 1.0 );\",\n\t\t\"}\",\n\n\t\t\"float bdepth(vec2 coords) {\",\n\t\t\t\"// Depth buffer blur\",\n\t\t\t\"float d = 0.0;\",\n\t\t\t\"float kernel[9];\",\n\t\t\t\"vec2 offset[9];\",\n\n\t\t\t\"vec2 wh = vec2(texel.x, texel.y) * dbsize;\",\n\n\t\t\t\"offset[0] = vec2(-wh.x,-wh.y);\",\n\t\t\t\"offset[1] = vec2( 0.0, -wh.y);\",\n\t\t\t\"offset[2] = vec2( wh.x -wh.y);\",\n\n\t\t\t\"offset[3] = vec2(-wh.x,  0.0);\",\n\t\t\t\"offset[4] = vec2( 0.0,   0.0);\",\n\t\t\t\"offset[5] = vec2( wh.x,  0.0);\",\n\n\t\t\t\"offset[6] = vec2(-wh.x, wh.y);\",\n\t\t\t\"offset[7] = vec2( 0.0,  wh.y);\",\n\t\t\t\"offset[8] = vec2( wh.x, wh.y);\",\n\n\t\t\t\"kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\",\n\t\t\t\"kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\",\n\t\t\t\"kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\",\n\n\n\t\t\t\"for( int i=0; i<9; i++ ) {\",\n\t\t\t\t\"float tmp = texture2D(tDepth, coords + offset[i]).r;\",\n\t\t\t\t\"d += tmp * kernel[i];\",\n\t\t\t\"}\",\n\n\t\t\t\"return d;\",\n\t\t\"}\",\n\n\n\t\t\"vec3 color(vec2 coords,float blur) {\",\n\t\t\t\"//processing the sample\",\n\n\t\t\t\"vec3 col = vec3(0.0);\",\n\n\t\t\t\"col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\",\n\t\t\t\"col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\",\n\t\t\t\"col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\",\n\n\t\t\t\"vec3 lumcoeff = vec3(0.299,0.587,0.114);\",\n\t\t\t\"float lum = dot(col.rgb, lumcoeff);\",\n\t\t\t\"float thresh = max((lum-threshold)*gain, 0.0);\",\n\t\t\t\"return col+mix(vec3(0.0),col,thresh*blur);\",\n\t\t\"}\",\n\n\t\t\"vec2 rand(vec2 coord) {\",\n\t\t\t\"// generating noise / pattern texture for dithering\",\n\n\t\t\t\"float noiseX = ((fract(1.0-coord.s*(width/2.0))*0.25)+(fract(coord.t*(height/2.0))*0.75))*2.0-1.0;\",\n\t\t\t\"float noiseY = ((fract(1.0-coord.s*(width/2.0))*0.75)+(fract(coord.t*(height/2.0))*0.25))*2.0-1.0;\",\n\n\t\t\t\"if (noise) {\",\n\t\t\t\t\"noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;\",\n\t\t\t\t\"noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;\",\n\t\t\t\"}\",\n\n\t\t\t\"return vec2(noiseX,noiseY);\",\n\t\t\"}\",\n\n\t\t\"vec3 debugFocus(vec3 col, float blur, float depth) {\",\n\t\t\t\"float edge = 0.002*depth; //distance based edge smoothing\",\n\t\t\t\"float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\",\n\t\t\t\"float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\",\n\n\t\t\t\"col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\",\n\t\t\t\"col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\",\n\n\t\t\t\"return col;\",\n\t\t\"}\",\n\n\t\t\"float linearize(float depth) {\",\n\t\t\t\"return -zfar * znear / (depth * (zfar - znear) - zfar);\",\n\t\t\"}\",\n\n\n\t\t\"float vignette() {\",\n\t\t\t\"float dist = distance(vUv.xy, vec2(0.5,0.5));\",\n\t\t\t\"dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\",\n\t\t\t\"return clamp(dist,0.0,1.0);\",\n\t\t\"}\",\n\n\t\t\"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\",\n\t\t\t\"float rings2 = float(rings);\",\n\t\t\t\"float step = PI*2.0 / float(ringsamples);\",\n\t\t\t\"float pw = cos(j*step)*i;\",\n\t\t\t\"float ph = sin(j*step)*i;\",\n\t\t\t\"float p = 1.0;\",\n\t\t\t\"if (pentagon) {\",\n\t\t\t\t\"p = penta(vec2(pw,ph));\",\n\t\t\t\"}\",\n\t\t\t\"col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\",\n\t\t\t\"return 1.0 * mix(1.0, i /rings2, bias) * p;\",\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\t\t\t\"//scene depth calculation\",\n\n\t\t\t\"float depth = linearize(texture2D(tDepth,vUv.xy).x);\",\n\n\t\t\t\"// Blur depth?\",\n\t\t\t\"if (depthblur) {\",\n\t\t\t\t\"depth = linearize(bdepth(vUv.xy));\",\n\t\t\t\"}\",\n\n\t\t\t\"//focal plane calculation\",\n\n\t\t\t\"float fDepth = focalDepth;\",\n\n\t\t\t\"if (autofocus) {\",\n\n\t\t\t\t\"fDepth = linearize(texture2D(tDepth,focusCoords).x);\",\n\n\t\t\t\"}\",\n\n\t\t\t\"// dof blur factor calculation\",\n\n\t\t\t\"float blur = 0.0;\",\n\n\t\t\t\"if (manualdof) {\",\n\t\t\t\t\"float a = depth-fDepth; // Focal plane\",\n\t\t\t\t\"float b = (a-fdofstart)/fdofdist; // Far DoF\",\n\t\t\t\t\"float c = (-a-ndofstart)/ndofdist; // Near Dof\",\n\t\t\t\t\"blur = (a>0.0) ? b : c;\",\n\t\t\t\"} else {\",\n\t\t\t\t\"float f = focalLength; // focal length in mm\",\n\t\t\t\t\"float d = fDepth*1000.0; // focal plane in mm\",\n\t\t\t\t\"float o = depth*1000.0; // depth in mm\",\n\n\t\t\t\t\"float a = (o*f)/(o-f);\",\n\t\t\t\t\"float b = (d*f)/(d-f);\",\n\t\t\t\t\"float c = (d-f)/(d*fstop*CoC);\",\n\n\t\t\t\t\"blur = abs(a-b)*c;\",\n\t\t\t\"}\",\n\n\t\t\t\"blur = clamp(blur,0.0,1.0);\",\n\n\t\t\t\"// calculation of pattern for dithering\",\n\n\t\t\t\"vec2 noise = rand(vUv.xy)*namount*blur;\",\n\n\t\t\t\"// getting blur x and y step factor\",\n\n\t\t\t\"float w = (1.0/width)*blur*maxblur+noise.x;\",\n\t\t\t\"float h = (1.0/height)*blur*maxblur+noise.y;\",\n\n\t\t\t\"// calculation of final color\",\n\n\t\t\t\"vec3 col = vec3(0.0);\",\n\n\t\t\t\"if(blur < 0.05) {\",\n\t\t\t\t\"//some optimization thingy\",\n\t\t\t\t\"col = texture2D(tColor, vUv.xy).rgb;\",\n\t\t\t\"} else {\",\n\t\t\t\t\"col = texture2D(tColor, vUv.xy).rgb;\",\n\t\t\t\t\"float s = 1.0;\",\n\t\t\t\t\"int ringsamples;\",\n\n\t\t\t\t\"for (int i = 1; i <= rings; i++) {\",\n\t\t\t\t\t\"/*unboxstart*/\",\n\t\t\t\t\t\"ringsamples = i * samples;\",\n\n\t\t\t\t\t\"for (int j = 0 ; j < maxringsamples ; j++) {\",\n\t\t\t\t\t\t\"if (j >= ringsamples) break;\",\n\t\t\t\t\t\t\"s += gather(float(i), float(j), ringsamples, col, w, h, blur);\",\n\t\t\t\t\t\"}\",\n\t\t\t\t\t\"/*unboxend*/\",\n\t\t\t\t\"}\",\n\n\t\t\t\t\"col /= s; //divide by sample count\",\n\t\t\t\"}\",\n\n\t\t\t\"if (showFocus) {\",\n\t\t\t\t\"col = debugFocus(col, blur, depth);\",\n\t\t\t\"}\",\n\n\t\t\t\"if (vignetting) {\",\n\t\t\t\t\"col *= vignette();\",\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor.rgb = col;\",\n\t\t\t\"gl_FragColor.a = 1.0;\",\n\t\t\"} \"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author zz85 / https://github.com/zz85 | twitter.com/blurspline\n *\n * Depth-of-field shader with bokeh\n * ported from GLSL shader by Martins Upitis\n * http://blenderartists.org/forum/showthread.php?237488-GLSL-depth-of-field-with-bokeh-v2-4-(update)\n *\n * Requires #define RINGS and SAMPLES integers\n */\n\n\n\nTHREE.BokehShader = {\n\n\tuniforms: {\n\n\t\t\"textureWidth\":  { type: \"f\", value: 1.0 },\n\t\t\"textureHeight\":  { type: \"f\", value: 1.0 },\n\n\t\t\"focalDepth\":   { type: \"f\", value: 1.0 },\n\t\t\"focalLength\":   { type: \"f\", value: 24.0 },\n\t\t\"fstop\": { type: \"f\", value: 0.9 },\n\n\t\t\"tColor\":   { type: \"t\", value: null },\n\t\t\"tDepth\":   { type: \"t\", value: null },\n\n\t\t\"maxblur\":  { type: \"f\", value: 1.0 },\n\n\t\t\"showFocus\":   { type: \"i\", value: 0 },\n\t\t\"manualdof\":   { type: \"i\", value: 0 },\n\t\t\"vignetting\":   { type: \"i\", value: 0 },\n\t\t\"depthblur\":   { type: \"i\", value: 0 },\n\n\t\t\"threshold\":  { type: \"f\", value: 0.5 },\n\t\t\"gain\":  { type: \"f\", value: 2.0 },\n\t\t\"bias\":  { type: \"f\", value: 0.5 },\n\t\t\"fringe\":  { type: \"f\", value: 0.7 },\n\n\t\t\"znear\":  { type: \"f\", value: 0.1 },\n\t\t\"zfar\":  { type: \"f\", value: 100 },\n\n\t\t\"noise\":  { type: \"i\", value: 1 },\n\t\t\"dithering\":  { type: \"f\", value: 0.0001 },\n\t\t\"pentagon\": { type: \"i\", value: 0 },\n\n\t\t\"shaderFocus\":  { type: \"i\", value: 1 },\n\t\t\"focusCoords\":  { type: \"v2\", value: new THREE.Vector2()},\n\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"uniform sampler2D tColor;\",\n\t\t\"uniform sampler2D tDepth;\",\n\t\t\"uniform float textureWidth;\",\n\t\t\"uniform float textureHeight;\",\n\n\t\t\"const float PI = 3.14159265;\",\n\n\t\t\"float width = textureWidth; //texture width\",\n\t\t\"float height = textureHeight; //texture height\",\n\n\t\t\"vec2 texel = vec2(1.0/width,1.0/height);\",\n\n\t\t\"uniform float focalDepth;  //focal distance value in meters, but you may use autofocus option below\",\n\t\t\"uniform float focalLength; //focal length in mm\",\n\t\t\"uniform float fstop; //f-stop value\",\n\t\t\"uniform bool showFocus; //show debug focus point and focal range (red = focal point, green = focal range)\",\n\n\t\t\"/*\",\n\t\t\"make sure that these two values are the same for your camera, otherwise distances will be wrong.\",\n\t\t\"*/\",\n\n\t\t\"uniform float znear; // camera clipping start\",\n\t\t\"uniform float zfar; // camera clipping end\",\n\n\t\t\"//------------------------------------------\",\n\t\t\"//user variables\",\n\n\t\t\"const int samples = SAMPLES; //samples on the first ring\",\n\t\t\"const int rings = RINGS; //ring count\",\n\n\t\t\"const int maxringsamples = rings * samples;\",\n\n\t\t\"uniform bool manualdof; // manual dof calculation\",\n\t\t\"float ndofstart = 1.0; // near dof blur start\",\n\t\t\"float ndofdist = 2.0; // near dof blur falloff distance\",\n\t\t\"float fdofstart = 1.0; // far dof blur start\",\n\t\t\"float fdofdist = 3.0; // far dof blur falloff distance\",\n\n\t\t\"float CoC = 0.03; //circle of confusion size in mm (35mm film = 0.03mm)\",\n\n\t\t\"uniform bool vignetting; // use optical lens vignetting\",\n\n\t\t\"float vignout = 1.3; // vignetting outer border\",\n\t\t\"float vignin = 0.0; // vignetting inner border\",\n\t\t\"float vignfade = 22.0; // f-stops till vignete fades\",\n\n\t\t\"uniform bool shaderFocus;\",\n\n\t\t\"bool autofocus = shaderFocus;\",\n\t\t\"//use autofocus in shader - use with focusCoords\",\n\t\t\"// disable if you use external focalDepth value\",\n\n\t\t\"uniform vec2 focusCoords;\",\n\t\t\"// autofocus point on screen (0.0,0.0 - left lower corner, 1.0,1.0 - upper right)\",\n\t\t\"// if center of screen use vec2(0.5, 0.5);\",\n\n\t\t\"uniform float maxblur;\",\n\t\t\"//clamp value of max blur (0.0 = no blur, 1.0 default)\",\n\n\t\t\"uniform float threshold; // highlight threshold;\",\n\t\t\"uniform float gain; // highlight gain;\",\n\n\t\t\"uniform float bias; // bokeh edge bias\",\n\t\t\"uniform float fringe; // bokeh chromatic aberration / fringing\",\n\n\t\t\"uniform bool noise; //use noise instead of pattern for sample dithering\",\n\n\t\t\"uniform float dithering;\",\n\t\t\"float namount = dithering; //dither amount\",\n\n\t\t\"uniform bool depthblur; // blur the depth buffer\",\n\t\t\"float dbsize = 1.25; // depth blur size\",\n\n\t\t\"/*\",\n\t\t\"next part is experimental\",\n\t\t\"not looking good with small sample and ring count\",\n\t\t\"looks okay starting from samples = 4, rings = 4\",\n\t\t\"*/\",\n\n\t\t\"uniform bool pentagon; //use pentagon as bokeh shape?\",\n\t\t\"float feather = 0.4; //pentagon shape feather\",\n\n\t\t\"//------------------------------------------\",\n\n\t\t\"float penta(vec2 coords) {\",\n\t\t\t\"//pentagonal shape\",\n\t\t\t\"float scale = float(rings) - 1.3;\",\n\t\t\t\"vec4  HS0 = vec4( 1.0,         0.0,         0.0,  1.0);\",\n\t\t\t\"vec4  HS1 = vec4( 0.309016994, 0.951056516, 0.0,  1.0);\",\n\t\t\t\"vec4  HS2 = vec4(-0.809016994, 0.587785252, 0.0,  1.0);\",\n\t\t\t\"vec4  HS3 = vec4(-0.809016994,-0.587785252, 0.0,  1.0);\",\n\t\t\t\"vec4  HS4 = vec4( 0.309016994,-0.951056516, 0.0,  1.0);\",\n\t\t\t\"vec4  HS5 = vec4( 0.0        ,0.0         , 1.0,  1.0);\",\n\n\t\t\t\"vec4  one = vec4( 1.0 );\",\n\n\t\t\t\"vec4 P = vec4((coords),vec2(scale, scale));\",\n\n\t\t\t\"vec4 dist = vec4(0.0);\",\n\t\t\t\"float inorout = -4.0;\",\n\n\t\t\t\"dist.x = dot( P, HS0 );\",\n\t\t\t\"dist.y = dot( P, HS1 );\",\n\t\t\t\"dist.z = dot( P, HS2 );\",\n\t\t\t\"dist.w = dot( P, HS3 );\",\n\n\t\t\t\"dist = smoothstep( -feather, feather, dist );\",\n\n\t\t\t\"inorout += dot( dist, one );\",\n\n\t\t\t\"dist.x = dot( P, HS4 );\",\n\t\t\t\"dist.y = HS5.w - abs( P.z );\",\n\n\t\t\t\"dist = smoothstep( -feather, feather, dist );\",\n\t\t\t\"inorout += dist.x;\",\n\n\t\t\t\"return clamp( inorout, 0.0, 1.0 );\",\n\t\t\"}\",\n\n\t\t\"float bdepth(vec2 coords) {\",\n\t\t\t\"// Depth buffer blur\",\n\t\t\t\"float d = 0.0;\",\n\t\t\t\"float kernel[9];\",\n\t\t\t\"vec2 offset[9];\",\n\n\t\t\t\"vec2 wh = vec2(texel.x, texel.y) * dbsize;\",\n\n\t\t\t\"offset[0] = vec2(-wh.x,-wh.y);\",\n\t\t\t\"offset[1] = vec2( 0.0, -wh.y);\",\n\t\t\t\"offset[2] = vec2( wh.x -wh.y);\",\n\n\t\t\t\"offset[3] = vec2(-wh.x,  0.0);\",\n\t\t\t\"offset[4] = vec2( 0.0,   0.0);\",\n\t\t\t\"offset[5] = vec2( wh.x,  0.0);\",\n\n\t\t\t\"offset[6] = vec2(-wh.x, wh.y);\",\n\t\t\t\"offset[7] = vec2( 0.0,  wh.y);\",\n\t\t\t\"offset[8] = vec2( wh.x, wh.y);\",\n\n\t\t\t\"kernel[0] = 1.0/16.0;   kernel[1] = 2.0/16.0;   kernel[2] = 1.0/16.0;\",\n\t\t\t\"kernel[3] = 2.0/16.0;   kernel[4] = 4.0/16.0;   kernel[5] = 2.0/16.0;\",\n\t\t\t\"kernel[6] = 1.0/16.0;   kernel[7] = 2.0/16.0;   kernel[8] = 1.0/16.0;\",\n\n\n\t\t\t\"for( int i=0; i<9; i++ ) {\",\n\t\t\t\t\"float tmp = texture2D(tDepth, coords + offset[i]).r;\",\n\t\t\t\t\"d += tmp * kernel[i];\",\n\t\t\t\"}\",\n\n\t\t\t\"return d;\",\n\t\t\"}\",\n\n\n\t\t\"vec3 color(vec2 coords,float blur) {\",\n\t\t\t\"//processing the sample\",\n\n\t\t\t\"vec3 col = vec3(0.0);\",\n\n\t\t\t\"col.r = texture2D(tColor,coords + vec2(0.0,1.0)*texel*fringe*blur).r;\",\n\t\t\t\"col.g = texture2D(tColor,coords + vec2(-0.866,-0.5)*texel*fringe*blur).g;\",\n\t\t\t\"col.b = texture2D(tColor,coords + vec2(0.866,-0.5)*texel*fringe*blur).b;\",\n\n\t\t\t\"vec3 lumcoeff = vec3(0.299,0.587,0.114);\",\n\t\t\t\"float lum = dot(col.rgb, lumcoeff);\",\n\t\t\t\"float thresh = max((lum-threshold)*gain, 0.0);\",\n\t\t\t\"return col+mix(vec3(0.0),col,thresh*blur);\",\n\t\t\"}\",\n\n\t\t\"vec2 rand(vec2 coord) {\",\n\t\t\t\"// generating noise / pattern texture for dithering\",\n\n\t\t\t\"float noiseX = ((fract(1.0-coord.s*(width/2.0))*0.25)+(fract(coord.t*(height/2.0))*0.75))*2.0-1.0;\",\n\t\t\t\"float noiseY = ((fract(1.0-coord.s*(width/2.0))*0.75)+(fract(coord.t*(height/2.0))*0.25))*2.0-1.0;\",\n\n\t\t\t\"if (noise) {\",\n\t\t\t\t\"noiseX = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;\",\n\t\t\t\t\"noiseY = clamp(fract(sin(dot(coord ,vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;\",\n\t\t\t\"}\",\n\n\t\t\t\"return vec2(noiseX,noiseY);\",\n\t\t\"}\",\n\n\t\t\"vec3 debugFocus(vec3 col, float blur, float depth) {\",\n\t\t\t\"float edge = 0.002*depth; //distance based edge smoothing\",\n\t\t\t\"float m = clamp(smoothstep(0.0,edge,blur),0.0,1.0);\",\n\t\t\t\"float e = clamp(smoothstep(1.0-edge,1.0,blur),0.0,1.0);\",\n\n\t\t\t\"col = mix(col,vec3(1.0,0.5,0.0),(1.0-m)*0.6);\",\n\t\t\t\"col = mix(col,vec3(0.0,0.5,1.0),((1.0-e)-(1.0-m))*0.2);\",\n\n\t\t\t\"return col;\",\n\t\t\"}\",\n\n\t\t\"float linearize(float depth) {\",\n\t\t\t\"return -zfar * znear / (depth * (zfar - znear) - zfar);\",\n\t\t\"}\",\n\n\n\t\t\"float vignette() {\",\n\t\t\t\"float dist = distance(vUv.xy, vec2(0.5,0.5));\",\n\t\t\t\"dist = smoothstep(vignout+(fstop/vignfade), vignin+(fstop/vignfade), dist);\",\n\t\t\t\"return clamp(dist,0.0,1.0);\",\n\t\t\"}\",\n\n\t\t\"float gather(float i, float j, int ringsamples, inout vec3 col, float w, float h, float blur) {\",\n\t\t\t\"float rings2 = float(rings);\",\n\t\t\t\"float step = PI*2.0 / float(ringsamples);\",\n\t\t\t\"float pw = cos(j*step)*i;\",\n\t\t\t\"float ph = sin(j*step)*i;\",\n\t\t\t\"float p = 1.0;\",\n\t\t\t\"if (pentagon) {\",\n\t\t\t\t\"p = penta(vec2(pw,ph));\",\n\t\t\t\"}\",\n\t\t\t\"col += color(vUv.xy + vec2(pw*w,ph*h), blur) * mix(1.0, i/rings2, bias) * p;\",\n\t\t\t\"return 1.0 * mix(1.0, i /rings2, bias) * p;\",\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\t\t\t\"//scene depth calculation\",\n\n\t\t\t\"float depth = linearize(texture2D(tDepth,vUv.xy).x);\",\n\n\t\t\t\"// Blur depth?\",\n\t\t\t\"if (depthblur) {\",\n\t\t\t\t\"depth = linearize(bdepth(vUv.xy));\",\n\t\t\t\"}\",\n\n\t\t\t\"//focal plane calculation\",\n\n\t\t\t\"float fDepth = focalDepth;\",\n\n\t\t\t\"if (autofocus) {\",\n\n\t\t\t\t\"fDepth = linearize(texture2D(tDepth,focusCoords).x);\",\n\n\t\t\t\"}\",\n\n\t\t\t\"// dof blur factor calculation\",\n\n\t\t\t\"float blur = 0.0;\",\n\n\t\t\t\"if (manualdof) {\",\n\t\t\t\t\"float a = depth-fDepth; // Focal plane\",\n\t\t\t\t\"float b = (a-fdofstart)/fdofdist; // Far DoF\",\n\t\t\t\t\"float c = (-a-ndofstart)/ndofdist; // Near Dof\",\n\t\t\t\t\"blur = (a>0.0) ? b : c;\",\n\t\t\t\"} else {\",\n\t\t\t\t\"float f = focalLength; // focal length in mm\",\n\t\t\t\t\"float d = fDepth*1000.0; // focal plane in mm\",\n\t\t\t\t\"float o = depth*1000.0; // depth in mm\",\n\n\t\t\t\t\"float a = (o*f)/(o-f);\",\n\t\t\t\t\"float b = (d*f)/(d-f);\",\n\t\t\t\t\"float c = (d-f)/(d*fstop*CoC);\",\n\n\t\t\t\t\"blur = abs(a-b)*c;\",\n\t\t\t\"}\",\n\n\t\t\t\"blur = clamp(blur,0.0,1.0);\",\n\n\t\t\t\"// calculation of pattern for dithering\",\n\n\t\t\t\"vec2 noise = rand(vUv.xy)*namount*blur;\",\n\n\t\t\t\"// getting blur x and y step factor\",\n\n\t\t\t\"float w = (1.0/width)*blur*maxblur+noise.x;\",\n\t\t\t\"float h = (1.0/height)*blur*maxblur+noise.y;\",\n\n\t\t\t\"// calculation of final color\",\n\n\t\t\t\"vec3 col = vec3(0.0);\",\n\n\t\t\t\"if(blur < 0.05) {\",\n\t\t\t\t\"//some optimization thingy\",\n\t\t\t\t\"col = texture2D(tColor, vUv.xy).rgb;\",\n\t\t\t\"} else {\",\n\t\t\t\t\"col = texture2D(tColor, vUv.xy).rgb;\",\n\t\t\t\t\"float s = 1.0;\",\n\t\t\t\t\"int ringsamples;\",\n\n\t\t\t\t\"for (int i = 1; i <= rings; i++) {\",\n\t\t\t\t\t\"/*unboxstart*/\",\n\t\t\t\t\t\"ringsamples = i * samples;\",\n\n\t\t\t\t\t\"for (int j = 0 ; j < maxringsamples ; j++) {\",\n\t\t\t\t\t\t\"if (j >= ringsamples) break;\",\n\t\t\t\t\t\t\"s += gather(float(i), float(j), ringsamples, col, w, h, blur);\",\n\t\t\t\t\t\"}\",\n\t\t\t\t\t\"/*unboxend*/\",\n\t\t\t\t\"}\",\n\n\t\t\t\t\"col /= s; //divide by sample count\",\n\t\t\t\"}\",\n\n\t\t\t\"if (showFocus) {\",\n\t\t\t\t\"col = debugFocus(col, blur, depth);\",\n\t\t\t\"}\",\n\n\t\t\t\"if (vignetting) {\",\n\t\t\t\t\"col *= vignette();\",\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor.rgb = col;\",\n\t\t\t\"gl_FragColor.a = 1.0;\",\n\t\t\"} \"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "BokehShader2.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-BokehShader2",
      "url": "/js/shaders/BokehShader2.js",
      "urls": [
        "/js/shaders/BokehShader2.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/BrightnessContrastShader.js",
      "relativePath": "js/shaders/BrightnessContrastShader.js",
      "basename": "BrightnessContrastShader",
      "outBasename": "BrightnessContrastShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "BrightnessContrastShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/BrightnessContrastShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "BrightnessContrastShader.js",
      "relativeOutPath": "js/shaders/BrightnessContrastShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/BrightnessContrastShader",
      "relativeOutBase": "js/shaders/BrightnessContrastShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.694Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author tapio / http://tapio.github.com/\n *\n * Brightness and contrast adjustment\n * https://github.com/evanw/glfx.js\n * brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)\n * contrast: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n */\n\nTHREE.BrightnessContrastShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":   { type: \"t\", value: null },\n\t\t\"brightness\": { type: \"f\", value: 0 },\n\t\t\"contrast\":   { type: \"f\", value: 0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float brightness;\",\n\t\t\"uniform float contrast;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"gl_FragColor = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"gl_FragColor.rgb += brightness;\",\n\n\t\t\t\"if (contrast > 0.0) {\",\n\t\t\t\t\"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;\",\n\t\t\t\"} else {\",\n\t\t\t\t\"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;\",\n\t\t\t\"}\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author tapio / http://tapio.github.com/\n *\n * Brightness and contrast adjustment\n * https://github.com/evanw/glfx.js\n * brightness: -1 to 1 (-1 is solid black, 0 is no change, and 1 is solid white)\n * contrast: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n */\n\nTHREE.BrightnessContrastShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":   { type: \"t\", value: null },\n\t\t\"brightness\": { type: \"f\", value: 0 },\n\t\t\"contrast\":   { type: \"f\", value: 0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float brightness;\",\n\t\t\"uniform float contrast;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"gl_FragColor = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"gl_FragColor.rgb += brightness;\",\n\n\t\t\t\"if (contrast > 0.0) {\",\n\t\t\t\t\"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) / (1.0 - contrast) + 0.5;\",\n\t\t\t\"} else {\",\n\t\t\t\t\"gl_FragColor.rgb = (gl_FragColor.rgb - 0.5) * (1.0 + contrast) + 0.5;\",\n\t\t\t\"}\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "BrightnessContrastShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-BrightnessContrastShader",
      "url": "/js/shaders/BrightnessContrastShader.js",
      "urls": [
        "/js/shaders/BrightnessContrastShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/ColorCorrectionShader.js",
      "relativePath": "js/shaders/ColorCorrectionShader.js",
      "basename": "ColorCorrectionShader",
      "outBasename": "ColorCorrectionShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "ColorCorrectionShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/ColorCorrectionShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "ColorCorrectionShader.js",
      "relativeOutPath": "js/shaders/ColorCorrectionShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/ColorCorrectionShader",
      "relativeOutBase": "js/shaders/ColorCorrectionShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.699Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Color correction\n */\n\nTHREE.ColorCorrectionShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"powRGB\":   { type: \"v3\", value: new THREE.Vector3( 2, 2, 2 ) },\n\t\t\"mulRGB\":   { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform vec3 powRGB;\",\n\t\t\"uniform vec3 mulRGB;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"gl_FragColor = texture2D( tDiffuse, vUv );\",\n\t\t\t\"gl_FragColor.rgb = mulRGB * pow( gl_FragColor.rgb, powRGB );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Color correction\n */\n\nTHREE.ColorCorrectionShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"powRGB\":   { type: \"v3\", value: new THREE.Vector3( 2, 2, 2 ) },\n\t\t\"mulRGB\":   { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform vec3 powRGB;\",\n\t\t\"uniform vec3 mulRGB;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"gl_FragColor = texture2D( tDiffuse, vUv );\",\n\t\t\t\"gl_FragColor.rgb = mulRGB * pow( gl_FragColor.rgb, powRGB );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "ColorCorrectionShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-ColorCorrectionShader",
      "url": "/js/shaders/ColorCorrectionShader.js",
      "urls": [
        "/js/shaders/ColorCorrectionShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/ColorifyShader.js",
      "relativePath": "js/shaders/ColorifyShader.js",
      "basename": "ColorifyShader",
      "outBasename": "ColorifyShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "ColorifyShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/ColorifyShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "ColorifyShader.js",
      "relativeOutPath": "js/shaders/ColorifyShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/ColorifyShader",
      "relativeOutBase": "js/shaders/ColorifyShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.701Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Colorify shader\n */\n\nTHREE.ColorifyShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"color\":    { type: \"c\", value: new THREE.Color( 0xffffff ) }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform vec3 color;\",\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"vec3 luma = vec3( 0.299, 0.587, 0.114 );\",\n\t\t\t\"float v = dot( texel.xyz, luma );\",\n\n\t\t\t\"gl_FragColor = vec4( v * color, texel.w );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Colorify shader\n */\n\nTHREE.ColorifyShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"color\":    { type: \"c\", value: new THREE.Color( 0xffffff ) }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform vec3 color;\",\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"vec3 luma = vec3( 0.299, 0.587, 0.114 );\",\n\t\t\t\"float v = dot( texel.xyz, luma );\",\n\n\t\t\t\"gl_FragColor = vec4( v * color, texel.w );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "ColorifyShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-ColorifyShader",
      "url": "/js/shaders/ColorifyShader.js",
      "urls": [
        "/js/shaders/ColorifyShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/ConvolutionShader.js",
      "relativePath": "js/shaders/ConvolutionShader.js",
      "basename": "ConvolutionShader",
      "outBasename": "ConvolutionShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "ConvolutionShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/ConvolutionShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "ConvolutionShader.js",
      "relativeOutPath": "js/shaders/ConvolutionShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/ConvolutionShader",
      "relativeOutBase": "js/shaders/ConvolutionShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.707Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nTHREE.ConvolutionShader = {\n\n\tdefines: {\n\n\t\t\"KERNEL_SIZE_FLOAT\": \"25.0\",\n\t\t\"KERNEL_SIZE_INT\": \"25\",\n\n\t},\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":        { type: \"t\", value: null },\n\t\t\"uImageIncrement\": { type: \"v2\", value: new THREE.Vector2( 0.001953125, 0.0 ) },\n\t\t\"cKernel\":         { type: \"fv1\", value: [] }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"uniform vec2 uImageIncrement;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float cKernel[ KERNEL_SIZE_INT ];\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform vec2 uImageIncrement;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec2 imageCoord = vUv;\",\n\t\t\t\"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\",\n\n\t\t\t\"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\",\n\n\t\t\t\t\"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\",\n\t\t\t\t\"imageCoord += uImageIncrement;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor = sum;\",\n\n\t\t\"}\"\n\n\n\t].join(\"\\n\"),\n\n\tbuildKernel: function ( sigma ) {\n\n\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n\t\tfunction gauss( x, sigma ) {\n\n\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\n\n\t\t}\n\n\t\tvar i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\n\n\t\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\n\t\thalfWidth = ( kernelSize - 1 ) * 0.5;\n\n\t\tvalues = new Array( kernelSize );\n\t\tsum = 0.0;\n\t\tfor ( i = 0; i < kernelSize; ++i ) {\n\n\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\n\t\t\tsum += values[ i ];\n\n\t\t}\n\n\t\t// normalize the kernel\n\n\t\tfor ( i = 0; i < kernelSize; ++i ) values[ i ] /= sum;\n\n\t\treturn values;\n\n\t}\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Convolution shader\n * ported from o3d sample to WebGL / GLSL\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\n */\n\nTHREE.ConvolutionShader = {\n\n\tdefines: {\n\n\t\t\"KERNEL_SIZE_FLOAT\": \"25.0\",\n\t\t\"KERNEL_SIZE_INT\": \"25\",\n\n\t},\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":        { type: \"t\", value: null },\n\t\t\"uImageIncrement\": { type: \"v2\", value: new THREE.Vector2( 0.001953125, 0.0 ) },\n\t\t\"cKernel\":         { type: \"fv1\", value: [] }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"uniform vec2 uImageIncrement;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float cKernel[ KERNEL_SIZE_INT ];\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform vec2 uImageIncrement;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec2 imageCoord = vUv;\",\n\t\t\t\"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\",\n\n\t\t\t\"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\",\n\n\t\t\t\t\"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\",\n\t\t\t\t\"imageCoord += uImageIncrement;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor = sum;\",\n\n\t\t\"}\"\n\n\n\t].join(\"\\n\"),\n\n\tbuildKernel: function ( sigma ) {\n\n\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\n\n\t\tfunction gauss( x, sigma ) {\n\n\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\n\n\t\t}\n\n\t\tvar i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\n\n\t\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\n\t\thalfWidth = ( kernelSize - 1 ) * 0.5;\n\n\t\tvalues = new Array( kernelSize );\n\t\tsum = 0.0;\n\t\tfor ( i = 0; i < kernelSize; ++i ) {\n\n\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\n\t\t\tsum += values[ i ];\n\n\t\t}\n\n\t\t// normalize the kernel\n\n\t\tfor ( i = 0; i < kernelSize; ++i ) values[ i ] /= sum;\n\n\t\treturn values;\n\n\t}\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "ConvolutionShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-ConvolutionShader",
      "url": "/js/shaders/ConvolutionShader.js",
      "urls": [
        "/js/shaders/ConvolutionShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/CopyShader.js",
      "relativePath": "js/shaders/CopyShader.js",
      "basename": "CopyShader",
      "outBasename": "CopyShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "CopyShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/CopyShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "CopyShader.js",
      "relativeOutPath": "js/shaders/CopyShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/CopyShader",
      "relativeOutBase": "js/shaders/CopyShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.714Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Full-screen textured quad shader\n */\n\nTHREE.CopyShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"opacity\":  { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float opacity;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\n\t\t\t\"gl_FragColor = opacity * texel;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Full-screen textured quad shader\n */\n\nTHREE.CopyShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"opacity\":  { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float opacity;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\n\t\t\t\"gl_FragColor = opacity * texel;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "CopyShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-CopyShader",
      "url": "/js/shaders/CopyShader.js",
      "urls": [
        "/js/shaders/CopyShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/DOFMipMapShader.js",
      "relativePath": "js/shaders/DOFMipMapShader.js",
      "basename": "DOFMipMapShader",
      "outBasename": "DOFMipMapShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "DOFMipMapShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/DOFMipMapShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "DOFMipMapShader.js",
      "relativeOutPath": "js/shaders/DOFMipMapShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/DOFMipMapShader",
      "relativeOutBase": "js/shaders/DOFMipMapShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.717Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Depth-of-field shader using mipmaps\n * - from Matt Handley @applmak\n * - requires power-of-2 sized render target with enabled mipmaps\n */\n\nTHREE.DOFMipMapShader = {\n\n\tuniforms: {\n\n\t\t\"tColor\":   { type: \"t\", value: null },\n\t\t\"tDepth\":   { type: \"t\", value: null },\n\t\t\"focus\":    { type: \"f\", value: 1.0 },\n\t\t\"maxblur\":  { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float focus;\",\n\t\t\"uniform float maxblur;\",\n\n\t\t\"uniform sampler2D tColor;\",\n\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 depth = texture2D( tDepth, vUv );\",\n\n\t\t\t\"float factor = depth.x - focus;\",\n\n\t\t\t\"vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );\",\n\n\t\t\t\"gl_FragColor = col;\",\n\t\t\t\"gl_FragColor.a = 1.0;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Depth-of-field shader using mipmaps\n * - from Matt Handley @applmak\n * - requires power-of-2 sized render target with enabled mipmaps\n */\n\nTHREE.DOFMipMapShader = {\n\n\tuniforms: {\n\n\t\t\"tColor\":   { type: \"t\", value: null },\n\t\t\"tDepth\":   { type: \"t\", value: null },\n\t\t\"focus\":    { type: \"f\", value: 1.0 },\n\t\t\"maxblur\":  { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float focus;\",\n\t\t\"uniform float maxblur;\",\n\n\t\t\"uniform sampler2D tColor;\",\n\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 depth = texture2D( tDepth, vUv );\",\n\n\t\t\t\"float factor = depth.x - focus;\",\n\n\t\t\t\"vec4 col = texture2D( tColor, vUv, 2.0 * maxblur * abs( focus - depth.x ) );\",\n\n\t\t\t\"gl_FragColor = col;\",\n\t\t\t\"gl_FragColor.a = 1.0;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "DOFMipMapShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-DOFMipMapShader",
      "url": "/js/shaders/DOFMipMapShader.js",
      "urls": [
        "/js/shaders/DOFMipMapShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/DotScreenShader.js",
      "relativePath": "js/shaders/DotScreenShader.js",
      "basename": "DotScreenShader",
      "outBasename": "DotScreenShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "DotScreenShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/DotScreenShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "DotScreenShader.js",
      "relativeOutPath": "js/shaders/DotScreenShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/DotScreenShader",
      "relativeOutBase": "js/shaders/DotScreenShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.724Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Dot screen shader\n * based on glfx.js sepia shader\n * https://github.com/evanw/glfx.js\n */\n\nTHREE.DotScreenShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"tSize\":    { type: \"v2\", value: new THREE.Vector2( 256, 256 ) },\n\t\t\"center\":   { type: \"v2\", value: new THREE.Vector2( 0.5, 0.5 ) },\n\t\t\"angle\":    { type: \"f\", value: 1.57 },\n\t\t\"scale\":    { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform vec2 center;\",\n\t\t\"uniform float angle;\",\n\t\t\"uniform float scale;\",\n\t\t\"uniform vec2 tSize;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"float pattern() {\",\n\n\t\t\t\"float s = sin( angle ), c = cos( angle );\",\n\n\t\t\t\"vec2 tex = vUv * tSize - center;\",\n\t\t\t\"vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\",\n\n\t\t\t\"return ( sin( point.x ) * sin( point.y ) ) * 4.0;\",\n\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 color = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"float average = ( color.r + color.g + color.b ) / 3.0;\",\n\n\t\t\t\"gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Dot screen shader\n * based on glfx.js sepia shader\n * https://github.com/evanw/glfx.js\n */\n\nTHREE.DotScreenShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"tSize\":    { type: \"v2\", value: new THREE.Vector2( 256, 256 ) },\n\t\t\"center\":   { type: \"v2\", value: new THREE.Vector2( 0.5, 0.5 ) },\n\t\t\"angle\":    { type: \"f\", value: 1.57 },\n\t\t\"scale\":    { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform vec2 center;\",\n\t\t\"uniform float angle;\",\n\t\t\"uniform float scale;\",\n\t\t\"uniform vec2 tSize;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"float pattern() {\",\n\n\t\t\t\"float s = sin( angle ), c = cos( angle );\",\n\n\t\t\t\"vec2 tex = vUv * tSize - center;\",\n\t\t\t\"vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;\",\n\n\t\t\t\"return ( sin( point.x ) * sin( point.y ) ) * 4.0;\",\n\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 color = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"float average = ( color.r + color.g + color.b ) / 3.0;\",\n\n\t\t\t\"gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "DotScreenShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-DotScreenShader",
      "url": "/js/shaders/DotScreenShader.js",
      "urls": [
        "/js/shaders/DotScreenShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/EdgeShader.js",
      "relativePath": "js/shaders/EdgeShader.js",
      "basename": "EdgeShader",
      "outBasename": "EdgeShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "EdgeShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/EdgeShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "EdgeShader.js",
      "relativeOutPath": "js/shaders/EdgeShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/EdgeShader",
      "relativeOutBase": "js/shaders/EdgeShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.729Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog\n *\n * Edge Detection Shader using Frei-Chen filter\n * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\n *\n * aspect: vec2 of (1/width, 1/height)\n */\n\nTHREE.EdgeShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"aspect\":    { type: \"v2\", value: new THREE.Vector2( 512, 512 ) },\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"uniform vec2 aspect;\",\n\n\t\t\"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\",\n\n\n\t\t\"mat3 G[9];\",\n\n\t\t// hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n\n\t\t\"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\",\n\t\t\"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\",\n\t\t\"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\",\n\t\t\"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\",\n\t\t\"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\",\n\t\t\"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\",\n\t\t\"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\",\n\t\t\"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\",\n\t\t\"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\",\n\n\t\t\"void main(void)\",\n\t\t\"{\",\n\n\t\t\t\"G[0] = g0,\",\n\t\t\t\"G[1] = g1,\",\n\t\t\t\"G[2] = g2,\",\n\t\t\t\"G[3] = g3,\",\n\t\t\t\"G[4] = g4,\",\n\t\t\t\"G[5] = g5,\",\n\t\t\t\"G[6] = g6,\",\n\t\t\t\"G[7] = g7,\",\n\t\t\t\"G[8] = g8;\",\n\n\t\t\t\"mat3 I;\",\n\t\t\t\"float cnv[9];\",\n\t\t\t\"vec3 sample;\",\n\n\t\t\t/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n\t\t\t\"for (float i=0.0; i<3.0; i++) {\",\n\t\t\t\t\"for (float j=0.0; j<3.0; j++) {\",\n\t\t\t\t\t\"sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\",\n\t\t\t\t\t\"I[int(i)][int(j)] = length(sample);\",\n\t\t\t\t\"}\",\n\t\t\t\"}\",\n\n\t\t\t/* calculate the convolution values for all the masks */\n\t\t\t\"for (int i=0; i<9; i++) {\",\n\t\t\t\t\"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\",\n\t\t\t\t\"cnv[i] = dp3 * dp3;\",\n\t\t\t\"}\",\n\n\t\t\t\"float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\",\n\t\t\t\"float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\",\n\n\t\t\t\"gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\",\n\t\t\"}\",\n\n\t].join(\"\\n\")\n};\n",
      "content": "/**\n * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog\n *\n * Edge Detection Shader using Frei-Chen filter\n * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\n *\n * aspect: vec2 of (1/width, 1/height)\n */\n\nTHREE.EdgeShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"aspect\":    { type: \"v2\", value: new THREE.Vector2( 512, 512 ) },\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"uniform vec2 aspect;\",\n\n\t\t\"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\",\n\n\n\t\t\"mat3 G[9];\",\n\n\t\t// hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45\n\n\t\t\"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );\",\n\t\t\"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );\",\n\t\t\"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );\",\n\t\t\"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );\",\n\t\t\"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );\",\n\t\t\"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );\",\n\t\t\"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );\",\n\t\t\"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );\",\n\t\t\"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );\",\n\n\t\t\"void main(void)\",\n\t\t\"{\",\n\n\t\t\t\"G[0] = g0,\",\n\t\t\t\"G[1] = g1,\",\n\t\t\t\"G[2] = g2,\",\n\t\t\t\"G[3] = g3,\",\n\t\t\t\"G[4] = g4,\",\n\t\t\t\"G[5] = g5,\",\n\t\t\t\"G[6] = g6,\",\n\t\t\t\"G[7] = g7,\",\n\t\t\t\"G[8] = g8;\",\n\n\t\t\t\"mat3 I;\",\n\t\t\t\"float cnv[9];\",\n\t\t\t\"vec3 sample;\",\n\n\t\t\t/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n\t\t\t\"for (float i=0.0; i<3.0; i++) {\",\n\t\t\t\t\"for (float j=0.0; j<3.0; j++) {\",\n\t\t\t\t\t\"sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\",\n\t\t\t\t\t\"I[int(i)][int(j)] = length(sample);\",\n\t\t\t\t\"}\",\n\t\t\t\"}\",\n\n\t\t\t/* calculate the convolution values for all the masks */\n\t\t\t\"for (int i=0; i<9; i++) {\",\n\t\t\t\t\"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\",\n\t\t\t\t\"cnv[i] = dp3 * dp3;\",\n\t\t\t\"}\",\n\n\t\t\t\"float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);\",\n\t\t\t\"float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);\",\n\n\t\t\t\"gl_FragColor = vec4(vec3(sqrt(M/S)), 1.0);\",\n\t\t\"}\",\n\n\t].join(\"\\n\")\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "EdgeShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-EdgeShader",
      "url": "/js/shaders/EdgeShader.js",
      "urls": [
        "/js/shaders/EdgeShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/EdgeShader2.js",
      "relativePath": "js/shaders/EdgeShader2.js",
      "basename": "EdgeShader2",
      "outBasename": "EdgeShader2",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "EdgeShader2.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/EdgeShader2.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "EdgeShader2.js",
      "relativeOutPath": "js/shaders/EdgeShader2.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/EdgeShader2",
      "relativeOutBase": "js/shaders/EdgeShader2",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.737Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog\n *\n * Edge Detection Shader using Sobel filter\n * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\n *\n * aspect: vec2 of (1/width, 1/height)\n */\n\nTHREE.EdgeShader2 = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"aspect\":    { type: \"v2\", value: new THREE.Vector2( 512, 512 ) },\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"varying vec2 vUv;\",\n\t\t\"uniform vec2 aspect;\",\n\n\n\t\t\"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\",\n\n\t\t\"mat3 G[2];\",\n\n\t\t\"const mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );\",\n\t\t\"const mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );\",\n\n\n\t\t\"void main(void)\",\n\t\t\"{\",\n\t\t\t\"mat3 I;\",\n\t\t\t\"float cnv[2];\",\n\t\t\t\"vec3 sample;\",\n\n\t\t\t\"G[0] = g0;\",\n\t\t\t\"G[1] = g1;\",\n\n\t\t\t/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n\t\t\t\"for (float i=0.0; i<3.0; i++)\",\n\t\t\t\"for (float j=0.0; j<3.0; j++) {\",\n\t\t\t\t\"sample = texture2D( tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\",\n\t\t\t\t\"I[int(i)][int(j)] = length(sample);\",\n\t\t\t\"}\",\n\n\t\t\t/* calculate the convolution values for all the masks */\n\t\t\t\"for (int i=0; i<2; i++) {\",\n\t\t\t\t\"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\",\n\t\t\t\t\"cnv[i] = dp3 * dp3; \",\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor = vec4(0.5 * sqrt(cnv[0]*cnv[0]+cnv[1]*cnv[1]));\",\n\t\t\"} \",\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog\n *\n * Edge Detection Shader using Sobel filter\n * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector\n *\n * aspect: vec2 of (1/width, 1/height)\n */\n\nTHREE.EdgeShader2 = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"aspect\":    { type: \"v2\", value: new THREE.Vector2( 512, 512 ) },\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"varying vec2 vUv;\",\n\t\t\"uniform vec2 aspect;\",\n\n\n\t\t\"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);\",\n\n\t\t\"mat3 G[2];\",\n\n\t\t\"const mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );\",\n\t\t\"const mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );\",\n\n\n\t\t\"void main(void)\",\n\t\t\"{\",\n\t\t\t\"mat3 I;\",\n\t\t\t\"float cnv[2];\",\n\t\t\t\"vec3 sample;\",\n\n\t\t\t\"G[0] = g0;\",\n\t\t\t\"G[1] = g1;\",\n\n\t\t\t/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */\n\t\t\t\"for (float i=0.0; i<3.0; i++)\",\n\t\t\t\"for (float j=0.0; j<3.0; j++) {\",\n\t\t\t\t\"sample = texture2D( tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;\",\n\t\t\t\t\"I[int(i)][int(j)] = length(sample);\",\n\t\t\t\"}\",\n\n\t\t\t/* calculate the convolution values for all the masks */\n\t\t\t\"for (int i=0; i<2; i++) {\",\n\t\t\t\t\"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);\",\n\t\t\t\t\"cnv[i] = dp3 * dp3; \",\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor = vec4(0.5 * sqrt(cnv[0]*cnv[0]+cnv[1]*cnv[1]));\",\n\t\t\"} \",\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "EdgeShader2.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-EdgeShader2",
      "url": "/js/shaders/EdgeShader2.js",
      "urls": [
        "/js/shaders/EdgeShader2.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/FXAAShader.js",
      "relativePath": "js/shaders/FXAAShader.js",
      "basename": "FXAAShader",
      "outBasename": "FXAAShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "FXAAShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/FXAAShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "FXAAShader.js",
      "relativeOutPath": "js/shaders/FXAAShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/FXAAShader",
      "relativeOutBase": "js/shaders/FXAAShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.739Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n * @author davidedc / http://www.sketchpatch.net/\n *\n * NVIDIA FXAA by Timothy Lottes\n * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\n * - WebGL port by @supereggbert\n * http://www.glge.org/demos/fxaa/\n */\n\nTHREE.FXAAShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":   { type: \"t\", value: null },\n\t\t\"resolution\": { type: \"v2\", value: new THREE.Vector2( 1 / 1024, 1 / 512 )  }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform vec2 resolution;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"#define FXAA_REDUCE_MIN   (1.0/128.0)\",\n\t\t\"#define FXAA_REDUCE_MUL   (1.0/8.0)\",\n\t\t\"#define FXAA_SPAN_MAX     8.0\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;\",\n\t\t\t\"vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;\",\n\t\t\t\"vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;\",\n\t\t\t\"vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;\",\n\t\t\t\"vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );\",\n\t\t\t\"vec3 rgbM  = rgbaM.xyz;\",\n\t\t\t\"float opacity  = rgbaM.w;\",\n\n\t\t\t\"vec3 luma = vec3( 0.299, 0.587, 0.114 );\",\n\n\t\t\t\"float lumaNW = dot( rgbNW, luma );\",\n\t\t\t\"float lumaNE = dot( rgbNE, luma );\",\n\t\t\t\"float lumaSW = dot( rgbSW, luma );\",\n\t\t\t\"float lumaSE = dot( rgbSE, luma );\",\n\t\t\t\"float lumaM  = dot( rgbM,  luma );\",\n\t\t\t\"float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\",\n\t\t\t\"float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );\",\n\n\t\t\t\"vec2 dir;\",\n\t\t\t\"dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\",\n\t\t\t\"dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\",\n\n\t\t\t\"float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );\",\n\n\t\t\t\"float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\",\n\t\t\t\"dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\",\n\t\t\t\t  \"max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\",\n\t\t\t\t\t\t\"dir * rcpDirMin)) * resolution;\",\n\n\t\t\t\"vec3 rgbA = texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz;\",\n\t\t\t\"rgbA += texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz;\",\n\t\t\t\"rgbA *= 0.5;\",\n\n\t\t\t\"vec3 rgbB = texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * -0.5 ).xyz;\",\n\t\t\t\"rgbB += texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * 0.5 ).xyz;\",\n\t\t\t\"rgbB *= 0.25;\",\n\t\t\t\"rgbB += rgbA * 0.5;\",\n\n\t\t\t\"float lumaB = dot( rgbB, luma );\",\n\n\t\t\t\"if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {\",\n\n\t\t\t\t\"gl_FragColor = vec4( rgbA, opacity );\",\n\n\t\t\t\"} else {\",\n\n\t\t\t\t\"gl_FragColor = vec4( rgbB, opacity );\",\n\n\t\t\t\"}\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n * @author davidedc / http://www.sketchpatch.net/\n *\n * NVIDIA FXAA by Timothy Lottes\n * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\n * - WebGL port by @supereggbert\n * http://www.glge.org/demos/fxaa/\n */\n\nTHREE.FXAAShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":   { type: \"t\", value: null },\n\t\t\"resolution\": { type: \"v2\", value: new THREE.Vector2( 1 / 1024, 1 / 512 )  }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform vec2 resolution;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"#define FXAA_REDUCE_MIN   (1.0/128.0)\",\n\t\t\"#define FXAA_REDUCE_MUL   (1.0/8.0)\",\n\t\t\"#define FXAA_SPAN_MAX     8.0\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;\",\n\t\t\t\"vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;\",\n\t\t\t\"vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;\",\n\t\t\t\"vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;\",\n\t\t\t\"vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );\",\n\t\t\t\"vec3 rgbM  = rgbaM.xyz;\",\n\t\t\t\"float opacity  = rgbaM.w;\",\n\n\t\t\t\"vec3 luma = vec3( 0.299, 0.587, 0.114 );\",\n\n\t\t\t\"float lumaNW = dot( rgbNW, luma );\",\n\t\t\t\"float lumaNE = dot( rgbNE, luma );\",\n\t\t\t\"float lumaSW = dot( rgbSW, luma );\",\n\t\t\t\"float lumaSE = dot( rgbSE, luma );\",\n\t\t\t\"float lumaM  = dot( rgbM,  luma );\",\n\t\t\t\"float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\",\n\t\t\t\"float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );\",\n\n\t\t\t\"vec2 dir;\",\n\t\t\t\"dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\",\n\t\t\t\"dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\",\n\n\t\t\t\"float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );\",\n\n\t\t\t\"float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\",\n\t\t\t\"dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\",\n\t\t\t\t  \"max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\",\n\t\t\t\t\t\t\"dir * rcpDirMin)) * resolution;\",\n\n\t\t\t\"vec3 rgbA = texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz;\",\n\t\t\t\"rgbA += texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz;\",\n\t\t\t\"rgbA *= 0.5;\",\n\n\t\t\t\"vec3 rgbB = texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * -0.5 ).xyz;\",\n\t\t\t\"rgbB += texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * 0.5 ).xyz;\",\n\t\t\t\"rgbB *= 0.25;\",\n\t\t\t\"rgbB += rgbA * 0.5;\",\n\n\t\t\t\"float lumaB = dot( rgbB, luma );\",\n\n\t\t\t\"if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {\",\n\n\t\t\t\t\"gl_FragColor = vec4( rgbA, opacity );\",\n\n\t\t\t\"} else {\",\n\n\t\t\t\t\"gl_FragColor = vec4( rgbB, opacity );\",\n\n\t\t\t\"}\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "FXAAShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-FXAAShader",
      "url": "/js/shaders/FXAAShader.js",
      "urls": [
        "/js/shaders/FXAAShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/FilmShader.js",
      "relativePath": "js/shaders/FilmShader.js",
      "basename": "FilmShader",
      "outBasename": "FilmShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "FilmShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/FilmShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "FilmShader.js",
      "relativeOutPath": "js/shaders/FilmShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/FilmShader",
      "relativeOutBase": "js/shaders/FilmShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.744Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Film grain & scanlines shader\n *\n * - ported from HLSL to WebGL / GLSL\n * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n *\n * Screen Space Static Postprocessor\n *\n * Produces an analogue noise overlay similar to a film grain / TV static\n *\n * Original implementation and noise algorithm\n * Pat 'Hawthorne' Shearon\n *\n * Optimized scanlines + noise version with intensity scaling\n * Georg 'Leviathan' Steinrohder\n *\n * This version is provided under a Creative Commons Attribution 3.0 License\n * http://creativecommons.org/licenses/by/3.0/\n */\n\nTHREE.FilmShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":   { type: \"t\", value: null },\n\t\t\"time\":       { type: \"f\", value: 0.0 },\n\t\t\"nIntensity\": { type: \"f\", value: 0.5 },\n\t\t\"sIntensity\": { type: \"f\", value: 0.05 },\n\t\t\"sCount\":     { type: \"f\", value: 4096 },\n\t\t\"grayscale\":  { type: \"i\", value: 1 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t// control parameter\n\t\t\"uniform float time;\",\n\n\t\t\"uniform bool grayscale;\",\n\n\t\t// noise effect intensity value (0 = no effect, 1 = full effect)\n\t\t\"uniform float nIntensity;\",\n\n\t\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\n\t\t\"uniform float sIntensity;\",\n\n\t\t// scanlines effect count value (0 = no effect, 4096 = full effect)\n\t\t\"uniform float sCount;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t// sample the source\n\t\t\t\"vec4 cTextureScreen = texture2D( tDiffuse, vUv );\",\n\n\t\t\t// make some noise\n\t\t\t\"float x = vUv.x * vUv.y * time *  1000.0;\",\n\t\t\t\"x = mod( x, 13.0 ) * mod( x, 123.0 );\",\n\t\t\t\"float dx = mod( x, 0.01 );\",\n\n\t\t\t// add noise\n\t\t\t\"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx * 100.0, 0.0, 1.0 );\",\n\n\t\t\t// get us a sine and cosine\n\t\t\t\"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\",\n\n\t\t\t// add scanlines\n\t\t\t\"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\",\n\n\t\t\t// interpolate between source and result by intensity\n\t\t\t\"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\",\n\n\t\t\t// convert to grayscale if desired\n\t\t\t\"if( grayscale ) {\",\n\n\t\t\t\t\"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor =  vec4( cResult, cTextureScreen.a );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Film grain & scanlines shader\n *\n * - ported from HLSL to WebGL / GLSL\n * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\n *\n * Screen Space Static Postprocessor\n *\n * Produces an analogue noise overlay similar to a film grain / TV static\n *\n * Original implementation and noise algorithm\n * Pat 'Hawthorne' Shearon\n *\n * Optimized scanlines + noise version with intensity scaling\n * Georg 'Leviathan' Steinrohder\n *\n * This version is provided under a Creative Commons Attribution 3.0 License\n * http://creativecommons.org/licenses/by/3.0/\n */\n\nTHREE.FilmShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":   { type: \"t\", value: null },\n\t\t\"time\":       { type: \"f\", value: 0.0 },\n\t\t\"nIntensity\": { type: \"f\", value: 0.5 },\n\t\t\"sIntensity\": { type: \"f\", value: 0.05 },\n\t\t\"sCount\":     { type: \"f\", value: 4096 },\n\t\t\"grayscale\":  { type: \"i\", value: 1 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t// control parameter\n\t\t\"uniform float time;\",\n\n\t\t\"uniform bool grayscale;\",\n\n\t\t// noise effect intensity value (0 = no effect, 1 = full effect)\n\t\t\"uniform float nIntensity;\",\n\n\t\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\n\t\t\"uniform float sIntensity;\",\n\n\t\t// scanlines effect count value (0 = no effect, 4096 = full effect)\n\t\t\"uniform float sCount;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t// sample the source\n\t\t\t\"vec4 cTextureScreen = texture2D( tDiffuse, vUv );\",\n\n\t\t\t// make some noise\n\t\t\t\"float x = vUv.x * vUv.y * time *  1000.0;\",\n\t\t\t\"x = mod( x, 13.0 ) * mod( x, 123.0 );\",\n\t\t\t\"float dx = mod( x, 0.01 );\",\n\n\t\t\t// add noise\n\t\t\t\"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx * 100.0, 0.0, 1.0 );\",\n\n\t\t\t// get us a sine and cosine\n\t\t\t\"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\",\n\n\t\t\t// add scanlines\n\t\t\t\"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\",\n\n\t\t\t// interpolate between source and result by intensity\n\t\t\t\"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\",\n\n\t\t\t// convert to grayscale if desired\n\t\t\t\"if( grayscale ) {\",\n\n\t\t\t\t\"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor =  vec4( cResult, cTextureScreen.a );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "FilmShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-FilmShader",
      "url": "/js/shaders/FilmShader.js",
      "urls": [
        "/js/shaders/FilmShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/FocusShader.js",
      "relativePath": "js/shaders/FocusShader.js",
      "basename": "FocusShader",
      "outBasename": "FocusShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "FocusShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/FocusShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "FocusShader.js",
      "relativeOutPath": "js/shaders/FocusShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/FocusShader",
      "relativeOutBase": "js/shaders/FocusShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.750Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Focus shader\n * based on PaintEffect postprocess from ro.me\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\n */\n\nTHREE.FocusShader = {\n\n\tuniforms : {\n\n\t\t\"tDiffuse\":       { type: \"t\", value: null },\n\t\t\"screenWidth\":    { type: \"f\", value: 1024 },\n\t\t\"screenHeight\":   { type: \"f\", value: 1024 },\n\t\t\"sampleDistance\": { type: \"f\", value: 0.94 },\n\t\t\"waveFactor\":     { type: \"f\", value: 0.00125 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float screenWidth;\",\n\t\t\"uniform float screenHeight;\",\n\t\t\"uniform float sampleDistance;\",\n\t\t\"uniform float waveFactor;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 color, org, tmp, add;\",\n\t\t\t\"float sample_dist, f;\",\n\t\t\t\"vec2 vin;\",\n\t\t\t\"vec2 uv = vUv;\",\n\n\t\t\t\"add = color = org = texture2D( tDiffuse, uv );\",\n\n\t\t\t\"vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );\",\n\t\t\t\"sample_dist = dot( vin, vin ) * 2.0;\",\n\n\t\t\t\"f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;\",\n\n\t\t\t\"vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );\",\n\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );\",\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\n\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );\",\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\n\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );\",\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\n\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );\",\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\n\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );\",\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\n\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );\",\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\n\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );\",\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\n\n\t\t\t\"color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );\",\n\t\t\t\"color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );\",\n\n\t\t\t\"gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );\",\n\n\t\t\"}\"\n\n\n\t].join(\"\\n\")\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Focus shader\n * based on PaintEffect postprocess from ro.me\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\n */\n\nTHREE.FocusShader = {\n\n\tuniforms : {\n\n\t\t\"tDiffuse\":       { type: \"t\", value: null },\n\t\t\"screenWidth\":    { type: \"f\", value: 1024 },\n\t\t\"screenHeight\":   { type: \"f\", value: 1024 },\n\t\t\"sampleDistance\": { type: \"f\", value: 0.94 },\n\t\t\"waveFactor\":     { type: \"f\", value: 0.00125 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float screenWidth;\",\n\t\t\"uniform float screenHeight;\",\n\t\t\"uniform float sampleDistance;\",\n\t\t\"uniform float waveFactor;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 color, org, tmp, add;\",\n\t\t\t\"float sample_dist, f;\",\n\t\t\t\"vec2 vin;\",\n\t\t\t\"vec2 uv = vUv;\",\n\n\t\t\t\"add = color = org = texture2D( tDiffuse, uv );\",\n\n\t\t\t\"vin = ( uv - vec2( 0.5 ) ) * vec2( 1.4 );\",\n\t\t\t\"sample_dist = dot( vin, vin ) * 2.0;\",\n\n\t\t\t\"f = ( waveFactor * 100.0 + sample_dist ) * sampleDistance * 4.0;\",\n\n\t\t\t\"vec2 sampleSize = vec2(  1.0 / screenWidth, 1.0 / screenHeight ) * vec2( f );\",\n\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.111964, 0.993712 ) * sampleSize );\",\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\n\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.846724, 0.532032 ) * sampleSize );\",\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\n\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.943883, -0.330279 ) * sampleSize );\",\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\n\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( 0.330279, -0.943883 ) * sampleSize );\",\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\n\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( -0.532032, -0.846724 ) * sampleSize );\",\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\n\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( -0.993712, -0.111964 ) * sampleSize );\",\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\n\n\t\t\t\"add += tmp = texture2D( tDiffuse, uv + vec2( -0.707107, 0.707107 ) * sampleSize );\",\n\t\t\t\"if( tmp.b < color.b ) color = tmp;\",\n\n\t\t\t\"color = color * vec4( 2.0 ) - ( add / vec4( 8.0 ) );\",\n\t\t\t\"color = color + ( add / vec4( 8.0 ) - color ) * ( vec4( 1.0 ) - vec4( sample_dist * 0.5 ) );\",\n\n\t\t\t\"gl_FragColor = vec4( color.rgb * color.rgb * vec3( 0.95 ) + color.rgb, 1.0 );\",\n\n\t\t\"}\"\n\n\n\t].join(\"\\n\")\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "FocusShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-FocusShader",
      "url": "/js/shaders/FocusShader.js",
      "urls": [
        "/js/shaders/FocusShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/FresnelShader.js",
      "relativePath": "js/shaders/FresnelShader.js",
      "basename": "FresnelShader",
      "outBasename": "FresnelShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "FresnelShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/FresnelShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "FresnelShader.js",
      "relativeOutPath": "js/shaders/FresnelShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/FresnelShader",
      "relativeOutBase": "js/shaders/FresnelShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.758Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Based on Nvidia Cg tutorial\n */\n\nTHREE.FresnelShader = {\n\n\tuniforms: {\n\n\t\t\"mRefractionRatio\": { type: \"f\", value: 1.02 },\n\t\t\"mFresnelBias\": { type: \"f\", value: 0.1 },\n\t\t\"mFresnelPower\": { type: \"f\", value: 2.0 },\n\t\t\"mFresnelScale\": { type: \"f\", value: 1.0 },\n\t\t\"tCube\": { type: \"t\", value: null }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"uniform float mRefractionRatio;\",\n\t\t\"uniform float mFresnelBias;\",\n\t\t\"uniform float mFresnelScale;\",\n\t\t\"uniform float mFresnelPower;\",\n\n\t\t\"varying vec3 vReflect;\",\n\t\t\"varying vec3 vRefract[3];\",\n\t\t\"varying float vReflectionFactor;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\",\n\n\t\t\t\"vec3 I = worldPosition.xyz - cameraPosition;\",\n\n\t\t\t\"vReflect = reflect( I, worldNormal );\",\n\t\t\t\"vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\",\n\t\t\t\"vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\",\n\t\t\t\"vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\",\n\t\t\t\"vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\",\n\n\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform samplerCube tCube;\",\n\n\t\t\"varying vec3 vReflect;\",\n\t\t\"varying vec3 vRefract[3];\",\n\t\t\"varying float vReflectionFactor;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\n\t\t\t\"vec4 refractedColor = vec4( 1.0 );\",\n\n\t\t\t\"refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\",\n\t\t\t\"refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\",\n\t\t\t\"refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\",\n\n\t\t\t\"gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Based on Nvidia Cg tutorial\n */\n\nTHREE.FresnelShader = {\n\n\tuniforms: {\n\n\t\t\"mRefractionRatio\": { type: \"f\", value: 1.02 },\n\t\t\"mFresnelBias\": { type: \"f\", value: 0.1 },\n\t\t\"mFresnelPower\": { type: \"f\", value: 2.0 },\n\t\t\"mFresnelScale\": { type: \"f\", value: 1.0 },\n\t\t\"tCube\": { type: \"t\", value: null }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"uniform float mRefractionRatio;\",\n\t\t\"uniform float mFresnelBias;\",\n\t\t\"uniform float mFresnelScale;\",\n\t\t\"uniform float mFresnelPower;\",\n\n\t\t\"varying vec3 vReflect;\",\n\t\t\"varying vec3 vRefract[3];\",\n\t\t\"varying float vReflectionFactor;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\n\t\t\t\"vec3 worldNormal = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal );\",\n\n\t\t\t\"vec3 I = worldPosition.xyz - cameraPosition;\",\n\n\t\t\t\"vReflect = reflect( I, worldNormal );\",\n\t\t\t\"vRefract[0] = refract( normalize( I ), worldNormal, mRefractionRatio );\",\n\t\t\t\"vRefract[1] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.99 );\",\n\t\t\t\"vRefract[2] = refract( normalize( I ), worldNormal, mRefractionRatio * 0.98 );\",\n\t\t\t\"vReflectionFactor = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( I ), worldNormal ), mFresnelPower );\",\n\n\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform samplerCube tCube;\",\n\n\t\t\"varying vec3 vReflect;\",\n\t\t\"varying vec3 vRefract[3];\",\n\t\t\"varying float vReflectionFactor;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 reflectedColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\",\n\t\t\t\"vec4 refractedColor = vec4( 1.0 );\",\n\n\t\t\t\"refractedColor.r = textureCube( tCube, vec3( -vRefract[0].x, vRefract[0].yz ) ).r;\",\n\t\t\t\"refractedColor.g = textureCube( tCube, vec3( -vRefract[1].x, vRefract[1].yz ) ).g;\",\n\t\t\t\"refractedColor.b = textureCube( tCube, vec3( -vRefract[2].x, vRefract[2].yz ) ).b;\",\n\n\t\t\t\"gl_FragColor = mix( refractedColor, reflectedColor, clamp( vReflectionFactor, 0.0, 1.0 ) );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "FresnelShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-FresnelShader",
      "url": "/js/shaders/FresnelShader.js",
      "urls": [
        "/js/shaders/FresnelShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/HorizontalBlurShader.js",
      "relativePath": "js/shaders/HorizontalBlurShader.js",
      "basename": "HorizontalBlurShader",
      "outBasename": "HorizontalBlurShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "HorizontalBlurShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/HorizontalBlurShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "HorizontalBlurShader.js",
      "relativeOutPath": "js/shaders/HorizontalBlurShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/HorizontalBlurShader",
      "relativeOutBase": "js/shaders/HorizontalBlurShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.764Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\n\nTHREE.HorizontalBlurShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"h\":        { type: \"f\", value: 1.0 / 512.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float h;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 sum = vec4( 0.0 );\",\n\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\",\n\n\t\t\t\"gl_FragColor = sum;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\n\nTHREE.HorizontalBlurShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"h\":        { type: \"f\", value: 1.0 / 512.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float h;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 sum = vec4( 0.0 );\",\n\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\",\n\n\t\t\t\"gl_FragColor = sum;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "HorizontalBlurShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-HorizontalBlurShader",
      "url": "/js/shaders/HorizontalBlurShader.js",
      "urls": [
        "/js/shaders/HorizontalBlurShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/HorizontalTiltShiftShader.js",
      "relativePath": "js/shaders/HorizontalTiltShiftShader.js",
      "basename": "HorizontalTiltShiftShader",
      "outBasename": "HorizontalTiltShiftShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "HorizontalTiltShiftShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/HorizontalTiltShiftShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "HorizontalTiltShiftShader.js",
      "relativeOutPath": "js/shaders/HorizontalTiltShiftShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/HorizontalTiltShiftShader",
      "relativeOutBase": "js/shaders/HorizontalTiltShiftShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.767Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n * - \"r\" parameter control where \"focused\" horizontal line lies\n */\n\nTHREE.HorizontalTiltShiftShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"h\":        { type: \"f\", value: 1.0 / 512.0 },\n\t\t\"r\":        { type: \"f\", value: 0.35 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float h;\",\n\t\t\"uniform float r;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 sum = vec4( 0.0 );\",\n\n\t\t\t\"float hh = h * abs( r - vUv.y );\",\n\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;\",\n\n\t\t\t\"gl_FragColor = sum;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n * - \"r\" parameter control where \"focused\" horizontal line lies\n */\n\nTHREE.HorizontalTiltShiftShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"h\":        { type: \"f\", value: 1.0 / 512.0 },\n\t\t\"r\":        { type: \"f\", value: 0.35 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float h;\",\n\t\t\"uniform float r;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 sum = vec4( 0.0 );\",\n\n\t\t\t\"float hh = h * abs( r - vUv.y );\",\n\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * hh, vUv.y ) ) * 0.051;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * hh, vUv.y ) ) * 0.0918;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * hh, vUv.y ) ) * 0.12245;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * hh, vUv.y ) ) * 0.1531;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * hh, vUv.y ) ) * 0.1531;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * hh, vUv.y ) ) * 0.12245;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * hh, vUv.y ) ) * 0.0918;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * hh, vUv.y ) ) * 0.051;\",\n\n\t\t\t\"gl_FragColor = sum;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "HorizontalTiltShiftShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-HorizontalTiltShiftShader",
      "url": "/js/shaders/HorizontalTiltShiftShader.js",
      "urls": [
        "/js/shaders/HorizontalTiltShiftShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/HueSaturationShader.js",
      "relativePath": "js/shaders/HueSaturationShader.js",
      "basename": "HueSaturationShader",
      "outBasename": "HueSaturationShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "HueSaturationShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/HueSaturationShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "HueSaturationShader.js",
      "relativeOutPath": "js/shaders/HueSaturationShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/HueSaturationShader",
      "relativeOutBase": "js/shaders/HueSaturationShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.772Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author tapio / http://tapio.github.com/\n *\n * Hue and saturation adjustment\n * https://github.com/evanw/glfx.js\n * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.\n * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n */\n\nTHREE.HueSaturationShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":   { type: \"t\", value: null },\n\t\t\"hue\":        { type: \"f\", value: 0 },\n\t\t\"saturation\": { type: \"f\", value: 0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float hue;\",\n\t\t\"uniform float saturation;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"gl_FragColor = texture2D( tDiffuse, vUv );\",\n\n\t\t\t// hue\n\t\t\t\"float angle = hue * 3.14159265;\",\n\t\t\t\"float s = sin(angle), c = cos(angle);\",\n\t\t\t\"vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\",\n\t\t\t\"float len = length(gl_FragColor.rgb);\",\n\t\t\t\"gl_FragColor.rgb = vec3(\",\n\t\t\t\t\"dot(gl_FragColor.rgb, weights.xyz),\",\n\t\t\t\t\"dot(gl_FragColor.rgb, weights.zxy),\",\n\t\t\t\t\"dot(gl_FragColor.rgb, weights.yzx)\",\n\t\t\t\");\",\n\n\t\t\t// saturation\n\t\t\t\"float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\",\n\t\t\t\"if (saturation > 0.0) {\",\n\t\t\t\t\"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));\",\n\t\t\t\"} else {\",\n\t\t\t\t\"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);\",\n\t\t\t\"}\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author tapio / http://tapio.github.com/\n *\n * Hue and saturation adjustment\n * https://github.com/evanw/glfx.js\n * hue: -1 to 1 (-1 is 180 degrees in the negative direction, 0 is no change, etc.\n * saturation: -1 to 1 (-1 is solid gray, 0 is no change, and 1 is maximum contrast)\n */\n\nTHREE.HueSaturationShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":   { type: \"t\", value: null },\n\t\t\"hue\":        { type: \"f\", value: 0 },\n\t\t\"saturation\": { type: \"f\", value: 0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float hue;\",\n\t\t\"uniform float saturation;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"gl_FragColor = texture2D( tDiffuse, vUv );\",\n\n\t\t\t// hue\n\t\t\t\"float angle = hue * 3.14159265;\",\n\t\t\t\"float s = sin(angle), c = cos(angle);\",\n\t\t\t\"vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;\",\n\t\t\t\"float len = length(gl_FragColor.rgb);\",\n\t\t\t\"gl_FragColor.rgb = vec3(\",\n\t\t\t\t\"dot(gl_FragColor.rgb, weights.xyz),\",\n\t\t\t\t\"dot(gl_FragColor.rgb, weights.zxy),\",\n\t\t\t\t\"dot(gl_FragColor.rgb, weights.yzx)\",\n\t\t\t\");\",\n\n\t\t\t// saturation\n\t\t\t\"float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;\",\n\t\t\t\"if (saturation > 0.0) {\",\n\t\t\t\t\"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));\",\n\t\t\t\"} else {\",\n\t\t\t\t\"gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);\",\n\t\t\t\"}\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "HueSaturationShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-HueSaturationShader",
      "url": "/js/shaders/HueSaturationShader.js",
      "urls": [
        "/js/shaders/HueSaturationShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/KaleidoShader.js",
      "relativePath": "js/shaders/KaleidoShader.js",
      "basename": "KaleidoShader",
      "outBasename": "KaleidoShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "KaleidoShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/KaleidoShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "KaleidoShader.js",
      "relativeOutPath": "js/shaders/KaleidoShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/KaleidoShader",
      "relativeOutBase": "js/shaders/KaleidoShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.779Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author felixturner / http://airtight.cc/\n *\n * Kaleidoscope Shader\n * Radial reflection around center point\n * Ported from: http://pixelshaders.com/editor/\n * by Toby Schachman / http://tobyschachman.com/\n *\n * sides: number of reflections\n * angle: initial angle in radians\n */\n\nTHREE.KaleidoShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"sides\":    { type: \"f\", value: 6.0 },\n\t\t\"angle\":    { type: \"f\", value: 0.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float sides;\",\n\t\t\"uniform float angle;\",\n\t\t\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec2 p = vUv - 0.5;\",\n\t\t\t\"float r = length(p);\",\n\t\t\t\"float a = atan(p.y, p.x) + angle;\",\n\t\t\t\"float tau = 2. * 3.1416 ;\",\n\t\t\t\"a = mod(a, tau/sides);\",\n\t\t\t\"a = abs(a - tau/sides/2.) ;\",\n\t\t\t\"p = r * vec2(cos(a), sin(a));\",\n\t\t\t\"vec4 color = texture2D(tDiffuse, p + 0.5);\",\n\t\t\t\"gl_FragColor = color;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author felixturner / http://airtight.cc/\n *\n * Kaleidoscope Shader\n * Radial reflection around center point\n * Ported from: http://pixelshaders.com/editor/\n * by Toby Schachman / http://tobyschachman.com/\n *\n * sides: number of reflections\n * angle: initial angle in radians\n */\n\nTHREE.KaleidoShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"sides\":    { type: \"f\", value: 6.0 },\n\t\t\"angle\":    { type: \"f\", value: 0.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float sides;\",\n\t\t\"uniform float angle;\",\n\t\t\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec2 p = vUv - 0.5;\",\n\t\t\t\"float r = length(p);\",\n\t\t\t\"float a = atan(p.y, p.x) + angle;\",\n\t\t\t\"float tau = 2. * 3.1416 ;\",\n\t\t\t\"a = mod(a, tau/sides);\",\n\t\t\t\"a = abs(a - tau/sides/2.) ;\",\n\t\t\t\"p = r * vec2(cos(a), sin(a));\",\n\t\t\t\"vec4 color = texture2D(tDiffuse, p + 0.5);\",\n\t\t\t\"gl_FragColor = color;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "KaleidoShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-KaleidoShader",
      "url": "/js/shaders/KaleidoShader.js",
      "urls": [
        "/js/shaders/KaleidoShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/LuminosityShader.js",
      "relativePath": "js/shaders/LuminosityShader.js",
      "basename": "LuminosityShader",
      "outBasename": "LuminosityShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "LuminosityShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/LuminosityShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "LuminosityShader.js",
      "relativeOutPath": "js/shaders/LuminosityShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/LuminosityShader",
      "relativeOutBase": "js/shaders/LuminosityShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.785Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nTHREE.LuminosityShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"vec3 luma = vec3( 0.299, 0.587, 0.114 );\",\n\n\t\t\t\"float v = dot( texel.xyz, luma );\",\n\n\t\t\t\"gl_FragColor = vec4( v, v, v, texel.w );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nTHREE.LuminosityShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"vec3 luma = vec3( 0.299, 0.587, 0.114 );\",\n\n\t\t\t\"float v = dot( texel.xyz, luma );\",\n\n\t\t\t\"gl_FragColor = vec4( v, v, v, texel.w );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "LuminosityShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-LuminosityShader",
      "url": "/js/shaders/LuminosityShader.js",
      "urls": [
        "/js/shaders/LuminosityShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/MirrorShader.js",
      "relativePath": "js/shaders/MirrorShader.js",
      "basename": "MirrorShader",
      "outBasename": "MirrorShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "MirrorShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/MirrorShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "MirrorShader.js",
      "relativeOutPath": "js/shaders/MirrorShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/MirrorShader",
      "relativeOutBase": "js/shaders/MirrorShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.790Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author felixturner / http://airtight.cc/\n *\n * Mirror Shader\n * Copies half the input to the other half\n *\n * side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom)\n */\n\nTHREE.MirrorShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"side\":     { type: \"i\", value: 1 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform int side;\",\n\t\t\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec2 p = vUv;\",\n\t\t\t\"if (side == 0){\",\n\t\t\t\t\"if (p.x > 0.5) p.x = 1.0 - p.x;\",\n\t\t\t\"}else if (side == 1){\",\n\t\t\t\t\"if (p.x < 0.5) p.x = 1.0 - p.x;\",\n\t\t\t\"}else if (side == 2){\",\n\t\t\t\t\"if (p.y < 0.5) p.y = 1.0 - p.y;\",\n\t\t\t\"}else if (side == 3){\",\n\t\t\t\t\"if (p.y > 0.5) p.y = 1.0 - p.y;\",\n\t\t\t\"} \",\n\t\t\t\"vec4 color = texture2D(tDiffuse, p);\",\n\t\t\t\"gl_FragColor = color;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author felixturner / http://airtight.cc/\n *\n * Mirror Shader\n * Copies half the input to the other half\n *\n * side: side of input to mirror (0 = left, 1 = right, 2 = top, 3 = bottom)\n */\n\nTHREE.MirrorShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"side\":     { type: \"i\", value: 1 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform int side;\",\n\t\t\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec2 p = vUv;\",\n\t\t\t\"if (side == 0){\",\n\t\t\t\t\"if (p.x > 0.5) p.x = 1.0 - p.x;\",\n\t\t\t\"}else if (side == 1){\",\n\t\t\t\t\"if (p.x < 0.5) p.x = 1.0 - p.x;\",\n\t\t\t\"}else if (side == 2){\",\n\t\t\t\t\"if (p.y < 0.5) p.y = 1.0 - p.y;\",\n\t\t\t\"}else if (side == 3){\",\n\t\t\t\t\"if (p.y > 0.5) p.y = 1.0 - p.y;\",\n\t\t\t\"} \",\n\t\t\t\"vec4 color = texture2D(tDiffuse, p);\",\n\t\t\t\"gl_FragColor = color;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "MirrorShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-MirrorShader",
      "url": "/js/shaders/MirrorShader.js",
      "urls": [
        "/js/shaders/MirrorShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/NormalMapShader.js",
      "relativePath": "js/shaders/NormalMapShader.js",
      "basename": "NormalMapShader",
      "outBasename": "NormalMapShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "NormalMapShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/NormalMapShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "NormalMapShader.js",
      "relativeOutPath": "js/shaders/NormalMapShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/NormalMapShader",
      "relativeOutBase": "js/shaders/NormalMapShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.800Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Normal map shader\n * - compute normals from heightmap\n */\n\nTHREE.NormalMapShader = {\n\n\tuniforms: {\n\n\t\t\"heightMap\":  { type: \"t\", value: null },\n\t\t\"resolution\": { type: \"v2\", value: new THREE.Vector2( 512, 512 ) },\n\t\t\"scale\":      { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\n\t\t\"height\":     { type: \"f\", value: 0.05 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float height;\",\n\t\t\"uniform vec2 resolution;\",\n\t\t\"uniform sampler2D heightMap;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"float val = texture2D( heightMap, vUv ).x;\",\n\n\t\t\t\"float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;\",\n\t\t\t\"float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;\",\n\n\t\t\t\"gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Normal map shader\n * - compute normals from heightmap\n */\n\nTHREE.NormalMapShader = {\n\n\tuniforms: {\n\n\t\t\"heightMap\":  { type: \"t\", value: null },\n\t\t\"resolution\": { type: \"v2\", value: new THREE.Vector2( 512, 512 ) },\n\t\t\"scale\":      { type: \"v2\", value: new THREE.Vector2( 1, 1 ) },\n\t\t\"height\":     { type: \"f\", value: 0.05 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float height;\",\n\t\t\"uniform vec2 resolution;\",\n\t\t\"uniform sampler2D heightMap;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"float val = texture2D( heightMap, vUv ).x;\",\n\n\t\t\t\"float valU = texture2D( heightMap, vUv + vec2( 1.0 / resolution.x, 0.0 ) ).x;\",\n\t\t\t\"float valV = texture2D( heightMap, vUv + vec2( 0.0, 1.0 / resolution.y ) ).x;\",\n\n\t\t\t\"gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height  ) ) + 0.5 ), 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "NormalMapShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-NormalMapShader",
      "url": "/js/shaders/NormalMapShader.js",
      "urls": [
        "/js/shaders/NormalMapShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/RGBShiftShader.js",
      "relativePath": "js/shaders/RGBShiftShader.js",
      "basename": "RGBShiftShader",
      "outBasename": "RGBShiftShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "RGBShiftShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/RGBShiftShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "RGBShiftShader.js",
      "relativeOutPath": "js/shaders/RGBShiftShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/RGBShiftShader",
      "relativeOutBase": "js/shaders/RGBShiftShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.798Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author felixturner / http://airtight.cc/\n *\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\n\nTHREE.RGBShiftShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"amount\":   { type: \"f\", value: 0.005 },\n\t\t\"angle\":    { type: \"f\", value: 0.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float amount;\",\n\t\t\"uniform float angle;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec2 offset = amount * vec2( cos(angle), sin(angle));\",\n\t\t\t\"vec4 cr = texture2D(tDiffuse, vUv + offset);\",\n\t\t\t\"vec4 cga = texture2D(tDiffuse, vUv);\",\n\t\t\t\"vec4 cb = texture2D(tDiffuse, vUv - offset);\",\n\t\t\t\"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author felixturner / http://airtight.cc/\n *\n * RGB Shift Shader\n * Shifts red and blue channels from center in opposite directions\n * Ported from http://kriss.cx/tom/2009/05/rgb-shift/\n * by Tom Butterworth / http://kriss.cx/tom/\n *\n * amount: shift distance (1 is width of input)\n * angle: shift angle in radians\n */\n\nTHREE.RGBShiftShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"amount\":   { type: \"f\", value: 0.005 },\n\t\t\"angle\":    { type: \"f\", value: 0.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float amount;\",\n\t\t\"uniform float angle;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec2 offset = amount * vec2( cos(angle), sin(angle));\",\n\t\t\t\"vec4 cr = texture2D(tDiffuse, vUv + offset);\",\n\t\t\t\"vec4 cga = texture2D(tDiffuse, vUv);\",\n\t\t\t\"vec4 cb = texture2D(tDiffuse, vUv - offset);\",\n\t\t\t\"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "RGBShiftShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-RGBShiftShader",
      "url": "/js/shaders/RGBShiftShader.js",
      "urls": [
        "/js/shaders/RGBShiftShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/SSAOShader.js",
      "relativePath": "js/shaders/SSAOShader.js",
      "basename": "SSAOShader",
      "outBasename": "SSAOShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "SSAOShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/SSAOShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "SSAOShader.js",
      "relativeOutPath": "js/shaders/SSAOShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/SSAOShader",
      "relativeOutBase": "js/shaders/SSAOShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.807Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Screen-space ambient occlusion shader\n * - ported from\n *   SSAO GLSL shader v1.2\n *   assembled by Martins Upitis (martinsh) (http://devlog-martinsh.blogspot.com)\n *   original technique is made by ArKano22 (http://www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)\n * - modifications\n * - modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)\n * - made fog more compatible with three.js linear fog\n * - refactoring and optimizations\n */\n\nTHREE.SSAOShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":     { type: \"t\", value: null },\n\t\t\"tDepth\":       { type: \"t\", value: null },\n\t\t\"size\":         { type: \"v2\", value: new THREE.Vector2( 512, 512 ) },\n\t\t\"cameraNear\":   { type: \"f\", value: 1 },\n\t\t\"cameraFar\":    { type: \"f\", value: 100 },\n\t\t\"fogNear\":      { type: \"f\", value: 5 },\n\t\t\"fogFar\":       { type: \"f\", value: 100 },\n\t\t\"fogEnabled\":   { type: \"i\", value: 0 },\n\t\t\"onlyAO\":       { type: \"i\", value: 0 },\n\t\t\"aoClamp\":      { type: \"f\", value: 0.3 },\n\t\t\"lumInfluence\": { type: \"f\", value: 0.9 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float cameraNear;\",\n\t\t\"uniform float cameraFar;\",\n\n\t\t\"uniform float fogNear;\",\n\t\t\"uniform float fogFar;\",\n\n\t\t\"uniform bool fogEnabled;\",  // attenuate AO with linear fog\n\t\t\"uniform bool onlyAO;\",      // use only ambient occlusion pass?\n\n\t\t\"uniform vec2 size;\",        // texture width, height\n\t\t\"uniform float aoClamp;\",    // depth clamp - reduces haloing at screen edges\n\n\t\t\"uniform float lumInfluence;\",  // how much luminance affects occlusion\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t// \"#define PI 3.14159265\",\n\t\t\"#define DL 2.399963229728653\",  // PI * ( 3.0 - sqrt( 5.0 ) )\n\t\t\"#define EULER 2.718281828459045\",\n\n\t\t// helpers\n\n\t\t\"float width = size.x;\",   // texture width\n\t\t\"float height = size.y;\",  // texture height\n\n\t\t\"float cameraFarPlusNear = cameraFar + cameraNear;\",\n\t\t\"float cameraFarMinusNear = cameraFar - cameraNear;\",\n\t\t\"float cameraCoef = 2.0 * cameraNear;\",\n\n\t\t// user variables\n\n\t\t\"const int samples = 8;\",     // ao sample count\n\t\t\"const float radius = 5.0;\",  // ao radius\n\n\t\t\"const bool useNoise = false;\",      // use noise instead of pattern for sample dithering\n\t\t\"const float noiseAmount = 0.0003;\", // dithering amount\n\n\t\t\"const float diffArea = 0.4;\",   // self-shadowing reduction\n\t\t\"const float gDisplace = 0.4;\",  // gauss bell center\n\n\t\t\"const vec3 onlyAOColor = vec3( 1.0, 0.7, 0.5 );\",\n\t\t// \"const vec3 onlyAOColor = vec3( 1.0, 1.0, 1.0 );\",\n\n\n\t\t// RGBA depth\n\n\t\t\"float unpackDepth( const in vec4 rgba_depth ) {\",\n\n\t\t\t\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\n\t\t\t\"float depth = dot( rgba_depth, bit_shift );\",\n\t\t\t\"return depth;\",\n\n\t\t\"}\",\n\n\t\t// generating noise / pattern texture for dithering\n\n\t\t\"vec2 rand( const vec2 coord ) {\",\n\n\t\t\t\"vec2 noise;\",\n\n\t\t\t\"if ( useNoise ) {\",\n\n\t\t\t\t\"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );\",\n\t\t\t\t\"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\",\n\n\t\t\t\t\"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\",\n\n\t\t\t\"} else {\",\n\n\t\t\t\t\"float ff = fract( 1.0 - coord.s * ( width / 2.0 ) );\",\n\t\t\t\t\"float gg = fract( coord.t * ( height / 2.0 ) );\",\n\n\t\t\t\t\"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"return ( noise * 2.0  - 1.0 ) * noiseAmount;\",\n\n\t\t\"}\",\n\n\t\t\"float doFog() {\",\n\n\t\t\t\"float zdepth = unpackDepth( texture2D( tDepth, vUv ) );\",\n\t\t\t\"float depth = -cameraFar * cameraNear / ( zdepth * cameraFarMinusNear - cameraFar );\",\n\n\t\t\t\"return smoothstep( fogNear, fogFar, depth );\",\n\n\t\t\"}\",\n\n\t\t\"float readDepth( const in vec2 coord ) {\",\n\n\t\t\t// \"return ( 2.0 * cameraNear ) / ( cameraFar + cameraNear - unpackDepth( texture2D( tDepth, coord ) ) * ( cameraFar - cameraNear ) );\",\n\t\t\t\"return cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );\",\n\n\n\t\t\"}\",\n\n\t\t\"float compareDepths( const in float depth1, const in float depth2, inout int far ) {\",\n\n\t\t\t\"float garea = 2.0;\",                         // gauss bell width\n\t\t\t\"float diff = ( depth1 - depth2 ) * 100.0;\",  // depth difference (0-100)\n\n\t\t\t// reduce left bell width to avoid self-shadowing\n\n\t\t\t\"if ( diff < gDisplace ) {\",\n\n\t\t\t\t\"garea = diffArea;\",\n\n\t\t\t\"} else {\",\n\n\t\t\t\t\"far = 1;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"float dd = diff - gDisplace;\",\n\t\t\t\"float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );\",\n\t\t\t\"return gauss;\",\n\n\t\t\"}\",\n\n\t\t\"float calcAO( float depth, float dw, float dh ) {\",\n\n\t\t\t\"float dd = radius - depth * radius;\",\n\t\t\t\"vec2 vv = vec2( dw, dh );\",\n\n\t\t\t\"vec2 coord1 = vUv + dd * vv;\",\n\t\t\t\"vec2 coord2 = vUv - dd * vv;\",\n\n\t\t\t\"float temp1 = 0.0;\",\n\t\t\t\"float temp2 = 0.0;\",\n\n\t\t\t\"int far = 0;\",\n\t\t\t\"temp1 = compareDepths( depth, readDepth( coord1 ), far );\",\n\n\t\t\t// DEPTH EXTRAPOLATION\n\n\t\t\t\"if ( far > 0 ) {\",\n\n\t\t\t\t\"temp2 = compareDepths( readDepth( coord2 ), depth, far );\",\n\t\t\t\t\"temp1 += ( 1.0 - temp1 ) * temp2;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"return temp1;\",\n\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec2 noise = rand( vUv );\",\n\t\t\t\"float depth = readDepth( vUv );\",\n\n\t\t\t\"float tt = clamp( depth, aoClamp, 1.0 );\",\n\n\t\t\t\"float w = ( 1.0 / width )  / tt + ( noise.x * ( 1.0 - noise.x ) );\",\n\t\t\t\"float h = ( 1.0 / height ) / tt + ( noise.y * ( 1.0 - noise.y ) );\",\n\n\t\t\t\"float pw;\",\n\t\t\t\"float ph;\",\n\n\t\t\t\"float ao;\",\n\n\t\t\t\"float dz = 1.0 / float( samples );\",\n\t\t\t\"float z = 1.0 - dz / 2.0;\",\n\t\t\t\"float l = 0.0;\",\n\n\t\t\t\"for ( int i = 0; i <= samples; i ++ ) {\",\n\n\t\t\t\t\"float r = sqrt( 1.0 - z );\",\n\n\t\t\t\t\"pw = cos( l ) * r;\",\n\t\t\t\t\"ph = sin( l ) * r;\",\n\t\t\t\t\"ao += calcAO( depth, pw * w, ph * h );\",\n\t\t\t\t\"z = z - dz;\",\n\t\t\t\t\"l = l + DL;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"ao /= float( samples );\",\n\t\t\t\"ao = 1.0 - ao;\",\n\n\t\t\t\"if ( fogEnabled ) {\",\n\n\t\t\t\t\"ao = mix( ao, 1.0, doFog() );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"vec3 color = texture2D( tDiffuse, vUv ).rgb;\",\n\n\t\t\t\"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );\",\n\t\t\t\"float lum = dot( color.rgb, lumcoeff );\",\n\t\t\t\"vec3 luminance = vec3( lum );\",\n\n\t\t\t\"vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\",  // mix( color * ao, white, luminance )\n\n\t\t\t\"if ( onlyAO ) {\",\n\n\t\t\t\t\"final = onlyAOColor * vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\",  // ambient occlusion only\n\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor = vec4( final, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Screen-space ambient occlusion shader\n * - ported from\n *   SSAO GLSL shader v1.2\n *   assembled by Martins Upitis (martinsh) (http://devlog-martinsh.blogspot.com)\n *   original technique is made by ArKano22 (http://www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)\n * - modifications\n * - modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)\n * - made fog more compatible with three.js linear fog\n * - refactoring and optimizations\n */\n\nTHREE.SSAOShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":     { type: \"t\", value: null },\n\t\t\"tDepth\":       { type: \"t\", value: null },\n\t\t\"size\":         { type: \"v2\", value: new THREE.Vector2( 512, 512 ) },\n\t\t\"cameraNear\":   { type: \"f\", value: 1 },\n\t\t\"cameraFar\":    { type: \"f\", value: 100 },\n\t\t\"fogNear\":      { type: \"f\", value: 5 },\n\t\t\"fogFar\":       { type: \"f\", value: 100 },\n\t\t\"fogEnabled\":   { type: \"i\", value: 0 },\n\t\t\"onlyAO\":       { type: \"i\", value: 0 },\n\t\t\"aoClamp\":      { type: \"f\", value: 0.3 },\n\t\t\"lumInfluence\": { type: \"f\", value: 0.9 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float cameraNear;\",\n\t\t\"uniform float cameraFar;\",\n\n\t\t\"uniform float fogNear;\",\n\t\t\"uniform float fogFar;\",\n\n\t\t\"uniform bool fogEnabled;\",  // attenuate AO with linear fog\n\t\t\"uniform bool onlyAO;\",      // use only ambient occlusion pass?\n\n\t\t\"uniform vec2 size;\",        // texture width, height\n\t\t\"uniform float aoClamp;\",    // depth clamp - reduces haloing at screen edges\n\n\t\t\"uniform float lumInfluence;\",  // how much luminance affects occlusion\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t// \"#define PI 3.14159265\",\n\t\t\"#define DL 2.399963229728653\",  // PI * ( 3.0 - sqrt( 5.0 ) )\n\t\t\"#define EULER 2.718281828459045\",\n\n\t\t// helpers\n\n\t\t\"float width = size.x;\",   // texture width\n\t\t\"float height = size.y;\",  // texture height\n\n\t\t\"float cameraFarPlusNear = cameraFar + cameraNear;\",\n\t\t\"float cameraFarMinusNear = cameraFar - cameraNear;\",\n\t\t\"float cameraCoef = 2.0 * cameraNear;\",\n\n\t\t// user variables\n\n\t\t\"const int samples = 8;\",     // ao sample count\n\t\t\"const float radius = 5.0;\",  // ao radius\n\n\t\t\"const bool useNoise = false;\",      // use noise instead of pattern for sample dithering\n\t\t\"const float noiseAmount = 0.0003;\", // dithering amount\n\n\t\t\"const float diffArea = 0.4;\",   // self-shadowing reduction\n\t\t\"const float gDisplace = 0.4;\",  // gauss bell center\n\n\t\t\"const vec3 onlyAOColor = vec3( 1.0, 0.7, 0.5 );\",\n\t\t// \"const vec3 onlyAOColor = vec3( 1.0, 1.0, 1.0 );\",\n\n\n\t\t// RGBA depth\n\n\t\t\"float unpackDepth( const in vec4 rgba_depth ) {\",\n\n\t\t\t\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\n\t\t\t\"float depth = dot( rgba_depth, bit_shift );\",\n\t\t\t\"return depth;\",\n\n\t\t\"}\",\n\n\t\t// generating noise / pattern texture for dithering\n\n\t\t\"vec2 rand( const vec2 coord ) {\",\n\n\t\t\t\"vec2 noise;\",\n\n\t\t\t\"if ( useNoise ) {\",\n\n\t\t\t\t\"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );\",\n\t\t\t\t\"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\",\n\n\t\t\t\t\"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\",\n\n\t\t\t\"} else {\",\n\n\t\t\t\t\"float ff = fract( 1.0 - coord.s * ( width / 2.0 ) );\",\n\t\t\t\t\"float gg = fract( coord.t * ( height / 2.0 ) );\",\n\n\t\t\t\t\"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"return ( noise * 2.0  - 1.0 ) * noiseAmount;\",\n\n\t\t\"}\",\n\n\t\t\"float doFog() {\",\n\n\t\t\t\"float zdepth = unpackDepth( texture2D( tDepth, vUv ) );\",\n\t\t\t\"float depth = -cameraFar * cameraNear / ( zdepth * cameraFarMinusNear - cameraFar );\",\n\n\t\t\t\"return smoothstep( fogNear, fogFar, depth );\",\n\n\t\t\"}\",\n\n\t\t\"float readDepth( const in vec2 coord ) {\",\n\n\t\t\t// \"return ( 2.0 * cameraNear ) / ( cameraFar + cameraNear - unpackDepth( texture2D( tDepth, coord ) ) * ( cameraFar - cameraNear ) );\",\n\t\t\t\"return cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );\",\n\n\n\t\t\"}\",\n\n\t\t\"float compareDepths( const in float depth1, const in float depth2, inout int far ) {\",\n\n\t\t\t\"float garea = 2.0;\",                         // gauss bell width\n\t\t\t\"float diff = ( depth1 - depth2 ) * 100.0;\",  // depth difference (0-100)\n\n\t\t\t// reduce left bell width to avoid self-shadowing\n\n\t\t\t\"if ( diff < gDisplace ) {\",\n\n\t\t\t\t\"garea = diffArea;\",\n\n\t\t\t\"} else {\",\n\n\t\t\t\t\"far = 1;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"float dd = diff - gDisplace;\",\n\t\t\t\"float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );\",\n\t\t\t\"return gauss;\",\n\n\t\t\"}\",\n\n\t\t\"float calcAO( float depth, float dw, float dh ) {\",\n\n\t\t\t\"float dd = radius - depth * radius;\",\n\t\t\t\"vec2 vv = vec2( dw, dh );\",\n\n\t\t\t\"vec2 coord1 = vUv + dd * vv;\",\n\t\t\t\"vec2 coord2 = vUv - dd * vv;\",\n\n\t\t\t\"float temp1 = 0.0;\",\n\t\t\t\"float temp2 = 0.0;\",\n\n\t\t\t\"int far = 0;\",\n\t\t\t\"temp1 = compareDepths( depth, readDepth( coord1 ), far );\",\n\n\t\t\t// DEPTH EXTRAPOLATION\n\n\t\t\t\"if ( far > 0 ) {\",\n\n\t\t\t\t\"temp2 = compareDepths( readDepth( coord2 ), depth, far );\",\n\t\t\t\t\"temp1 += ( 1.0 - temp1 ) * temp2;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"return temp1;\",\n\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec2 noise = rand( vUv );\",\n\t\t\t\"float depth = readDepth( vUv );\",\n\n\t\t\t\"float tt = clamp( depth, aoClamp, 1.0 );\",\n\n\t\t\t\"float w = ( 1.0 / width )  / tt + ( noise.x * ( 1.0 - noise.x ) );\",\n\t\t\t\"float h = ( 1.0 / height ) / tt + ( noise.y * ( 1.0 - noise.y ) );\",\n\n\t\t\t\"float pw;\",\n\t\t\t\"float ph;\",\n\n\t\t\t\"float ao;\",\n\n\t\t\t\"float dz = 1.0 / float( samples );\",\n\t\t\t\"float z = 1.0 - dz / 2.0;\",\n\t\t\t\"float l = 0.0;\",\n\n\t\t\t\"for ( int i = 0; i <= samples; i ++ ) {\",\n\n\t\t\t\t\"float r = sqrt( 1.0 - z );\",\n\n\t\t\t\t\"pw = cos( l ) * r;\",\n\t\t\t\t\"ph = sin( l ) * r;\",\n\t\t\t\t\"ao += calcAO( depth, pw * w, ph * h );\",\n\t\t\t\t\"z = z - dz;\",\n\t\t\t\t\"l = l + DL;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"ao /= float( samples );\",\n\t\t\t\"ao = 1.0 - ao;\",\n\n\t\t\t\"if ( fogEnabled ) {\",\n\n\t\t\t\t\"ao = mix( ao, 1.0, doFog() );\",\n\n\t\t\t\"}\",\n\n\t\t\t\"vec3 color = texture2D( tDiffuse, vUv ).rgb;\",\n\n\t\t\t\"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );\",\n\t\t\t\"float lum = dot( color.rgb, lumcoeff );\",\n\t\t\t\"vec3 luminance = vec3( lum );\",\n\n\t\t\t\"vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\",  // mix( color * ao, white, luminance )\n\n\t\t\t\"if ( onlyAO ) {\",\n\n\t\t\t\t\"final = onlyAOColor * vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\",  // ambient occlusion only\n\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor = vec4( final, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "SSAOShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-SSAOShader",
      "url": "/js/shaders/SSAOShader.js",
      "urls": [
        "/js/shaders/SSAOShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/SepiaShader.js",
      "relativePath": "js/shaders/SepiaShader.js",
      "basename": "SepiaShader",
      "outBasename": "SepiaShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "SepiaShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/SepiaShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "SepiaShader.js",
      "relativeOutPath": "js/shaders/SepiaShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/SepiaShader",
      "relativeOutBase": "js/shaders/SepiaShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.812Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Sepia tone shader\n * based on glfx.js sepia shader\n * https://github.com/evanw/glfx.js\n */\n\nTHREE.SepiaShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"amount\":   { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float amount;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 color = texture2D( tDiffuse, vUv );\",\n\t\t\t\"vec3 c = color.rgb;\",\n\n\t\t\t\"color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\",\n\t\t\t\"color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\",\n\t\t\t\"color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\",\n\n\t\t\t\"gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Sepia tone shader\n * based on glfx.js sepia shader\n * https://github.com/evanw/glfx.js\n */\n\nTHREE.SepiaShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"amount\":   { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float amount;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 color = texture2D( tDiffuse, vUv );\",\n\t\t\t\"vec3 c = color.rgb;\",\n\n\t\t\t\"color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );\",\n\t\t\t\"color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );\",\n\t\t\t\"color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );\",\n\n\t\t\t\"gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "SepiaShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-SepiaShader",
      "url": "/js/shaders/SepiaShader.js",
      "urls": [
        "/js/shaders/SepiaShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/TriangleBlurShader.js",
      "relativePath": "js/shaders/TriangleBlurShader.js",
      "basename": "TriangleBlurShader",
      "outBasename": "TriangleBlurShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "TriangleBlurShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/TriangleBlurShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "TriangleBlurShader.js",
      "relativeOutPath": "js/shaders/TriangleBlurShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/TriangleBlurShader",
      "relativeOutBase": "js/shaders/TriangleBlurShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.831Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Triangle blur shader\n * based on glfx.js triangle blur shader\n * https://github.com/evanw/glfx.js\n *\n * A basic blur filter, which convolves the image with a\n * pyramid filter. The pyramid filter is separable and is applied as two\n * perpendicular triangle filters.\n */\n\nTHREE.TriangleBlurShader = {\n\n\tuniforms : {\n\n\t\t\"texture\": { type: \"t\", value: null },\n\t\t\"delta\":   { type: \"v2\", value:new THREE.Vector2( 1, 1 )  }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"#define ITERATIONS 10.0\",\n\n\t\t\"uniform sampler2D texture;\",\n\t\t\"uniform vec2 delta;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"float random( vec3 scale, float seed ) {\",\n\n\t\t\t// use the fragment position for a different seed per-pixel\n\n\t\t\t\"return fract( sin( dot( gl_FragCoord.xyz + seed, scale ) ) * 43758.5453 + seed );\",\n\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 color = vec4( 0.0 );\",\n\n\t\t\t\"float total = 0.0;\",\n\n\t\t\t// randomize the lookup values to hide the fixed number of samples\n\n\t\t\t\"float offset = random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );\",\n\n\t\t\t\"for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {\",\n\n\t\t\t\t\"float percent = ( t + offset - 0.5 ) / ITERATIONS;\",\n\t\t\t\t\"float weight = 1.0 - abs( percent );\",\n\n\t\t\t\t\"color += texture2D( texture, vUv + delta * percent ) * weight;\",\n\t\t\t\t\"total += weight;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor = color / total;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Triangle blur shader\n * based on glfx.js triangle blur shader\n * https://github.com/evanw/glfx.js\n *\n * A basic blur filter, which convolves the image with a\n * pyramid filter. The pyramid filter is separable and is applied as two\n * perpendicular triangle filters.\n */\n\nTHREE.TriangleBlurShader = {\n\n\tuniforms : {\n\n\t\t\"texture\": { type: \"t\", value: null },\n\t\t\"delta\":   { type: \"v2\", value:new THREE.Vector2( 1, 1 )  }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"#define ITERATIONS 10.0\",\n\n\t\t\"uniform sampler2D texture;\",\n\t\t\"uniform vec2 delta;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"float random( vec3 scale, float seed ) {\",\n\n\t\t\t// use the fragment position for a different seed per-pixel\n\n\t\t\t\"return fract( sin( dot( gl_FragCoord.xyz + seed, scale ) ) * 43758.5453 + seed );\",\n\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 color = vec4( 0.0 );\",\n\n\t\t\t\"float total = 0.0;\",\n\n\t\t\t// randomize the lookup values to hide the fixed number of samples\n\n\t\t\t\"float offset = random( vec3( 12.9898, 78.233, 151.7182 ), 0.0 );\",\n\n\t\t\t\"for ( float t = -ITERATIONS; t <= ITERATIONS; t ++ ) {\",\n\n\t\t\t\t\"float percent = ( t + offset - 0.5 ) / ITERATIONS;\",\n\t\t\t\t\"float weight = 1.0 - abs( percent );\",\n\n\t\t\t\t\"color += texture2D( texture, vUv + delta * percent ) * weight;\",\n\t\t\t\t\"total += weight;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor = color / total;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "TriangleBlurShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-TriangleBlurShader",
      "url": "/js/shaders/TriangleBlurShader.js",
      "urls": [
        "/js/shaders/TriangleBlurShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/UnpackDepthRGBAShader.js",
      "relativePath": "js/shaders/UnpackDepthRGBAShader.js",
      "basename": "UnpackDepthRGBAShader",
      "outBasename": "UnpackDepthRGBAShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "UnpackDepthRGBAShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/UnpackDepthRGBAShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "UnpackDepthRGBAShader.js",
      "relativeOutPath": "js/shaders/UnpackDepthRGBAShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/UnpackDepthRGBAShader",
      "relativeOutBase": "js/shaders/UnpackDepthRGBAShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.835Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Unpack RGBA depth shader\n * - show RGBA encoded depth as monochrome color\n */\n\nTHREE.UnpackDepthRGBAShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"opacity\":  { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float opacity;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t// RGBA depth\n\n\t\t\"float unpackDepth( const in vec4 rgba_depth ) {\",\n\n\t\t\t\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\n\t\t\t\"float depth = dot( rgba_depth, bit_shift );\",\n\t\t\t\"return depth;\",\n\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"float depth = 1.0 - unpackDepth( texture2D( tDiffuse, vUv ) );\",\n\t\t\t\"gl_FragColor = opacity * vec4( vec3( depth ), 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Unpack RGBA depth shader\n * - show RGBA encoded depth as monochrome color\n */\n\nTHREE.UnpackDepthRGBAShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"opacity\":  { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float opacity;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t// RGBA depth\n\n\t\t\"float unpackDepth( const in vec4 rgba_depth ) {\",\n\n\t\t\t\"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\",\n\t\t\t\"float depth = dot( rgba_depth, bit_shift );\",\n\t\t\t\"return depth;\",\n\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"float depth = 1.0 - unpackDepth( texture2D( tDiffuse, vUv ) );\",\n\t\t\t\"gl_FragColor = opacity * vec4( vec3( depth ), 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "UnpackDepthRGBAShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-UnpackDepthRGBAShader",
      "url": "/js/shaders/UnpackDepthRGBAShader.js",
      "urls": [
        "/js/shaders/UnpackDepthRGBAShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/VerticalBlurShader.js",
      "relativePath": "js/shaders/VerticalBlurShader.js",
      "basename": "VerticalBlurShader",
      "outBasename": "VerticalBlurShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "VerticalBlurShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/VerticalBlurShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "VerticalBlurShader.js",
      "relativeOutPath": "js/shaders/VerticalBlurShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/VerticalBlurShader",
      "relativeOutBase": "js/shaders/VerticalBlurShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.846Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\n\nTHREE.VerticalBlurShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"v\":        { type: \"f\", value: 1.0 / 512.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float v;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 sum = vec4( 0.0 );\",\n\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\",\n\n\t\t\t\"gl_FragColor = sum;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author zz85 / http://www.lab4games.net/zz85/blog\n *\n * Two pass Gaussian blur filter (horizontal and vertical blur shaders)\n * - described in http://www.gamerendering.com/2008/10/11/gaussian-blur-filter-shader/\n *   and used in http://www.cake23.de/traveling-wavefronts-lit-up.html\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n */\n\nTHREE.VerticalBlurShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"v\":        { type: \"f\", value: 1.0 / 512.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float v;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 sum = vec4( 0.0 );\",\n\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\",\n\n\t\t\t\"gl_FragColor = sum;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "VerticalBlurShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-VerticalBlurShader",
      "url": "/js/shaders/VerticalBlurShader.js",
      "urls": [
        "/js/shaders/VerticalBlurShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/VerticalTiltShiftShader.js",
      "relativePath": "js/shaders/VerticalTiltShiftShader.js",
      "basename": "VerticalTiltShiftShader",
      "outBasename": "VerticalTiltShiftShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "VerticalTiltShiftShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/VerticalTiltShiftShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "VerticalTiltShiftShader.js",
      "relativeOutPath": "js/shaders/VerticalTiltShiftShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/VerticalTiltShiftShader",
      "relativeOutBase": "js/shaders/VerticalTiltShiftShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.849Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n * - \"r\" parameter control where \"focused\" horizontal line lies\n */\n\nTHREE.VerticalTiltShiftShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"v\":        { type: \"f\", value: 1.0 / 512.0 },\n\t\t\"r\":        { type: \"f\", value: 0.35 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float v;\",\n\t\t\"uniform float r;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 sum = vec4( 0.0 );\",\n\n\t\t\t\"float vv = v * abs( r - vUv.y );\",\n\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;\",\n\n\t\t\t\"gl_FragColor = sum;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Simple fake tilt-shift effect, modulating two pass Gaussian blur (see above) by vertical position\n *\n * - 9 samples per pass\n * - standard deviation 2.7\n * - \"h\" and \"v\" parameters should be set to \"1 / width\" and \"1 / height\"\n * - \"r\" parameter control where \"focused\" horizontal line lies\n */\n\nTHREE.VerticalTiltShiftShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"v\":        { type: \"f\", value: 1.0 / 512.0 },\n\t\t\"r\":        { type: \"f\", value: 0.35 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform float v;\",\n\t\t\"uniform float r;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 sum = vec4( 0.0 );\",\n\n\t\t\t\"float vv = v * abs( r - vUv.y );\",\n\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;\",\n\t\t\t\"sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;\",\n\n\t\t\t\"gl_FragColor = sum;\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "VerticalTiltShiftShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-VerticalTiltShiftShader",
      "url": "/js/shaders/VerticalTiltShiftShader.js",
      "urls": [
        "/js/shaders/VerticalTiltShiftShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders/VignetteShader.js",
      "relativePath": "js/shaders/VignetteShader.js",
      "basename": "VignetteShader",
      "outBasename": "VignetteShader",
      "extension": "js",
      "outExtension": "js",
      "extensions": [
        "js"
      ],
      "filename": "VignetteShader.js",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/files/js/shaders",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders/VignetteShader.js",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/js/shaders",
      "outFilename": "VignetteShader.js",
      "relativeOutPath": "js/shaders/VignetteShader.js",
      "relativeDirPath": "js/shaders",
      "relativeOutDirPath": "js/shaders",
      "relativeBase": "js/shaders/VignetteShader",
      "relativeOutBase": "js/shaders/VignetteShader",
      "contentType": "application/javascript",
      "outContentType": "application/javascript",
      "ctime": "2014-12-21T20:46:43.000Z",
      "mtime": "2014-12-21T20:46:43.000Z",
      "rtime": null,
      "wtime": "2014-12-21T22:35:28.850Z",
      "exists": true,
      "encoding": "utf8",
      "source": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Vignette shader\n * based on PaintEffect postprocess from ro.me\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\n */\n\nTHREE.VignetteShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"offset\":   { type: \"f\", value: 1.0 },\n\t\t\"darkness\": { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float offset;\",\n\t\t\"uniform float darkness;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t// Eskil's vignette\n\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\n\t\t\t\"vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\",\n\t\t\t\"gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\",\n\n\t\t\t/*\n\t\t\t// alternative version from glfx.js\n\t\t\t// this one makes more \"dusty\" look (as opposed to \"burned\")\n\n\t\t\t\"vec4 color = texture2D( tDiffuse, vUv );\",\n\t\t\t\"float dist = distance( vUv, vec2( 0.5 ) );\",\n\t\t\t\"color.rgb *= smoothstep( 0.8, offset * 0.799, dist *( darkness + offset ) );\",\n\t\t\t\"gl_FragColor = color;\",\n\t\t\t*/\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "content": "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Vignette shader\n * based on PaintEffect postprocess from ro.me\n * http://code.google.com/p/3-dreams-of-black/source/browse/deploy/js/effects/PaintEffect.js\n */\n\nTHREE.VignetteShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\"offset\":   { type: \"f\", value: 1.0 },\n\t\t\"darkness\": { type: \"f\", value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join(\"\\n\"),\n\n\tfragmentShader: [\n\n\t\t\"uniform float offset;\",\n\t\t\"uniform float darkness;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t// Eskil's vignette\n\n\t\t\t\"vec4 texel = texture2D( tDiffuse, vUv );\",\n\t\t\t\"vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );\",\n\t\t\t\"gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );\",\n\n\t\t\t/*\n\t\t\t// alternative version from glfx.js\n\t\t\t// this one makes more \"dusty\" look (as opposed to \"burned\")\n\n\t\t\t\"vec4 color = texture2D( tDiffuse, vUv );\",\n\t\t\t\"float dist = distance( vUv, vec2( 0.5 ) );\",\n\t\t\t\"color.rgb *= smoothstep( 0.8, offset * 0.799, dist *( darkness + offset ) );\",\n\t\t\t\"gl_FragColor = color;\",\n\t\t\t*/\n\n\t\t\"}\"\n\n\t].join(\"\\n\")\n\n};\n",
      "tags": null,
      "render": false,
      "write": true,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "VignetteShader.js",
      "date": "2014-12-21T20:46:43.000Z",
      "slug": "js-shaders-VignetteShader",
      "url": "/js/shaders/VignetteShader.js",
      "urls": [
        "/js/shaders/VignetteShader.js"
      ],
      "ignored": false,
      "standalone": false,
      "meta": {}
    },
    {
      "fullPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/layouts/default.html.eco",
      "relativePath": "default.html.eco",
      "basename": "default",
      "outBasename": "default",
      "extension": "eco",
      "outExtension": "html",
      "extensions": [
        "html",
        "eco"
      ],
      "filename": "default.html.eco",
      "fullDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/src/layouts",
      "outPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out/default.html",
      "outDirPath": "/Users/patrickwolleb/Documents/WORK/pumpatterns/out",
      "outFilename": "default.html",
      "relativeOutPath": "default.html",
      "relativeDirPath": ".",
      "relativeOutDirPath": ".",
      "relativeBase": "default",
      "relativeOutBase": "default",
      "contentType": "application/octet-stream",
      "outContentType": "text/html",
      "ctime": "2014-12-21T22:33:35.000Z",
      "mtime": "2014-12-21T22:35:24.828Z",
      "rtime": "2014-12-21T22:35:25.156Z",
      "wtime": null,
      "exists": true,
      "encoding": "utf8",
      "source": "<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title><%= @document.title %></title>\n    <%- @getBlock(\"meta\").toHTML() %>\n    <link href='http://fonts.googleapis.com/css?family=Marcellus+SC' rel='stylesheet' type='text/css'>\n    <%- @getBlock(\"styles\").add([\"/screen.css\"]).toHTML() %>\n\n    <meta property=\"og:image\" content=\"http://www.mixcloud.com/wolleb/pumpatterns-3/\">\n\n\n</head>\n<body onload=\"App.Main()\">\n    <header>\n        <h1 class=\"logo\"><%= @document.title %></h1>\n    </header>\n\n    <section id=\"grid\" class=\"content\">\n\t\t\t<%- @content %>\n    </section>\n    \n    <!--<div id=\"canvas-css\"></div>-->\n    <section id=\"canvas-three\"></section>\n\n\n\n    <%- @getBlock(\"scripts\").add([ \"/js/three.min.js\",\"/js/shaders/VignetteShader.js\", \"/js/shaders/CopyShader.js\", \"/js/shaders/DotScreenShader.js\", \"/js/shaders/RGBShiftShader.js\", \"/js/post/EffectComposer.js\" , \"/js/post/RenderPass.js\", \"/js/post/MaskPass.js\", \"/js/post/ShaderPass.js\", \"/js/lib.js\", \"/js/processing-1.4.1.js\",  \"/js/TrackballControls.js\"]).toHTML() %>\n\n    <script>\n        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\n\n        ga('create', 'UA-48062185-1', 'pumpatterns.co.uk');\n        ga('send', 'pageview');\n\n    </script>\n\n    <!-- AddThis Smart Layers BEGIN -->\n    <!-- Go to http://www.addthis.com/get/smart-layers to customize -->\n    <script type=\"text/javascript\" src=\"//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-52fd0fa531ffef7f\"></script>\n    <script type=\"text/javascript\">\n        addthis.layers({\n            'theme' : 'light',\n            'share' : {\n                'position' : 'right',\n                'numPreferredServices' : 1\n            }\n        });\n    </script>\n    <!-- AddThis Smart Layers END -->\n\n\n\n\n</body>\n</html>",
      "content": "<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title><%= @document.title %></title>\n    <%- @getBlock(\"meta\").toHTML() %>\n    <link href='http://fonts.googleapis.com/css?family=Marcellus+SC' rel='stylesheet' type='text/css'>\n    <%- @getBlock(\"styles\").add([\"/screen.css\"]).toHTML() %>\n\n    <meta property=\"og:image\" content=\"http://www.mixcloud.com/wolleb/pumpatterns-3/\">\n\n\n</head>\n<body onload=\"App.Main()\">\n    <header>\n        <h1 class=\"logo\"><%= @document.title %></h1>\n    </header>\n\n    <section id=\"grid\" class=\"content\">\n\t\t\t<%- @content %>\n    </section>\n    \n    <!--<div id=\"canvas-css\"></div>-->\n    <section id=\"canvas-three\"></section>\n\n\n\n    <%- @getBlock(\"scripts\").add([ \"/js/three.min.js\",\"/js/shaders/VignetteShader.js\", \"/js/shaders/CopyShader.js\", \"/js/shaders/DotScreenShader.js\", \"/js/shaders/RGBShiftShader.js\", \"/js/post/EffectComposer.js\" , \"/js/post/RenderPass.js\", \"/js/post/MaskPass.js\", \"/js/post/ShaderPass.js\", \"/js/lib.js\", \"/js/processing-1.4.1.js\",  \"/js/TrackballControls.js\"]).toHTML() %>\n\n    <script>\n        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\n\n        ga('create', 'UA-48062185-1', 'pumpatterns.co.uk');\n        ga('send', 'pageview');\n\n    </script>\n\n    <!-- AddThis Smart Layers BEGIN -->\n    <!-- Go to http://www.addthis.com/get/smart-layers to customize -->\n    <script type=\"text/javascript\" src=\"//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-52fd0fa531ffef7f\"></script>\n    <script type=\"text/javascript\">\n        addthis.layers({\n            'theme' : 'light',\n            'share' : {\n                'position' : 'right',\n                'numPreferredServices' : 1\n            }\n        });\n    </script>\n    <!-- AddThis Smart Layers END -->\n\n\n\n\n</body>\n</html>",
      "tags": null,
      "render": false,
      "write": false,
      "writeSource": false,
      "dynamic": false,
      "title": null,
      "name": "default.html",
      "date": "2014-12-21T22:33:35.000Z",
      "slug": "default",
      "url": "/default.html",
      "urls": [
        "/default.html"
      ],
      "ignored": false,
      "standalone": false,
      "referencesOthers": false,
      "header": null,
      "parser": null,
      "body": "<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title><%= @document.title %></title>\n    <%- @getBlock(\"meta\").toHTML() %>\n    <link href='http://fonts.googleapis.com/css?family=Marcellus+SC' rel='stylesheet' type='text/css'>\n    <%- @getBlock(\"styles\").add([\"/screen.css\"]).toHTML() %>\n\n    <meta property=\"og:image\" content=\"http://www.mixcloud.com/wolleb/pumpatterns-3/\">\n\n\n</head>\n<body onload=\"App.Main()\">\n    <header>\n        <h1 class=\"logo\"><%= @document.title %></h1>\n    </header>\n\n    <section id=\"grid\" class=\"content\">\n\t\t\t<%- @content %>\n    </section>\n    \n    <!--<div id=\"canvas-css\"></div>-->\n    <section id=\"canvas-three\"></section>\n\n\n\n    <%- @getBlock(\"scripts\").add([ \"/js/three.min.js\",\"/js/shaders/VignetteShader.js\", \"/js/shaders/CopyShader.js\", \"/js/shaders/DotScreenShader.js\", \"/js/shaders/RGBShiftShader.js\", \"/js/post/EffectComposer.js\" , \"/js/post/RenderPass.js\", \"/js/post/MaskPass.js\", \"/js/post/ShaderPass.js\", \"/js/lib.js\", \"/js/processing-1.4.1.js\",  \"/js/TrackballControls.js\"]).toHTML() %>\n\n    <script>\n        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\n\n        ga('create', 'UA-48062185-1', 'pumpatterns.co.uk');\n        ga('send', 'pageview');\n\n    </script>\n\n    <!-- AddThis Smart Layers BEGIN -->\n    <!-- Go to http://www.addthis.com/get/smart-layers to customize -->\n    <script type=\"text/javascript\" src=\"//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-52fd0fa531ffef7f\"></script>\n    <script type=\"text/javascript\">\n        addthis.layers({\n            'theme' : 'light',\n            'share' : {\n                'position' : 'right',\n                'numPreferredServices' : 1\n            }\n        });\n    </script>\n    <!-- AddThis Smart Layers END -->\n\n\n\n\n</body>\n</html>",
      "rendered": false,
      "contentRendered": null,
      "contentRenderedWithoutLayouts": null,
      "renderSingleExtensions": false,
      "isLayout": true,
      "meta": {}
    }
  ]
}